'From Smalltalk-80 of March 1, 1984 (Customer Version 4) on 18 April 1985 at 5:59:15 pm;Fun with Pens developed by Mike Malcolm and packaged by Evelyn Van Orden'!!Pen class methodsFor: 'instance creation'!new 	| quill |	quill _ super new.	quill destForm: Display.	quill frame: Display boundingBox.	quill sourceOrigin: 0@0.	quill mask: Form black.	quill defaultNib: 1.	quill combinationRule: Form over. "was Form paint"	quill down.	quill home.	quill north.	^quill! !!Pen class methodsFor: 'examples'!connections	"Press a key or mouse button to stop."	Display black.	Pen new randomConnects.	ScheduledControllers restore!mandala	"Press a key or mouse button to stop."	Pen new mandala2: 30 diameter: 400.	ScheduledControllers restore!mandalas	"Press a key or mouse button to stop."	Display black.	Pen new randomMandalas.	ScheduledControllers restore!moire	"Press a mouse button to change the delta. Press a key to stop."	Pen new moire: 90 r: 240 delta: 3@2.	ScheduledControllers restore!poly	"Press a key or mouse button to stop."	Pen new poly: 60 minPts: 3 maxPts: 8 displayTime: false.	ScheduledControllers restore!stars	"Press a key or mouse button to stop."	Display black. Pen new randomStars: 50.	ScheduledControllers restore!starsNstripes	"Press a mouse button to stop."	Pen new starsNstripes.	ScheduledControllers restore!twisty 	"Press a key or mouse button to stop."	Pen new twisty: 39 maxSpeed: 19.	ScheduledControllers restore! !!Pen methodsFor: 'moving'!drawFrom: startPoint to: stopPoint	| offset point1 point2 |	"always draw down, or at least left-to-right"	((startPoint y = stopPoint y		and: [startPoint x < stopPoint x])		or: [startPoint y < stopPoint y])			ifTrue: [point1 _ startPoint. point2 _ stopPoint]			ifFalse: [point1 _ stopPoint. point2 _ startPoint].	offset _ sourceForm offset.	destX _ (point1 x + offset x) rounded.	destY _ (point1 y + offset y) rounded.	self drawLoopX: (point2 x - point1 x) rounded 				  Y: (point2 y - point1 y) rounded! !!Pen methodsFor: 'geometric designs'!connectPoints: points outward: outward	"Successively draws lines between the specified points."		"pts _ Array new.	[Sensor yellowButtonPressed] whileFalse:		[Sensor redButtonPressed ifTrue:			[pts _ pts, (Array with: Sensor waitNoButton)]].	Pen new connectPoints: pts."	| n i cosets |	n _ points size.	self place: (points at: (i _ 1)); down.	(outward ifTrue: [1 to: n // 2] ifFalse: [n // 2 to: 1 by: -1]) do:		[:skip | 		cosets _ n gcd: skip.		cosets timesRepeat:			["draw a coset"			n // cosets timesRepeat:				["draw lines in a coset"				(i _ i + skip) > n ifTrue: [i _ i - n].				self goto: (points at: i)].			"change coset"			i _ i = n ifTrue: [1] ifFalse: [i + 1].			self place: (points at: i)].			Processor yield]!mandala: n diameter: d at: c outward: outward	"On a circle of diameter d, whose center is located at c on the display,	evenly place n points, drawing them from the center outward if	outward is true."	| i points cosets theta dTheta r |	points _ Array new: n.	theta _ 0.0.	dTheta _ Float pi * 2.0 / n.	r _ d asFloat / 2.0.	1 to: n do:		[:i | 		theta _ theta + dTheta.		points			at: i			put: (theta cos * r) rounded @ (theta sin * r) rounded + c].	self connectPoints: points outward: true!mandala2: n diameter: d 	"On a circle of diameter d, evenly places n points in the center	of the display. Draws all possible connecting lines directly on the	display; when possible, stay sconnected; also, doesn't color.	This version is much faster than mandala:diameter:.	Press a key or mouse button to stop."	"Pen new mandala2: 30 diameter: 400."	| c |	c _ frame center.	Display black.	Cursor blank showWhile:	[[Sensor keyboardPressed | Sensor anyButtonPressed] whileFalse:		[self combinationRule: Form erase; mandala: n diameter: d at: c outward: true.		self combinationRule: Form under; mandala: n diameter: d at: c outward: false]].	Cursor normal show.	Sensor flushKeyboard!moire: n r: r delta: delta	"Draws a moire pattern by intersecting two xoring 4n-spoke systems	of radius r with centers separated by vector (a Point) delta.	Press a mouse button to change the delta.	Press a key to stop."	"Pen new moire: 90 r: 240 delta: 3@2."	| c1 c2 wedge rf k rsin dxdy draw m |	c1 _ self location.	c2 _ c1 + delta.	wedge _ Float pi / n asFloat / 2.0.	rf _ r asFloat.	rsin _ #(0), ((1 to: n) collect: [:i | ((wedge * i asFloat) sin * rf) rounded]).	k _ n + 1.  "= rsin size"	dxdy _ ( (1 to: n) collect: [:i | (rsin at: i)@(rsin at: k - i)] ).	dxdy _ dxdy, (dxdy collect: [:xy | xy y negated@xy x]).	dxdy _ dxdy, (dxdy collect: [:xy | xy x negated@xy y negated]).	dxdy _ dxdy, (Array with: dxdy first).	Display black.	self combinationRule: Form reverse; down.	draw _ [:xy | self	drawFrom: c1 - xy to: c1 + xy;						drawFrom: c2 - xy to: c2 + xy].	m _ 0.	Cursor blank showWhile:	[[Sensor keyboardPressed] whileFalse:		[[Sensor anyButtonPressed] whileTrue:			[c2 _ Sensor mousePoint.			self drawFrom: c1 to: c2; drawFrom: c1 to: c2].		m+1 to: m+n do:			[:i |			draw value: (dxdy at: i);			value: (dxdy at: dxdy size - i)].		m _ m = 0 ifTrue: [n] ifFalse: [0]]].	Cursor normal show.	Sensor flushKeyboard!poly: iterations minPts: min maxPts: max displayTime: displayTime	"Picks two n point sets of random points [min <= n <= max].	Interpolates iterations sets between them, drawing from point to point.	Press a key or mouse button to stop."	"Pen new poly: 60 minPts: 3 maxPts: 8 displayTime: false."	| r point n points pointsDelta |	(min < 3 or: [max < min]) ifTrue: [^self].	r _ Random new.	point _ [(r next * 1024) truncated @ (r next * 808) truncated].	self combinationRule: Form erase.	Cursor blank showWhile:	[[Sensor keyboardPressed | Sensor anyButtonPressed] whileFalse:		[n _ min + (r next * (max - min)) truncated.		points _ Array new: n.		pointsDelta _ Array new: n.		1 to: n do:			[:i |			points at: i put: point value.			pointsDelta				at: i				put: (point value - (points at: i)) // iterations].		self up goto: points first; down.		Display black.		displayTime ifTrue:			[Time now printString asParagraph asForm reverse				displayAt: (points inject: 0@0 into: [:sum :pt | sum + pt])//n].		1 to: iterations do:			[:j |			1 to: n do:				[:i |				self goto: (points at: i).				points					at: i					put: (points at: i) + (pointsDelta at: i)]]]].	Cursor normal show.	Sensor flushKeyboard!randomConnects	"Connects random points on the display.	Press a key or mouse button to stop."	"Display black. Pen new randomConnects."	| r w h newPoint n points |	r _ Random new.	w _ Display width.	h _ Display height.	newPoint _ [(r next*w) truncated @ (r next*h) truncated].	Cursor blank showWhile:	[[Sensor keyboardPressed | Sensor anyButtonPressed] whileFalse:		[n _ (r next*9.0) rounded + 3.		points _ Array new: n.		1 to: n do: [:i | points at: i put: newPoint value].		self combinationRule: Form erase; connectPoints: points outward: (r next > 0.5).		self combinationRule: Form under; connectPoints: points outward: (r next > 0.5)]].	Cursor normal show.	Sensor flushKeyboard!randomMandalas	"Repeatedly draws a mandala of random sizes in random positions.	Press a key or mouse button to stop."	"Display black. Pen new randomMandalas."		| r n d c w h |	r _ Random new.	w _ Display width.	h _ Display height.	Cursor blank showWhile:	[[Sensor keyboardPressed | Sensor anyButtonPressed] whileFalse:		[n _ (r next * 12.0) truncated + 12.		d _ (r next * 400.0) truncated + 100.		c _ (((w - d - d) * r next) truncated + d) @ (((h - d - d) * r next) truncated + d).		self combinationRule: Form erase; mandala: n diameter: d at: c outward: (r next > 0.5).		self combinationRule: Form under; mandala: n diameter: d at: c outward: (r next > 0.5)]].	Cursor normal show.	Sensor flushKeyboard!randomStars: n	"Repeatedly displays n stars on the display in random positions.	Press a key or mouse button to stop."	"Display black. Pen new randomStars: 50."	| star points point w h ran i |	star _ Form extent: 16@16.	self destForm: star; up; goto: 0@4; north; turn: 90; down.	5 timesRepeat: [self go: 12; turn: 144].  "draw 5 point star"	self sourceForm: star; destForm: Display.	w _ Display width asFloat.	h _ Display height asFloat.	points _ Array new: n withAll: 0@0.	ran _ Random new.	i _ 1.	Cursor blank showWhile:	[[Sensor keyboardPressed | Sensor anyButtonPressed] whileFalse:		[point _ points at: i.		self combinationRule: 7;  "black out old star"			destX: point x;			destY: point y;			copyBits.		point _ (w*ran next) truncated@(h*ran next) truncated.		points at: i put: point.		self combinationRule: 4;  "show white star"			destX: point x;			destY: point y;			copyBits.		i _ i < n ifTrue: [i + 1] ifFalse: [1].		Processor yield]].	Cursor normal show.	Sensor flushKeyboard!starsNstripes	"Repeatedly display 50 stars and 13 stripes on the display.	Press a mouse button to stop."	"Pen new starsNstripes. ScheduledControllers restore."	[Pen new twisty: 13 maxSpeed: 19] fork.	self randomStars: 50.	[Sensor anyButtonPressed] whileTrue: [Processor yield].	Cursor normal show!twisty: nLines maxSpeed: dMax	"Draws lines on the display continuously, showing nLines at all times.	Press a key or mouse button to stop."	"Pen new twisty: 39 maxSpeed: 19. ScheduledControllers restore."		| ddArray ddIndex dda ddb da db dNew pointNew lines a b i r |	ddArray _		(Array with: 0@1 with: -1@-1 with: 1@1 with: 0@-1),		(Array with: -1@0 with: 1@0 with: 1@-1 with: -1@1),		(Array with: 0@-2).	ddIndex _ 1.	dda _ ddArray last copy.	ddb _ ddArray first copy.	r _ Random new.	da _ (r next * dMax * 2.0) rounded - dMax		 @ ((r next * dMax * 2.0) rounded - dMax).	db _ (r next * dMax * 2.0) rounded - dMax		 @ ((r next * dMax * 2.0) rounded - dMax).	dNew _		[:old :dd |		old _ old + dd.		old x < (0 - dMax) ifTrue: [old x: old x + 2. dd x: 0 - dd x].		old x > dMax ifTrue: [old x: old x - 2. dd x: 0 - dd x].		old y < (0 - dMax) ifTrue: [old y: old y + 2. dd y: 0 - dd y].		old y > dMax ifTrue: [old y: old y - 2. dd y: 0 - dd y].		old].	pointNew _		[:point :d |		point _ point + d.		point x < 0 ifTrue: [point x: 0 - point x. d x: 0 - d x.].		point x > 1023 ifTrue: [point x: 2046 - point x. d x: 0 - d x.].		point y < 0 ifTrue: [point y: 0 - point y. d y: 0 - d y.].		point y > 807 ifTrue: [point y: 1614 - point y. d y: 0 - d y.].		point].	a _ b _ Display boundingBox center.	lines _ Array new: nLines withAll: (a corner: b).	i _ 1.	Display black.	Cursor blank showWhile:	[[Sensor keyboardPressed | Sensor anyButtonPressed] whileFalse:		[Processor yield.		self combinationRule: Form under;	"erase old"			place: (lines at: i) origin;			goto: (lines at: i) corner.		lines at: i put: (a corner: b).		self combinationRule: Form erase;	"draw new"			place: a;			goto: b.		a _ pointNew value: a value: da.		b _ pointNew value: b value: db.		da _ dNew value: da value: dda.		i \\ 2 = 0 ifTrue: [db _ dNew value: db value: ddb].		i _ i = nLines			ifTrue:				[ddIndex _ ddIndex + 1 \\ ddArray size + 1.				dda _ (ddArray at: ddIndex) copy.				ddIndex _ ddIndex + 1 \\ ddArray size + 1.				ddb _ (ddArray at: ddIndex) copy.				1]			ifFalse: [i + 1]]].	Cursor normal show.	Sensor flushKeyboard! !