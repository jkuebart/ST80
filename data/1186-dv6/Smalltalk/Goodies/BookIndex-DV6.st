'Unmodified from LV4 (interface-book-index.st) for CV4 by Evelyn Van Orden on 7 December 1983'!ListController subclass: #IndexCardListController	instanceVariableNames: ''	classVariableNames: 'IndexCardListYellowButtonMenu IndexCardListYellowButtonMessages '	poolDictionaries: ''	category: 'Interface-Book Index'!!IndexCardListController methodsFor: 'initialize-release'!initialize	super initialize.	self initializeYellowButtonMenu! !!IndexCardListController methodsFor: 'menu messages'!addDefnPage	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model addDefnPage.	self controlInitialize!addPage	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model addPage.	self controlInitialize!addUsePage	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model addUsePage.	self controlInitialize!changeCategory	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model changeCategory.	self controlInitialize!changeKey	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model changeKey.	self controlInitialize!changeNesting	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model changeNesting.	self controlInitialize!changeSee	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model changeSee.	self controlInitialize!changeSeeAlso	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model changeSeeAlso.	self controlInitialize!makeRanges	self controlTerminate.	model makeRanges.	self controlInitialize!newCard	self controlTerminate.	model newCard.	self controlInitialize!newNestedCard	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model newNestedCard.	self controlInitialize!removeCard	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model removeCard.	self controlInitialize!removePage	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model removePage.	self controlInitialize!updateDatabase	self controlTerminate.	model updateDatabase.	self controlInitialize! !!IndexCardListController methodsFor: 'private'!initializeYellowButtonMenu 	self yellowButtonMenu: IndexCardListYellowButtonMenu 		yellowButtonMessages: IndexCardListYellowButtonMessages! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IndexCardListController class	instanceVariableNames: ''!!IndexCardListController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button menu information."		IndexCardListYellowButtonMenu _		PopUpMenu 				labels: 'add pageadd defn pageadd use pageremove pagenew cardnew nested cardremove cardchange keychange nestingchange categorychange Seechange See Alsoupdate filemake ranges' 				lines: #(4 7 10 12).	IndexCardListYellowButtonMessages _ 			#(addPage addDefnPage addUsePage removePage newCard newNestedCard removeCard changeKey changeNesting changeCategory changeSee changeSeeAlso updateDatabase makeRanges)	"IndexCardListController initialize."	"IndexCardListController allInstancesDo: [:each | each initialize]."! !IndexCardListController initialize!Object subclass: #IndexCard	instanceVariableNames: 'key definitions mentions uses presentation synonyms references nestedFrom category comparisonKey '	classVariableNames: 'LastCategory LastPage '	poolDictionaries: ''	category: 'Interface-Book Index'!!IndexCard methodsFor: 'initialize-release'!initialize	key _ 'no key'.	definitions _ SortedCollection new.	mentions _ SortedCollection new.	uses _ SortedCollection new.	presentation _ #normal.	synonyms _ ''.	references _ ''.	nestedFrom _ Array new.	category _ 'no category'! !!IndexCard methodsFor: 'accessing'!addDefnPageFromString: aString	| stream start stop includee |	aString isEmpty		ifTrue: [includee _ LastPage]		ifFalse: [stream _ ReadStream on: aString.				start _ Integer readFrom: stream.				stream next == $-					ifTrue: [stop _ Integer readFrom: stream.							includee _ IndexRange start: start stop: stop]					ifFalse: [includee _ start].				LastPage _ includee].	(definitions includes: includee)		ifFalse: [definitions add: includee]!addPageFromString: aString	| stream start stop includee |	aString isEmpty		ifTrue: [includee _ LastPage]		ifFalse: [stream _ ReadStream on: aString.				start _ Integer readFrom: stream.				stream next == $-					ifTrue: [stop _ Integer readFrom: stream.							includee _ IndexRange start: start stop: stop]					ifFalse: [includee _ start].				LastPage _ includee].	(mentions includes: includee)		ifFalse: [mentions add: includee]!addUsePageFromString: aString	| stream start stop includee |		aString isEmpty		ifTrue: [includee _ LastPage]		ifFalse: [stream _ ReadStream on: aString.				start _ Integer readFrom: stream.				stream next == $-					ifTrue: [stop _ Integer readFrom: stream.							includee _ IndexRange start: start stop: stop]					ifFalse: [includee _ start].				LastPage _ includee].	(uses includes: includee)		ifFalse: [uses add: includee]!category	^category!category: anObject	anObject isEmpty		ifTrue: [category _ LastCategory]		ifFalse: [category _ anObject.				 LastCategory _ category]!definitions: anObject	definitions _ anObject!key	^key!key: anObject	key _ anObject.	comparisonKey _ nil!mentions: anObject	mentions _ anObject!nestedFrom	^nestedFrom!nestedFrom: anObject	nestedFrom _ anObject.	comparisonKey _ nil!presentation: anObject	presentation _ anObject!references	^references!references: anObject	references _ anObject!removePageFromString: aString	| stream start stop includee |	aString first = $*		ifTrue: [definitions _ SortedCollection new.				mentions _ SortedCollection new.				^uses _ SortedCollection new].	stream _ ReadStream on: aString.	start _ Integer readFrom: stream.	stream next == $-		ifTrue: [stop _ Integer readFrom: stream.				includee _ IndexRange start: start stop: stop]		ifFalse: [includee _ start].	(mentions includes: includee)		ifTrue: [mentions _ mentions copyWithout: includee].	(definitions includes: includee)		ifTrue: [definitions _ definitions copyWithout: includee].		(uses includes: includee)		ifTrue: [uses _ uses copyWithout: includee].!synonyms	^synonyms!synonyms: anObject	synonyms _ anObject!uses: anObject	uses _ anObject! !!IndexCard methodsFor: 'comparing'!< anotherIndexCard	^self comparisonKey < anotherIndexCard comparisonKey!<= anotherIndexCard	^self comparisonKey <= anotherIndexCard comparisonKey!checkNesting	category = 'concepts'		ifTrue: [(uses isEmpty&definitions isEmpty)						ifTrue: [^nil]						ifFalse: [self error: 'illegal concept card']].	category = 'classes'		ifTrue: [nestedFrom isEmpty						ifTrue: [^nil]						ifFalse: [key=']' ifTrue: [^nil].								 self error: 'illegal classes card']].	category = 'examples'		ifTrue: [nestedFrom isEmpty						ifTrue: [^nil]						ifFalse: [self error: 'illegal examples card']].	self error: 'illegal category'!comparisonKey	comparisonKey == nil		ifTrue: [self computeComparisonKey].	^comparisonKey!matchesFilter: aStringOrInteger	aStringOrInteger isInteger		ifTrue: [^self isOnPage: aStringOrInteger].	aStringOrInteger = '*' ifTrue: [^true].	aStringOrInteger = category ifTrue: [^true].	^false! !!IndexCard methodsFor: 'range merging'!canMerge: last and: next	last class = IndexRange		ifTrue: [next class = IndexRange					ifTrue: [^last stop+1 = next start]					ifFalse: [^last stop+1 = next]]		ifFalse: [next class = IndexRange					ifTrue: [^last+1 = next start]					ifFalse: [^last+1 = next]]!makeRanges	mentions _ self makeRangesFrom: mentions asSortedCollection.	definitions _ self makeRangesFrom: definitions asSortedCollection.	uses _ self makeRangesFrom: uses asSortedCollection!makeRangesFrom: aList	| newList last next |	aList isEmpty ifTrue: [^aList].	newList _ SortedCollection new.	last _ aList removeFirst.	[aList isEmpty]		whileFalse:			[next _ aList removeFirst.			 (self canMerge: last and: next)				ifTrue: [last _ self merge: last and: next]				ifFalse: [newList add: last.						  last _ next]].	newList add: last.	^newList!merge: last and: next	last class = IndexRange		ifTrue: [next class = IndexRange					ifTrue: [^IndexRange start: last start stop: next stop]					ifFalse: [^IndexRange start: last start stop: next]]		ifFalse: [next class = IndexRange					ifTrue: [^IndexRange start: last stop: next stop]					ifFalse: [^IndexRange start: last stop: next]]! !!IndexCard methodsFor: 'printing'!printCategoryOn: aStream	aStream nextPutAll: category!printKeyOn: aStream	1 to: nestedFrom size do:		[:i | aStream nextPutAll: (nestedFrom at: i); crtab: i+2].	aStream nextPutAll: key!printOn: aStream	nestedFrom size timesRepeat:		[aStream tab].	aStream nextPutAll: key!printPagesOn: aStream	| table first intOrRange |		table _ SortedCollection new.	definitions do:		[:def | table add: (Association key: def value: #definition)].	mentions do:		[:men | table add: (Association key: men value: #mention)].	uses do:		[:use | table add: (Association key: use value: #use)].	first _ true.	table do:		[:index |		first ifFalse: [aStream nextPut: $,; space].		first _ false.		intOrRange _ index key.		index value == #definition ifTrue: [aStream nextPut: $(].		index value == #use ifTrue: [aStream nextPut: $<].		(intOrRange isKindOf: IndexRange)			ifTrue:				[intOrRange start printOn: aStream.				aStream nextPut: $-.				intOrRange stop printOn: aStream]			ifFalse:				[intOrRange printOn: aStream].			index value == #definition ifTrue: [aStream nextPut: $)].			index value == #use ifTrue: [aStream nextPut: $>].		]!printRefsOn: aStream		aStream nextPutAll: references!printSynonymsOn: aStream	aStream nextPutAll: synonyms! !!IndexCard methodsFor: 'fileOut'!fileOutOn: aStream	^self storeOn: aStream! !!IndexCard methodsFor: 'private'!computeComparisonKey	| aString |	aString _ ''.	nestedFrom do:		[:ref | aString _ aString, ref, '	'].	"tab so that compares before spaces"	aString _ aString, key.	comparisonKey _ aString!isOnPage: aNumber 	definitions do: 		[:each | (each isKindOf: IndexRange)					ifTrue: [(each includes: aNumber)								ifTrue: [^true]]					ifFalse: [each = aNumber ifTrue: [^true]]].	mentions do: 		[:each | (each isKindOf: IndexRange)					ifTrue: [(each includes: aNumber)								ifTrue: [^true]]					ifFalse: [each = aNumber ifTrue: [^true]]].	uses do: 		[:each | (each isKindOf: IndexRange)					ifTrue: [(each includes: aNumber)								ifTrue: [^true]]					ifFalse: [each = aNumber ifTrue: [^true]]].	^false!storeOn: aStream	| table first intOrRange |	nestedFrom size timesRepeat: [aStream nextPut: $[].		aStream nextPutAll: key.	aStream tab.		self printPagesOn: aStream.	aStream tab.		self printSynonymsOn: aStream.	aStream tab.		self printRefsOn: aStream.	aStream tab.		self printCategoryOn: aStream.	aStream cr! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IndexCard class	instanceVariableNames: ''!!IndexCard class methodsFor: 'instance creation'!initialize	LastPage _ 0.	LastCategory _ 'concepts'!new	| card |	card _ super new.	card initialize.	^card! !IndexCard initialize!Object subclass: #IndexCardCollection	instanceVariableNames: 'collection listIndex filter list isLocked lastPageString myFileString '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Book Index'!!IndexCardCollection methodsFor: 'initialize-release'!collection: aCollection	collection _ aCollection.	listIndex _ 0.	filter _ '*'.	myFileString _ ''.	lastPageString _ ''.	isLocked _ false! !!IndexCardCollection methodsFor: 'accessing'!contents	| aStream card |	listIndex = 0 ifTrue: [^''].	aStream _ WriteStream on: (String new: 100).	card  _ self selection.	aStream nextPutAll: 'Key:	'.		card printKeyOn: aStream.	aStream cr; nextPutAll: 'Pages:	'.		card printPagesOn: aStream.	aStream cr; nextPutAll: 'See:	'.		card printSynonymsOn: aStream.	aStream cr; nextPutAll: 'See also:	'.		card printRefsOn: aStream.	aStream cr; nextPutAll: 'Category:	'.		card printCategoryOn: aStream.	^aStream contents!fileName: aFileName	myFileString _ aFileName!filter: aString	filter _ aString.	list _ nil.	listIndex _ 0.	self changed: #list!list	| array i |	list == nil ifTrue: [self computeList].	array _ Array new: list size.	i _ 0.	list do:		[:indexCard |		array at: (i _ i+1) put: indexCard printString].	^array! !!IndexCardCollection methodsFor: 'lock access'!isUnlocked	^isLocked not!unlock	isLocked _ false! !!IndexCardCollection methodsFor: 'list access'!listIndex	^listIndex!makeRanges	collection do: [ :card | card makeRanges]!toggleListIndex: anInteger	"Select the file name in the receiver's list whose index is the argument, anInteger.  If the current selection index is already anInteger, deselect it."	listIndex = anInteger		ifTrue:			[listIndex _ 0]		ifFalse: 			[listIndex _ anInteger].	self changed: #listIndex! !!IndexCardCollection methodsFor: 'menu messages'!addDefnPage	(self selection) addDefnPageFromString: self getPage.	self changed: #listIndex!addPage	(self selection) addPageFromString: self getPage.	self changed: #listIndex!addUsePage	(self selection) addUsePageFromString: self getPage.	self changed: #listIndex!changeCategory	| newCat |	newCat _ (FillInTheBlank request: 'new category?').	newCat isEmpty ifTrue: [^self].	(self selection) category: newCat.	filter = '*'		ifTrue: [self changed: #listIndex]		ifFalse:			[list _ nil.			self changed: #list]!changeKey	| newKey |	newKey _ (FillInTheBlank request: 'new key?' initialAnswer: self selection key).	newKey isEmpty ifTrue: [^self].	(self selection) key: newKey.	list _ nil.	listIndex _ 0.	self changed: #list!changeNesting	| newNest oldCard thisCard |	newNest _ (FillInTheBlank request: 'new nesting (use tab between levels)').	newNest isEmpty ifTrue: [^self].	oldCard _ collection detect: [:aCard | aCard comparisonKey = newNest] ifNone: [^self].	thisCard _ self selection.	collection remove: thisCard.	thisCard nestedFrom: oldCard nestedFrom, (Array with: oldCard key).	thisCard category: oldCard category.	collection add: thisCard.	list _ nil.	self changed: #list!changeSee	| newSee |	newSee _ (FillInTheBlank request: 'new synonym?'							   initialAnswer: self selection synonyms).	newSee isEmpty ifTrue: [^self].	(self selection) synonyms: newSee.	self changed: #listIndex!changeSeeAlso	| newSee |	newSee _ (FillInTheBlank request: 'new see also?'							   initialAnswer: self selection references).	newSee isEmpty ifTrue: [^self].	(self selection) references: newSee.	self changed: #listIndex!getPage	^lastPageString _ FillInTheBlank request: 'page number?' initialAnswer: lastPageString!newCard	| card newKey oldCategory |	newKey _ (FillInTheBlank request: 'Key for card?').	newKey isEmpty ifTrue: [^self].	card _ IndexCard new.	card key: newKey.	oldCategory _ (self selection == nil ifTrue: [''] ifFalse: [self selection category]).	card category: (FillInTheBlank request: 'category?' initialAnswer: oldCategory).	collection add: card.	list _ nil.	self changed: #list!newNestedCard	| card newKey |	newKey _ (FillInTheBlank request: 'nested key for card?').	newKey isEmpty ifTrue: [^self].	card _ IndexCard new.	card key: newKey.	card nestedFrom: self selection nestedFrom, (Array with: self selection key).	card category: self selection category.	collection add: card.	list _ nil.	self changed: #list!removeCard	| remove |	BinaryChoice		message: 'do you really want to remove this card?' 		displayAt: Sensor cursorPoint 		centered: true		ifTrue:			[remove _ true]		ifFalse: [remove _ false].	remove		ifTrue: 			[collection remove: self selection.			list _ nil.			listIndex _ 0.			self changed: #list]!removePage	(self selection) removePageFromString: self getPage.	self changed: #listIndex!updateDatabase	| fileName file |	fileName _ FillInTheBlank request: 'file name?' initialAnswer: myFileString.	self fileOutOn: fileName! !!IndexCardCollection methodsFor: 'fileOut'!fileOutOn: aFileName	| file |	file _ FileStream fileNamed: aFileName.	Cursor write showWhile:		[collection do: [:indexCard | indexCard fileOutOn: file]].	file close.	isLocked _ false! !!IndexCardCollection methodsFor: 'private'!changed: aSymbol	isLocked _ true.	super changed: aSymbol!computeList	| aStringOrInteger |	list _ OrderedCollection new.	filter first = $# 		ifTrue: [aStringOrInteger _ Integer readFrom: 						(ReadStream on: (filter copyFrom: 2 to: filter size))]		ifFalse: [aStringOrInteger _ filter].	filter = '*'		ifTrue:			[collection do: [:indexCard | list add: indexCard]]		ifFalse:			[collection do:				[:indexCard |				(indexCard matchesFilter: aStringOrInteger)					ifTrue: [list add: indexCard]]]!selection	^list at: listIndex! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IndexCardCollection class	instanceVariableNames: ''!!IndexCardCollection class methodsFor: 'examples'!openOn: aString	"IndexCardCollection openOn: 'book1.index'."	| collection topView aTypingView aListView anIndexList aReadOnlyView |	anIndexList _ self on: aString.	topView _ StandardSystemView new.	topView model: anIndexList.	topView label: 'An Index List'.	topView minimumSize: 200 @ 200.	aTypingView _ StringHolderView new.	aTypingView model: (IndexQueryHolder new collection: anIndexList).	aTypingView window: (0@0 extent: 200@5).	aTypingView insideColor: Form white.	aTypingView		borderWidthLeft: 2		right: 2		top: 2		bottom: 1.	topView addSubView: aTypingView.	aListView _ ListView new.	aListView controller: IndexCardListController new.	aListView model: anIndexList.	aListView list: anIndexList list.	aListView window: (0@0 extent: 200@45).	aListView insideColor: Form white.	aListView		borderWidthLeft: 2		right: 2		top: 1		bottom: 1.	topView addSubView: aListView below: aTypingView..	aReadOnlyView _ StringHolderView new.	aReadOnlyView model: anIndexList.	aReadOnlyView controller: Controller new.	"to make it read-only"	aReadOnlyView window: (0@0 extent: 200@20).	aReadOnlyView insideColor: Form white.	aReadOnlyView		borderWidthLeft: 2		right: 2		top: 1		bottom: 2.	topView addSubView: aReadOnlyView below: aListView.	topView controller open! !!IndexCardCollection class methodsFor: 'private'!collectFrom: aStream	"Return a collection of IndexCards read in from the (typically file) stream."	| lastKeys nesting thisCard thisLine collection string nextChar defs mens uses |	lastKeys _ Array new: 10.	collection _ OrderedCollection new.	[aStream atEnd] whileFalse:		[thisCard _ IndexCard new.		nesting _ 0.		defs _ OrderedCollection new.		mens _ OrderedCollection new.		uses _ OrderedCollection new.		thisLine _ ReadStream on: (aStream upTo: Character cr).		[thisLine peekFor: $[] whileTrue: [nesting _ nesting + 1].		string _ thisLine upTo: Character tab.		string isEmpty ifTrue: [self error: 'empty key'].		thisCard key: string.		thisCard nestedFrom: (lastKeys copyFrom: 1 to: nesting).		lastKeys at: nesting+1 put: string.		[nextChar _ thisLine peek.		nextChar == Character tab]			whileFalse:			[nextChar == $(				ifTrue: [thisLine next.						defs add: (self readNumberOrIntervalFrom: thisLine). thisLine next]				ifFalse: [nextChar == $<							ifTrue: [thisLine next.									uses add: (self readNumberOrIntervalFrom: thisLine).									thisLine next]							ifFalse: [mens add: (self readNumberOrIntervalFrom: thisLine)]].			thisLine peekFor: $,. thisLine peekFor: $ ].		thisLine next.	"skip tab"		thisCard definitions: defs; mentions: mens; uses: uses.		thisCard synonyms: (thisLine upTo: Character tab).		thisCard references: (thisLine upTo: Character tab).		thisCard category: (thisLine upTo: Character cr).		collection add: thisCard		].	^collection asSortedCollection!on: aFileName	| file collection |		collection _ self new.	file _ FileStream fileNamed: aFileName.	file readOnly.	Cursor read showWhile: [collection collection: (self collectFrom: file)].	file close.	collection fileName: aFileName.	^collection!readNumberOrIntervalFrom: aStream	| int char |	int _ Integer readFrom: aStream.	(aStream peekFor: $-)		ifTrue: [int _ IndexRange start: int stop: (Integer readFrom: aStream)].	^int! !Magnitude subclass: #IndexRange	instanceVariableNames: 'start stop '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Book Index'!!IndexRange methodsFor: 'accessing'!printOn: aStream	start printOn: aStream.	aStream nextPut: $-.	stop printOn: aStream!start	^start!start: anInteger	^start _ anInteger!stop	^stop!stop: anInteger	^stop _ anInteger! !!IndexRange methodsFor: 'comparing'!< anObject	(anObject isKindOf: IndexRange)		ifTrue: [^start < anObject start]		ifFalse: [^start < anObject]!<= anObject	(anObject class == IndexRange)		ifTrue: [^start <= anObject start]		ifFalse: [^start <= anObject]!= anObject	(anObject isKindOf: IndexRange)		ifTrue: [^(start = anObject start) and: [stop = anObject stop]]		ifFalse: [^false]!>= anObject	(anObject isKindOf: IndexRange)		ifTrue: [^start >= anObject start]		ifFalse: [^start >= anObject]!coerce: aNumber	^self class start: aNumber stop: aNumber!generality	^90!hash	^start hash!includes: aNumber	^start <= aNumber and: [stop >= aNumber]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IndexRange class	instanceVariableNames: ''!!IndexRange class methodsFor: 'instance creation'!start: anInteger stop: another	| inst |	inst _ self new.	inst start: anInteger; stop: another.	^inst! !StringHolder subclass: #IndexQueryHolder	instanceVariableNames: 'collection '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Book Index'!!IndexQueryHolder methodsFor: 'accessing'!collection: anIndexCardCollection	collection _ anIndexCardCollection!contents: aString	super contents: aString.	collection filter: aString! !