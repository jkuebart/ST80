'From The Analyst(tm) on Smalltalk-80 of August 28, 1986 (Dandelion/Daybreak Version 6) on 30 April 1987 at 6:51:16 pm'!!Object methodsFor: 'comparing'!~~ anObject 	"Answer true if the receiver and the argument are not the same object 	(have the same object pointer) and false otherwise."	^(self == anObject) == false! !!Object methodsFor: 'error handling'!booboo: aString 	"Create and start up a SingleChoice menu with the argument as the message in order to inform the user of a bad idea."	^User booboo: aString	"| answer |	Cursor normal showWhile:[	answer _ false.	BinaryChoice		myMessage: aString		displayAt: Sensor cursorPoint		centered: true		ifTrue: [answer _ false]		ifFalse: [answer _ false]].	(Smalltalk includesKey: #Auditor) ifTrue:		[Auditor add: aString, ' -- ', answer printString].	^answer"!confirm: aString 	"Create and start up a BinaryChoice menu with the argument as the message in order to determine true or false. Answers true or false."	^User confirm: aString	"| answer |	Cursor normal showWhile:[	answer _ false.	BinaryChoice		message: aString		displayAt: Sensor cursorPoint		centered: true		ifTrue: [answer _ true]		ifFalse: [answer _ false]].	(Smalltalk includesKey: #Auditor) ifTrue:		[Auditor add: aString, ' -- ', answer printString].	^answer"!confirm: aString yesLabel: yesString noLabel: noString	"Create and start up a SingleChoice menu with the argument as the message in order to determine true or false. User provides the labels. Answers true or false."		^User confirm: aString trueMessage: yesString  falseMessage: noString	"| answer |	answer _ false.	Cursor normal showWhile:[	BinaryChoice		myMessage: aString		displayAt: Sensor cursorPoint		centered: true		yesLabel:yesString		noLabel:noString		ifTrue: [answer _ true]		ifFalse: [answer _ false]].	^answer"!doesNotUnderstand: aMessage 	"First check for a compound selector.  If found, try copying down code	into the receiver's class.  If this is unsuccessful,	announce that the receiver does not understand the argument, aMessage,	as a message.  The default behavior is to create a Notifier containing the 	appropriate message and to allow the user to open a Debugger. 	Subclasses can override this message in order to modify this behavior."	| status gripe |	status _ self class tryCopyingCodeFor: aMessage selector.	status==#OK ifTrue:		[^self perform: aMessage selector withArguments: aMessage arguments].	gripe _ status==#HierarchyViolation		ifTrue: [aMessage selector classPart , ' is not one of my superclasses: ']		ifFalse: ['Message not understood: ', aMessage selector].	(Smalltalk includesKey: #SmalltalkSignal)		ifTrue: [(Smalltalk at: #SmalltalkSignal) signal: gripe]		ifFalse: [(self confirm: gripe, 'Do you want to debug?')			ifTrue: [	NotifierView						openContext: thisContext						label: gripe						contents: thisContext shortStack] 			ifFalse: [NotifierView reportContext: thisContext]].	"Try the message again if the programmer decides to proceed."	^self perform: aMessage selector withArguments: aMessage arguments!error: aString 	"The default behavior for error: is the same as halt:.  	This additional message is the one a subclass should override in order to 	change the handling of errors."			"nil error: 'error message'."	(Smalltalk includesKey: #SmalltalkSignal)		ifTrue: [(Smalltalk at: #SmalltalkSignal) signal: aString]		ifFalse: [(self confirm: aString , 'Do you want to debug?')				ifTrue: [NotifierView						openContext: thisContext						label: aString						contents: thisContext shortStack]				ifFalse: [NotifierView reportContext: thisContext]]! !!Object methodsFor: 'file accessing'!getFileName: aFileName	^self class getFileName: aFileName!getNewFileName: aFileName	^self class getNewFileName: aFileName!getOldFileName: aFileName	^self class getOldFileName: aFileName!openFile: aFileName	^self class openFile: aFileName!openNewFile: aFileName	^self class openNewFile: aFileName!openOldFile: aFileName	^self class openOldFile: aFileName! !DBox comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986.  All rights reserved.'!!DBox methodsFor: 'about links'!addLinkBy: colOfIndices	colOfIndices do: [:anIndex |		((linkTo includes: anIndex) or: [linkTo includes: anIndex negated])			ifTrue: [SmalltalkSignal signal: #recursive]].	linkBy add: colOfIndices"	((linkTo includes: anIndex) or: [linkTo includes: anIndex negated])		ifTrue: [SmalltalkSignal signal: #recursive]		ifFalse: [linkBy add: anIndex]"!addLinkTo: anIndex	((linkBy includes: anIndex) or: [linkBy includes: anIndex negated])		ifTrue: [SmalltalkSignal signal: #recursive]		ifFalse: [linkTo add: anIndex]! !!DBox methodsFor: 'states'!deselected	variable _ nil!disable	state _ false!enable	state _ true!enabled	^state!isSelected	^state		and: [(type == #select or: [type == #multipleSelect])				and: [variable == nil == false]]!selected	variable _ description! !!DBox methodsFor: 'accessing'!description	^description!description: aString	"description is an array of two elements. The first one is the state of the DBox and the second is a string of descriptions."	description _ aString!group	^(group isKindOf: Array)		ifTrue: [group first]		ifFalse: [group]!group: anInterval	group _ anInterval!initial	^initial!initial: aString	initial _ aString.!linkBy	^linkBy!linkTo	^linkTo!query	^query!query: anObject	query _ anObject!type	^type!type: anObject	type _ anObject!variable	^variable!variable: aString	variable _ aString.! !!DBox methodsFor: 'initialize-release'!initialize	linkTo _ OrderedCollection new.	linkBy _ OrderedCollection new.	state _ true	"meaning enable"! !FileStringHolder comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986.  All rights reserved.I represent an interface between a File and an editable view of it.  As a StringHolder, the string is the contents of the File.Instance Variables:	fileStream	<FileStream> onto the file that can be viewed'!!FileStringHolder methodsFor: 'accessing'!getNewContents	"Reinitialize the information the receiver models by re-reading the file stream."	^fileName contentsOfEntireFile!put: aString 	"Update the contents of the file stream with the receiver's contents.  If the file name does not include an explicit version number, create a new version."	fileName writeShorten; reset; nextPutAll: aString; close.	^true! !!FileStringHolder methodsFor: 'private'!setFileName: fullFileName	fileName _ (FileStream fileNamed: fullFileName).	contents _ self getNewContents!setFileStream: aStream 	fileName _ aStream.	contents _ aStream contentsOfEntireFile! !AnnotationModel comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation.  All rights reserved.'!!AnnotationModel methodsFor: 'instance creation'!withSuitcase: aSuitcase defaultSize: minSize	"Answer a scheduled view whose model is aAnnotationModel and whose	label is aString."	| textView topView|	Cursor execute show.	textView _ StringHolderView new.	textView model: self;		controller: ComposeTextController new;		window: (0 @ 0 extent: 1024@800);		insideColor: Form white;		borderWidth: 1.	topView _ StandardSystemView new model: self;		controller: ComposeSystemController new;		borderWidth: 1;		label: (aSuitcase dataItem label);		minimumSize: minSize;		maximumSize: 1024@800;		helpIndex: #Text.	topView classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.	topView addSubView: textView.	Cursor normal show.	topView controller open! !!AnnotationModel methodsFor: 'menu messages'!annotateCreate: aText	"Returns the annotation at key - aString"	| theKey|	theKey _ self getNextKey.	annoDictionary at:theKey  put: aText.	^theKey!annotateDisplay: aString	"Returns the annotation at key as a text "	| annotation|	annotation _ (annoDictionary at: aString ifAbsent:			[self booboo:'the current selection is not an annotation'.			validAnno _ false.			^ aString asText]).	(annotation isKindOf: Text)		ifFalse: [annoDictionary at: aString put: (Object readFrom: (ReadStream on: annotation))].	validAnno _ true.	^annotation _ annoDictionary at: aString!put: text dataItem: aDataItem	self put: text dataItem: aDataItem in: fileName!put: text dataItem: aDataItem in: thisFileStream	| outDict |	Cursor write showWhile:	[thisFileStream writeShorten; writeHeaderFor: aDataItem.	thisFileStream writeShorten; reset; nextPutAll: text string.	outDict _ self findAnyAnnos: text.	self storeDict: outDict on: thisFileStream.	(text runs values = #(1)) ifFalse:		[outDict size = 0			ifTrue: [thisFileStream nextPut: (Character value: 255)].		 thisFileStream nextPut: Character  cr; store: text runs]].	thisFileStream close.	^true! !!AnnotationModel methodsFor: 'private'!changeFileStreamTo: fileStream	fileName == nil ifFalse: [fileName close].	fileName _ fileStream!changeRequest	"Receiver wants to change; check with all dependents that it is OK."	| useLater |	self dependents do: [:dep | dep updateRequest ifFalse: [^false]. useLater _ dep].	fileName close.	(fileName name findString: #TMPV asString startingAt: 1) = 0 ifFalse:		[useLater topView suitcase dataItem centerIndex = 0 ifTrue: [Disk removeKey: fileName name ifAbsent: []]].	^true!setFileStream: aStream 	annoDictionary _ OopConservingDictionary new:16.	nextAnno _ 100.	fileName _ aStream.	contents _ self getNewContents.	annoDictionary removeKey: #classification asString ifAbsent: [].!setFileStream: aStream withSuitcase: theSuitcase	| classification | 	annoDictionary _ OopConservingDictionary new:16.	nextAnno _ 100.	fileName _ aStream.	contents _ self getNewContents.	(theSuitcase updateFromHeaderIn: fileName)		ifFalse: "for backwards compatiblity"				[classification _ annoDictionary at: #classification asString ifAbsent: [^self].				annoDictionary removeKey: #classification asString.				theSuitcase classification: (Classification readFromString: classification)].	theSuitcase accept! !!AnnotationModel methodsFor: 'accessing'!annoDictionary^annoDictionary!annoDictionary: annoDict 	annoDictionary _ annoDict!bossModel	"Answer my boss's model."	^bossModel!bossModel: aBossModel	"Define my boss's model to be aBossModel."	bossModel _ aBossModel!currentAnno	^currentAnno!currentAnno: annoCode	currentAnno _ annoCode!dependentAnnoViews	^dependentAnnoViews!getIntegratedAnnotationText	"printing and other things need the text in a format with the annotations either gone or spelled out at the end"	| sourceText omitPosArray stream character nextCharacter startAnnotation annoString orderedKeys annotation crString |	contents isEmpty ifTrue: [^Text new].	crString _ String with: Character cr.	sourceText _ contents copy. 	((annoDictionary == nil or: [annoDictionary isEmpty]) not and: [self confirm: 'With any annotations?'])		ifTrue: "put the annotations in at the end - this assumes a clean dictionary"			[annoString _ Text new.			(annoDictionary == nil or: [annoDictionary isEmpty]) ifFalse: 				[orderedKeys _ annoDictionary keys asSortedCollection.				 orderedKeys do: [:key |					annotation _ (annoDictionary at: key).					(annotation isKindOf: Text) ifFalse:						[annoDictionary at: key put: (Object readFrom: (ReadStream on: annotation)).						 annotation _ annoDictionary at: key].					annotation _ crString, annotation.					(annotation at: annotation size) = Character cr						ifFalse: [annotation _ annotation, crString].					annotation _ annotation, crString.					annoString _ annoString, (Text string: key emphasis: 2), (Text string: annotation emphasis: 1)]].			^sourceText, (Text string: 'APPENDIX' emphasis: 4), annoString]		ifFalse: "get the annotation markers out of the text"			[omitPosArray _ OrderedCollection new.			stream _ ReadStream on: sourceText.			[stream atEnd] whileFalse: "creates an array of pairs of annotation positions"				[character _ stream next.				 character = $: ifTrue: 					[nextCharacter _ stream next.	"search for ::"					 nextCharacter = $: ifTrue: 						[startAnnotation _ stream position - 1.						 stream skipTo: $:.						 stream skipTo: $:.						 omitPosArray add: (Array with: startAnnotation with: stream position)]]].			omitPosArray reverseDo: [:posPair |				annoString _ sourceText string copyFrom: posPair first to: posPair last.				(annoDictionary includesKey: annoString) ifTrue:					[sourceText						replaceFrom: posPair first						to: posPair last						with: Text new]].			^sourceText]!getNewContents	"Reinitialize the information the receiver models by re-reading the	file stream."	| string runs dictString nextOne|	fileName reopen; readOnly; reset.	string _ fileName upTo: (Character value: 255).	nextOne _ fileName peek.	nextOne = Character cr | nextOne == nil		ifFalse: [self retrieveDict: fileName].	runs _ Compiler evaluate: fileName.	fileName close.	runs == nil		ifTrue: [^string asText]		ifFalse: [^Text string: string runs: runs]!nextAnno: annoCode 	nextAnno _ annoCode!validAnno	^validAnno! !!AnnotationModel methodsFor: 'annotation'!findAnyAnnos: aText 	"Returns a dictionary of any annotations in aText"	| outputDict |	outputDict _ OopConservingDictionary new.	self class cleanDict: outputDict fromString: aText asString fromDict: annoDictionary.	^outputDict!getNextKey	"Returns the next key as a string"	| theKey|	[theKey _ ('::',nextAnno printString,'::').	annoDictionary includesKey:theKey	]	whileTrue:[nextAnno _ nextAnno + 1.].	^theKey!paste: selectedText theDict: passDict 	"checks pastes for annotations and renumbers them if nessary"	| theNewAnno theValue theSwitchDict useThisKey|	theSwitchDict _ OopConservingDictionary new.	passDict == nil		ifFalse:[passDict keys do: [:key | (annoDictionary includesKey: key)		ifTrue: [ useThisKey _ self getNextKey.			theSwitchDict at: key put: useThisKey.			annoDictionary at: useThisKey put: (passDict at:key)]		ifFalse:[annoDictionary at: key put: (passDict at:key)]].	theSwitchDict keys do: [:key | 		theValue _ theSwitchDict at: key.		theNewAnno _ self swapTheAnnos: (passDict at: key)					theDict: theSwitchDict.		annoDictionary at: theValue put: theNewAnno].	self tidyText: selectedText theSwapDict: theSwitchDict.].	^selectedText!retrieveDict: fileStream 	"read in the annotations from the file"	| theValue theRealKey nextOne theText|	annoDictionary _ OopConservingDictionary new.	nextAnno _ 100.	[nextOne _ fileStream peek.	(nextOne = (Character cr)) | (nextOne == nil )]whileFalse: 			[theRealKey _ fileStream upTo: (Character value: 255).			annoDictionary at: theRealKey put:(fileStream upTo: (Character value: 255)).].!storeDict: outDict on: fileStream 	"save this annotaion dictionary"	| theValue |	outDict size = 0 ifFalse:	[fileStream nextPut: (Character value: 255).	 outDict keys do: [:key | 		theValue _ outDict at: key.		fileStream writeShorten; nextPutAll: key.		fileStream nextPut: (Character value: 255).		(theValue isKindOf: Text)			ifTrue: [theValue storeOn:fileStream]			ifFalse: [fileStream writeShorten; nextPutAll: theValue].		fileStream nextPut: (Character value: 255)]]!swapTheAnnos:string theDict:theSwitchDict	"find any annotations in the string and change them if needed"	| newString theValue theIndex theParen theKey |	newString _ string.	theIndex _ 1.	[theIndex _ newString findString: '::' startingAt: theIndex.	theIndex = 0]		whileFalse:[theParen _ newString findString: '::' startingAt: (theIndex+1).			theKey _  newString copyFrom: theIndex to: (theParen+1).			(theSwitchDict includesKey:theKey)	ifTrue:[theValue _ theSwitchDict at:theKey.		newString _ newString replaceFrom:theIndex  to: (theParen+1) with:theValue startingAt:1].		theIndex _ theParen + 1.].	^ newString!tidyText: aText theSwapDict: swapDict 	"clean up this piece of display text"	| theValue theIndex theParen theKey newKey |	theIndex _ 1.	[theIndex _ aText findString: '::' startingAt: theIndex.	theIndex = 0]		whileFalse: 			[theParen _ aText findString: '::' startingAt: (theIndex+1).			theKey _ (aText copyFrom: theIndex to: (theParen+1)) asString.			(swapDict includesKey: theKey)				ifTrue: 					[newKey _ Text string: (swapDict at: theKey)								emphasis: (TextStyle getNumForStrikeFont: 'Helvetica7').					aText						replaceFrom: theIndex						to: (theParen +1)						with: newKey.].					theIndex _ theParen + 1]! !!AnnotationModel methodsFor: 'intialization'!initialize	dependentAnnoViews _ OrderedCollection new.	super initialize! !!AnnotationModel methodsFor: 'locking'!lock	super lock.	bossModel == nil ifFalse: [bossModel lock]! !KeyFileList comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation.  All rights reserved.'!!KeyFileList methodsFor: 'Select key'!toggleListIndex: anInteger	| anAISForm formViewModel offsetPoint |	formViewModel _ whereToPutIt model.	formViewModel white.	listIndex = anInteger		ifTrue:			[listIndex _ 0.			contents _ String new.			fileName _ nil]		ifFalse: 			[listIndex _ anInteger.			Cursor read showWhile:				[anAISForm _ (Form readFrom: (KeyFileList getFileName: (list2 at: anInteger))).				offsetPoint _ 0@0.				(anAISForm extent x < 512) ifTrue:[offsetPoint x: (512 - anAISForm extent x) / 2].				(anAISForm extent y < 512) ifTrue:[offsetPoint y: (512 - anAISForm extent y) / 2].				formViewModel copyBits: anAISForm boundingBox						from: anAISForm 						at: offsetPoint						clippingBox: formViewModel boundingBox						rule: Form over						mask: Form black]].	formViewModel changed: self.	whereToPutIt displayView.	self changed: #listIndex! !!KeyFileList methodsFor: 'accessing'!list	"Answer the list of file names currently accessed by the receiver."	^list!list2	"Answer the list of file names currently accessed by the receiver."	^list2!list: aList	"Set the list of file names currently accessed by the receiver to be the argument,	aList, sorted alphabetically."	list _ aList .	listIndex _ 0.	contents _ String new.	self changed: #list!listIndex	"Answer the index into the receiver's list of the currently selected file name."	^listIndex!listIndex: anInteger	"Set the index into the receiver's list of the currently selected file name."	listIndex _ anInteger!newListAndPattern: aFileName	"The argument, aString, consists of file names and file name patterns separated by	carriage returns.  (Patterns include the character $*.)	Make my new list be those file names, and those files on my directory whose	names match the patterns."	| newList newList2 aStream |	listName _  aFileName.	aStream _ KeyFileList openFile: aFileName.	newList _ OrderedCollection new.	newList2 _ OrderedCollection new.	[aStream atEnd] whileFalse:		[newList add: (aStream upTo: $*).		newList2 add: (aStream upTo: Character cr)].	aStream close.	list _ newList.	list2 _ newList2.	listIndex _ 0.	contents _ String new.	self changed: #list!newListAndPattern: aFileName theKey:key	"lets find the mail items for this list.  The file 'user.safemail' is read and its contents displayed in the 	second list"	| readStream temp listKey |	Cursor read		showWhile: 			[readStream _ (Disk file: aFileName) readOnly.			list _ OrderedCollection new.			list2 _ OrderedCollection new.	key = 'ALL'	ifFalse:[			[readStream atEnd]				whileFalse: 					[listKey _ readStream upTo: $*.					listKey = key						ifTrue: 							[list add: (readStream upTo: $*).							list2 add: (readStream upTo: Character cr)]						ifFalse: [temp _ readStream upTo: Character cr]]]	ifTrue:[			[readStream atEnd]				whileFalse: 					[listKey _ readStream upTo: $*.					list add: (readStream upTo: $*).							list2 add: (readStream upTo: Character cr)]].].	listIndex _ 0.!rewriteListFile	"Update the image list in a biography window."	| index aStream |	aStream _ (KeyFileList openFile: listName) writeShorten.	1 to: list size do: [:index |	aStream nextPutAll: (list at:index),(String with: $*),(list2 at:index), (String with: Character cr)].	aStream close.	self changed: #list!whereToPutIt	^whereToPutIt!whereToPutIt: aKeyView	whereToPutIt _ aKeyView! !!KeyFileList methodsFor: 'menu messages'!deleteImage	"delete an image from the bio window."	whereToPutIt model white .	whereToPutIt display.	list remove:(list at: listIndex) ifAbsent:[^false].	list2 remove:(list2 at: listIndex) ifAbsent:[^false].	self rewriteListFile.!pasteImage	"paste an image into the bio window. "	| type entry theNewForm |	type _ Clipboard nextClass.	type == Form | (type == Text) ifFalse: [^Clipboard booboo].	entry _ Clipboard retrieveEntry.	theNewForm _ (type == Form			ifTrue: [entry contents]			ifFalse: [entry contents asDisplayText form]).	^self pasteImage: theNewForm class: (entry propertyAt: #classification)!pasteImage: aForm class: class	| theNewLabel theNewFileName offsetPoint origForm dataItem theNewForm classif |	classif _ (class == nil ifTrue: [Classification new] ifFalse: [class]).	theNewForm _ aForm.	offsetPoint _ (512@512 - theNewForm extent) / 2.	(offsetPoint x < 0 or: [offsetPoint y < 0]) ifTrue:		[origForm _ theNewForm.		 theNewForm _ Form new extent: (512@512 min: origForm extent).		 theNewForm			copyBits: ((0@0 - offsetPoint max: 0@0) extent: (512@512 min: origForm extent))			from: origForm			at: 0@0			clippingBox: (0@0 extent: 512@512)			rule: Form over			mask: Form black.		 offsetPoint _ 0@0 max: offsetPoint].	theNewForm		border: theNewForm boundingBox		widthRectangle:			((offsetPoint x > 0 ifTrue: [2] ifFalse: [0])@(offsetPoint y > 0 ifTrue: [2] ifFalse: [0])			corner:  (offsetPoint x > 1 ifTrue: [2] ifFalse: [0])@(offsetPoint y > 1 ifTrue: [2] ifFalse: [0]))		mask: Form black.	theNewForm displayOn: whereToPutIt model white at: offsetPoint.	whereToPutIt display.	[theNewLabel _ FillInTheBlank request: 'Name this figure please'  default:'Figure label'.	theNewLabel isEmpty ifTrue: [^false].	(listIndex _ list indexOf: theNewLabel ifAbsent:[0]) = 0]		whileFalse: [(self confirm: 'The name already exists.Do you want to overwrite the old image?')				 ifTrue: [theNewForm writeOn: (list2 at: listIndex).						 ^true]].	theNewFileName _ Disk makeNewFileName: theNewLabel withSuffix: (DataMaster giveMe: #suffixString for: #image asString).	dataItem _ DataItem locked: false classification: classif classification modifiers: classif modifiers type: #Item label: theNewLabel filename: theNewFileName bPointers: nil fPointers: nil atIndex: 0.	theNewForm writeAsDataItem: dataItem.	list add: theNewLabel.	list2 add: theNewFileName.	self listIndex: list size.	self rewriteListFile.	^true!rename	| newName | 	"rename the selection."	[newName _ FillInTheBlank request: 'Please specify a new name '  default: (list at: listIndex).	newName isEmpty ifTrue: [^false].	newName = (list at: listIndex) ifTrue: [^false].	(list indexOf: newName ifAbsent:[0]) = 0] whileFalse.	list at: listIndex put: newName.	self rewriteListFile.	^true! !MapFileList comment:'Copyright (c) 1983, 1984 Xerox Corporation.  All Rights Reserved.'!!MapFileList methodsFor: 'Select image'!toggleListIndex: anInteger	| mapdraw |	listIndex = anInteger		ifTrue:			[listIndex _ 0.			contents _ ''.			fileName _ nil]		ifFalse: 			[listIndex _ anInteger.			Cursor read showWhile:				[(whereToPutIt==nil)					ifFalse:						[						mapdraw _ whereToPutIt controller.						mapdraw getMap: (list2 at: anInteger)]]].	self changed: #listIndex! !!Project methodsFor: 'accessing'!projectWindows	^projectWindows! !DataListModel comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation. All rights reserved.'!!DataListModel methodsFor: 'adding data'!addData: theEntry 	| label value |	labelList add: (theEntry at: 1).	dataList add: (Compiler evaluate: (theEntry at: 2)).	label _ self padString: (theEntry at: 1)				withSpaceInBack: LabelSpace.	value _ self padString: (theEntry at: 2) asNumber printString withSpaceInFront: DataSpace.	^label _ label , value!addStack: theEntry	stackList add: (theEntry at:1).!addStackData: theEntry 	| temp s |	labelList add: (theEntry at: 1).	temp _ OrderedCollection new.	2 to: theEntry size do: [:each | temp add: (Compiler evaluate: (theEntry at: each))].	dataList add: temp.	temp _ self padString: (theEntry at: 1)				withSpaceInBack: LabelSpace.	2 to: theEntry size do: 		[:each | 		s _ self padString: (theEntry at: each) asNumber printString withSpaceInFront: DataSpace.		temp _ temp , s].	^temp! !!DataListModel methodsFor: 'menu messages'!copyLabel: label atIndex: index	CopyBuffer at: 1 put: (dataList at: index) copy.		CopyBuffer at: 2 put: (labelList at: index) copy.	CopyBuffer at: 5 put: label!copyStackLabel: item 	CopyBuffer at: 4 put: (stackList at: item) copy!cutLabel: label atIndex: index	self copyLabel: label atIndex: index.	labelList removeObjectAt: index.	dataList removeObjectAt: index.!cutStackLabel: item	CopyBuffer at: 4 put: (stackList at: item) copy.	stackList removeObjectAt: item.!list	"^dataDisplayList"	| aList temp s t |	aList _ OrderedCollection new.	labelList isEmpty ifTrue: [^aList].	((dataList at: 1) isKindOf: OrderedCollection)		ifTrue: [1 to: labelList size do: 				[:i | 				temp _ String new.				(dataList at: i)					do: 						[:j | 						s _ self padString: j printString withSpaceInFront: 10.						temp _ temp , s].				s _ self padString: (labelList at: i)							withSpaceInBack: 15.				aList add: s , temp]]		ifFalse: [1 to: labelList size do: 				[:i | 				s _ self padString: (labelList at: i)							withSpaceInBack: 15.				t _ self padString: (dataList at: i) printString withSpaceInFront: 10.				aList add: s , t]].	^aList!paste: item 	"check to see if something is there to add.  check also if they have the right 	elements "	(CopyBuffer at: 1) == nil | ((CopyBuffer at: 2) == nil)		ifTrue: [^false]		ifFalse: 			[(CopyBuffer at: 1) size = (dataList at: 1) size				ifFalse: [self booboo: 'Wrong format!!  Cannot paste!!'. ^false].			item = 0				ifTrue: 					[dataList add: (CopyBuffer at: 1) copy.					labelList add: (CopyBuffer at: 2) copy]				ifFalse: 					[dataList add: (CopyBuffer at: 1) copy atIndex: item.					labelList add: (CopyBuffer at: 2) copy atIndex: item].			^true]!pasteStackLabel: item 	((CopyBuffer at: 4) ==nil or: [(CopyBuffer at: 4) isEmpty])		ifTrue: [^false]		ifFalse: 			[item = 0				ifTrue: [stackList add: (CopyBuffer at: 4) copy]				ifFalse: [stackList add: (CopyBuffer at: 4) copy atIndex: item].			^true]! !!DataListModel methodsFor: 'access'!copyBuffer	^CopyBuffer!copyBuffer: anArray	CopyBuffer _ anArray!viewList	"Answer the label list for this folder"	^labelList! !!DataListModel methodsFor: 'initialize'!initialize	"set up the left hand list of the tool box window"	super initialize.	dataList _ OrderedCollection new.	stackList _ OrderedCollection new.	labelList _ OrderedCollection new.! !!DataListModel methodsFor: 'accessing'!dataDisplayList: aList	dataDisplayList _ aList!dataList	^dataList!dataList: aList	dataList _ aList!labelList 	^labelList!labelList: aList	labelList _ aList!stackList	^stackList!stackList: aList	stackList _ aList! !!DataListModel methodsFor: 'private'!padString: aString withSpaceInBack: aNumber 	| string return | 	string _ aString copy.	string size > aNumber		ifTrue: [^string copyFrom: 1 to: aNumber]		ifFalse: 			[return _ String new: aNumber withAll: Character space.			^return				copyReplaceFrom: 1				to: string size				with: string]!padString: aString withSpaceInFront: aNumber 	| string return |	string _ aString copy. 	string size > aNumber		ifTrue: [^string copyFrom: 1 to: aNumber]		ifFalse: 			[return _ String new: aNumber withAll: Character space.			^return				copyReplaceFrom: aNumber - string size + 1				to: aNumber				with: string]! !AutoBook comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!AutoBook methodsFor: 'initialize'!getCountryArray: theBook	"set up the country array from the file FactBook.index"	|fileFlag section dump countryName numberCountries |	countryArray _ OrderedCollection new.	1 to: 18 do: [:i | countryArray add: OrderedCollection new].	indexFileStream _ (self openFile: theBook) readWriteShorten.	numberCountries _ Number readNumberFrom: indexFileStream.		dump _ (indexFileStream upTo: Character cr).		1 to: numberCountries do: [:i |		section _ Number readNumberFrom: indexFileStream.		indexFileStream next.			countryName _ (indexFileStream upTo: Character cr).		(countryArray at:section) add:countryName].	bytePointerList _ OrderedCollection new.	[indexFileStream atEnd] whileFalse:	[bytePointerList add: (indexFileStream upTo: Character cr).].	indexFileStream close.!initialize: theBook"set up the left hand list of the tool box window "	super initialize.	changedFlag _ false.	indexFlag _ false.	mapSection _ 0.	copyBuffer _ OrderedCollection new.	copyBuffer add: String new;		add: String new;		add: String new.	subChapterArray _ Array new.	self getCountryArray: theBook, (self class suffixFor: #index).	sourcesFileStream _ (self openFile: theBook, (self class suffixFor: #sources)) readOnly.	changesFileStream _ (self openFile: theBook, (self class suffixFor: #changes)) readWriteShorten.	contents _ String with: Character space.	firstList _ Array new.	firstListIndex _ 0.	secondList _ Array new.	secondListIndex _ 0.	thirdListIndex _ 0.	thirdList _ Array new.! !!AutoBook methodsFor: 'first list'!firstListIndex	"Answer the selected index for the first view"	^ firstListIndex!firstListIndex: anInteger	"Set the selected mainViewListIndex to be anInteger.		Update all other selections to be deselected."	firstListIndex _ anInteger.	contents _ String with: Character space.	secondListIndex _ 0.	secondList _ Array new.	thirdListIndex _ 0.	thirdList _ Array new.	anInteger = 0		ifFalse: [self getCountry].	self changed: #firstViewSelectionChanged!firstViewList	"Answer the list for the first view"	^ firstList!toggleFirstListIndex: anInteger	"If anInteger is the current first view selection, deselect it. Else		make it the new selection."	self firstListIndex: (firstListIndex = anInteger		ifTrue: [0]		ifFalse: [anInteger])! !!AutoBook methodsFor: 'first list action'!fixCountryIndex: byteCount	"patch up the bytePointerList to show the new location for this countries data"	bytePointerList at: (Number readFromString:((firstPointerList) at: firstListIndex)) put: ( '0 ',(byteCount printString))!getCountry	"a country has been selected so read it in"| tempString  whichFile bytePointer	number|	number _ Number readFromString:((firstPointerList) at: firstListIndex).	Cursor read showWhile:[tempString _ bytePointerList at: number.	whichFile _ Number readFromString: tempString.	tempString _ tempString copyFrom:3 to: tempString size .	bytePointer _ Number readFromString: tempString.	whichFile = 1		ifTrue:[self readCountryData: sourcesFileStream where: bytePointer]		ifFalse:[self readCountryData: changesFileStream where: bytePointer].]!mustSaveCountryData	"a country has been changed so write to the end of the changes file"	| byteCount |	changedFlag _ false.	indexFlag _ true.	Cursor write showWhile: [	changesFileStream setToEnd.	byteCount _ changesFileStream position.	changesFileStream nextPutAll: countryHeader.	changesFileStream nextPut: Character cr.	changesFileStream nextPutAll: (secondList size) printString.	changesFileStream nextPut: Character cr.	1 to: secondList size do:		[:i | changesFileStream nextPutAll: (((subChapterArray at: i) size) printString),' ',(secondList at: i).			changesFileStream nextPut: Character cr.].	1 to: secondList size do:		[:i | 1 to: (subChapterArray at: i) size do: [:k | changesFileStream nextPutAll: ((subChapterArray at: i ) at: k), '^']].	changesFileStream nextPut: $_.	self fixCountryIndex: byteCount.	changesFileStream close.].!readCountryData: theFileStream where: bytePointer	"a country has been selected so read it in"| tempString  sectionCount	 tempArray number|	theFileStream position: bytePointer.	countryHeader _ theFileStream upTo: Character cr.	sectionCount _ Number readNumberFrom: theFileStream.	tempString _ theFileStream upTo: Character cr.	secondList _ OrderedCollection new.	subChapterArray _ OrderedCollection new.	tempArray _ OrderedCollection new.	1 to: sectionCount do:[:i|tempArray add: (Number readNumberFrom: theFileStream).		tempString _ theFileStream next. "skip the space"		secondList add: (theFileStream upTo: Character cr).].	1 to: sectionCount do:[:i|subChapterArray add: OrderedCollection new.		1 to: (tempArray at: i) do:[:k| (subChapterArray at: i )add: (theFileStream upTo: $^).			tempString _ theFileStream upTo: Character cr.]].!saveIndexFile	"set up the country array from the file theBook.index"	|fileFlag section pointer countryName number counter|	changedFlag = true		ifTrue: [self writeCountryData].	sourcesFileStream setToEnd.	sourcesFileStream close.	changesFileStream setToEnd.	changesFileStream close.	indexFlag = true		ifFalse:			[indexFileStream setToEnd.			indexFileStream close.			^true].	Cursor write showWhile: [	indexFileStream reset.	number _ 0.	1 to: countryArray size do: [:i |		number _ number + ((countryArray at:i) size)].	indexFileStream nextPutAll: number printString.	indexFileStream nextPut: Character cr.	1 to: countryArray size do: [:i |		1 to: ((countryArray at:i) size) do: [:k |	indexFileStream nextPutAll: i printString.	indexFileStream nextPut: Character space.	indexFileStream nextPutAll: ((countryArray at: i) at: k).	indexFileStream nextPut: Character cr.]].	1 to: bytePointerList size do:		[:i | indexFileStream nextPutAll: (bytePointerList at: i).			indexFileStream nextPut: Character cr.].	indexFileStream close.]!setFirstList: location	| tempList displayList newString|	mapSection _ location.	contents _ String with: Character space.	displayList _ OrderedCollection new.	firstPointerList _ OrderedCollection new.	tempList _  countryArray at: location.	1 to: tempList size do: [:i | newString _ (tempList at: i) copyUpTo: $*.	displayList add: newString.	firstPointerList add: ((tempList at: i) copyFrom: ((tempList at: i) indexOf: $*) + 1 to: (tempList at: i) size)].	firstList _  displayList..	firstListIndex _0.	secondList _Array new.	secondListIndex _0.	thirdList _Array new.	secondListIndex _0.	self changed: #countrySelectionChanged!writeCountryData	"a country has been changed so write to the end of the changes file"	|byteCount|	changedFlag _ false.	(self confirm: 'Contents have been changed for ',(firstList at: firstListIndex),'.Do you want to save those changes?') ifFalse: [^self].	self mustSaveCountryData! !!AutoBook methodsFor: 'second list'!secondListIndex	"Answer the selected index for the second view"	^ secondListIndex!secondListIndex: anInteger	"Set the selectedsecondListIndex to be anInteger.		Update all other selections to be deselected."	secondListIndex _ anInteger.	contents _ String with: Character space.	thirdListIndex _ 0.	thirdList _ Array new.	anInteger = 0		ifFalse: [self setThirdList].	self changed: #secondViewSelectionChanged!secondViewList	"Answer the list for the second view"	^ secondList!toggleSecondListIndex: anInteger	"If anInteger is the current Second view selection, deselect it. Else		make it the new selection."	self secondListIndex: (secondListIndex = anInteger		ifTrue: [0]		ifFalse: [anInteger])! !!AutoBook methodsFor: 'second list action'!setThirdList	| tempList displayList newString|	displayList _ OrderedCollection new.	tempList _  subChapterArray at: secondListIndex.	1 to: tempList size  do:[:i|newString _ (tempList at: i) copyUpTo: $:.	displayList add: newString].	thirdList _  displayList.! !!AutoBook methodsFor: 'third list'!acceptText	"accept this text in to the model"	(subChapterArray at: secondListIndex)at:thirdListIndex put: contents asString.	changedFlag _ true!thirdListIndex	"Answer the selected index for the third view"	^ thirdListIndex!thirdListIndex: anInteger	"Set the selectedthirdListIndex to be anInteger.		Update all other selections to be deselected."	thirdListIndex _ anInteger.	contents _ String with: Character space.	anInteger = 0		ifTrue: [self changed: #thirdViewSelectionChanged]		ifFalse: [contents _ (subChapterArray at: secondListIndex) at: thirdListIndex].	self changed: #displayContents!thirdViewList	"Answer the list for the third view"	^ thirdList!toggleThirdListIndex: anInteger	"If anInteger is the current Third view selection, deselect it. Else		make it the new selection."	self thirdListIndex: (thirdListIndex = anInteger		ifTrue: [0]		ifFalse: [anInteger])! !!AutoBook methodsFor: 'accessing'!changedFlag	^changedFlag!indexFlag	^indexFlag!mapSection	^mapSection! !!AutoBook methodsFor: 'mm country'!addCountry	"add a new country here"	|cname newString|	indexFlag _ true.	cname _ FillInTheBlank request: 'input new country name' default: String new.	bytePointerList add: '1 0'.	(countryArray at: mapSection) add: cname, (String with: $*), bytePointerList size printString.	self setFirstList: mapSection.	firstListIndex _ firstList size.	self getCountry.	countryHeader _ (String with: $*), cname, (String with: $*), mapSection printString.	1 to: secondList size do: [:i |		1 to: (subChapterArray at: i) size do: [:k |			newString _ ((subChapterArray at: i) at: k) copyUpTo: $:.			(subChapterArray at: i) at: k put: newString, ':'].].	self mustSaveCountryData.	copyBuffer at: 1 put: ((countryArray at: mapSection) at: firstListIndex).	firstListIndex _ 0.	self setFirstList: mapSection.	self changed: #firstViewSelectionChanged!copyCountry	"save the pointer to this country and its section in the saveBuffer as an ordered collection"	indexFlag _ true.	copyBuffer at: 1 put: ((countryArray at: mapSection) at: firstListIndex ).!cutCountry	"save the pointer to this country and its section in the saveBuffer as an ordered collection"	indexFlag _ true.	copyBuffer at: 1 put: ((countryArray at: mapSection) at: firstListIndex ).	(countryArray at: mapSection) removeObjectAt: firstListIndex.	self setFirstList: mapSection.	firstListIndex _ 0.	self changed: #firstViewSelectionChanged!editCountry	"edit this country name"	|theSectionName tempList theEnd newString|	tempList _  countryArray at: mapSection.	newString _ (tempList at: firstListIndex) copyUpTo: $*.	theEnd _ ((tempList at: firstListIndex) copyFrom:((tempList at: firstListIndex) indexOf: $*) to: (tempList at: firstListIndex) size).	theSectionName _ FillInTheBlank request: 'edit the country name' default: newString.	(countryArray at: mapSection) at: firstListIndex put: theSectionName,theEnd.		indexFlag _ true.	self setFirstList: mapSection.	self changed: #firstViewSelectionChanged!pasteCountry	"save the pointer to this country and its section in the saveBuffer as an ordered collection"		indexFlag _ true.	(copyBuffer at: 1) = String new	ifTrue: [self booboo: 'There is no country to paste.']	ifFalse: [(countryArray at: mapSection) add: (copyBuffer at: 1).		self setFirstList: mapSection.		self changed: #firstViewSelectionChanged].!showAllCountry.	"make the contents to be all of the selected country.		Update all other selections to be deselected."	contents _ String new.	1 to: secondList size do: [:k |		contents _ contents, (secondList at: k),''.		1 to: (subChapterArray at: k) size do: [:i |		contents _ contents, '	', ((subChapterArray at: k) at: i),''].].	self changed: #displayContents! !!AutoBook methodsFor: 'mm chapter'!addChapter	"add new chapter to this Section"	|cname tempArray|	cname _ FillInTheBlank request: 'input new chapter' default: 'heading'.	tempArray _ OrderedCollection new.	tempArray add: cname.	tempArray add: OrderedCollection new.	copyBuffer at: 3 put: tempArray.	secondList add: cname.	subChapterArray add: OrderedCollection new.	self upDateChapter!copyChapter	"copy the selected chapter in this Section"	|tempArray|		tempArray _ OrderedCollection new.	tempArray add: (secondList at: secondListIndex).	tempArray add: (subChapterArray at: secondListIndex).	copyBuffer at: 3 put: tempArray.!cutChapter	"remove the selected chapter in this Section"	|cname tempArray|	tempArray _ OrderedCollection new.	tempArray add: (secondList at: secondListIndex).	tempArray add: (subChapterArray at: secondListIndex).	copyBuffer at: 3 put: tempArray.	secondList removeObjectAt: secondListIndex.	subChapterArray removeObjectAt: secondListIndex.	self upDateChapter!editChapter	"copy the selected chapter in this Section"	|cname tempArray|	secondList at:secondListIndex put: (FillInTheBlank request: 'edit the chapter label' default: (secondList at:secondListIndex)).	tempArray _ OrderedCollection new.	tempArray add: (secondList at: secondListIndex).	tempArray add: (subChapterArray at: secondListIndex).	copyBuffer at: 3 put: tempArray.	changedFlag _ true.	self changed: #firstViewSelectionChanged!pasteChapter	"add the chapter in the buffer to this Section"	|cname tempArray|	tempArray _ copyBuffer at: 3.	secondListIndex = 0		ifTrue:[secondList add: (tempArray at: 1).			subChapterArray add: (tempArray at: 2)]		ifFalse:[secondList add: (tempArray at: 1) atIndex: secondListIndex.			subChapterArray add: (tempArray at: 2) atIndex: secondListIndex.].	self upDateChapter!showAllChapter	"make the contents to be all of the selected chapter.		Update all other selections to be deselected."	contents _ String new.	1 to: (subChapterArray at: secondListIndex) size do: [:i |		contents _ contents, ((subChapterArray at: secondListIndex) at: i), ''].	self changed: #displayContents!upDateChapter	"update chapter list"	secondListIndex _ 0.	thirdListIndex _ 0.	thirdList _ Array new.	changedFlag _ true.	self changed: #firstViewSelectionChanged! !!AutoBook methodsFor: 'mm subChapter'!addSubChapter	"add new sub-chapter to this chapter"	|cname|	cname _ FillInTheBlank request: 'input new heading' default: 'heading'.	(subChapterArray at: secondListIndex) add: cname, (String with: $: with: Character space).	copyBuffer at: 3 put: cname, (String with: $: with: Character space).	self upDateSubChapter!copySubChapter	"copy selected sub-chapter to this chapter"	copyBuffer at: 3 put: ((subChapterArray at: secondListIndex) at: thirdListIndex).!cutSubChapter	"remove selected sub-chapter to this chapter"	copyBuffer at: 3 put: ((subChapterArray at: secondListIndex) at: thirdListIndex).	(subChapterArray at: secondListIndex) removeObjectAt: thirdListIndex.	self upDateSubChapter!editSubChapter	"edit the selected sub-chapter in this chapter"	|newString tempList oldString theText|	oldString _ (subChapterArray at: secondListIndex) at: thirdListIndex.	newString _ oldString  copyUpTo: $:.	newString _  FillInTheBlank request: 'edit the sub-chapter label' default:newString.	theText _ oldString copyFrom:(oldString indexOf: $:) to: oldString size.	(subChapterArray at: secondListIndex) at: thirdListIndex put: newString,theText.	copyBuffer at: 3 put: ((subChapterArray at: secondListIndex) at: thirdListIndex).	thirdList _ OrderedCollection new.	tempList _ subChapterArray at: secondListIndex.	1 to: tempList size  do:[:i| newString _ (tempList at: i) copyUpTo: $:.		thirdList add: newString].	contents _  newString,theText.	changedFlag _ true.	self changed: #secondViewSelectionChanged!pasteSubChapter	"remove selected sub-chapter to this chapter"	thirdListIndex = 0		ifTrue:[(subChapterArray at: secondListIndex) add: (copyBuffer at: 3).]		ifFalse:[(subChapterArray at: secondListIndex) add: (copyBuffer at: 3) atIndex: thirdListIndex.].	 self upDateSubChapter!showSubChapter	"make the contents to be all of the selected chapter.		Update all other selections to be deselected."	contents _ (subChapterArray at: secondListIndex)at: thirdListIndex.	self changed: #displayContents!upDateSubChapter	"update sub chapter to this chapter"	|tempList newString|	thirdList _ OrderedCollection new.	tempList _ subChapterArray at: secondListIndex.	1 to: tempList size  do:[:i| newString _ (tempList at: i) copyUpTo: $:.		thirdList add: newString].	thirdListIndex _ 0.	changedFlag _ true.	contents _ String new.	self changed: #secondViewSelectionChanged! !!AutoBook methodsFor: 'mm map'!compressChanges	| newChangesStream bytePointer tempString newChangesPosition whichFile changesFileName |	(self confirm: 'Are you sure you want to compress the changes file ?This will take some time.') ifFalse: [^self].	Cursor write showWhile: [	newChangesStream _ (self openFile: 'CMPRSXXX', (self class suffixFor: #changes)) writeShorten.	1 to: bytePointerList size do:		[:i |		newChangesPosition _ newChangesStream position.		tempString _ bytePointerList at: i.		whichFile _ Number readFromString: tempString.		tempString _ tempString copyFrom: 3 to: tempString size.		bytePointer _ Number readFromString: tempString.		whichFile = 0 ifTrue:			[changesFileStream position: bytePointer.			Cursor read show.			tempString _ changesFileStream upTo: $_.			Cursor write show.			newChangesStream nextPutAll: tempString; nextPut: $_.			bytePointerList at: i put: '0 ', newChangesPosition printString]].	Cursor normal show.	newChangesStream close.	changesFileName _ changesFileStream name.	changesFileStream close.	Disk removeKey: changesFileName ifAbsent: [].	Disk renameKey: newChangesStream name newName: changesFileName.	changesFileStream _ (self openFile: changesFileName) readWriteShorten.	indexFlag _ true]!rewriteSources	"write a new sources file from the current data in the old source file and the changes file"	| newSourceStream tempString whichFile bytePointer newSourcePosition sourcesFileName |	(self confirm: 'Are you sure you want to rewrite the sources file?This will take some time.') ifFalse: [^self].	Cursor write showWhile: [		newSourceStream _ (self openFile: 'CMPRSXXX', (self class suffixFor: #sources)) writeShorten.	1 to: bytePointerList size do:		[:i |		newSourcePosition _ newSourceStream position.		tempString _ bytePointerList at: i.		whichFile _ Number readFromString: tempString.		tempString _ tempString copyFrom: 3 to: tempString size .		bytePointer _ Number readFromString: tempString.		Cursor read show.		whichFile = 1			ifTrue:				[sourcesFileStream position: bytePointer.				tempString _ sourcesFileStream upTo:  $_]			ifFalse:				[changesFileStream position: bytePointer.				tempString _ changesFileStream upTo:  $_].		Cursor write show.		newSourceStream nextPutAll: tempString, '_'.		bytePointerList at: i put: '1 ', newSourcePosition printString].	Cursor normal show.	newSourceStream close.	sourcesFileName _ sourcesFileStream name.	sourcesFileStream close.	Disk removeKey: sourcesFileName ifAbsent: [].	Disk renameKey: newSourceStream name newName: sourcesFileName.	sourcesFileStream _ (self openFile: sourcesFileName) readOnly.	changesFileStream reset.	changesFileStream close.	indexFlag _ true]! !RS232FunctionKeys comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!RS232FunctionKeys methodsFor: 'actions'!bufferSelectedFunction	"store elements of selected function in an array, and return it"	| buffer |	buffer _ Array new: 3.	buffer		at: 1 put: (keyList at: viewListIndex);		at: 2 put: (viewList at: viewListIndex);		at: 3 put: (viewActionList at: viewListIndex).	^ buffer!putLabelDefs	"store the current definition of the labels"	"need to rewrite only that section of the file having to do with this program"	"go through the keyList, outputting each key, its corresponding label, and it's function.		If the key is that of a user function, then the key is $?"	| sectionStream key |	sectionStream _ WriteStream on: String new.	1 to: viewList size do:		[:i |		 ((key _ keyList at: i) isKindOf: Integer)			ifTrue: [key _ $?].	"user def"		 (key isKindOf: Character) ifTrue:			[sectionStream				nextPut: key;				nextPutAll: (viewList at: i);				nextPutAll: (String with: $| with: $|);				nextPutAll: (viewActionList at: i);				nextPutAll: (String with: $| with: $|);				nextPut: Character cr]].	ConfigFileModel replaceSection: (userAndProgram at: 2) inFile: (userAndProgram at: 1), '-FunctionKeyDefs' with: sectionStream contents inSectionName: nil! !!RS232FunctionKeys methodsFor: 'initialize'!getLabelDefs	"set defs for current program"	lastUserKey _ 0.	keyList _ OrderedCollection new.	viewList _ OrderedCollection new.	viewActionList _ OrderedCollection new.	viewListIndex _ 0.	self readLabelDefs	"initialize function key lists"!initForUser: aUser onSection: sectionName	userAndProgram _ Array with: aUser with: sectionName.	contents _ nil.	self getLabelDefs		"initialize function key lists"!readLabelDefs	"read defs for this program and put in the lists"	| aStream aLabel function key section |	aStream _ (FileStream fileNamed: (userAndProgram at: 1), '-FunctionKeyDefs' asFileName) readOnly.	"return the text of program section"	section _ ConfigFileModel getSection: (userAndProgram at: 2) inStream: aStream.	aStream close.	aStream _ ReadStream on: section.	[aStream atEnd]		whileFalse:			[key _ aStream next.			 aLabel _ self parseStringFrom: aStream.			 function _ self parseStringFrom: aStream.			 (key = $?) ifTrue: [key _ self newUserKey].			 self addFunctionLabel: aLabel withAction: function atKey: key.			 aStream skipTo: Character cr	"proceed to end of line"			]! !!RS232FunctionKeys methodsFor: 'list access'!addBufferedFunction: functionKeyBuffer	"insert contents of functionKeyBuffer into the function list in front of what		is now selected, or if nothing selected, put at the end of the list.		Give it a new key if there is already a function using the current one"	| key |	key _ functionKeyBuffer at: 1.	(0 < (keyList findFirst: [:k | k = key]))		ifTrue: [key _ self newUserKey].	(viewListIndex = 0)		ifTrue:			[viewList addLast: (functionKeyBuffer at: 2).			 keyList addLast: key.			 viewActionList addLast: (functionKeyBuffer at: 3).			 viewListIndex _ viewList size			]		ifFalse:			[viewList add: (functionKeyBuffer at: 2) atIndex: viewListIndex.			 keyList add: key atIndex: viewListIndex.			 viewActionList add: (functionKeyBuffer at: 3) atIndex: viewListIndex			]!addFunctionKey: aKey withString: aString	"add to the function key list for the view, create label from text to be sent"	| aLabel |	aString = String new ifTrue: [^self].	aLabel _ aString copyUpTo: Character cr.	aLabel = String new		ifTrue: [aLabel _ 'Enter']		ifFalse: [aLabel = (String with: $	 "Tab") ifTrue: [aLabel _ 'Tab']].	self addFunctionLabel: aLabel withAction: aString atKey: aKey!addFunctionLabel: aLabel withAction: aString atKey: aKey	"add to the function key list for the view, or redefine key if already defined"	| index |	(0 = (index _ keyList findFirst: [:k | k = aKey]))		ifTrue:			[viewList addLast: aLabel.			 keyList addLast: aKey.			 viewActionList addLast: aString]		ifFalse:			[(viewActionList at: index) = aString	"Is this action already there?"				ifFalse:	"Only redefine if it isnt"					[viewList at: index put: aLabel.					 viewActionList at: index put: aString]]!changeSelectedLabelTo: aString	"change the currently selected label to aString. This does not update the view's list"	viewList at: viewListIndex put: aString!definitionForKey: theKey	"return the string associated with theKey"	| index |	(index _ keyList indexOf: theKey) = 0		ifFalse: [^viewActionList at: index].	^String new!isItUserDefKey	"answer if current selection is of a user defined function"	^ ((keyList at: viewListIndex) isKindOf: Integer)!newUserKey	^ lastUserKey _ lastUserKey + 1!removeSelectedItem	"remove the currently selected function. Leave it to caller to update display"	viewList removeObjectAt: viewListIndex.	viewActionList removeObjectAt: viewListIndex.	keyList removeObjectAt: viewListIndex.	viewListIndex _ 0!toggleListIndex: anInteger	"If anInteger is the current view selection, deselect it.		Else make it the new selection."	viewListIndex _		(viewListIndex = anInteger			ifTrue: [0] ifFalse: [anInteger]).	contents _ nil.	self changed: #viewSelectionChanged!viewActionList	"Answer the function action list for the view"	^ viewActionList!viewList	"Answer the function list for the view"	^ viewList!viewListIndex	"Answer the selected index for the view"	^ viewListIndex!zapKeyAt: theKey	| index | 	index _ keyList indexOf: theKey.	viewList removeObjectAt: index.	viewActionList removeObjectAt: index.	keyList removeObjectAt: index.	viewListIndex _ 0!zapSpecialKeys	| newKeyList newViewList newViewActionList testKey |	newKeyList _ OrderedCollection new.	newViewList _ OrderedCollection new.	newViewActionList _ OrderedCollection new.	1 to: keyList size do:		[:i |		((testKey _ keyList at: i) class == String and: [(testKey at: 1) = $+]) ifFalse:			[newKeyList addLast: (keyList at: i).			newViewList addLast: (viewList at: i).			newViewActionList addLast: (viewActionList at: i)]].	viewList _ newViewList.	keyList _ newKeyList.	viewActionList _ newViewActionList.	viewListIndex _ 0! !!RS232FunctionKeys methodsFor: 'private'!changeToUser: aUser andProgram: sectionName	userAndProgram _ Array with: aUser with: sectionName.!parseStringFrom: aStream	"read in characters up to (but not including) the next double-|		and return that as a string"	| bufferStream chr |	bufferStream _ WriteStream on: (String new: 200).	[aStream atEnd] whileFalse:		[chr _ aStream next.		 (chr = $| and: [aStream peek = $|])			ifTrue:				[aStream next.	"gobble |"				 ^ bufferStream contents].		 bufferStream nextPut: chr		].	^ bufferStream contents!userAndProgram	^userAndProgram!userWriteAccess	"return whether this user has write permission (either the owner or a wheel)"	^((userAndProgram at: 1) = UserName or: [Wheel])! !ConfigFileModel comment:'Copyright (c) 1986 Xerox Corporation. All rights reserved.'!EditStringHolder comment:'Copyright (c) 1986 Xerox Corporation. All rights reserved.'!!EditStringHolder methodsFor: 'editing'!evaluateAcceptBlock	blockOnAccept value: contents value: argsOnAccept!initialize	super initialize.	blockOnAccept _ [:cnts :args | "this is the default block - do nothing"].	argsOnAccept _ nil.!openEditorOn: initContents blockOnAccept: aBlock withArgs: args withLabel: aLabel	"open an edit window on the text defaultContents. If changes are accepted, evaluate aBlock with arguments of the new contents and whatever args is"	| topView |	contents _ initContents.	blockOnAccept _ aBlock.	argsOnAccept _ args.	topView _ StandardSystemView new.	topView		model: self;		label: aLabel;		minimumSize: 450 @ 450.	topView addSubView:		(StringHolderView new			model: self;			controller: EditStringHolderController new;			insideColor: Form white;			borderWidthLeft: 2 right: 2 top: 2 bottom: 2).	topView controller open! !RS232Model comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.<serialPort>	an AsyncSerialPort (or subclass) which takes care of the actual transmission of data.<inputStops>	an Array of 128 that contains a symbol to perform at each location asciiValue + 1 that an input character needs special handling. <stateOfRS232>	an Integer. Has possible values: 1=transmit; 2=receive; 3=browse; 4=edit function keys<abortSignal>	a Signal.  Used by the basic parsing mechanism to unwind cleanly from anywhere in the parser upon termination of receive state.<rs232Windows>	an Array containing the views for the window panes: 1- status, 2 - received text, 3 - send text, 4 - function keys, 5 - function key status.<displayStream>	an RS232DisplayMem which does the displaying (and remember what was  displayed) in the receive pane.<numLines>	an Integer.  The number of lines that have been displayed on the current page (since the last nextPage).<programName>	a String (or nil).  Used by some subclasses to keep track of what the window was opened for.<SaveState>	nil or an Array with: a Rectangle with: a Form, where a Rectangle is the area on the screen for a Form, which is a copy of the displayed contents of the receive pane, for restoring the display after leaving the window or browsing.'!!RS232Model methodsFor: 'initialize/release'!initialize	super initialize.	serialPort _ AsyncSerialPort new open: 1.	serialPort sendTextString: (String with: Character cr). "get it started"	self setInputStops. 	stateOfRS232 _ 1.	"1 = transmit; 2 = receiving; 3 = browse "	numLines _ 0.	abortSignal _ Signal new.	self initializeWatchRS232!initializeWatchRS232	(displayStream _ RS232DisplayMem new) combRule: Form over.	rs232Windows _ Array new: 4. "status, received text, send text, function keys"!openRS232View	"Create an instance of RS232SystemView with RS232Collector as model."	| topView |	topView _ StandardSystemView new.	topView		model: RS232Collector;		controller: RS232SystemController new;		label: 'RS232';		minimumSize: 500 @ 677;		maximumSize: 500 @ 677.	"create subView for current status"	rs232Windows at: 1 put: MessageView new.	(self statusWindow)		withEmphasis: 5;		contents: 'Transmit';		insideColor: Form white;		controller: NoController new;		borderWidthLeft: 2 right: 2 top: 2 bottom: 1.	topView addSubView: self statusWindow viewport: (0 @ 0 extent: 500 @ 20).	"create subView for RS232 reception"	rs232Windows at: 2 put: RS232TextView new.	self rs232Window		model: RS232Collector;		insideColor: Form white;		borderWidthLeft: 2 right: 2 top: 1 bottom: 1;		window: (0 @ 0 extent: 500 @ 594).	topView addSubView: self rs232Window below: self statusWindow.	"create subView for sending window"	rs232Windows at: 3 put: StringHolderView new.	self sendWindow		model: StringHolder new;		controller: RS232SendController new;		insideColor: Form white;		borderWidthLeft: 2 right: 2 top: 1 bottom: 2;		window: (0 @ 0 extent: 500 @ 63);		editString: String new. "tacky way to be sure get right kind of Paragraph".	topView addSubView: self sendWindow below: self rs232Window.	Cursor normal show.	topView controller open!release	serialPort release.	displayStream release.	SaveState _ nil.	super release!setInputStops	"set up array which determines what action should		be performed for every character input on RS-232"	inputStops _ Array new: 128.	inputStops		at: 16r0 + 1 put: #ignoreChar;		at: 16rA + 1 put: #ignoreChar;		"LF"		at: 16rC + 1 put: #nextPage;		"form feed"		at: 16rD + 1 put: #cr;	"CR"		at: 16r11 + 1 put: #rs232ToTransmitState;		"Xon"		at: 16r7F + 1 put: #ignoreChar		"ascii DEL char"! !!RS232Model methodsFor: 'entry control'!appendTextPages: n	"refresh window display, with the current contents plus the next n pages"	| newContents |	newContents _ self contentsStream nextPagesForAppend: n.	(newContents isKindOf: Text)		ifFalse:			[newContents == nil ifTrue: [^true].	"page unchanged"			 newContents _ Text string: newContents emphasis: DefaultFont].	contents _ contents, newContents.	self updateBrowseDisplay!browseTextPage: aChar	"refresh window display, with contents from the page represented by aChar"	contents _ self contentsStream getPageByCode: aChar.	(contents isKindOf: Text)		ifFalse:			[contents == nil ifTrue: [contents _ String new. ^true].	"page unchanged"			 contents _ Text string: contents emphasis: DefaultFont].	self updateBrowseDisplay!checkWindowLocation	| w | 	(displayStream updateWindowLoc: (w _ self rs232Window insetDisplayBox)) ifTrue:		[SaveState == nil			ifTrue:				[SaveState _ Array with: w with: (Form extent: w extent).				self blankSaveState]			ifFalse: [SaveState at: 1 put: w].		self restoreSaveState.		^true].	self restoreSaveState.	^false!contentsStream	^ displayStream contentsStream!defaultFont	^DefaultFont!displayMemory	^ displayStream!displayStatus: aString	"display aString in status window"	(rs232Windows at: 1) updateDisplayTo: aString asString!functionKeysWindow	^ rs232Windows at: 4!getTextPages: firstPage to: lastPage	"refresh window display, with contents from page firstPage through lastPage"	contents _ displayStream contentsStream getPages: firstPage to: lastPage.	(contents isKindOf: Text)		ifFalse:			[contents == nil ifTrue: [contents _ String new. ^true].	"page unchanged"			 contents _ Text string: contents emphasis: DefaultFont].	self updateBrowseDisplay!idleForm	"offers the oppotunity to have a different Idle cursor to remind the user of this window's presence"	^((Text string:'  Terminal  Emulation   Window    is open ' emphasis: 8) asParagraph asForm reverse)!insertTextPages: n	"refresh window display, with the current contents plus the previous n pages"	| newContents |	newContents _ self contentsStream prevPagesForAdd: n.	(newContents isKindOf: Text)		ifFalse:			[newContents == nil ifTrue: [^true].	"page unchanged"			 newContents _ Text string: newContents emphasis: DefaultFont].	contents _ newContents, contents.	self updateBrowseDisplay!logSentText: logText	displayStream paintStringAsLine: logText!programName	^programName!rs232Window^ rs232Windows at: 2!scrollToEnd	self rs232Window controller scrollToEnd!sendWindow^ (rs232Windows at: 3)!serialPort	^serialPort!shutDown: fromInside	"prepare to close window if user answers affirmatively"	"fromInside is a boolean to indicate if the user is inside the window, or coming from outside somewhere" 	fromInside		ifTrue: [(self confirm: 'Are you sure?') ifFalse: [^false]]		ifFalse: [(self confirm: ('RS232 window is still open.O.K. to close it?')) ifFalse: [^false]].	^ true!statusWindow	^ (rs232Windows at: 1)!updateBrowseDisplay	"refresh browse window display"	self displayStatus: ('Browsing pages ', displayStream contentsStream pageStatus).	Display white: self rs232Window insetDisplayBox.	self changed: #update! !!RS232Model methodsFor: 'input parsing'!clearMemory	displayStream clearMemory.	"clear buffer"	displayStream clearLines: 1 to: displayStream maxLines.!cr	numLines _ numLines + 1.	displayStream paint: Character cr.	self checkForUserInput	"need to check every once in aWhile"!ignoreChar	"should not be displayed or saved"	^false!nextPage	"cause a next page on display and in saved contents"	numLines _ 0.	displayStream nextPage!userClearMemory	self clearMemory.	self blankSaveState.! !!RS232Model methodsFor: 'reading and writing'!checkRS232Input	"get a character from RS232, and do something with it "	| theByte |	abortSignal do:		[[theByte _ self lookForNextNonDelByte.		 (inputStops at: theByte + 1) == nil			ifTrue: [displayStream paintAV: theByte]			ifFalse: [self perform: (inputStops at: theByte + 1)].		 true] whileTrue: []] handle: [abortSignal handleReturn: false].!displayTest	"For time testing from file only"	| buffer spy fileStream |	buffer _ Array new: 1400.	1 to: buffer size do:		[:i | buffer at: i put: serialPort nextByte].	spy _MessageTally new.	fileStream _ FileStream fileNamed: 'spyOnDisplayTest-w6.report'.	spy spyEvery: 6 on: [buffer do: [:j | displayStream paintAV: j]].	spy continueSpying.	spy reportOn: fileStream; close.	fileStream close!lookForNextNonDelByte	"as long as still in receive mode, take the next non-DEL byte in the input buffer.		If empty, watch for a user abort.  If no longer in receive mode, then signal to unwind"	| theByte |	[stateOfRS232 = 2 "self receivingRS232"]		whileTrue:			[[(theByte _ serialPort nextByte) = 16r7F "DEL"] whileTrue: [].			 theByte = NoData ifFalse: [^theByte].			 displayStream paintCurLine.			 self checkForUserInput].	displayStream paintCurLine.	abortSignal signal.	"user aborted"	^NoData  "shouldn't get here, but"!sendTextString: aString	serialPort sendTextString: aString!takeControlIfNeeded	"use this (when not in receive state) to check if anything more has come as input.		This is needed to catch timeout messages, for instance"	serialPort inputBufferEmpty		ifFalse: [self takeControl]!timeDisplayTest	"For time testing from file only"	| buffer aString |	buffer _ ByteArray new: 1400.	1 to: buffer size do:		[:i | buffer at: i put: serialPort nextByte].	"aString _ String new: 1400.	aString replaceFrom: 1 to: 1400 withByteArray: buffer startingAt: 1."	^ (Time millisecondsToRun: 		[buffer do: [:j | displayStream paintAV: j]])! !!RS232Model methodsFor: 'state control'!abortReceiving	"only used to stop watching RS232 input when user aborts with yellow button"	self sendWindow controller forcedStop.	self rs232ToTransmitState!browseState	^ (stateOfRS232 = 3)	"in browsing state?"!checkForUserInput	"check for user input during receive state. Process if any"	| index |	Sensor yellowButtonPressed		ifTrue:			[(index _ (PopUpMenu labels: 'breakabort' lines: #()) startUpYellowButton) = 0				ifFalse:					[index = 1 ifTrue: [serialPort sendBreak] ifFalse: [self abortReceiving]]]!editFuncKeysState	^ (stateOfRS232 = 4)	"in edit function keys state?"!fileTransferServer	self displayStatus: 'File Transfer - Server'.	RS232Kermit new startUpServerOn: serialPort with: displayStream.	self displayStatus: 'Transmit'!fileTransferUser	self displayStatus: 'File Transfer - User'.	RS232Kermit new startUpTransferOn: serialPort with: displayStream.	self displayStatus: 'Transmit'!receivingRS232	^ (stateOfRS232 = 2)	"in receive state?"!rs232ToBrowseState	"changes stateOfRS232 to browsing saved input text"	(stateOfRS232 = 3) ifTrue: [^self].	stateOfRS232 _ 3.	self saveSaveState.	displayStream updateForBrowse.	self rs232Window controller class initializeFirstScrollingPagesMenu.	self browseTextPage: $l!rs232ToEditFunctionKeysState	"changes stateOfRS232 to editing function keys"	(stateOfRS232 = 4) ifFalse:		[stateOfRS232 _ 4.		 self displayStatus: 'Editing Function Keys']!rs232ToReceiveState	"changes stateOfRS232 to receive state"	stateOfRS232 = 2 ifTrue: [^self].	stateOfRS232 _ 2.	self displayStatus: #Receive.	Cursor mouse show.	numLines > 60 ifTrue: [displayStream nextPage. numLines _ 0]!rs232ToTransmitState	"changes stateOfRS232 to transmit state; initializes window		for transmission if were in receive state"	self displayStatus: #Transmit.	(stateOfRS232 = 2) "was receiving?"		ifFalse:			[displayStream contentsStream resetToPreBrowseState.			stateOfRS232 _ 1.			^self].	stateOfRS232 _ 1.	displayStream paintCurLine.	(self rs232Window controller) controlInitialize. "change menu"	Cursor normal show!takeControl	"give control to controller of rs232Window"	self rs232ToReceiveState.	self rs232Window controller startUp!transmitState	^ (stateOfRS232 = 1)	"in transmit state?"! !!RS232Model methodsFor: 'save state'!blankSaveState	(SaveState at: 2) fill: (SaveState at: 2) boundingBox rule: Form over mask: Form white!restoreSaveState	"want to call whenever come back into window or from browse"	Display		copyBits: (SaveState at: 2) boundingBox		from: (SaveState at: 2)		at: (SaveState at: 1) origin		clippingBox: (SaveState at: 1)		rule: Form over		mask: Form black!saveSaveState	"want to call whenever leave window or go to browse"	(SaveState at: 2)		copyBits: (SaveState at: 1)		from: Display		at: 0@0		clippingBox: (0@0 corner: (SaveState at: 1) extent)		rule: Form over		mask: Form black! !TekModel comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!TekModel methodsFor: 'initialize/release'!captureGraphics: aBoolean	| captureFileName num |	aBoolean == captureGraphics ifFalse:		[aBoolean			ifTrue:				[captureFileNameArray _ InformationCenter fileNameData: #map  defaultSuitcase: (Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem type: (DataItem typeIndexFor: #Item) label: 'CapturedItem' atIndex: 0)) defaultKeys: String new askMethod: true askClass: true.				(captureFileNameArray at: 1) == nil ifTrue: [^captureGraphics _ false].				captureFileName _ (captureFileNameArray at: 1) filename.				 "since captureFileName will not exist until drawn and saved in map window -						makeNewFileName cannot insure uniqueness"				num _ 2.				[Disk includesKey: captureFileName, (DataMaster giveMe: #specialSuffixString for: #map)] whileTrue:						[(captureFileNameArray at: 1) filename:								(captureFileName _ (captureFileName copyUpTo: $+), (String with: $+), num printString).						 num _ num + 1].				Cursor wait showWhile:					[(captureFileStream _ FileStream newFileNamed: captureFileName, '.mapData') binary readWrite.					(hintFileStream _ FileStream newFileNamed: captureFileName, '.mapHints') binary readWrite].				lastPoint _ nil.				isFirstPoint _ true.				lastHeaderPosition _ nil.]			ifFalse:				[(captureGraphics == nil or: [boundingRectangle == nil])  ifFalse:					[Cursor wait showWhile: [					self fixLastHeader.					captureFileStream close; release.					hintFileStream close; release.					captureFileName _ (captureFileNameArray at: 1) filename.					(FileStream newFileNamed: captureFileName, (DataMaster giveMe: #specialSuffixString for: #map))						readWrite;						nextPutAll: ((42 bitShift: 12) + (boundingRectangle top - 10) * 180 / 2r1e10 / 2r1e10 - 90) asFloat printString;	"Save an oop by dividing by 2r1e10 twice because 2r1e20 may not be a SmallInteger."						space;						nextPutAll: (boundingRectangle left - 10 * 360 / 2r1e10 / 2r1e10) asFloat printString;						space;						nextPutAll: ((42 bitShift: 12) + (boundingRectangle bottom + 10) * 45 / 2r1e9 / 2r1e9 - 90) asFloat printString;						space;						nextPutAll: (boundingRectangle right + 10 * 45 / 2r1e9 / 2r1e8) asFloat printString;						space;						nextPutAll: 2r1e12 printString;						space;						nextPutAll: captureFileName printString;						close;						release].				captureGraphics _ aBoolean.				InformationCenter putFileNameAway: captureFileNameArray]				ifTrue:				[captureGraphics == nil ifFalse:					[captureFileStream close; release.					 hintFileStream close; release.					 Disk removeKey: (captureFileNameArray at: 1), '.mapData' ifAbsent: [].					 Disk removeKey: (captureFileNameArray at: 1), '.mapHints' ifAbsent: []]]]].	captureGraphics _ aBoolean!checkWindowLocation	| oldRect | 	oldRect _ graphRect.	graphRect _ self graphicsWindow insetDisplayBox.	oldRect = graphRect ifFalse:		[theBlt _ BitBlt				destForm: Display				sourceForm: (Form new extent: 1@1) black				halftoneForm: Form black				combinationRule: Form over				destOrigin: graphRect origin				sourceOrigin: 0@0				extent: 1@1				clipRect: graphRect].	(windowType bitAnd: 2) = 0 "non-tack?"		ifTrue: [super checkWindowLocation]		ifFalse: "tack type"			[displayStream updateWindowLoc: graphRect.			 (windowType bitAnd: 1) = 0 "small size?"				ifTrue: [self rs232Window clearInside]]!idleForm	^((Text string:' OIT Window       is open ' emphasis: 19) asParagraph asForm reverse)!initialize	super initialize.	self resetTek!initializeWatchRS232	(displayStream _ RS232GraphicsDisplayMem new) combRule: Form under.	rs232Windows _ Array new: 5. "status, received text, send text, function keys, graphics"!openBigTekViewInTopView: topView	| statusView |	topView		minimumSize: 1024 @ 804; 		maximumSize: 1024 @ 804.	self statusWindow borderWidthLeft: 1 right: 0 top: 1 bottom: 0.	topView addSubView: self statusWindow viewport: (612 @ 784 extent: 412 @ 24).	self rs232Window borderWidthLeft: 0 right: 0 top: 1 bottom: 1.	topView addSubView: self rs232Window viewport: (100 @ 0 extent: 500"824" @ 782).	"Form extent is wierd because displayTransformation used to refresh display doesn't go to insetDisplayBox, so added the difference to left and top of form, and offset actual graphics within it"	self graphicsWindow model extent: 1024@781.	self graphicsWindow borderWidthLeft: 0 right: 0 top: 1 bottom: 1.	topView addSubView: self graphicsWindow viewport: (0 @ 0 extent: 1024 @ 782).	self sendWindow borderWidthLeft: 1 right: 1 top: 1 bottom: 1.	topView addSubView: self sendWindow viewport: (100 @ 784 extent: 512 @ 24).	Cursor normal show.	topView controller openDisplayAt: 0@4!openSmallTekViewInTopView: topView	| statusView |	topView		minimumSize: 596 @ 766; 		maximumSize: 596 @ 766.	self statusWindow borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: self statusWindow viewport: (0 @ 0 extent: 516 @ 22).	"Form extent is wierd because displayTransformation used to refresh display doesn't go to insetDisplayBox, so added the difference to left and top of form, and offset actual graphics within it"	self graphicsWindow model extent: 514@513.	self graphicsWindow		borderWidthLeft: 2 right: 2 top: 0 bottom: 0;		window: (0 @ 0 extent: 516 @ 512).	topView addSubView: self graphicsWindow below: self statusWindow.	self rs232Window		borderWidthLeft: 2 right: 2 top: 2 bottom: 1;		window: (0 @ 0 extent: 516 @ 190).	topView addSubView: self rs232Window below: self graphicsWindow.	self sendWindow		borderWidthLeft: 2 right: 2 top: 1 bottom: 2;		window: (0 @ 0 extent: 516 @ 42).	topView addSubView: self sendWindow below: self rs232Window.	"create subView for function key view status"	(statusView _ StringHolderView new)		model: (StringHolder new contents: String new);		controller: NoController new;		borderWidthLeft: 1 right: 2 top: 2 bottom: 2;		window: (0 @ 0 extent: 80 @ 22).	topView addSubView: statusView toRightOf: self statusWindow.	"create subview for function keys"	rs232Windows at: 4 put: (RS232FunctionKeysController newWithStatusView: statusView forUser: UserName onSection: programName).	self functionKeysWindow		window: (0 @ 0 extent: 80 @ 744);		borderWidthLeft: 1 right: 2 top: 0 bottom: 2.	topView addSubView: self functionKeysWindow toRightOf: self graphicsWindow.	Cursor normal show.	topView controller open!openTekViewType: typeWindow withLabel: aLabel autoSendString: autoString	"create basics, then call specific window message to get correct sizes"	| topView |	programName _ aLabel.	windowType _ typeWindow.	displayStream textOnGraphics: (windowType bitAnd: 2) = 2. "tack?"	topView _ StandardSystemView new.	topView		model: RS232Collector;		controller: RS232SystemController new;		label: programName;		helpIndex: #VMGraphics;		insideColor: Form white.	"create subView for current status"	rs232Windows at: 1 put: MessageView new.	(self statusWindow)		withEmphasis: 5;		contents: 'Transmit';		insideColor: Form white;		controller: NoController new.	"create subView for displaying and browse"	rs232Windows at: 2 put: RS232TextView new.	self rs232Window		model: RS232Collector;		insideColor: Form white.	"create subView for graphics display"	rs232Windows at: 5 put: FormView new.	self graphicsWindow		model: Form new;		insideColor: Form white;		controller: NoController new.	"create subView for user input"	rs232Windows at: 3 put: StringHolderView new.	self sendWindow		model: StringHolder new;		controller: (TekController new initializeAutoSending: autoString);		insideColor: Form white.	(windowType bitAnd: 1) = 0		ifTrue: [self openSmallTekViewInTopView: topView]		ifFalse: [self openBigTekViewInTopView: topView]!resetTek	mode _ $A.	"alpha"	hiY _ hiX _ loY _ loX _ extraX _ extraY _ 0.	loYchanged _ false.	currentLoc _ 0@0.	lineType _ 0.	"solid vectors"	self captureGraphics: false!setInputStops	"set up array which determines what action should		be performed for every character input on RS-232"	inputStops _ Array new: 128.	inputStops		at: 16r0 + 1 put: #ignoreChar;		at: 16r05 + 1 put: #ignoreChar;	"no send answer back"		at: 16r07 + 1 put: #ringBell;		at: 16r08 + 1 put: #ignoreChar;	"BS"		at: 16r09 + 1 put: #horizSpace;	"HT"		at: 16r0A + 1 put: #ignoreChar;	"LF"		at: 16r0B + 1 put: #ignoreChar;	"VT"		at: 16r0C + 1 put: #clearMemory;	"form feed"		at: 16r0D "CR" + 1 put: #carraigeReturn;		at: 16r0E + 1 put: #ignoreChar;		"shift out"		at: 16r11 + 1 put: #switchToTransmit;	"Xon"		at: 16r13 + 1 put: #ignoreChar;	"Xoff"		at: 16r14 + 1 put: #clearMemory;	"^T or DC4"		at: 16r16 + 1 put: #stopEchoForPassword;	"SYN"		at: 16r18 + 1 put: #ignoreChar;	"^X or CAN"		at: 16r1A + 1 put: #ignoreChar;	"SUB""GIN mode"		at: 16r1B + 1 put: #escapeSeq;	"ESC"		at: 16r1C + 1 put: #enterPointPlotMode;	 "FS""point plot mode"		at: 16r1D + 1 put: #enterGraphicsMode; "GS""enter graphics mode"		at: 16r1E + 1 put: #ignoreChar;	"RS""incremental plot mode"		at: 16r1F + 1 put: #enterAlphaMode;	"US"		at: 16r7F + 1 put: #ignoreChar		"ascii DEL char"!shutDown: fromInside	"prepare to close window if user answers affirmatively"	"fromInside is a boolean to indicate if the user is inside the window, or coming from outside somewhere" 	fromInside		ifTrue: [(self confirm: 'HAVE YOU LOGGED OFF?') ifFalse: [^false]] 		ifFalse: [(self confirm: ('Tektronix window is still open.HAVE YOU LOGGED OFF?')) ifFalse: [^false]].	self functionKeysWindow = nil		ifFalse: [self functionKeysWindow controller checkAndPutLabelDefs].	self captureGraphics: false.    "close capture file, if it's open."	^ true! !!TekModel methodsFor: 'input stops'!carraigeReturn	numLines _ numLines + 1.	mode _ $A.	displayStream paint: Character cr.	self checkForUserInput	"need to check every once in aWhile"!clearMemory	super clearMemory.	self clearGraphics!enterAlphaMode	mode _ $A.	(windowType bitAnd: 2) = 0 "non-tack?"		ifFalse: [displayStream setAtOffset: currentLoc]!enterGraphicsMode	mode _ $G.	self processGraphics!enterPointPlotMode	mode _ $P.	self processGraphics!escapeSeq	| cmdByte |	cmdByte _ self lookForNextNonSynByte.	(self setCharSize: cmdByte) ifFalse:		[cmdByte = 16r70"p"			ifTrue: [self sendWindow controller noEcho]			ifFalse:				[(inputStops at: cmdByte + 1) == nil					ifTrue: [displayStream paintAV: cmdByte]					ifFalse: [self perform: (inputStops at: cmdByte + 1)]]]!horizSpace	displayStream paint: $ .	"space"!nextPage	"clear saved contents and display"	mode _ $A.	super nextPage.	self clearGraphics!ringBell	self graphicsWindow flash!stopEchoForPassword	self sendWindow controller noEcho!switchToTransmit	"received an Xon.  Switch to transmit state. Save whatever is in graphics window."	self saveGraphics; rs232ToTransmitState! !!TekModel methodsFor: 'alpha input'!checkRS232Input	"get a character from RS232, and do something with it"	| theByte |	abortSignal _ Signal new.	abortSignal do:		[[theByte _ self lookForNextByte.		 (inputStops at: theByte + 1) == nil			ifTrue: [displayStream paintAV: theByte]			ifFalse: [self perform: (inputStops at: theByte + 1)].		 true] whileTrue: []] handle: [abortSignal handleReturn: false].!logSentText: logText	displayStream paintStringAsLine: logText.	"(windowType bitAnd: 2) = 0 ""non-tack?""		ifTrue:			[super logSentText: logText]		ifFalse:			[logText do: [:ch | displayStream paint: ch].			 displayStream nextTekLine.			 contentsStream nextForcePutAll: logText]"!lookForNextByte	"as long as still in receive mode, take the next byte in the input buffer.		If empty, watch for a user abort.  If no longer in receive mode, then signal to unwind"	| theByte |	[stateOfRS232 = 2 "self receivingRS232"]		whileTrue:			[(theByte _ serialPort nextByte) = NoData ifFalse: [^theByte].			 self checkForUserInput].	displayStream paintCurLine.	abortSignal signal.	"user aborted"	^NoData  "shouldn't get here, but"!lookForNextNonSynByte	"as long as still in receive mode, take the next non-SYN byte in the input buffer.		If empty, watch for a user abort.  If no longer in receive mode, then signal to unwind"	| theByte |	[stateOfRS232 = 2"self receivingRS232"]		whileTrue:			[[(theByte _ serialPort nextByte) = 16r16 "SYN"] whileTrue: [].			 theByte = NoData ifFalse: [^theByte].			 self checkForUserInput].	displayStream paintCurLine.	abortSignal signal.	"user aborted"	^NoData  "shouldn't get here, but"!setCharSize: cmdByte	"return true if this is valid command; but don't do anything for now"	^(cmdByte >= 16r38"8" and: [cmdByte <= 16r3B])! !!TekModel methodsFor: 'graphics'!captureLineTo: aPoint penDown: down	"If the pen is not down, just remember the new point.	If the pen is down, store the last point if the pen was just depressed, then store the new point."	"This is where we write the control-file header (if the first point), and store	point deltas.  The header gets completed (correct #points field) and the hints	file gets written to in <fixLastHeader>."	captureGraphics ifFalse: [^self].      "Only do this stuff if in capture mode."	down		ifTrue:			[ isFirstPoint ifTrue:				[ "Hey, kids: let's write the Segment Header !!"				isFirstPoint _ false.				self fixLastHeader.				"nPts(gets fixed later) rank minY minX maxY maxX :"				#( 0   1   10752 0   0 0    11007 65535   255 65535 ) do:					[ :each | captureFileStream nextWordPut: each ].				captureFileStream					nextWordPut: 10752 + (lastPoint y bitShift: -4);					nextWordPut: ((lastPoint y bitShift: 12) bitAnd: 65535);      "minY + y * 2^12"					nextWordPut: (lastPoint x bitShift: -4);					nextWordPut: ((lastPoint x bitShift: 12) bitAnd: 65535)      "minX + x * 2^12".				boundingRectangle _ boundingRectangle == nil					ifTrue: [lastPoint corner: lastPoint]					ifFalse: [boundingRectangle merge: (lastPoint corner: lastPoint)]				].			"Now write the x,y deltas for this point."			captureFileStream				nextWordPut: aPoint y - lastPoint y;				nextWordPut: aPoint x - lastPoint x.			boundingRectangle _ boundingRectangle merge: (aPoint corner: aPoint)]		ifFalse:			[isFirstPoint _ true ].	lastPoint _ aPoint!clearGraphics	self graphicsWindow model fill: (0@0 extent: self graphicsWindow model extent) rule: Form over mask: Form white.	self graphicsWindow displayView!drawLineTo: newPoint penDown: draw	| segmentLen |	draw ifTrue:		["draw line according to lineType from currentLoc to newPoint"		 "lineTypes: 0 = solid; 1 = dotted; 2 = dotted dash; 3 = short dash; 4 = long dash; 5 = center"		 mode = $P			ifTrue: [theBlt destOrigin: newPoint + graphRect origin; copyBits]			ifFalse:				[lineType = 0					ifTrue: [theBlt drawFrom: currentLoc + graphRect origin to: newPoint + graphRect origin]					ifFalse:						[segmentLen _ #(1 3 8 16 25) at: lineType.						 theBlt drawFrom: currentLoc + graphRect origin to: newPoint + graphRect origin segmentLength: segmentLen]]].	currentLoc _ newPoint!fixLastHeader	"Go back to the last header, and write in the proper number of points.	Also write a header into the hints file."	| newHeaderPosition numberOfPoints |	isFirstPoint ifTrue: [^self].      "No points written yet."	newHeaderPosition _ captureFileStream position.	lastHeaderPosition notNil ifTrue:		[numberOfPoints _ (newHeaderPosition-lastHeaderPosition-28) // 4.    "assumes 28-byte header"		captureFileStream			position: lastHeaderPosition;			nextWordPut: numberOfPoints;			position: newHeaderPosition.		hintFileStream nextWordPut: numberOfPoints.		#( 1 42 0 42 0) do: [:each | hintFileStream nextPut: each ] ].	lastHeaderPosition _ newHeaderPosition!graphicsWindow	^(rs232Windows at: 5)!processCmdInGraphics: inByte	| cmdByte |	self checkForUserInput. "just to check once in awhile"	inByte = 16r1B "ESC"		ifTrue: [cmdByte _ self lookForNextByte]		ifFalse: [cmdByte _ inByte].	cmdByte = 16r1D "GS" ifTrue: [^false].	"return false if reentering graphics mode"	(cmdByte <= 16r65 and: [cmdByte >= 16r60])		ifTrue: [lineType _ cmdByte - 16r60]		ifFalse:			[cmdByte = 16r0D "CR" ifTrue: ["mode _ $A"]				ifFalse:					[(inputStops at: cmdByte + 1) = nil						ifFalse: [self perform: (inputStops at: cmdByte + 1)]						ifTrue:							[(inByte = 16r1B "ESC" and: [self setCharSize: cmdByte])								ifFalse: [self error: 'Unknown command']]]].	^true!processGraphics	| inByte dataBits typeByte draw x y |	displayStream paintCurLine.	draw _ false.	[(mode = $G or: [mode = $P]) and: [stateOfRS232 = 2"self receivingRS232"]] whileTrue:		[inByte _ self lookForNextNonSynByte.		 typeByte _ (inByte bitAnd: 16r60) bitShift: -5.		 typeByte = 0			ifTrue: [draw _ self processCmdInGraphics: inByte]			ifFalse:				[dataBits _ inByte bitAnd: 16r1F.				 typeByte = 2					ifTrue:						[loX _ dataBits bitShift: 2.						 x _ (hiX bitOr: loX) bitOr: extraX."4096@4096"						 y _ (hiY bitOr: loY) bitOr: extraY.						 mode = $G ifTrue: [self captureLineTo: x @ y penDown: draw].						 (windowType bitAnd: 1) = 0							ifFalse: "1024by780"								[x _ (x + (extraX bitShift: -1)) bitShift: -2.								 y _ (y + (extraY bitShift: -1)) bitShift: -2.								 self drawLineTo: x @ (779 - y) penDown: draw]	"the y axis is reverse direction"							ifTrue: "512by512"								[x _ (x + (((loX bitShift: 1) bitAnd: 16r02) bitOr: (extraX bitShift: -1))) bitShift: -3.								 y _ (y + (((loY bitShift: 1) bitAnd: 16r02) bitOr: (extraY bitShift: -1))) bitShift: -3.								 self drawLineTo: x @ (511 - y) penDown: draw].	"the y axis is reverse direction"						 loYchanged _ false.						 draw _ true]					ifFalse:						[typeByte = 3							ifTrue:								[loYchanged ifTrue:	"was shifted left by two"									[extraX _ (loY bitAnd: 16r0C) bitShift: -2.									 extraY _ (loY bitAnd: 16r30) bitShift: -4].								 loY _ dataBits bitShift: 2.								 loYchanged _ true]							ifFalse:								[loYchanged									ifTrue: [hiX _ dataBits bitShift: 7]									ifFalse: [hiY _ dataBits bitShift: 7]]]]].	^false!saveGraphics	"Form extent is wierd because displayTransformation used to refresh display doesn't go to insetDisplayBox, so added the difference to left and top of form, and offset actual graphics within it"	self graphicsWindow model		copyBits: self graphicsWindow insetDisplayBox		from: Display		at: ((windowType bitAnd: 1) = 0 "reg. size?"				ifTrue: [2@1] ifFalse: [0@1])		clippingBox: self graphicsWindow model boundingBox		rule: Form over		mask: Form black! !!TekModel methodsFor: 'state control'!blankSaveState	displayStream textOnGraphics ifFalse: [super blankSaveState]!restoreSaveState	displayStream textOnGraphics ifFalse: [super restoreSaveState]!rs232ToReceiveState	super rs232ToReceiveState.	self sendWindow controller echo	"resume echoing"!rs232ToTransmitState	"changes stateOfRS232 to transmit state; initializes window		for transmission if were in receive state"	self displayStatus: #Transmit.	(stateOfRS232 = 2) "was receiving?"		ifFalse:			[displayStream contentsStream resetToPreBrowseState.			 self graphicsWindow displayView.			 stateOfRS232 _ 1.			^self].	stateOfRS232 _ 1.	displayStream paintCurLine.	(self rs232Window controller) controlInitialize. "change menu"	Cursor normal show!saveSaveState	displayStream textOnGraphics ifFalse: [super saveSaveState]! !ContainerModel comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.ContainerModel displays the contents of a folder data item.Instance variables:talkView	the StringHolderView at the top of every folder used to display messages.theOffset	used only for structure views.viewList	the collection of labels (Strings) to be shown in the view.pointerList	the collection of pointers (Array with: certainty with: linkType with: indexInCenter) to items which corresponds to the labels in viewList.listIndex	the index in viewList and pointerList of the currently selected item.folder		the DataItem being displayed (that is, the items in it are shown in the view).searchString	if non-nil, a String that was searched on to obtain this folder.center		the information center this folder is in.Class Variables:UserMessage	a string to be displayed in the upper pane of the folder window.'!!ContainerModel methodsFor: 'instance creation'!open: aString tabLabel: theTabLabel indexCollection: aCollection	"Creates the file structure view."	| topView aDisplayTextView |	self findTheOneLabeled: theTabLabel.	(aDisplayTextView _ StructureView new) hasChanged: false;		model: (self contents: aString);		controller: (StructureController new indexCollection: aCollection);		window: (0 @ 0 extent: 800@800);		insideColor: Form white;		borderWidth: 1.	topView _ StandardSystemView new model: self;		label: theTabLabel;		borderWidth: 1;		helpIndex: #FileStructure;		minimumSize: 400@400;		classifyLabel: folder .	topView addSubView: aDisplayTextView.	ContainerModel addDependent: aDisplayTextView.	Cursor normal show.	topView controller open!scheduleTheFolder: titleTab usingMenu: aMenuNumber width: aNumber helpMessage: help	"schedule a folder view from the infomation/training center. aMenuNember is:	1 = container; 2 = in box; 3 = trash; 4 = key view; 5 = item; 6 = folder"		| topView aContainerListView fileCabinetStructureView tabLabel formsView formsModel |	tabLabel _ self class fixName: titleTab.	self findTheOneLabeled: tabLabel.	talkView _ StringHolderView new.	talkView model: self.	talkView controller: NoController new.	talkView window: (0@0 extent: 900@150).	talkView insideColor: Form white.	talkView borderWidth:  aNumber.	aContainerListView  _ ContainerListView new.	aContainerListView  model: self controller: (ContainerListController new: aMenuNumber).	aContainerListView  selection:  listIndex.	aContainerListView  window: (0 @ 0 extent: 900@500).	aContainerListView borderWidth: aNumber.	ContainerModel addDependent: aContainerListView.	formsView _ FormsView new.	formsModel _ FormsModel named: 'fred'.	formsView model: formsModel.	formsView controller: LockedFormsController new.	formsView insideColor: Form lightGray.	formsView  window: (0 @ 0 extent: 900@100).	formsView borderWidth: 1.	formsModel addControlPanel: #(ExecuteElement ExecuteElement ExecuteElement ExecuteElement ImmediateExecuteElement) labels: #( 'in box' 'trash' ' key words ' 'sort' 'direct') messages: #(showInBox showTrash showKeywords sort showMenu) targetController: aContainerListView controller boundingBox: (0@0 extent: 900 @ 25).	formsModel updateControllers: formsView controller.	topView _ StandardSystemView new model: self.	topView label: tabLabel.	topView helpIndex: help.	topView borderWidth: aNumber.	topView minimumSize: 385@200.	topView maximumSize: 900@750.	topView classifyLabel: folder.	topView addSubView: talkView.	topView addSubView: formsView below: talkView.	topView addSubView: aContainerListView below: formsView.	Cursor normal show.	topView controller open! !!ContainerModel methodsFor: 'initialize-release'!initialize: atIndex in: aCenter 	"set up the display of the contents of this folder"	super initialize.	contents _ String new.	listIndex _ 0.	center _ aCenter.	center name = 'Scavenge' ifFalse: [InformationCenter lastUsedCenterName: center name].	(atIndex isKindOf: Integer)		ifTrue:			[folder _ (center fileCabinet) at: atIndex]		ifFalse:			[folder _ atIndex].	self setFolderLists!release	viewList release.	viewList _ nil.	folder _ nil.	talkView  release.	talkView _ nil.	super release!setFolderLists	"set up the view list and contents dictionary for this folder"	| theEntry sortList size pointers points |	points _ folder fPointers. 	points == nil ifTrue: [viewList _ OrderedCollection new. pointerList _ OrderedCollection new. ^self].	pointers _ OrderedCollection new.	points do: [:each | (center linkTypeFor: #keyword) = each linkType ifFalse: [pointers add: each]].	pointers isEmpty ifTrue: [viewList _ OrderedCollection new. pointerList _ OrderedCollection new. ^self].	viewList _ OrderedCollection new.	pointerList _ OrderedCollection new.	pointers do: [:each |		(theEntry _ center fileCabinet at: (each index)) ==nil		ifFalse:[(center okToFoolWith: theEntry) ifTrue:			[viewList add: theEntry iconDisplayString.			pointerList add: each]]]! !!ContainerModel methodsFor: 'private'!checkSelection	| theItemIndex |	listIndex = 0		ifTrue: [^self centerIndex]		ifFalse:			[theItemIndex _ (pointerList at: listIndex) index.			(center fileCabinet at: theItemIndex) typeSymbol = #Item				ifFalse: [(center fileCabinet at: theItemIndex) typeSymbol = #Folder							ifTrue: [^theItemIndex]]				ifTrue: [(self confirm: 'Selection is a item. Do you want to view it?')						ifTrue:[^self viewSelection]]].	^nil!findTheHolderLabeled: theTabLabel	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: ContainerModel) and: [each view label = theTabLabel]].!findTheOneLabeled: theTabLabel	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: ContainerModel)				and: [each model folder == folder and: [each view label = theTabLabel]]].!findThisFolder: theItem message: theMessage	DataMaster findTheOneByEvaluating:		[:each | ((each model isKindOf: ContainerModel)			and: [each model folder == theItem])				ifTrue: [self booboo: theMessage.					true]				ifFalse: [false]].!findThisSelection: theItem message: theMessage	| theSuitcase | 	DataMaster findTheOneByEvaluating:		[:each | (each isKindOf: StandardSystemController)				and: [theSuitcase _ each view suitcase.					(theSuitcase ~~ nil and: [theSuitcase dataItem == theItem])						ifTrue: [self booboo: theMessage.							true]						ifFalse: [false]]].!holderChanged	| fPointers | 	self centerIndex = 0 ifTrue: "this is assumed to be a holder"		[(fPointers _ folder fPointers) == nil ifFalse:			[fPointers do: [:fp | (center fileCabinet at: (fp index)) == nil ifTrue: [folder removeFPointer: fp]]].		 folder classification: (center folderClassificationFor: folder).		 self refreshContainerList]!refreshContainerList	"refresh the container list from the folder"	self refreshContainerListNoCheck.	ContainerModel changed: folder!refreshContainerListNoCheck	"refresh the container list from the folder"	self setFolderLists.	listIndex _ 0.	Cursor normal show!removeFromFolderList	"set up the view list and contents dictionary for this folder"	viewList removeObjectAt: listIndex.	pointerList removeObjectAt: listIndex.	self class changed: folder.	listIndex _ 0!removeFromFolderList: aListIndex	"set up the view list and contents dictionary for this folder"	viewList removeObjectAt: aListIndex.	pointerList removeObjectAt: aListIndex.	 self class changed: folder.	listIndex _ 0.!toggleListIndex: anInteger	"If anInteger is the current list view selection, deselect it. Else	make it the new selection."	self listIndex: (listIndex = anInteger		ifTrue: [0]		ifFalse: [anInteger])! !!ContainerModel methodsFor: 'list structure view'!showStructure: theItem on: theStream indexCollection: aCollection hardcopy: hardcopy 	| fPointers localOffset |	(center okToFoolWith: theItem) ifFalse: [^self].	localOffset  _ theOffset.	theStream nextPutAll:  localOffset, (hardcopy ifTrue: [theItem hardcopyWithTypeString] ifFalse: [theItem iconDisplayString]).	aCollection add: theItem centerIndex.	theItem filename == nil		ifTrue:			[theStream cr.			theItem isFlagSet				ifTrue:					[theStream skip: -1.					theStream nextPutAll:  ' ...'; cr.					^theOffset _ localOffset]				ifFalse: [theItem setFlag].			(theItem fPointersOfType: (center linkTypeFor: #contains)) do:				[:thePointer |				theOffset _ localOffset,'	'.				self showStructure: (center fileCabinet at: (thePointer index)) on: theStream indexCollection: aCollection hardcopy: hardcopy.				(center fileCabinet at: (thePointer index)) clearFlag]]		ifFalse: [theStream cr].	theOffset _ localOffset!updateStructureText	| theSelectionIndex theStream aCollection |	(theSelectionIndex _ self checkSelection) == nil ifTrue: [^nil].	theStream _ ReadWriteStream on: String new.	theOffset _ String new.	center clearFlags.	aCollection _ OrderedCollection new.	self showStructure: (center fileCabinet at: theSelectionIndex) on: theStream indexCollection: aCollection hardcopy: false.	theStream cr. ^Array with: (StructureParagraph withText: theStream contents asText) with: aCollection! !!ContainerModel methodsFor: 'scavenge'!bashLocalFromBackedCenter: centerName xde: aXDE	"the second part of bashLocalFromBackup.  Get all the filenames in centerName and retrieve them to the local disk - ignoring whether they might bash over some other valid file that happens to have the same name"	| sendString theCenter centers theFiles spaceString | 	(Disk includesKey: centerName, '.center') ifFalse: [aXDE locked: false. ^self].	((centers _ InformationCenter possibleCenters) includes: centerName) ifFalse:		[InformationCenter closeCenterChoiceBar.		centers add: centerName before: #Scavenge asString.		InformationCenter possibleCenters: centers].	(InformationCenter check: centerName) ifFalse: [aXDE locked: false. ^self].	aXDE show: 'Figuring out what files to retrieve, please wait . . . '.	theCenter _ InformationCenter centerFor: centerName.	theFiles _ theCenter getFileNamesForSelection: theCenter fileCabinetIndex withMapSupport: false.	sendString _ 'ftp/l "', UserProfile current ifsName, (String with: $"), ' dir/c <', UserName, '>BackUpData> retrieve/ua '. 	spaceString _ String with: Character space.	theFiles do: [:item | sendString _ sendString, item, spaceString].	aXDE sendTemplate: sendString doAfter: [:xde :centerNameAndOldList | self bashMoreLocalFromBackedCenter: centerNameAndOldList xde: xde] withArgs: (Array with: centerName with: theFiles).	aXDE locked: false!bashLocalFromBackup	"ask the user which center to retrieve, go to file server and retrieve it, then get all the filenames in it and retrieve them to the local disk - ignoring whether they might bash over some other valid file that happens to have the same name"	| aXDE theFileServerName sendString centerName | 	(Smalltalk includesKey: #XDEInterfaceModel) ifFalse: [^self booboo: 'Sorry, I cannot do that'].	(self confirm: 'Do you really want to retrieve an entire center,any local file of the same name will be overwritten?') ifFalse: [^self].	centerName _ FillInTheBlank request: 'What is the center name?' default: UserName.	(InformationCenter centerFor: centerName) == nil ifFalse: [^self booboo: 'Please close down that center first'].	theFileServerName _ UserProfile current selectFileServer.	theFileServerName == nil ifTrue: [^self].	aXDE _XDEInterfaceModel giveMeOne: true.	sendString _ 'ftp/l "', theFileServerName, (String with: $"), ' dir/c <', UserName, '>BackUpData> retrieve/c ', centerName, '.center'.	aXDE sendTemplate: sendString doAfter: [:xde :theCenterName | self bashLocalFromBackedCenter: theCenterName xde: xde] withArgs: centerName.	aXDE changed.	XDEInterfaceModel openWith: aXDE!bashMoreLocalFromBackedCenter: centerNameAndOldList xde: aXDE	"the third part of bashLocalFromBackup.  Get all the filenames in centerName again, and retrieve any that didn't get in the last list"	| sendString theCenter theNewFileList spaceString | 	aXDE show: 'Figuring out if more files to retrieve, please wait . . . '.	theCenter _ InformationCenter centerFor: (centerNameAndOldList at: 1).	theNewFileList _ theCenter getFileNamesForSelection: theCenter fileCabinetIndex withMapSupport: false.	InformationCenter removeCenter: (centerNameAndOldList at: 1).	theNewFileList size = (centerNameAndOldList at: 2) size ifFalse:		[(centerNameAndOldList at: 2) do: [:i | theNewFileList remove: i].		sendString _ 'ftp/l "', UserProfile current ifsName, (String with: $"), ' dir/c <', UserName, '>BackUpData> retrieve/ua '.		spaceString _ String with: Character space.		theNewFileList do: [:item | sendString _ sendString, item, spaceString].		aXDE sendCommandString: sendString heading: sendString resultsFrom: 'ftp.log'].	aXDE show: 'Really done now'.	aXDE locked: false.!checkOverwrite: theItem	| shortName suffixSymbol suffixString newLabel theLabel | 	shortName _ (FileDirectory decomposeName: theItem filename) at: 'Name-Body'.	suffixSymbol _ DataMaster giveMe: #symbol for: shortName.	suffixString _ DataMaster giveMe: #suffixString for: suffixSymbol.	(Disk includesKey: shortName)		ifFalse: [^true]		ifTrue:			[(self confirm: 'Overwrite existing data item?')				ifTrue: "we're going to have to pick a new name"					[suffixSymbol = (DataMaster giveMe: #symbol for: #spreadsheet asString) ifTrue:						[newLabel _ theItem label.						 [theLabel _ newLabel asFileName.	 					  (Disk includesKey: (shortName _ theLabel, suffixString))]							whileTrue: [newLabel _ FillInTheBlank request: 'Need NEW name for spreadsheet ', theItem label default: 'newSSLabel'].						 theItem label: theLabel].					^true]].	^false!destroyAll	"delete all files in the scavenge center"	| theItems fileCabinet |	viewList size = 0 ifTrue:[^false]."check for empty scavenge center"	fileCabinet _ center fileCabinet.	theItems _ pointerList collect: [:itemPtr | fileCabinet at: (itemPtr index)].	(self confirm: 'Destroy All will remove all the items in this folder from the disk. Are you sure?')		ifFalse: [^false].	theItems do: [:each |	self findThisSelection: each message: each iconDisplayString,' must be closed before it can be destroyed'].	folder removeAllFPointers.		theItems do:			[:theItem |			self userMessage: 'currently destroying ', theItem iconDisplayString.			Auditor audit ifTrue: [InformationCenter auditThis: (Array with: #destroySelection with: theItem iconDisplayString with: folder displayString with: center name)].			self killThisItem: theItem.			center freeList add: theItem centerIndex.			fileCabinet at: theItem centerIndex put: nil].		self refreshContainerList.		^true!destroySelection	"delete this file on the local disk"	| thisItem newClass |	thisItem _ center fileCabinet at: ((pointerList at: listIndex) index). 	self findThisSelection: thisItem message: thisItem iconDisplayString,' must be closed before it can be destroyed'.	(self confirm: 'Destroy will remove ', thisItem iconDisplayString, ' from the disk. Are you sure?')		ifTrue:			[self userMessage: 'currently destroying ', thisItem iconDisplayString.			Auditor audit ifTrue: [InformationCenter auditThis: (Array with: #destroySelection with: (viewList at: listIndex) with: folder displayString with: center name)].			self killThisItem: thisItem.			Clipboard remove: thisItem.			center removeSelection: (pointerList at: listIndex).			newClass _ center folderClassificationFor: folder.			newClass = folder classificationIndex				ifFalse: [folder classification: newClass.						center updateClassFor: folder].			self removeFromFolderList.	"self refreshContainerList."			^true]		ifFalse: [^false]!getFilesFromServer	| aXDE sendString theFileServerName | 	"get a list of file names for the user."	(Smalltalk includesKey: #XDEInterfaceModel) ifFalse: [^self booboo: 'Sorry, I cannot do that'].	theFileServerName _ UserProfile current selectFileServer.	theFileServerName == nil ifTrue: [^self].	aXDE _XDEInterfaceModel giveMeOne: true.	sendString _ 'createDir AnalystTransport; ftp/l "', theFileServerName, '" dir/c <AnalystSupport>', UserName, ' localDirectory/c <>AnalystTransport retrieve/c ''* delete/c ''*!!''*'.	aXDE sendTemplate: sendString doAfter: [:showObject :unusedArgs | center fetchNewFilesFrom: 'AnalystTransport>' message: showObject. self refreshContainerList] withArgs: nil.	aXDE changed.	XDEInterfaceModel openWith: aXDE!getSelectionFromServer	| aXDE theFileString theFileServerName sendString theEntry theFiles spaceString | 	"try to get from the file server the item that is the currently in the copy buffer "	(Smalltalk includesKey: #XDEInterfaceModel) ifFalse: [^self booboo: 'Sorry, I cannot do that'].	Clipboard isEmpty | (Clipboard nextClass ~= DataItem) ifTrue:		[Sensor leftShiftDown ifTrue: [^self bashLocalFromBackup]. ^self booboo:'There must be a selection in the copy buffer'].	theFileServerName _ UserProfile current selectFileServer.	theFileServerName == nil ifTrue: [^self].	theFiles _ ((theEntry _ Clipboard retrieveEntry) propertyAt: #center) getFileNamesForSelection: (theEntry propertyAt: #pointer) index withMapSupport: false.	theFileString _ String new.	spaceString _ String with: Character space.	theFiles do: [:item | theFileString _ theFileString, item, spaceString].	aXDE _XDEInterfaceModel giveMeOne: true.	sendString _ 'createDir AnalystTransport; ftp/l "', theFileServerName, '" dir/c <', UserName, '>BackUpData> localDirectory/c <>AnalystTransport retrieve/c ',theFileString.	aXDE sendTemplate: sendString doAfter: [:showObject :unusedArgs | center fetchNewFilesFrom: 'AnalystTransport>' message: showObject. self refreshContainerList] withArgs: nil.	aXDE changed.	XDEInterfaceModel openWith: aXDE!killThisItem: thisItem	"delete this item from the disk "	| ending theFilename |	Cursor execute showWhile: [	theFilename _ thisItem filename.	Disk removeKey: theFilename ifAbsent: [].	ending _ DataMaster giveMe: #specialSuffixString for: theFilename.	(ending ~~ nil and: [Disk includesKey: theFilename, ending])		ifTrue: [Disk removeKey: theFilename, ending]]!refileSelection	"menu message in trash and scavenge center - refile this guy where the user wants"	| theItem itemArray fs overwrite |	theItem _ center fileCabinet at: ((pointerList at: listIndex) index).	self findThisSelection: theItem message: theItem iconDisplayString,' must be closed before it can be refiled'.	(theItem filename includes: $>) "see if it's in a subdirectory"		ifTrue: [overwrite _ self checkOverwrite: theItem].	itemArray _ InformationCenter fileNameData: nil defaultSuitcase: (Suitcase new packTheSuitcaseFrom: center name forItem: theItem) defaultKeys: (center keywordStringFor: theItem) askMethod: true askClass: (DataMaster externalClassOn: theItem filename).	(itemArray at: 1) == nil ifTrue: [^false].	(DataMaster thisFile: theItem filename isKindOf: #spreadsheet) ifTrue: [(itemArray at: 1) label: theItem label].	(theItem filename includes: $>) "see if it's in a subdirectory"		ifTrue: [DataMaster moveToMainDirectory: (itemArray at: 1) overwrite: overwrite].	center removeSelection: (pointerList at: listIndex).	folder classification: (center folderClassificationFor: folder).	center updateClassFor: folder.	self class changed: #holderChanged.	self removeFromFolderList.	"self refreshContainerList."	(DataMaster headerOKon: (itemArray at: 1) filename) ifTrue:		[(fs _ HeaderFileStream fileNamed: (itemArray at: 1) filename) readWrite.		fs writeHeaderFor: (itemArray at: 1).		fs close].	overwrite = true "could be nil"		ifTrue: [InformationCenter putFileNameAwayWithCheck: itemArray]		ifFalse: [InformationCenter putFileNameAway: itemArray].	^true!releaseAll	| centerName theItems | 	viewList size = 0 ifTrue:[^false]."check for empty scavenge center"	centerName _ center name.	theItems _ pointerList collect: [:itemPtr | center fileCabinet at: (itemPtr index)].	theItems do: [:each |	self findThisSelection: each message: each iconDisplayString,' must be closed before it can be released'].	InformationCenter activeCenters removeKey: centerName.	InformationCenter possibleCenters remove: centerName.	InformationCenter addNewInfoCenter: (Array with: centerName with: String new).	^true!releaseSelection	| theItem | 	"this is for use by the scavenge folder"	theItem _ center fileCabinet at: ((pointerList at: listIndex) index).	self findThisSelection: theItem message: theItem iconDisplayString,' must be closed before it can be released'.	folder removeFPointer: (pointerList at: listIndex).	center freeList add: ((pointerList at: listIndex) index).	center fileCabinet at: ((pointerList at: listIndex) index) put: nil.	self removeFromFolderList.	"self refreshContainerList."	^true!scavengeThese	"specify the data type to be scavenged"	| theReturn theList endLabel fs class newClass saveCenterName |	saveCenterName _ InformationCenter lastUsedCenterName.	theReturn _ DBoxView		openFor: (Array with: #multipleSelect)		title: 'Select Scavenge Types'		labels: (Array with: ((Array with: 'data types:'), DataMaster englishStrings))		defaults: (Array with: Array new).	(theReturn == nil or: [theReturn first == nil]) ifTrue: [^false].	theList _ self scavengeThese: theReturn first.	InformationCenter lastUsedCenterName: saveCenterName.	theList isEmpty		ifFalse: [self userMessage: '~I am now formatting list of found files~'.				center addFilesInList: theList toFolder: folder. self refreshContainerList]			ifTrue: [self booboo: 'There were no recoverable files of the specified types'. ^false].	^true!scavengeThese: theDataTypes	"return a list of all the basic files on the local disk of the specified data types which are not referenced anywhere"	| basicFilesOnDisk theReferencedFiles messWithThese searchPattern |	 self userMessage: '~I am getting all active data items~'.	theReferencedFiles _ Set new.	Cursor execute showWhile:		[InformationCenter getAllFilesInAllCentersExcept: nil return: theReferencedFiles.		theReferencedFiles addAll: (DataMaster getBasicAssociatedFilesOfTypes: theDataTypes localDirectory: String new).		messWithThese _ OrderedCollection new.		theDataTypes do:			[:aDataType |			searchPattern _ DataMaster giveMe: #suffixString for: aDataType.			self userMessage: '~I am now searching for ', aDataType, ' files~'.			basicFilesOnDisk _ DataMaster trimList: (DataMaster getDiskList: ((String with: $*), searchPattern, (String with: $*))) for: aDataType.			Disk findFiles: basicFilesOnDisk inList: theReferencedFiles inclusive: false addTo: messWithThese]].	^messWithThese! !!ContainerModel methodsFor: 'accessing'!center	^center!centerIndex	^folder centerIndex!centerName	^center name!folder	^folder!listIndex	"Answer the selected index for the folder"	^ listIndex!listIndex: anInteger	"Set the selected listIndex to be anInteger."	listIndex _ anInteger.	(anInteger = 0)		ifTrue:[Cursor normal show. self changed: #deSelect]		ifFalse: [ Cursor mouse show].!searchString	^searchString!searchString: aString	searchString _ aString!userAccessMessage	"This will display in the top message pane some reassuring information to  	the outside world about what is going on inside."	Clipboard nextClass == DataItem		ifTrue: [self class message: 'The available Item Reference is: ' , Clipboard next contents iconDisplayString]		ifFalse: [self class message: 'There is no available Item Reference.'].	talkView model contents: self class message.	talkView updateDisplayContents!userMessage: aMessage	"This will display in the top message pane some reassuring information to the outside world about what is going on inside."	self class message: aMessage. 	talkView model contents: self class message.	talkView updateDisplayContents.!viewList	"Answer the label list for this folder"	^ viewList! !!ContainerModel methodsFor: 'menu messages add'!addContainer	"add a container to the active fileCabinet "	| newItemArray itemLoc theNewItem |	newItemArray _ InformationCenter getNewKeyFor: (DataItem type: #Folder label: 'New Folder' atIndex: 0) withKeywords: String new dBoxTitle: 'Create New Folder' askClass: false.	(newItemArray == nil or: [(newItemArray at: 1) isEmpty]) ifTrue:[^nil].	itemLoc _ center		addThis: (theNewItem _ DataItem 					locked: false 					classification: 1 					modifiers: nil 					type: #Folder					label: (newItemArray at: 1) 					filename: nil 					bPointers: (Array with: (DataItemPointer index: self centerIndex))					fPointers: nil 					atIndex: 0)		linkType: (center linkTypeFor: #contains)		to: folder		beforePointer: (listIndex = 0 ifTrue: [nil] ifFalse: [pointerList at: listIndex]).	center setKeywordsForItemAt: itemLoc to: (newItemArray at: 2).	self class changed: folder.	listIndex = 0 ifTrue:[listIndex _ viewList size + 1].	Auditor audit ifTrue:[InformationCenter auditThis: (Array with: #addContainer with: theNewItem displayString with: folder displayString with: center name)].	viewList add: theNewItem iconDisplayString atIndex: listIndex.	pointerList add: (DataItemPointer index: itemLoc) atIndex: listIndex.	^Array with: theNewItem iconDisplayString with: (DataItemPointer index: itemLoc)!addDataItem: fileEnglishString	" add an item to the FCUser's fileCabinet. If fileCreation is nil, then by default just open an empty file"	| return filename itemLoc theNewItem newClass |	return _ DataMaster createItemOfType: fileEnglishString.	return == nil ifTrue: [^nil].	filename _ return at: 2.	return _ return at: 1.	itemLoc _ center		addThis: (theNewItem _ DataItem					locked: false					classification: (return at: 3)					modifiers: (return at: 4)					type: #Item					label: (return at: 1)					filename: filename					bPointers: (Array with: (DataItemPointer index: self centerIndex))					fPointers: nil					atIndex: 0)			linkType: (center linkTypeFor: #contains)			to: folder			beforePointer: (listIndex = 0 ifTrue: [nil] ifFalse: [pointerList at: listIndex]).	center setKeywordsForItemAt: itemLoc to: (return at: 2).	newClass _ center folderClassificationFor: folder.	newClass = folder classificationIndex ifFalse:		[folder classification: newClass.		center updateClassFor: folder].	listIndex = 0 ifTrue:[listIndex _ viewList size +1].	Auditor audit ifTrue:[InformationCenter auditThis: (Array with: #addItem with: theNewItem displayString with: folder displayString with: center name)].	self class changed: folder.	viewList add: theNewItem iconDisplayString atIndex: listIndex.	pointerList add: (DataItemPointer index: itemLoc) atIndex: listIndex.	^Array with: theNewItem iconDisplayString with: (DataItemPointer index: itemLoc)!connectSelection	| theItem | 	"add links to this guy"	theItem _ center fileCabinet at: ((pointerList at: listIndex) index).	theItem filename == nil		ifFalse:[(DataMaster thisFile: theItem filename isKindOf: #map)			ifTrue: [^center makeDatabaseConnectionTo: theItem]].	self booboo: 'The selection must be the target map'!makeNewCenter	"generate a new info center from this selection if it is a folder, otherwise put this item in a new info center."	| theFolder theIndex answer newCenter theItem newCenterName | 	listIndex = 0		ifTrue: [theFolder _ folder]		ifFalse:			[theIndex _ (pointerList at: listIndex) index.			(center fileCabinet at: theIndex) isFolder				ifTrue: [theFolder _ center fileCabinet at: theIndex]				ifFalse: "make a new folder with selected item in it"					[theFolder _ DataItem type: #Folder label: 'A New Info Center' fPointers: (Array with: (DataItemPointer index: theIndex)) atIndex: 0]].	answer _ DBoxView		openFor: #(fill password)		title: 'Add new information center for ',UserName		labels: (Array with: #(Name:) with: #(Password:))		defaults: (Array with: theFolder label with: String new)		autoAccept: true.	answer == nil ifTrue: [^nil].	(newCenterName _ InformationCenter addNewInfoCenter: answer) == nil ifTrue: [^false].	Cursor execute show.	newCenter _ InformationCenter centerFor: newCenterName.	(theFolder fPointersOfType: (center linkTypeFor: #contains)) do:		[:fp | "copy from top level of theFolder to top level of new info center"		theItem _ center fileCabinet at: (fp index).		theItem typeSymbol = #Folder			ifTrue: [newCenter duplicateThisFolder: theItem sourceCenter: center into: (newCenter fileCabinet at: newCenter fileCabinetIndex) keepItems: true dupItems: false]			ifFalse: [newCenter duplicateThisItem: theItem sourceCenter: center into: (newCenter fileCabinet at: newCenter fileCabinetIndex) dupFileName: nil]].	InformationCenter open: newCenterName! !!ContainerModel methodsFor: 'menu messages main'!addFromBuffer	| theArray | 	"take the reference in the buffer and add it to this folder"	theArray _ center pasteFromBufferIntoFolder: folder before: (listIndex = 0 ifFalse:[pointerList at: listIndex]).	theArray == nil ifFalse:		[listIndex = 0 ifTrue:[listIndex _ (viewList size = 0 ifTrue:[1] ifFalse:[viewList size + 1])].		viewList add: (theArray at: 1) atIndex: listIndex.		pointerList add: (theArray at: 2) atIndex: listIndex].	^theArray!cutSelection	"cut selection from this folder"	| newClass containsLink item copyCenter copyPointer | 	self putInTheCopyBuffer.	item _ Clipboard last.	copyCenter _ item propertyAt: #center.	copyPointer _ item propertyAt: #pointer.	containsLink _ center linkTypeFor: #contains.	folder removeFPointer: copyPointer.	item contents removeBPointer: self centerIndex type: containsLink.	(item contents bPointersOfType: containsLink) isEmpty		ifTrue: "not referenced elsewhere, so put in trash"			[copyCenter trash addFPointer: copyPointer.			item contents addBPointer: center trashIndex type: containsLink.			copyCenter trash classification: (copyCenter folderClassificationFor: copyCenter trash).			self class changed: copyCenter trash].	newClass _ center folderClassificationFor: folder.	newClass = folder classificationIndex		ifFalse: [folder classification: newClass.				center updateClassFor: folder].	self removeFromFolderList.	Auditor audit ifTrue:[InformationCenter auditThis: (Array with: #cut with: item contents displayString with: folder displayString with: center name)].^true!dumpFolder	| haveIChanged | 	"this is only for use with trash folder - cut everything from the trash"	pointerList isEmpty ifTrue: [^false].	(self confirm: 'Do you really want to dump the whole folder ?') ifTrue: [		[pointerList isEmpty]			whileFalse: [listIndex _ 1.				self cutSelection]].	listIndex _ 0.	^true!duplicateSelection	| theItem newItemArray newItemIndex structureOnly typeOfDataIndex newDataItem | 	(pointerList at: listIndex) index = 1 ifTrue:[^self booboo: 'You can''t put the information center into the copy buffer'].	theItem _ (center fileCabinet at: ((pointerList at: listIndex) index)) deepCopy.	theItem typeSymbol = #Folder		ifTrue: "this is a folder"			[newItemArray _ InformationCenter getNewKeyFor: theItem withKeywords: (center keywordStringFor: theItem) dBoxTitle: 'Duplicate folder''s label' askClass: false.			(newItemArray == nil or: [(newItemArray at: 1) isEmpty]) ifTrue: [^nil].			structureOnly _ (self confirm: '		 Which type of folder copy  		' yesLabel: 'copy only structure' noLabel: 'structure and contents').			theItem label: (newItemArray at: 1).			newItemIndex _ center duplicateThisFolder: theItem sourceCenter: center into: center trash keepItems: structureOnly not dupItems: true]		ifFalse:			[theItem typeSymbol = #Item ifFalse: [^nil].			typeOfDataIndex _ DataMaster suffixIndexForFileName: theItem filename.			newItemArray _ InformationCenter getNewKeyFor: theItem withKeywords: (center keywordStringFor: theItem) dBoxTitle: 'Duplicate ',(DataMaster giveMe: #englishString for: typeOfDataIndex),'''s label' askClass: (DataMaster externalClassOn: typeOfDataIndex).			newItemArray == nil ifTrue: [^nil].			theItem _ DataItem locked: theItem isLocked classification: (newItemArray at: 3) modifiers: (newItemArray at: 4) type: theItem type label: (newItemArray at: 1) filename: theItem filename bPointers: nil fPointers: nil atIndex: 0.			newItemIndex _ center duplicateThisItem: theItem sourceCenter: center into: center trash dupFileName: (newItemArray at: 1)].	newItemIndex = 0 ifTrue: [^self booboo: 'Sorry, could not duplicate that selection'].	center setKeywordsForItemAt: newItemIndex abs to: (newItemArray at: 2).	Clipboard clip: (newDataItem _ center fileCabinet at: newItemIndex abs).	Clipboard last propertyAt: #pointer put: (DataItemPointer index: newItemIndex abs).	Clipboard last propertyAt: #center put: center.	(DataMaster headerOKon: newDataItem filename) ifTrue:		[(HeaderFileStream fileNamed: newDataItem filename) readWrite;  writeHeaderLabel: (newItemArray at: 1) class: (newItemArray at: 3) mods: (newItemArray at: 4) dataType: newDataItem dataTypeUpdated].	self class changed: center trash.	self userAccessMessage!hardcopySelection	"hardcopy the selection  "	| theSelection theSelectionIndex |	listIndex = 0 ifTrue: [^self hardcopyStructure: (center fileCabinet at: self centerIndex)].	theSelectionIndex _ (pointerList at: listIndex) index.	theSelection _ center fileCabinet at: theSelectionIndex.	theSelection isFolder		ifTrue: [self hardcopyStructure: theSelection]		ifFalse: [self hardcopySelection: theSelection]!hardcopySelection: theSelection	theSelection isFolder		ifTrue: [	center clearFlags.			self hardcopyStructure: theSelection]		ifFalse: [self findThisSelection: theSelection message: 'Hardcopy of ',theSelection iconDisplayString,' should be done from this open window.'.DataMaster hardcopyItemInSuitcase: (Suitcase new packTheSuitcaseFrom: center name forItem: theSelection)]!hardcopyStructure: theItem	"create the file structure text string for hardcopy."	| theStream | 	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].	Cursor execute show.	theStream _ ReadWriteStream on: String new.	theOffset _ String with: Character tab.	center clearFlags.	self showStructure: theItem on: theStream indexCollection: OrderedCollection new hardcopy: true.	theStream nextPut: Character cr.	BackgroundPrinter putText: (Text fromString: theStream contents) annoDict: nil suitcase: (Suitcase new packTheSuitcaseFrom: center name forItem: theItem).	theOffset _ nil!openMenu: aPointerList"return a treemenu that can be used to open any accessible item"	| items cr menuString form menu sublist ts font |	items _ Array new: aPointerList size.	cr _ String with: Character cr.	1 to: aPointerList size do: [:i | items at: i put: (center fileCabinet at: (aPointerList at: i) index)].	menuString _ (items at: 1) iconDisplayString.	2 to: items size do: [:i | menuString _ menuString, cr, (items at: i) iconDisplayString].	ts _ TextStyle default.	font _ ts fontAt: 1.	ts lineGrid: font height + 4; baseline: font ascent + 2; rightIndent: 2; restIndent: 2; firstIndent: 2. 	form _ FastTextDisplayScanner new			formFromText: (Text string: menuString emphasis: 1)			textStyle: ts			maxWidth: 8000.	menu _ ScrollMenu new form: form height: ts lineGrid.	menu		answers: items;		children: [:menu |			(sublist _ menu answer fPointersOfType: 1) isEmpty				ifTrue: [nil]				ifFalse: [self openMenu: sublist]];		maxLines: 7;		popUpChildren: false.	^menu!putInTheCopyBuffer	(pointerList at: listIndex) index = 1 ifTrue:[^self booboo: 'You can''t put the information center into the copy buffer'].	Clipboard clip: (center fileCabinet at: (pointerList at: listIndex) index).	Clipboard last propertyAt: #center put: center.	Clipboard last propertyAt: #pointer put:  (pointerList at: listIndex).	self userAccessMessage!reclassifySelection	"change the label and or the key of the selection"	| theItem return itemIndex fullName fs theClass |	itemIndex _ (pointerList at: listIndex) index.	theItem _ center fileCabinet at: itemIndex.	(theItem isFolder or: [(DataMaster externalClassOn: theItem filename) not])		ifTrue: [self booboo:'You can''t manually reclassify this type of item.'. ^nil]		ifFalse:			[self findThisSelection: theItem message: theItem iconDisplayString,' must be closed before it can be reclassified'.			(fullName _ self class getOldFileName: theItem filename) == nil				ifTrue: [self booboo: 'This item does not really exist'. ^nil].			(fs _ HeaderFileStream fileNamed: fullName) readWrite.			(theClass _ fs classAndModsFromHeader) == nil ifFalse:				[theItem class: (theClass at: 1) modifiers: (theClass at: 2).				theItem label: fs labelFromHeader].			return _ InformationCenter getNewKeyFor: theItem withKeywords: (center keywordStringFor: theItem) dBoxTitle: 'Edit this ',(DataMaster giveMe: #englishString for: theItem filename),'''s label' askClass: true.			return == nil ifFalse:				[(DataMaster thisFile: theItem filename isKindOf: #spreadsheet)					ifTrue: [return at: 1 put: theItem label].				 (DataMaster headerOKon: theItem filename) ifTrue:					[fs writeHeaderLabel: (return at: 1) class: (return at: 3) mods: (return at: 4) dataType: theItem dataTypeUpdated]].			fs close].	(return == nil or: [(return at: 1) isEmpty]) ifTrue: [^nil].	(center modifyItemAt: itemIndex with: return at: self centerIndex)		ifTrue: [theItem _ center fileCabinet at: itemIndex.				self class changed: folder.				viewList at: listIndex put: theItem iconDisplayString.				^theItem iconDisplayString].	^nil!renameSelection	"change the label and or the key of the selection"	| theItem return itemIndex askClass fullName fs theClass theMessage |	itemIndex _ (pointerList at: listIndex) index.	theItem _ center fileCabinet at: itemIndex.	InformationCenter lastUsedCenterName: center name.	theMessage _ theItem iconDisplayString,' must be closed before it can be renamed'.	theItem filename == nil		ifTrue: [self findThisFolder: theItem message: theMessage]		ifFalse:			[self findThisSelection: theItem message: theMessage.			(fullName _ self class getOldFileName: theItem filename) == nil				ifTrue: [self booboo: 'This item does not really exist'. ^nil].			(fs _ HeaderFileStream fileNamed: fullName) readWrite.			(theClass _ fs classAndModsFromHeader) == nil ifFalse:				[theItem class: (theClass at: 1) modifiers: (theClass at: 2).				theItem label: fs labelFromHeader]].	return _ InformationCenter getNewKeyFor: theItem withKeywords: (center keywordStringFor: theItem) dBoxTitle: 'Edit this selection''s label' askClass: false.	(return == nil or: [(return at: 1) isEmpty]) ifTrue: [^nil].	(DataMaster thisFile: theItem filename isKindOf: #spreadsheet)		ifTrue: [return at: 1 put: theItem label].	(DataMaster headerOKon: theItem filename) ifTrue:		[fs writeHeaderLabel: (return at: 1) class: (return at: 3) mods: (return at: 4) dataType: theItem dataTypeUpdated].	fs == nil ifFalse: [fs close].	(center modifyItemAt: itemIndex with: return at: self centerIndex)		ifTrue: [theItem _ center fileCabinet at: itemIndex.				self class changed: folder.				viewList at: listIndex put: theItem iconDisplayString.				^theItem iconDisplayString].	^nil!selectFromOpenMenu	| item |	(item _ (self openMenu: pointerList) startUp: nil) == nil		ifFalse: [self viewSelection: item].!showInBox	"open the in box"	Cursor execute show.		(ContainerModel createForIndexOrItem: center inboxIndex inCenter: center) scheduleTheFolder: center name , '''s In Box' usingMenu: 2 width: 1 helpMessage: #InBox!showTrash	"open the trash bin"	Cursor execute show.	(ContainerModel createForIndexOrItem: center trashIndex inCenter: center) scheduleTheFolder: center name , '''s TRASH' usingMenu: 3 width: 1 helpMessage: #Trash!sort	| oldPointers sortList theEntry size newPointerList fileCabinet | 	Cursor execute show.	oldPointers _ folder fPointersOfType: (center linkTypeFor: #contains).	oldPointers isEmpty ifTrue: [^false].	sortList _ SortedCollection sortBlock: [:x :y | (x at: 1) <= (y at: 1)].	fileCabinet _ center fileCabinet.	oldPointers do: [:each | theEntry _ fileCabinet at: (each index).		sortList add: (Array with: theEntry iconDisplayString with: each)].	size _ sortList size.	newPointerList _ Array new: size.	1 to: size do: [:i | newPointerList at: i put: ((sortList at: i) at: 2)].	folder replaceFPointersWith: newPointerList.	self refreshContainerListNoCheck.	Cursor normal show.	^true!viewSelection	"pack his suitcase and send him off"	^self viewSelection: (center fileCabinet at: ((pointerList at: listIndex) index))!viewSelection: theItem	"pack his suitcase and send him off"	| theSuitcase backwards thePointers tabLabel |	theItem isFolder ifTrue: [^self class openThisFolder: theItem inCenter: center searchString: searchString].	theItem isKeyword ifTrue:		[tabLabel _ 'Connections from keyword ' , theItem label.		self findTheHolderLabeled: tabLabel.		backwards _ theItem bPointers.		thePointers _ OrderedCollection new.		backwards == nil ifFalse: [backwards do: [:each | each index >= center dataStart ifTrue:[thePointers add: each]]].		thePointers do: [:each | (center okToFoolWith: (center fileCabinet at: each index))								ifFalse: [thePointers remove: each]].		thePointers isEmpty ifTrue: [^self booboo: 'There are no items linked to this keyword.'].		center makeAHolderOn: thePointers withLabel: tabLabel searchString: nil menuType: 5].	(theItem typeSymbol = #Item)		ifTrue: [theSuitcase _ (Suitcase new packTheSuitcaseFrom: center name forItem: theItem).				theSuitcase searchString: searchString.				^DataMaster viewSelection: theItem withSuitcase: theSuitcase]! !!ContainerModel methodsFor: 'menu messages trash'!checkPossibleOrphansOf: theItem message: theMessage	| fPointers thisItem |	self findThisFolder: theItem message: theItem iconDisplayString , theMessage.	(fPointers _ theItem fPointersOfType: (center linkTypeFor: #contains)) == nil		ifFalse: [fPointers do: 			[:fP | thisItem _ center fileCabinet at: fP index.			thisItem isFolder ifTrue: [self closePossibleOrphansOf: thisItem].			self findThisSelection: thisItem message: thisItem iconDisplayString , theMessage]]!closePossibleOrphansOf: theItem 	| fPointers thisItem containsLink |	containsLink _ center linkTypeFor: #contains.	(theItem bPointersOfType: containsLink) size <= 1		ifTrue: [self findThisFolder: theItem message: theItem iconDisplayString , ' must be closed before it can be dumped from the trash'].	(fPointers _ theItem fPointersOfType: containsLink) == nil		ifFalse: [fPointers do: [:fP | 			thisItem _ center fileCabinet at: fP index.			thisItem isFolder ifTrue: [self closePossibleOrphansOf: thisItem].			(thisItem bPointersOfType: containsLink) size <= 1				ifTrue: [self findThisSelection: thisItem message: thisItem iconDisplayString , ' must be closed before it can be dumped from the trash']]]!closeThisOnTheScreen: dataItem	|  theSuitcase | 	"this is only for use with trash folder - cut the selection from the trash"	ScheduledControllers scheduledControllers do: "make sure this item isn't open on the screen"		[:each | ((each isKindOf: StandardSystemController)			and: [theSuitcase _ each view suitcase.				theSuitcase ~~ nil and: [dataItem == theSuitcase dataItem]])					ifTrue: [each closeAndUnschedule ifFalse:[^false]]].	^true!destroyTrashSelection	"this is only for use with trash folder - cut the selection from the trash"	| theItem allFiles aString | 	theItem _ center fileCabinet at: ((pointerList at: listIndex) index).	theItem isFolder		ifTrue: [^(self confirm: 'Folders may not be destroyed. do you want to dump it')					ifTrue: [self dumpSelection]					ifFalse: [false]].	self findThisSelection: theItem message: theItem iconDisplayString, ' must be closed before it can be destroyed'.	 self userMessage: '~ I am looking for other owners of this data item ~'.	allFiles _ OrderedCollection new.	Cursor execute showWhile: [InformationCenter getAllFileReferencesToThisFile: theItem filename putIn: allFiles].	allFiles size > 1 ifTrue:		[aString _ String new.		allFiles do: [:each | aString _ aString, each, (String with: Character cr)].		self showThisString: aString withLabel: ' is in these centers'].	allFiles _ (DataMaster getBasicAssociatedFilesOfTypes: (Array with: (DataMaster giveMe: #englishString for: theItem filename)) localDirectory: String new).	(allFiles includes: theItem filename)		ifTrue: [self booboo: 'This item must be referenced by a preview or report'. ^false]		ifFalse:[^self destroySelection]!dumpSelection	"this is only for use with trash folder - cut the selection from the trash"	^self dumpSelection: listIndex!dumpSelection: aListIndex	| theItem messageString fPointers |	"this is only for use with trash folder - cut the selection from the trash"	Cursor wait showWhile: [	messageString _' must be closed before it can be dumped from the trash'.	theItem _ center fileCabinet at: ((pointerList at: aListIndex) index).	theItem isFolder		ifTrue: [	(fPointers _ theItem fPointersOfType: (center linkTypeFor: #contains)) isEmpty			ifFalse: [(self confirm: theItem iconDisplayString , ' contains some items.Are you sure you want to cut it?') ifFalse:[^false].			self checkPossibleOrphansOf: theItem message: messageString]]		ifFalse: [self findThisSelection: theItem message:theItem iconDisplayString,messageString].	center removeSelection: (pointerList at: aListIndex).	Clipboard remove: theItem.	folder classification: (center folderClassificationFor: folder).	self class changed: #holderChanged.	Auditor audit ifTrue:[InformationCenter auditThis: (Array with: #cut with: (viewList at: aListIndex)  with: folder displayString with: center name)].	self removeFromFolderList: aListIndex].	^true!dumpTrashBin	| haveIChanged | 	"this is only for use with trash folder - cut everything from the trash"	pointerList isEmpty ifTrue: [^false].	(self confirm: 'Do you really want to dump the whole trash bin ?')		ifTrue:[ haveIChanged _ false.			[pointerList isEmpty] whileFalse: [(self dumpSelection: 1) ifTrue:[haveIChanged _ true] ifFalse:[^haveIChanged]].			^haveIChanged].	^false!refileTrashSelection	"self putInTheCopyBuffer."	center showFolderList: (center fileCabinet at: (pointerList at: listIndex) index)! !!ContainerModel methodsFor: 'menu messages display'!connectionsForThisSelection	"generate a holder of all items connected to the current selection."  	| lookAtIndex theStartItem |	listIndex = 0		ifTrue: [lookAtIndex _ self centerIndex]		ifFalse: [lookAtIndex _ (pointerList at: listIndex) index].	lookAtIndex = 0 ifTrue: [^self booboo: 'There are no connections for this item'].	theStartItem _ (center fileCabinet at: lookAtIndex).	center connectionsForThisItem: theStartItem!cutKeyword	| thePointer | 	center removeKeyword: (thePointer _ (pointerList at: listIndex)).	folder removeFPointer: thePointer.	self removeFromFolderList.	self class changed: #holderChanged.	self class changed: #all.	^true!renameKeyword	"change the name of this keyword"	| return itemIndex theKeyword oldIconDisplayString theOtherIndex recieverIndex theRecieverKeyword keywordLinkType bPointers keywordPointer |	keywordPointer _ pointerList at: listIndex.	itemIndex _ keywordPointer index.	theKeyword _ center fileCabinet at: itemIndex.	return _ DBoxView		openFor: #(#fill)		title: 'Rename keyword'		labels: #(#(Name:))		defaults:( Array with: theKeyword label)		commands: #(accept cancel bailOut)		autoAccept: true.	(return == nil or: [(return at: 1) isEmpty]) ifTrue: [^nil].	(return at: 1) = theKeyword label ifTrue: [^nil].	theKeyword label: (return at: 1).	theOtherIndex _ viewList indexOf: theKeyword iconDisplayString.	theOtherIndex = 0		ifTrue: [self class changed: folder.			viewList at: listIndex put: theKeyword iconDisplayString.			^theKeyword iconDisplayString]		ifFalse: [recieverIndex _ (pointerList at: theOtherIndex) index.			theRecieverKeyword _ center fileCabinet at: recieverIndex.			keywordLinkType _ center linkTypeFor: #keyword.			bPointers _ theKeyword bPointers.			bPointers do: [:eachPointer| (theRecieverKeyword bPointersIncludes: (eachPointer index) type: (eachPointer linkType))				ifFalse: [theRecieverKeyword addBPointer: eachPointer].				(center fileCabinet at: eachPointer index) addFPointer: recieverIndex type: keywordLinkType.				(center fileCabinet at: eachPointer index) removeFPointer: itemIndex type: keywordLinkType.].			center removeKeyword: keywordPointer.			folder removeFPointer: keywordPointer.			center keywords removeFPointer: keywordPointer.			self removeFromFolderList.			self class changed: #holderChanged.			^String new]!retrieveByDataItem"find all of the data items of the specified types for the user."	| theSelectionIndex labels theReturn thePointers aDict theSelection size eachItem filename theLabel aDataItem |	(theSelectionIndex _ self checkSelection) == nil ifTrue: [^nil].	labels _ Array with: #('search path:' selection center) with:#('data types:'), DataMaster englishStrings asSortedCollection.	theReturn _ DBoxView		openFor: #(select multipleSelect)		title: 'Select Data Types'		labels: labels		defaults: (Array with: (listIndex= 0 ifTrue: [#center] ifFalse: [#selection]) with: Array new).	theReturn == nil ifTrue: [^nil].	(theReturn at: 2) isEmpty ifTrue: [^nil].	Cursor execute show.	thePointers _ OrderedCollection new.	aDict _ OopConservingDictionary new.	(theReturn at: 1) = #selection		ifTrue: [theSelection _ center fileCabinet at: theSelectionIndex.			center clearFlags.			center search: theSelection fileType: (theReturn at: 2) hitDict: aDict checkLocked: (center owner ~= UserName)]		ifFalse:[theSelection _ center fileCabinet at: 1.			center searchTotalCenterFor: (theReturn at: 2) hitDict: aDict checkLocked: (center owner ~= UserName)].	aDict keysDo: [:theKey | thePointers add: theKey].	thePointers isEmpty ifTrue: [^self booboo: 'I have no items of those data types'].	theLabel _ 'Data types ( '.	(theReturn at: 2) do: [:i | theLabel _ theLabel, i printString, (String with: Character space)].	center makeAHolderOn: thePointers withLabel: theLabel, ' ) from ', theSelection label searchString: nil menuType: 5!showFolderList	"Generate a list of folders from the selection" 	| aDataItem lookAt aDict thePointers lookAtIndex |	(lookAtIndex _ self checkSelection) == nil ifTrue:[^self].	lookAt _ center fileCabinet at: lookAtIndex.	thePointers _ center search: lookAt dataType: #Folder linkType: (center linkTypeFor: #contains) target: nil checkLocked: (center owner ~= UserName).	thePointers isEmpty ifTrue: [^self booboo:'There are no other folders in this folder.'].	center makeAHolderOn: thePointers withLabel: 'Folder list from ', lookAt label searchString: nil menuType: 5!showGraphicTree	"open graph view on selection"	| theIndex |	Cursor execute show.	theIndex _ listIndex = 0					ifTrue: [self centerIndex]					ifFalse: [(pointerList at: listIndex) index].	InfoCenterGraphView viewTwoWayGraphFor: (center fileCabinet at: theIndex) in: center.	^nil!showItemList	"generate a list of all items held in the current selection."  	| aDataItem lookAtIndex thePointers theStartItem |	(lookAtIndex _ self checkSelection) == nil ifTrue:[^self].	theStartItem _ (center fileCabinet at: lookAtIndex).	thePointers _ center search: theStartItem dataType: #Item linkType: (center linkTypeFor: #contains) target: nil checkLocked: (center owner ~= UserName).	thePointers isEmpty ifTrue: [^self booboo:'There are no items in this folder.'].	center makeAHolderOn: thePointers withLabel: 'Item list from ', theStartItem label searchString: nil menuType: 5!showItemListKey	"generate a folder with items containing the key word "	| lookAtIndex lookAt |	(lookAtIndex _ self checkSelection) == nil ifTrue: [^self].	lookAt _ lookAtIndex = 0 ifTrue: [folder] ifFalse: [center fileCabinet at: lookAtIndex].	^center lookForThisString: String new startingWith: lookAt!showKeyWordList	"show the key words for this selection."	| lookAtIndex lookAt keywords keywordItems query queryStream foundIndices keywordItem conjunction moreIndices left thePointers theLabel aDataItem fileCabinet |	(lookAtIndex _ self checkSelection) == nil ifTrue: [^self].	Cursor execute show.	fileCabinet _ center fileCabinet.	lookAt _ (lookAtIndex = 0 ifTrue: [folder] ifFalse: [fileCabinet at: lookAtIndex]).	keywords _ SortedCollection new.	keywordItems _ SortedCollection sortBlock: [:x :y | x label <= y label].	center clearFlags.	lookAt == (fileCabinet at: 1) "overall center"		ifTrue: [fileCabinet do: [:i | i == nil ifFalse: [i setFlag]]]		ifFalse: [center setFlagsDownFromDataItem: lookAt].	((center keywords) fPointersOfType: (center linkTypeFor: #contains)) do:		[:fp | (fileCabinet at: fp index) isFlagSet				ifTrue: [keywords add: (fileCabinet at: fp index) label.						keywordItems add: (fileCabinet at: fp index)]].	keywords isEmpty ifTrue: [^self booboo: 'There are no keywords'].	query _ KeywordQuerier request: 'Enter query with these keywords ' withFields: keywords.	(query == nil or: [query isEmpty]) ifTrue: [^self].	queryStream _ ReadStream on: query.	foundIndices _ Set new.	keywordItem _ keywordItems at: (keywords indexOf: queryStream next).	(keywordItem bPointersOfType: (center linkTypeFor: #keyword)) do:		[:bp | (fileCabinet at: bp index) isFlagSet ifTrue: [foundIndices add: bp index]].	[queryStream atEnd] whileFalse:		[conjunction _ queryStream next.		queryStream atEnd ifFalse:			[moreIndices _ Set new.			keywordItem _ keywordItems at: (keywords indexOf: queryStream next).			(keywordItem bPointersOfType: (center linkTypeFor: #keyword)) do:				[:bp | (fileCabinet at: bp index) isFlagSet ifTrue: [moreIndices add: bp index]].			(conjunction = #and asString or: [conjunction = #or asString])				ifTrue:					[conjunction = #and asString						ifTrue:							[left _ foundIndices.							foundIndices _ Set new.							left do: [:i | (moreIndices includes: i) ifTrue: [foundIndices add: i]]]						ifFalse: "conjunction = 'or'"							[moreIndices do: [:i | foundIndices add: i]]]				ifFalse:					[conjunction = 'and not'						ifTrue:							[left _ foundIndices.							foundIndices _ Set new.							left do: [:i | (moreIndices includes: i) ifFalse: [foundIndices add: i]]]						ifFalse: "conjunction = 'or not'"							[keywordItems do:								[:kwi |								kwi == keywordItem ifFalse:									[(kwi bPointersOfType: (center linkTypeFor: #keyword)) do:										[:bp | (fileCabinet at: bp index) isFlagSet ifTrue: [foundIndices add: bp index]]]]]]]].	thePointers _ OrderedCollection new.	foundIndices do: [:i | thePointers add: (DataItemPointer index: i)].	thePointers isEmpty ifTrue: [^self booboo: 'There were no hits for the keywords.'].	theLabel _ 'Hits for keywords ( '.	query do: [:i | theLabel _ theLabel, i, (String with: Character space)].	center makeAHolderOn: thePointers withLabel: theLabel, ') from ', lookAt label searchString: nil menuType: 5!showKeywords	"generate a holder of all keywords in the center"  	| thePointers  tabLabel |	Cursor execute show.	tabLabel _ 'Key words in ', center label.	self findTheHolderLabeled: tabLabel.	thePointers _ (center fileCabinet at: 4) fPointers.	thePointers == nil ifTrue: [^self booboo:'There are no keywords in this Information Center.'].	center makeAHolderOn: thePointers withLabel: tabLabel searchString: nil menuType: 4!showOtherPointers	| lookAt pointers aDataItem theReturn aCollection aString |	lookAt _ center fileCabinet at: ((pointerList at: listIndex) index).	theReturn _ DBoxView		openFor: #(select)		title: 'Get cross references for this selection'		labels: (Array with: #('Cross references in:' 'this center' 'all centers'))		defaults: (Array with: #('this center')).	theReturn == nil ifTrue: [^nil].	(theReturn at: 1) = 'this center'		ifTrue:			[pointers _ lookAt bPointersOfType: (center linkTypeFor: #contains).			(pointers == nil or: [pointers size = 1]) ifTrue: [^self booboo: 'There are no other references to this selection'].			center makeAHolderOn: pointers withLabel: lookAt label,' is referenced in' searchString: nil menuType: 5]		ifFalse:			[lookAt isFolder ifTrue: [^self booboo: 'Folders only exist in one information center'].			aCollection _ OrderedCollection new.			InformationCenter getAllFileReferencesToThisFile: lookAt filename putIn: aCollection.			aString _ String new.			aCollection do: [:each | aString _ aString, each, (String with: Character cr)].			self showThisString: aString withLabel: 'cross references']!showStructure	"start the file structure display."	| theSelectionIndex theStream aCollection |	(theSelectionIndex _ self checkSelection) == nil ifTrue: [^nil].	theStream _ ReadWriteStream on: String new.	theOffset _ String new.	aCollection _ OrderedCollection new.	center clearFlags.	self showStructure: (center fileCabinet at: theSelectionIndex)		on: theStream		indexCollection: aCollection		hardcopy: false.	theStream cr.	(ContainerModel createForIndexOrItem: theSelectionIndex inCenter: center)		open: theStream contents		tabLabel: 'Structure of ' , (center fileCabinet at: theSelectionIndex) label		indexCollection: aCollection! !!ContainerModel methodsFor: 'menu messages maintenance'!backup	center backup: (listIndex = 0		ifTrue: [self centerIndex]		ifFalse: [(pointerList at: listIndex) index])!changePassword	| answer owner | 	center owner = UserName		ifFalse: [^self booboo: 'Only ',center owner,' may change this password.'].	answer _ DBoxView openFor: #(fill)		title: 'Change the information center password.'		labels:  (Array with: (Array with:#Password:))		defaults: (Array with: String new).	answer == nil ifTrue: [^nil].	center password: ((answer at: 1) == nil		ifTrue:[String new] 		ifFalse:[(answer at: 1)])!editLinkTypes	center editLinkTypes!lockSelection	| theIndex | 	center owner = UserName ifFalse: [self booboo: 'Only owner may lock this selection'. ^false].	theIndex _ (pointerList at: listIndex) index.	(center fileCabinet at: theIndex) isLocked ifTrue:[^false].	(center fileCabinet at: theIndex) lock.	self refreshContainerList.	^true!recoverSelection	center recoverSelection: (pointerList at: listIndex) index!removeUser	| temp whichTypes scavengedList fileSet ending |	center owner = UserName		ifFalse: [^self booboo: 'Only ',center owner,' may DESTROY this Information Center'].	(self confirm: ('This will DESTROY the ',(self class fixName: center name),' Information Center.				 Are You Sure?')) ifFalse:[^nil]. 	center checkForDataWindows.	temp _ self class dependents copy.	Cursor execute showWhile:		[whichTypes _ center getAllTypesOfData.		fileSet _ Set new.		center getAllFilesStartingAt: center fileCabinetIndex putIn: fileSet linkType: nil extended: false.		Clipboard removeUsing: [:each | (each propertyAt: #center) == center]. 		InformationCenter removeCenter: center name.		InformationCenter possibleCenters remove: center name ifAbsent: [nil].		InformationCenter closeCenterChoiceBar.		(Disk includesKey: (center name , '.center')) ifTrue: [Disk removeKey: (center name, '.center')]].	scavengedList _ (whichTypes isEmpty ifTrue: [Array new] ifFalse: [self scavengeThese: whichTypes]).	scavengedList isEmpty ifFalse:		[fileSet do:			[:fileFromCenter |			(scavengedList includes: fileFromCenter) ifTrue:				[self userMessage: 'currently destroying ', fileFromCenter.				Disk removeKey: fileFromCenter ifAbsent: [].				ending _ DataMaster giveMe: #specialSuffixString for: fileFromCenter.				(ending ~= #nil and: [Disk includesKey: fileFromCenter, ending])					ifTrue: [self userMessage: 'currently destroying ', fileFromCenter, ending.							Disk removeKey: fileFromCenter, ending]]]].	temp do: [:dep | (dep centerName sameAs: center name)			ifTrue: [dep superView controller closeAndUnschedule]].	InformationCenter lastUsedCenterName: nil.	InformationCenter openCenterChoiceBar.!renameInfoCenter	| temp newName centerSuffix centerName | 	centerName _ center name.	(self confirm:'This will rename ',(self class fixName: centerName),'''s Information Center. To do so all the windows that refer to it must be closed.  Proceed?') ifFalse:[^nil].	(newName _ FillInTheBlank request: 'New information center name?' default: String new) isEmpty ifTrue: [^nil].	centerSuffix _ '.center'.	newName _ newName asFileName.	( InformationCenter doesInfoUsersIncludeThisCenter: newName) ifTrue: [^self booboo: 'That name already exists.'].	center checkForDataWindows.	temp _ self class dependents copy.	temp do:[:dep |  (dep centerName sameAs: centerName)			ifTrue:[dep superView controller closeAndUnschedule]].	(center fileCabinet at: center fileCabinetIndex) label: newName.	center save.	InformationCenter closeCenterChoiceBar.	InformationCenter possibleCenters remove: centerName ifAbsent: [nil].	(Disk includesKey: (centerName , '.center')) ifTrue: [Disk removeKey: (centerName, '.center')].	InformationCenter removeCenter: centerName.	InformationCenter possibleCenters add: newName.	Cursor wait showWhile: [InformationCenter open: newName]!restore	| temp centerName |	(self confirm:('This will Restore the ',(self class fixName: center name),' Information Center to its last saved state.Are You Sure?')) ifFalse:[^nil].	centerName  _ center name.	center checkForDataWindows.	temp _ self class dependents copy.	temp do:[:dep |  (dep centerName sameAs: centerName)			ifTrue:[dep superView controller closeAndUnschedule]].	Clipboard removeUsing: [:each | (each propertyAt: #center) == center]. 	InformationCenter removeCenter: centerName.	Cursor wait showWhile: [InformationCenter open: centerName]!save	center save!sendFilesToServer		center sendFilesToServer: (listIndex = 0		ifTrue: [self centerIndex]		ifFalse: [(pointerList at: listIndex) index])!showFileNames	"get a list of file names for the user"	| theString theFiles spaceString |	theFiles _ center getFileNamesForSelection: (listIndex = 0 ifTrue: [self centerIndex] ifFalse: [(pointerList at: listIndex) index]) withMapSupport: true.	theString _ String new.	spaceString _ String with: Character space.	theFiles do: [:item | theString _ theString, item, spaceString].	self showThisString: theString withLabel: 'file name list'!showThisString: theString withLabel: aLabel	"get a list of file names for the user"	| aDisplayTextView topView dumbItem aSuitcase selected myLabel |	(aDisplayTextView _ StringHolderView new)		model: (ContainerModel new contents: theString);		controller: ClassifiedStringHolderController new;		window: (0 @ 0 extent: 800@800);		insideColor: Form white;		borderWidth: 1.	selected _ (listIndex = 0 ifTrue: [folder] ifFalse: [center fileCabinet at: ((pointerList at: listIndex) index)]).	myLabel _ selected label, (String with: $ ),aLabel.	dumbItem _ DataItem locked: false classification: selected classification modifiers: selected modifiers type: #Item label: myLabel filename: nil bPointers: nil fPointers: nil atIndex: 0.	(topView _ StandardSystemView new)		borderWidth: 1;		label: myLabel;		minimumSize: 400@400;		addSubView: aDisplayTextView.	aSuitcase _ Suitcase new packTheSuitcaseFrom: center name forItem: dumbItem.	topView classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.	Cursor normal show.	topView controller open!shutDown	| temp centerName | 	(self confirm:'This will save ',(self class fixName: center name),'''s Information Center, and close all the windows that refer to it.  Proceed?') ifFalse:[^nil].	centerName _ center name.	center checkForDataWindows.	center save.	Clipboard removeUsing: [:each | (each propertyAt: #center) == center]. 	temp _ self class dependents copy.	temp do:[:dep |  (dep centerName sameAs: centerName)			ifTrue:[dep superView controller closeAndUnschedule]].	InformationCenter removeCenter: centerName.	ScheduledControllers searchForActiveController!unlockSelection	"unlock this selection if you are the owner of this information center"	| theIndex |	center owner = UserName ifFalse: [self booboo: 'Only owner may unlock this selection'. ^false].	theIndex _ (pointerList at: listIndex) index.	(center fileCabinet at: theIndex) isUnlocked ifTrue: [^false].	(center fileCabinet at: theIndex) unlock.	self refreshContainerList.	^true!verify	| count | 	center owner = UserName ifFalse: [self booboo: 'Only ',center owner,' the owner may verify this center'. ^false].	(count _ center verify) == nil		ifTrue:[self booboo: '     This center is OK     ']		ifFalse:[self booboo: 'This center had ',count printString, ' loose items in it.Check the InBox for them.']! !!ContainerModel methodsFor: 'menu messages item list'!makeInToAFolder	"this message is used to turn a holder into a real folder which is then put in the copy buffer and inbox" 	| return newFolder itemLoc fPointers |	self holderChanged.	return _ InformationCenter getNewKeyFor: folder withKeywords: (center keywordStringFor: folder) dBoxTitle: 'New folder label' askClass: false.	(return == nil or: [(return at: 1) isEmpty]) ifTrue: [^false].	newFolder _ folder deepCopy.	center addThis: newFolder linkType: (center linkTypeFor: #contains) to: center inbox.	newFolder addBPointer: center inboxIndex type: (center linkTypeFor: #contains).	(fPointers _ newFolder fPointers) == nil ifFalse:		[fPointers do: [:fp | (center fileCabinet at: (fp index)) addBPointer: newFolder centerIndex type: (fp at: 2)]].	center modifyItemAt: newFolder centerIndex with: return at: self centerIndex.	Clipboard clip: newFolder.	Clipboard last propertyAt: #pointer put: (DataItemPointer index: newFolder centerIndex).	Clipboard last propertyAt: #center put: center.	self userAccessMessage! !!ContainerModel methodsFor: 'menu messages folder list'!inThisFolder	"put the item in the search string into the selected folder. this is pure sleze but the instance variable was there and I used it "	searchString == nil ifTrue:[^nil].	center putThisItem: searchString inThisFolder: (center fileCabinet at: (pointerList at: listIndex) index) before: nil notifyError: true! !Sprite comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!Sprite methodsFor: 'initialization'!initialize	events _ OrderedCollection new.	locations _ OrderedCollection new.	positions _ OrderedCollection new.	info _ Array new: 7 withAll: false! !!Sprite methodsFor: 'accessing'!beginTime: aUTime	beginTime _ aUTime!currentTime: aUTime	currentTime _ aUTime!endTime: aUTime	endTime _ aUTime!info: anArray	info _ anArray!interval: anArray	interval _ anArray!isForward	^interval at: 4!labels	^labels!labels: anArray	labels _ anArray!objectForm: object	(object isKindOf: Form) 		ifTrue: [objectForm _ object] 		ifFalse: [objectForm _ object printString asForm].	objectForm offset: 0 - (objectForm extent // 2)!showConnect	^info at: 6!showDate	^info at: 4!showLabel	^info at: 3!showOpen	^info at: 7!showStep	^info at: 1!showTime	^info at: 5!showTrace	^info at: 2!window: aRect	window _ aRect! !!Sprite methodsFor: 'simulation'!calculateLocationAt: aTime 	| index multiple k |	multiple _ locations first size.	aTime <= events first		ifTrue: [1 to: multiple do: [:j | positions at: j put: (locations first at: j) copy]]		ifFalse: [aTime >= events last				ifTrue: [1 to: multiple do: [:j | positions at: j put: (locations last at: j) copy]]				ifFalse: 					[index _ self findIndex.					(self showStep not or: [aTime = (events at: index)])						ifTrue: [1 to: multiple do: [:j | positions at: j put: ((locations at: index) at: j) copy]]						ifFalse: [self isForward								ifTrue: [1 to: multiple do: 										[:j | 										k _ (aTime copy subtractBy: (events at: index) copy)										/ ((events at: index + 1) copy subtractBy: (events at: index) copy) asFloat.										positions at: j put: (((locations at: index) at: j) + (((locations at: index + 1)										at: j) - ((locations at: index) at: j) * k)) copy]]								ifFalse: [1 to: multiple do: 										[:j | 										k _ (aTime copy subtractBy: (events at: index) copy)										/ ((events at: index - 1) copy subtractBy: (events at: index) copy) asFloat.										positions at: j put: (((locations at: index) at: j) + (((locations at: index - 1)										at: j) - ((locations at: index) at: j) * k)) copy]]]]].	^index!display	| tempPos anIndex |	anIndex _ self findIndex.	self displayExtraAtLoc: positions index: anIndex.	1 to: positions size do: 		[:j | 		tempPos _ (positions at: j) copy rounded.		objectForm			displayOn: Display			at: tempPos			clippingBox: window			rule: Form under			mask: Form black].	self displayConnectAt: positions index: anIndex!displayAtLoc: loc index: anIndex 	| tempPos |	self displayExtraAtLoc: loc index: anIndex.	1 to: positions size do: 		[:j | 		tempPos _ (loc at: j) copy rounded.		objectForm			displayOn: Display			at: tempPos			clippingBox: window			rule: Form reverse			mask: Form black].	self displayConnectAt: loc index: anIndex!displayConnect	| multiple size |	self showConnect		ifTrue: 			[multiple _ positions size.			size _ multiple.			self showOpen ifTrue: [size _ size - 1 max: 1].			multiple > 1 ifTrue: [1 to: size do: [:l | (Line						from: (positions at: l)						to: (positions at: (l \\ multiple + 1))						withForm: ((Form new) extent: 1 @ 1; black; reverse))						displayOn: Display						at: 0 @ 0						clippingBox: window						rule: Form under						mask: Form black]]]!displayConnectAt: loc index: anIndex 	| multiple size |	self showConnect		ifTrue: 			[multiple _ positions size.			size _ multiple.			self showOpen ifTrue: [size _ size - 1 max: 1].			multiple > 1 ifTrue: [1 to: size do: [:l | (Line						from: (loc at: l)						to: (loc at: (l \\ multiple + 1))						withForm: ((Form new) extent: 1 @ 1; black))						displayOn: Display						at: 0 @ 0						clippingBox: window						rule: Form reverse						mask: Form black]]]!displayExtra	| multiple offset aForm anIndex |	anIndex _ self findIndex.	multiple _ positions size.	offset _ objectForm width // 2 @ -12.	self showLabel ifTrue: [labels ~= nil			ifTrue: 				[aForm _ (labels at: anIndex) asForm.				1 to: multiple do: [:i | aForm						displayOn: Display						at: ((positions at: anIndex) at: i) + offset						clippingBox: window						rule: Form under						mask: Form black]]].	self showTime		ifTrue: 			[offset _ offset + (0 @ 18).			aForm _ (events at: anIndex) time printString asForm.			1 to: multiple do: [:i | aForm					displayOn: Display					at: ((positions at: anIndex) at: i) + offset					clippingBox: window					rule: Form under					mask: Form black]].	self showDate		ifTrue: 			[offset _ offset + (0 @ 18).			aForm _ (events at: anIndex) date printString asForm.			1 to: multiple do: [:i | aForm					displayOn: Display					at: ((positions at: anIndex) at: i) + offset					clippingBox: window					rule: Form under					mask: Form black]]!displayExtraAtLoc: loc index: anIndex 	| multiple offset aForm |	multiple _ loc size.	offset _ objectForm width // 2 @ -12.	self showLabel ifTrue: [labels ~= nil			ifTrue: 				[aForm _ (labels at: anIndex) asForm.				1 to: multiple do: [:i | aForm						displayOn: Display						at: (loc at: i) + offset						clippingBox: window						rule: Form reverse						mask: Form black]]].	self showTime		ifTrue: 			[offset _ offset + (0 @ 18).			aForm _ (events at: anIndex) time printString asForm.			1 to: multiple do: [:i | aForm					displayOn: Display					at: (loc at: i) + offset					clippingBox: window					rule: Form reverse					mask: Form black]].	self showDate		ifTrue: 			[offset _ offset + (0 @ 18).			aForm _ (events at: anIndex) date printString asForm.			1 to: multiple do: [:i | aForm					displayOn: Display					at: (loc at: i) + offset					clippingBox: window					rule: Form reverse					mask: Form black]]!findIndex	self isForward		ifTrue: 			[^self locate: currentTime in: events]		ifFalse: 			[^self locateBack: currentTime in: events]!locate: aTime in: aList 	aTime >= aList last ifTrue: [^events size].	aTime <= aList first ifTrue: [^1].	1 to: aList size do: [:i | (aList at: i) >= aTime 							ifTrue: [(aList at: i) > aTime								ifTrue: [^i - 1]								ifFalse: [^i]]]!locateBack: aTime in: aList 	aTime <= aList first ifTrue: [^1].	aTime >= aList last ifTrue: [^aList size].	aList size to: 1 by: -1		do: [:i | (aList at: i) <= aTime 					ifTrue: [(aList at: i) < aTime								ifTrue: [^i + 1]								ifFalse: [^i]]]!step	| oldPositions oldIndex index |	oldPositions _ positions copy.	oldIndex _ self findIndex.	self isForward			ifTrue: [currentTime < endTime ifTrue: [currentTime addMinutes: (interval at: 3)]]			ifFalse: [currentTime > beginTime ifTrue: [currentTime subtractMinutes: (interval at: 3)]].	index _ self findIndex.	self calculateLocationAt: currentTime.	self showTrace ifFalse: [self displayAtLoc: oldPositions index: oldIndex].	self displayAtLoc: positions index: index! !!Sprite methodsFor: 'private'!cleanUp	| index | 	index _ self findIndex.	self showTrace ifFalse: [self displayAtLoc: positions index: index]!getInfo	| defaultArray ans title |	defaultArray _ OrderedCollection new.	title _ 'Parameter Information'.	labels == nil ifFalse: [title _ title, ' = ', labels first].	info do: [:each | each			ifTrue: [defaultArray add: #yes]			ifFalse: [defaultArray add: #no]].	ans _ DBoxView				openFor: #(select select select select select select select )				title: title				labels: #((Step yes no ) (Trace yes no ) (Label yes no ) (Date yes no ) (Time yes no ) (Connection yes no ) (Open yes no ) )				defaults: defaultArray.	ans == nil		ifFalse: 			[info _ Array new: 7.			1 to: 7 do: [:i | (ans at: i) asSymbol = #yes					ifTrue: [info at: i put: true]					ifFalse: [info at: i put: false]]]!object: anObject events: eventList locations: locationList labels: label 	| multiple tempLocat tempPos temp |	self objectForm: anObject.	events _ eventList.	(locationList first isKindOf: Collection)		ifTrue: 			[multiple _ locationList first size.			tempLocat _ locationList]		ifFalse: 			[multiple _ 1.			[(multiple < eventList size and: [((eventList at: multiple)					= (eventList at: multiple + 1))])]				whileTrue: [multiple _ multiple + 1].			tempLocat _ OrderedCollection new.			multiple = 1				ifTrue: [locationList do: [:each | tempLocat add: (Array with: each copy) asOrderedCollection]]				ifFalse: [events _ OrderedCollection new.						1 to: eventList size // multiple do: 						[:i | 						events add: (eventList at: i - 1 * multiple + 1).						temp _ OrderedCollection new.						1 to: multiple do: [:j | temp add: (locationList at: i - 1 * multiple + j)].						tempLocat add: temp]]]..	locations _ tempLocat.	self isForward		ifTrue: 			[currentTime == nil ifTrue: [currentTime _ beginTime copy]]		ifFalse: 			[currentTime == nil ifTrue: [currentTime _ endTime copy]]. 	self setPosition.	labels _ label!setPosition	beginTime == nil | (endTime == nil) ifTrue: [^self].	positions _ OrderedCollection new.	positions _ Array new: (locations first size).	self calculateLocationAt: currentTime! !!StrikeFont methodsFor: 'accessing'!ascent: aHeight	"Set the font's maximum extent of characters above the baseline."	ascent _ aHeight!descent: anInteger	descent _ anInteger!glyphs: aForm	glyphs _ aForm!isRemote	^glyphs isMemberOf: String!maxWidth: width 	"Sets the maximum width of the character set."	maxWidth _ width!raster: anInteger	raster _ anInteger!strikeFont	"for compatibility with PressFont"	^self!strikeLength	^strikeLength!type	^type!widthOfString: aString	"Answer the width of the argument as a sequence of characters	in the receiver."	"(TextStyle default fontAt: 1) widthOfString: 'Hello there'."	| width |	width _ 0.	aString do:		[:eachChar |		width _ width + (self widthOf: eachChar)].	^width!xOffset	^xOffset!xTable: anArray	xTable _ anArray! !!StrikeFont methodsFor: 'printing'!charsInString: aString fitting: aLength  	"Answer the characters of the argument which will fit into aLength.		(Kurt Piersol 12/84)"	| width retString |	width _ 0.	retString _ WriteStream on: String new.	aString do:		[ :eachChar |		width _ width + (self widthOf: eachChar).		width < aLength ifTrue: [retString nextPut: eachChar] ifFalse: [^retString contents]].	^aString! !Pool named: #TextConstants includes: #Space!Pool named: #TextConstants includes: #DefaultSpace!!StrikeFont methodsFor: 'private'!asPrinterWidthsFont	"Like a StrikeFont except the widths are according to the PressFont version, i.e. in micas."	| pressFont |	pressFont _ PressFont fontName: name strikeFont: self.	pressFont glyphs: glyphs.	pressFont emphasis: emphasis.	^ pressFont!newFromStrike: fileName	"Build an instance from the strike font file named. The '.strike' extension is optional."	| strike startName |	name _ fileName copyUpTo: $.. 	"assume extension (if any) is '.strike'"	strike _ FileStream oldFileNamed: name, '.strike'.	strike binary.	strike readOnly. 		"strip off directory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $]) & ((name at: startName) ~= $/)]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord.	maxAscii		_		strike nextWord.	maxWidth		_		strike nextWord.	strikeLength	_		strike nextWord.	ascent			_		strike nextWord.	descent			_		strike nextWord.	xOffset			_		strike nextWord. 		raster			_		strike nextWord.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs _		Form new extent: (raster * 16) @ (self height)  				   offset: 0@0				   bits: ((WordArray new: raster * self height) fromByteStream: strike).	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord].	"set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont]!setStopConditions	"some things don't make copies of the stop conditions, so they get messed up right here in the font.  This essentially sets them back the way they get read in clean from a strike font file"	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont]!storeOn: aStream	aStream nextPut: $(.	aStream nextPutAll: 'TextStyle default fontAt: (TextStyle getNumForStrikeFont: ', self name printString.	aStream nextPut: $); nextPut: $)! !FormsStrikeFont comment:'Copyright (c) Xerox Corporation, 1986.  All rights reserved.'!!FormsStrikeFont methodsFor: 'initialize-release'!, anItem	cache == nil | (cache isKindOf: LRUCacheDictionary)		ifTrue:			[cache _ (anItem isKindOf: Form)				ifTrue: [anItem.] ifFalse: [OrderedCollection with: anItem.].			]		ifFalse: [cache add: anItem].!with: aNameOrNil	| aForm temp |	offsetsArray == nil ifTrue:	"Not initialized yet, so initialize."		[xTable == nil ifTrue:			[xTable _ Array new: 256.			glyphs _ Form extent: 256 @ 16.			name == nil ifTrue: [name _ self class name.].			stopConditions _ Array new: 256.			type _ 2r1e15.			minAscii _ $1 asciiValue.			maxAscii _ minAscii - 1.			1 to: minAscii + 1 do: [:i | xTable at: i put: 0.].			maxWidth _ strikeLength _ 0.			ascent == nil ifTrue: [ascent _ 16.].			descent _ xOffset _ raster _ subscript _ superscript _ emphasis _ 0.			].		offsetsArray _ Array new: 256 * 4.		].	maxAscii _ maxAscii + 1.	(cache class == OrderedCollection)		ifTrue:			[temp _ (cache last isKindOf: Point)				ifTrue: [cache removeLast.]				ifFalse: [0 @ 0.].			aForm _ (Form extent: 16 @ glyphs height) offset: temp.			1 to: aForm bits size do:				[:i | aForm bits at: i put:					(cache at: i - 1 * 2 \\ cache size + 1) * 256 +						(cache at: i * 2 - 1 \\ cache size + 1)				].			]		ifFalse: [aForm _ cache.].	offsetsArray at: maxAscii * 4 - 1 put: aForm extent x.	offsetsArray at: maxAscii * 4 put: aForm extent y.	offsetsArray at: maxAscii * 4 + 1 put: aForm offset x.	offsetsArray at: maxAscii * 4 + 2 put: aForm offset y.	xTable at: maxAscii + 2 put: (xTable at: maxAscii + 1) + aForm width.	glyphs width < (xTable at: maxAscii + 2) ifTrue:		[temp _ glyphs.		glyphs _ Form extent: temp width * 3 / 2 + 8 @ temp height.		temp displayOn: glyphs.		].	aForm displayOn: glyphs at: (xTable at: maxAscii + 1) @ 0.	aNameOrNil == nil ifFalse:		[self list at: aNameOrNil put: maxAscii - minAscii + 1.		]."glyphs displayOn: Display at: 0 @ (maxAscii - minAscii + 1 * 16)."	cache _ LRUCacheDictionary new: 3.	^maxAscii - minAscii + 1! !!FormsStrikeFont methodsFor: 'accessing'!at: key	^cache find: key ifAbsentUseResultOf: 		[Form new			extent: (offsetsArray at: maxAscii * 4 - 1) @ (offsetsArray at: maxAscii * 4)			offset: (offsetsArray at: maxAscii * 4 + 1) @ (offsetsArray at: maxAscii * 4 + 2)			bits: (self characterForm: (((key isKindOf: Integer) ifTrue: [key.] ifFalse: [list at: key.]) + minAscii - 1) asCharacter) bits.		]!list	list == nil ifTrue: [list _ OopConservingDictionary new.].	^list! !SearchPath comment:'Copyright (c) 1986 Xerox Corporation.  All Rights Reserved.I am the interface to the Pilot Search path mechanism.My two sub-views contain lists of:		a. all directories on the volume, and		b. the current search path; i.e. the currently specified			order of inquiry when files are looked up.Instance Variables:		dirInAllDir			<String>		the current selection in the left (Directory) sub-view		dirInSearchPath		<String>		the current selection in the right (Search Path) sub-view'!FakeCollection comment:'Warning: My main drawback is circular garbage.'!!FakeCollection methodsFor: 'initialize-release'!actionBlock	^actionBlock!actionBlock: aBlock	actionBlock _ aBlock copy fixTemps!release	actionBlock _ nil.	super release!value: anObject	value _ anObject! !!FakeCollection methodsFor: 'accessing'!at: aKeyOrIndex	actionBlock isNil ifTrue: [^value].	^actionBlock value: aKeyOrIndex! !!Point methodsFor: 'press printing'!fromPress: press value: aStream 	x _ aStream nextWord.	y _ aStream nextWord.!hidePress: press complete: code 	"This expression is not implemented....	press skipcode: self pressCode data: (self hideData: code)"!pressCode	^7! !!Point methodsFor: 'enumerating'!numbersDo: aBlock	x _ aBlock value: x.	y _ aBlock value: y!numbersInit: aBlock	x _ aBlock value.	y _ aBlock value.!numbersReverseDo: aBlock	y _ aBlock value: y.	x _ aBlock value: x.!numbersReverseInit: aBlock	y _ aBlock value.	x _ aBlock value.! !Auditor comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!FormsModel comment:'Copyright (c) 1986, 1987 Xerox Corporation.  All rights reserved.'!!FormsModel methodsFor: 'initialize-release'!changeRequest	| answer | 	answer _ self hasChanged not		or: [(self confirm: name, '''s contents have not been saved.Are you certain that you want to close?')].	answer ifFalse: [elements first controller view resetDisplayCache].	^answer!initializeValues	"Set my element's values to their initialValues and reset to an unchanged state."	elements do:		[:element |		element value: element initialValue copy.		element hasChanged: false]!release	"Release all of my elements."	elements do: [:element | element release].!resetState	"Tell my elements to reset to an unchanged state. Typically done after reading	or storing values from/to a file."	elements do: [:element | element hasChanged: false]!setInitialValues	"Set my element's initialValues to their values and reset to an unchanged state."	elements do:		[:element |		element initialValue: element value.		element hasChanged: false]! !!FormsModel methodsFor: 'accessing'!boundingBox	"Answer the minimum Rectangle that encloses the bounding boxes of my elements."	| aRectangle |	aRectangle _ elements first box.	elements do: [:element | aRectangle _ aRectangle merge: element box].	^aRectangle!codeString	| stream | 	stream _ WriteStream on: (String new: 100).	self codeOn: stream.	^stream contents!elements	^elements!elements: aDictionary	elements _ aDictionary!elemNames	^elemNames!elemNames: aDictionary	elemNames _ aDictionary!fillElementsDict	| aDict value |	aDict _ Dictionary new.	elements do: [:element | element hasStringData			ifTrue: 				[value _ element value.				(value isKindOf: Text)					ifTrue: [aDict at: element name asSymbol put: element value string]					ifFalse: [aDict at: element name asSymbol put: element value printString]]].	^aDict!fillElementsString	| aStream value |	aStream _ WriteStream on: (String new: 100).	elements do: [:element | element hasStringData			ifTrue: 				[aStream nextPutAll: element name; nextPut: $:; nextPut: $ .				value _ element value.				(value isKindOf: Text)					ifTrue: [aStream nextPutAll: element value string]					ifFalse: [aStream nextPutAll: element value printString].				aStream cr]].	^aStream contents!hasChanged	"Answer whether any of my element's values have been changed."	elements do: [:element | element hasChanged ifTrue: [^true]].	^false!name	^name!name: aString	name _ aString!removeElementNamed: aName	| element oldElements | 	element _ self elementNamed: aName.	elemNames removeKey: aName.	elements remove: element.! !!FormsModel methodsFor: 'searching'!elementNamed: aName	^elemNames at: aName asString ifAbsent: [nil]!next: elementClass after: anElement	| index i | 	index _ elements indexOf: anElement.	i _ index.	[i _ i + 1.	i > elements size ifTrue:[i _ 1].	index = i] whileFalse: [((elements at: i) isKindOf: elementClass) ifTrue:[^elements at: i]].	^anElement!nextFillAfter: anElement	| index i | 	index _ elements indexOf: anElement.	i _ index.	[i _ i + 1.	i > elements size ifTrue:[i _ 1].	index = i] whileFalse: [((elements at: i) isKindOf: FillElement) ifTrue:[^elements at: i]].	^anElement! !!FormsModel methodsFor: 'copying'!copy	"Answer a new instance of my class that has my name and a copy of my template, but not my values."	| formsModel |	formsModel _ self class named: name.	elements do: [:element | formsModel add: element copy].	^formsModel! !!FormsModel methodsFor: 'adding'!add: newElement 	(elemNames includesKey: newElement name)		ifTrue: [^self booboo: 'that name has been used, think of another'].	elements add: newElement.	elemNames at: newElement name put: newElement!atValueNamed: valueName put: value	(elements at: valueName) value: value! !!FormsModel methodsFor: 'control panel'!addControlPanel: elementClass labels: labels messages: messages targetController: targetController boundingBox: boundingBox 	"Adds ExecuteElements with the specified labels and messages, positioning 	them within the specified bounding box and using the specified controller."	| scanner width w inset breadth height |	scanner _ FastTextDisplayScanner new.	width _ 0.	labels do: 		[:each | 		w _ scanner widthOfString: each emphasis: 1.		w > width ifTrue: [width _ w]].	width _ width + 10.	inset _ 5.	breadth _ boundingBox extent x - (inset * 2) // width.	height _ boundingBox extent y - (inset * 2).	1 to: labels size do: [:i | self add: ((((elementClass isKindOf: SequenceableCollection)				ifTrue: [Smalltalk at: (elementClass at: i)]				ifFalse: [elementClass]) named: (labels at: i))					label: (labels at: i);					message: (messages at: i);					bordered: true;					enabled: true;					targetController: targetController;					box: ((i - 1 \\ breadth * width + inset @ (i - 1 // breadth * height + inset) extent: width + 1 @ (height + 1))					translateBy: boundingBox origin))]! !!FormsModel methodsFor: 'fileIn/Out'!codeOn: aStream 	| values |	aStream nextPutAll: '	"Create the model to hold the various elements"'; cr.	aStream nextPutAll: '	model _ FormsModel named: ', name printString, (String with: $.).	aStream cr.	elements do: 		[:each | 		each codeOn: aStream.		aStream nextPutAll: '			yourself).'.		aStream cr]!readFrom: aStream 	| cr valuesSize |	name _ aStream next: aStream nextWord.	valuesSize _ aStream nextWord.	elements _ SortedCollection new: valuesSize.	elements sortBlock: SortBlock.	elemNames _ OopConservingDictionary new: valuesSize.	valuesSize timesRepeat:		[self add: ((Smalltalk at: (aStream next: aStream nextWord) asSymbol) new						readFrom: aStream)]!save	|  file theSuitcase |	elements size < 1 ifTrue: [^self booboo: 'This form is empty and cannot be saved'].	theSuitcase _ elements first controller view topView suitcase.	Cursor write showWhile: [	theSuitcase accept.	file _ (MixedFileStream fileNamed: theSuitcase dataItem filename) readWriteShorten.	file writeHeaderFor: theSuitcase dataItem.	self storeOn: file.	file close].	(Smalltalk includesKey: #Auditor) ifTrue:		[Auditor add: 'Saved the Form Values Named: ', name]!saveQueriesWithFormOn: fileName	| aStream theSize |	Cursor write showWhile: [	aStream _ (MixedFileStream  fileNamed: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) readWriteShorten.	"read in the queries and report formats"	aStream next.	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	"save the new entry form"	self storeOn: aStream.	aStream close]!storeOn: aStream 	| values |	aStream nextWordPut: name size.	aStream nextPutAll: name.	aStream nextWordPut: elements size.	elements do: 		[:each | 		aStream nextWordPut: each class name size.		aStream nextPutAll: each class name.		each storeOn: aStream]! !!FormsModel methodsFor: 'private'!updateControllers: aController 	elements do: [:element | element controller: aController]! !DatabaseFormsModel comment:'Copyright (c) 1987 Xerox Corporation.  All rights reserved.'!!DatabaseFormsModel methodsFor: 'fileIn/Out'!save	| aStream theSize fileName |	fileName _ elements first controller view topView suitcase spare at: 1.	Cursor write showWhile: [	aStream _ (MixedFileStream  fileNamed: fileName , (DataMaster giveMe: #specialSuffixString for: #database asString)) readWriteShorten.	"read in the queries and report formats"	aStream size = 0		ifTrue:			[aStream nextPut: $F.			aStream nextWordPut: 0.			aStream nextWordPut: 0]		ifFalse:			[aStream next.			theSize _ aStream nextWord.			theSize timesRepeat: [aStream skip: aStream nextWord].			theSize _ aStream nextWord.			theSize timesRepeat: [aStream skip: aStream nextWord]].	"save the new entry form"	self storeOn: aStream.	aStream close]! !DataBase comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!DataBase methodsFor: 'initialize-release'!initialize: aFileName 	"Initialize the database with its new file"	self setFile: aFileName.	queryList _ OrderedCollection new.	queryListIndex _ 0.	reportList _ OrderedCollection new.	reportListIndex _ 0.	recordList _ OrderedCollection new.	self readQueries!release	self closeFile.	file release.	self nilFields!setFile: aFileName 	"Point the database at its new file"	fileName _ aFileName.	file _ ClassifiedFixedFileStream fileNamed: aFileName.	hitList _ OrderedCollection new.	hitListIndex _ 0.	fieldList _ file fieldNames.	fieldListIndex _ 0.! !!DataBase methodsFor: 'accessing'!file	^file!selectedField	"return the field to be displayed in the hit list"	fieldListIndex = 0 ifTrue: [^fieldList at: 1].	^fieldList at: fieldListIndex!selectedFieldIndex	"return the field to be displayed in the hit list"	fieldListIndex = 0 ifTrue: [^1].	^fieldListIndex!selectedQuery	"return the selected query or create an ad hoc query if none is selected"	queryListIndex = 0 ifTrue: [^Querier			request: 'Enter your query:          '			withFields: file fieldNames			types: file fieldTypes].	^queryList at: queryListIndex!selectedRecordClassification	hitListIndex = 0 ifTrue:[^Classification new].	^(file classificationOfRecord: (recordList at: hitListIndex))!selectedRecordNumber	"return the number of the selected record or a zero of none is selected"	hitListIndex = 0 ifTrue: [^0].	^recordList at: hitListIndex!selectedReport	"return the selected report or create an ad hoc report if none is selected"	reportListIndex = 0 ifTrue: [^SimpleQuerier request: 'Enter your report:          ' withFields: fieldList , #(classification )].	^reportList at: reportListIndex! !!DataBase methodsFor: 'manage - communications'!classView	^topView subViews at: 3!fieldView	^topView subViews at: 1!hitView	^topView subViews at: 2!queryView	^topView subViews at: 5!reportView	^topView subViews at: 6!textView	^topView subViews at: 4!topView: aView	topView _ aView! !!DataBase methodsFor: 'manage - contents'!blankContents	| theRecord |	contents _ Array with: fieldList with: (OrderedCollection new: fieldList size).	fieldList do: [:each | contents last add: ((String new: (file fieldLengthOf: each))				atAllPut: $ )]!checkContents	"See whether any numeric fields have non-numeric values. 	Return <nil> if all is OK, otherwise return an Array with the bad field 	number and 	an error message."	| signal |	signal _ Signal new.	1 to: contents first size do: 		[:i | 		(file fieldTypes at: i) = #number 			ifTrue: [(contents last at: i) isNumeric ifFalse: [^Array with: i with: 'Invalid Number']].		(file fieldTypes at: i) = #date 			ifTrue: [signal do: [Date readFrom: (contents last at: i)]				handle: [^Array with: i with: 'Invalid Date Format']].		(file fieldTypes at: i) = #time 			ifTrue: [signal do: [Time readFrom: (contents last at: i)]				handle: [^Array with: i with: 'Invalid Time Format']]].	^nil!clearContents	contents _ nil!contents	^contents!contents: anObject	contents _ anObject!lock!parseContents	"create a dictionary for adding or replacing records from the contents in the center pane."	| theDictionary length value |	theDictionary _ OopConservingDictionary new.	1 to: contents first size do:		[ :i |		length _ file fieldLengths at: i.		value _ contents last at: i.		value class == String ifFalse: [value _ value printString].		value size ~= length ifTrue:			[value _				(value size > length					ifTrue: [value copyFrom: 1 to: length]    "truncate"					ifFalse: [value, (String new: length - value size withAll: Character space)])].    "pad"		theDictionary				at: (fieldList at: i)				put: value]. 	^theDictionary!setContents	| theRecord | 	contents _ nil.	hitListIndex = 0 ifFalse:[theRecord _ file record: (recordList at: hitListIndex).		contents _ Array with: fieldList with: (OrderedCollection new: fieldList size).		fieldList do: [:each | contents last add: (file fieldFromThisRecord: each)]].!unlock! !!DataBase methodsFor: 'manage - field list'!fieldList	^fieldList!fieldList: aCollection	fieldList _ aCollection!fieldListIndex	^(fieldListIndex = 0 ifTrue: [fieldListIndex _ 1] ifFalse: [fieldListIndex])!fieldListIndex: anInteger	fieldListIndex _ anInteger! !!DataBase methodsFor: 'manage - hit list'!addExecuteButtonsTo: aFormModel"add the record control buttons to this form"	aFormModel add: ((ExecuteElement named: 'edit')		box: (10@10 corner: 140@30);		label: (Text string: 'overwrite record' runs: (RunArray runs: #(16 ) values: #(2 )));		initialValue: #editDatabaseRecord;		bordered: true;		alignment: #centered;		yourself).	aFormModel add: ((ExecuteElement named: 'add')		box: (160@10 corner: 240@30);		label: (Text string: 'add record' runs: (RunArray runs: #(10 ) values: #(2 )));		initialValue: #addDatabaseRecord;		bordered: true;		alignment: #centered;		yourself).	aFormModel add: ((ExecuteElement named: 'reset')		box: (260@10 corner: 350@30);		label: (Text string: 'reset record' runs: (RunArray runs: #(12 ) values: #(2 )));		initialValue: #getDatabaseRecord;		bordered: true;		alignment: #centered;		yourself)!clearHitList	"clear contents and hit list"	contents _ nil.	hitList _ OrderedCollection new.	recordList _ OrderedCollection new.	hitListIndex _ 0!hitList	^hitList!hitList: aCollection	hitList _ aCollection!hitListIndex	^hitListIndex!hitListIndex: anInteger	hitListIndex _ anInteger!inverseSortList	"sort the present hit list"	| sortedList |	sortedList _ (SortedCollection new: recordList size) sortBlock: [:x :y | (x at: 1) > (y at: 1)].	1 to: recordList size do: [:i | sortedList add: (Array with: (hitList at: i) with: (recordList at: i))].	hitList _ OrderedCollection new.	recordList _ OrderedCollection new.	sortedList do: 		[:each | 		hitList add: (each at: 1).		recordList add: (each at: 2)]!showRecordForm"display the selected record in a form window"	| aFormsModel textHeight height topY theDict labelSize valueStart fieldValue lines theSuitcase title mySize speedy |	title _ 'Record from ', topView suitcase dataItem label.	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: DatabaseFormsModel)			and: [(each view suitcase spare at: 2)  = (recordList at: hitListIndex) and: [(each view label)  = title]]].	aFormsModel _ self getEntryForm.	aFormsModel == nil ifFalse: [self showSavedEntryForm: aFormsModel].	speedy _ FastTextDisplayScanner new.	aFormsModel _ DatabaseFormsModel named: 'DatabaseEntryForm'.	textHeight _ 25.	height _ 15.	topY _ 40. 	self addExecuteButtonsTo: aFormsModel.	labelSize _0.	1 to: fieldList size do: [:each| mySize _ speedy widthOfString: (fieldList at: each) emphasis: 1.		mySize > labelSize ifTrue: [labelSize _ mySize]].	labelSize _ labelSize + 6.	valueStart _ labelSize + 15. 	1 to: fieldList size do: [:each |		aFormsModel add:		((LabelElement named: each printString )			box: (10@topY corner: (labelSize + 10) @(topY + height));			label: ((fieldList at: each) printString asText);			bordered: false;			alignment: #rightFlush;			yourself).		fieldValue _ (contents at: 2) at: each.		lines _ ((fieldValue size // 40) + 1) min: 5.		aFormsModel add:		((FillElement named: (fieldList at: each))			box: (valueStart@topY corner: (valueStart + 300)@(topY + (textHeight * lines)));			initialValue: ((fieldValue isKindOf: String) ifTrue:[fieldValue stripLeadingAndTrailingSpaces] ifFalse:[fieldValue printString]) asText;			yourself). 	topY _ topY + (textHeight * lines) + 5.].	theSuitcase _ (Suitcase new packTheSuitcaseFrom: nil forItem: ((DataItem type: #Item label: title atIndex: 0) + self textView controller classification)).	theSuitcase spare: (Array with: fileName with:  (recordList at: hitListIndex)).	DatabaseFormsModel openOn: aFormsModel label: title suitcase: theSuitcase!showSavedEntryForm: aFormsModel"display the selected record in the saved entry form window"	| fieldValue newValue theSuitcase title theElement | 	title _ 'Record from ', topView suitcase dataItem label. 	1 to: fieldList size do: [:each |		fieldValue _ (contents at: 2) at: each.		newValue _ ((fieldValue isKindOf: String)			ifTrue:[fieldValue stripLeadingAndTrailingSpaces]			ifFalse:[fieldValue printString]) asText.		theElement _ aFormsModel elementNamed: (fieldList at: each) printString.		theElement == nil ifFalse: [theElement initialValue: newValue]].	theSuitcase _ (Suitcase new packTheSuitcaseFrom: nil forItem: ((DataItem type: #Item label: title atIndex: 0) + self textView controller classification)).	theSuitcase spare: (Array with: fileName with:  (recordList at: hitListIndex)).	DatabaseFormsModel openOn: aFormsModel label: title suitcase: theSuitcase!sortList	"sort the present hit list"	| sortedList |	sortedList _ (SortedCollection new: recordList size) sortBlock: [:x :y | (x at: 1) <= (y at: 1)].	1 to: recordList size do: [:i | sortedList add: (Array with: (hitList at: i) with: (recordList at: i))].	hitList _ OrderedCollection new.	recordList _ OrderedCollection new.	sortedList do: 		[:each | 		hitList add: (each at: 1).		recordList add: (each at: 2)]! !!DataBase methodsFor: 'manage - query list'!dumpEntryForm	| aStream theSize |	(Disk includesKey: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) ifFalse: [^nil].	aStream _ (MixedFileStream fileNamed: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) readWriteShorten.	aStream next. " skip the F that is is the front of this file as a format id"	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	aStream close!getEntryForm	| aStream aFormModel theSize |	(Disk includesKey: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) ifFalse: [^nil].	aFormModel _ nil.	aStream _ (MixedFileStream fileNamed: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) readOnly.	aStream next. " skip the F that is is the front of this file as a format id"	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	aStream atEnd		ifTrue: [^nil]		ifFalse: [aFormModel _ DatabaseFormsModel fromStream: aStream.				aStream close.				^aFormModel]!getSavedEntryForm	| aStream aFormModel theSize formStream leftOver |	(Disk includesKey: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) ifFalse: [^nil].	aFormModel _ nil.	aStream _ (MixedFileStream fileNamed: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) readOnly.	aStream next. " skip the F that is is the front of this file as a format id"	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	theSize _ aStream nextWord.	theSize timesRepeat: [aStream skip: aStream nextWord].	aStream atEnd		ifTrue: [^nil]		ifFalse: [formStream _ ReadWriteStream on: String new.			leftOver _ aStream size - aStream position.			[leftOver > 4096] whileTrue:			[formStream nextPutAll: (aStream next: 4096).			leftOver _ leftOver - 4096].			formStream nextPutAll: (aStream next: leftOver).			aStream close.			^formStream]!queryList	^queryList!queryList: aCollection	queryList _ aCollection!queryListIndex	^queryListIndex!queryListIndex: anInteger	queryListIndex _ anInteger!readNewQueries: aStream	| theSize | 	Cursor read showWhile: [	theSize _ aStream nextWord.	theSize timesRepeat: [queryList add: (aStream next: aStream nextWord)].	theSize _ aStream nextWord.	theSize timesRepeat: [reportList add: (aStream next: aStream nextWord)]]!readOldQueries: aStream	| theKey |	Cursor read showWhile: [		[aStream atEnd] whileFalse: 			[theKey _ aStream next.			theKey = $Q 				ifTrue: [queryList add: (aStream upTo: Character cr)]				ifFalse: 					[theKey = $R						ifTrue: [reportList add: (aStream upTo: Character cr)]]].		aStream reset; readWrite.		aStream nextPut: $F.		aStream nextWordPut: queryList size.		queryList do: [:aQuery | aStream nextWordPut: aQuery size. aStream nextPutAll: aQuery].		aStream nextWordPut: reportList size.		reportList do: [:aReport |  aStream nextWordPut: aReport size. aStream nextPutAll: aReport].		aStream close]!readQueries	| aStream |	(Disk includesKey: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) ifFalse: [^self].	aStream _ (MixedFileStream fileNamed: fileName, (DataMaster giveMe: #specialSuffixString for: #database asString)) readOnly.	(aStream atEnd not and: [aStream next = $F])		ifTrue: [self readNewQueries: aStream]		ifFalse: [aStream reset.			self readOldQueries: aStream].	aStream close!saveQueries	| aStream aFormModel | 	Cursor write showWhile:[		aFormModel _ self getSavedEntryForm.		aStream _ (MixedFileStream fileNamed: (fileName, (DataMaster giveMe: #specialSuffixString for: #database asString))) writeShorten.		aStream nextPut: $F.		aStream nextWordPut: queryList size.		queryList do: [:aQuery | aStream nextWordPut: aQuery size. aStream nextPutAll: aQuery].		aStream nextWordPut: reportList size.		reportList do: [:aReport |  aStream nextWordPut: aReport size. aStream nextPutAll: aReport].		aFormModel == nil ifFalse: [aStream nextPutAll: aFormModel contents].		aStream close].	^true! !!DataBase methodsFor: 'manage - record list'!lastRecordList	^lastRecordList!lastRecordList: aCollection	^lastRecordList _ aCollection!recordList	^recordList!recordList: aCollection	recordList _ aCollection! !!DataBase methodsFor: 'manage - report list'!reportList	^reportList!reportList: aCollection	reportList _ aCollection!reportListIndex	^reportListIndex!reportListIndex: anInteger	reportListIndex _ anInteger! !!DataBase methodsFor: 'classification'!classify: aClassification	file classifyRecord: (recordList at: hitListIndex) with: aClassification! !!DataBase methodsFor: 'file manipulation'!addNewField	"add a new field to the dataBase, by creating an entire new file with the 	newly specified field"	| newName theFieldNames theFieldLengths theFieldTypes answers theNewFieldName theNewFieldLength theNewFieldType newFile theOldRecord aggregateClassification |	newName _ 'CNVRTXXX.DB'.	theFieldNames _ file fieldNames.	theFieldLengths _ file fieldLengths.	theFieldTypes _ file fieldTypes.	answers _ self fieldDBox.	answers = nil ifTrue: [^false].	theNewFieldName _ answers at: 1.	theNewFieldLength _ answers at: 2.	theNewFieldType _ answers at: 3.	theNewFieldType = #date & (theNewFieldLength < 18)		ifTrue: 			[self booboo: 'Minimum date field length is 18.Field length is now 18.'.			theNewFieldLength _ 18].	theNewFieldType = #time & (theNewFieldLength < 12)		ifTrue: 			[self booboo: 'Minimum time field length is 12.Field length is now 12.'.			theNewFieldLength _ 12].	theFieldNames add: theNewFieldName.	theFieldLengths add: theNewFieldLength.	theFieldTypes add: theNewFieldType.	ClassifiedFixedFileStream		newOn: newName		withHeaderFor: topView suitcase dataItem		withFieldNames: theFieldNames		fieldLengths: theFieldLengths		fieldTypes: theFieldTypes.	aggregateClassification _ Classification new.	newFile _ ClassifiedFixedFileStream fileNamed: newName.	file setToRecordBegin.	1 to: file numberOfRecords do: 		[:each | 		theOldRecord _ file nextRecord.		(theOldRecord at: 1) = $* ifFalse:			[aggregateClassification _ aggregateClassification + file classificationFromThisRecord.			newFile addRecord: (theOldRecord copyFrom: 2 to: theOldRecord size)]].	newFile classification: aggregateClassification.	newFile close.	file close.	Disk removeKey: fileName ifAbsent: [].	Disk renameKey: newName newName: fileName.	self setFile: fileName.	self updateClassification!changeFieldLength	"change the length of the current selected field"	| newName theFieldNames theFieldLengths theFieldTypes theOldFieldName theOldFieldLength theNewFieldLength theNewFileStream theNewContents theOldRecord oldData newData oldFieldIndex aggregateClassification |	newName _ 'CNVRTXXX.DB'.	theFieldNames _ file fieldNames.	theFieldLengths _ file fieldLengths.	theFieldTypes _ file fieldTypes.	oldFieldIndex _ fieldListIndex.	theOldFieldName _ theFieldNames at: fieldListIndex.	theOldFieldLength _ theFieldLengths at: fieldListIndex.	theNewFieldLength _ (FillInTheBlank request: 'New field length?' default: theOldFieldLength printString) asNumber.	Cursor wait showWhile: [	theFieldLengths at: fieldListIndex put: theNewFieldLength.	ClassifiedFixedFileStream		newOn: newName		withHeaderFor: topView suitcase dataItem		withFieldNames: theFieldNames		fieldLengths: theFieldLengths		fieldTypes: theFieldTypes.	aggregateClassification _ Classification new.	theNewFileStream _ ClassifiedFixedFileStream fileNamed: newName.	file setToRecordBegin.	1 to: file numberOfRecords do: 		[:each | 		theNewContents _ OopConservingDictionary new.		theOldRecord _ file nextRecord.		(theOldRecord at: 1) = $* ifFalse: 			[file fields keys do: 				[:field | 				oldData _ file returnField: field.				field = theOldFieldName					ifTrue: 						[newData _ String new: theNewFieldLength withAll: $ .						1 to: (theNewFieldLength min: oldData size)							do: [:eachCharacter | newData at: eachCharacter put: (oldData at: eachCharacter)]]					ifFalse: [newData _ oldData].				theNewContents at: field put: newData].			theNewFileStream constructRecordFrom: theNewContents.			theNewFileStream classifyRecord: each with: file classificationFromThisRecord]].	theNewFileStream close.	file close.	Disk removeKey: fileName ifAbsent: [].	Disk renameKey: newName newName: fileName.	self setFile: fileName.	self updateClassification.	fieldListIndex _ oldFieldIndex]!cloneDataBase: dataItem	"make a new DataBase dataItem containing all the records currently in the hit list whose classification is <= to that of dataItem"	| aggClassification theNewFileStream theRecord |	ClassifiedFixedFileStream		newOn: dataItem filename		withHeaderFor: dataItem		withFieldNames: file fieldNames		fieldLengths: file fieldLengths		fieldTypes: file fieldTypes.	aggClassification _ Classification new.	theNewFileStream _ ClassifiedFixedFileStream fileNamed: dataItem filename.	recordList do: [:each |		theRecord _ file record: each.		((theRecord at: 1) ~= $* and: [dataItem contains: file classificationFromThisRecord]) ifTrue:			[aggClassification _ aggClassification + file classificationFromThisRecord.			theNewFileStream dumpRecord: theRecord]].	theNewFileStream classification: aggClassification.	dataItem class: aggClassification classification modifiers: aggClassification modifiers.	theNewFileStream close!closeAllSpawnedRecords	"if any kind of compression of the database is going to take place, all spawned record forms must be closed"	DataMaster findTheOneByEvaluating:		[:each |		((each model isKindOf: DatabaseFormsModel) and: [(each view suitcase spare at: 1) = fileName])			ifTrue: [self booboo: 'Spawned records must be closed before doing this procedure'. true]			ifFalse: [false]]!closeFile	"the window is closing so close the database file"	file setToEnd; close!compressDatabase			file compress.	"attach to new file"	file _ ClassifiedFixedFileStream fileNamed: fileName.	self clearHitList.	self updateClassification!deleteField	| newName theFieldNames theFieldLengths theFieldTypes start stop theNewFileStream theOldRecord tempHitList aggregateClassification | 	"add a new field to the dataBase, by creating an entire new file with the  	newly specified field"	newName _ 'CNVRTXXX.DB'.	theFieldNames _ file fieldNames.	theFieldLengths _ file fieldLengths.	theFieldTypes _ file fieldTypes.	start _ (file beginningOfField: (file fieldNames at: fieldListIndex)) - 1.	stop _ (file endOfField: (file fieldNames at: fieldListIndex))- 1.	theFieldNames removeObjectAt: fieldListIndex.	theFieldLengths removeObjectAt: fieldListIndex.	theFieldTypes removeObjectAt: fieldListIndex.	ClassifiedFixedFileStream		newOn: newName		withHeaderFor: topView suitcase dataItem		withFieldNames: theFieldNames		fieldLengths: theFieldLengths		fieldTypes: theFieldTypes.	aggregateClassification _ Classification new.	theNewFileStream _ ClassifiedFixedFileStream fileNamed: newName.	fieldList size = 0 ifFalse:		[file setToRecordBegin.		1 to: file numberOfRecords do: 			[:each | 			theOldRecord _ file nextRecord.			(theOldRecord at: 1) = $* ifFalse:				[aggregateClassification _ aggregateClassification + file classificationFromThisRecord.			theNewFileStream addRecord: (theOldRecord copyFrom: 2 to: start), (theOldRecord copyFrom: stop to: theOldRecord size)]]].	theNewFileStream classification: aggregateClassification.	theNewFileStream close.	file close.	Disk removeKey: fileName ifAbsent: [].	Disk renameKey: newName newName: fileName.	self setFile: fileName.	self updateClassification!deleteRecord	"delete the selected record"	file deleteRecord: (recordList at: hitListIndex).	recordList remove: (recordList at: hitListIndex).	hitList remove: (hitList at: hitListIndex).	hitListIndex > hitList size ifTrue:[hitListIndex _ hitList size].!renameField	"rename a field in the dataBase, by creating an entire new file with the changed field name"	| newName theFieldNames theNewFieldName theNewFileStream theRecord aggregateClassification oldFieldIndex | 	newName _ 'CNVRTXXX.DB'.	theFieldNames _ file fieldNames copy.	theNewFieldName _ self checkForSpaces:(FillInTheBlank request: 'New field name?' default: (theFieldNames at:fieldListIndex) asString).	theFieldNames at: fieldListIndex  put: theNewFieldName.	oldFieldIndex _ fieldListIndex.	Cursor wait showWhile: [	ClassifiedFixedFileStream		newOn: newName		withHeaderFor: topView suitcase dataItem		withFieldNames: theFieldNames		fieldLengths: file fieldLengths		fieldTypes: file fieldTypes.	aggregateClassification _ Classification new.	theNewFileStream _ ClassifiedFixedFileStream fileNamed: newName.	file setToRecordBegin.	1 to: file numberOfRecords do: [:each |		theRecord _ file nextRecord.		(theRecord at: 1) = $* ifFalse:			[aggregateClassification _ aggregateClassification + file classificationFromThisRecord.			theNewFileStream dumpRecord: theRecord]].	theNewFileStream classification: aggregateClassification.	theNewFileStream close.	file close.	Disk removeKey: fileName ifAbsent: [].	Disk renameKey: newName newName: fileName.	self setFile: fileName.	self updateClassification.	fieldListIndex _ oldFieldIndex]!undeleteRecord	"undelete the selected record"	file undeleteRecord: (recordList at: hitListIndex)! !!DataBase methodsFor: 'querying'!getAllRecords	| specifier theList | 	"Answer the list for the hits in the db"	fieldList size = 0 ifTrue: [^false].	theList _ file 		field: self selectedField		vs: nil		recordNumbers: true		fitting: true		sorted: false		from: nil.	hitList _ theList at: 1.	lastRecordList _ recordList.	recordList _ theList at: 2.	^true!getDeletedRecords	"get all of the deleted records in the database"	| tempRecordList theOldRecord tempHitList | 	fieldList size = 0 ifTrue: [^nil].	tempRecordList _ OrderedCollection new.	file setToRecordBegin.	1 to: file numberOfRecords do: 		[:each | 		theOldRecord _ file nextRecord.		(theOldRecord at: 1) = $* ifTrue: [tempRecordList add: each]].	lastRecordList _ recordList.	recordList _ tempRecordList.	tempHitList _ OrderedCollection new.	recordList do: [:eachRecord | tempHitList add: (file record: eachRecord field: self selectedField)].	hitList _ tempHitList.	hitListIndex _ 0!getFieldFromPresentList	| specifier theList | 	"Answer the list for the hits in the db"	theList _ file 		field: self selectedField		vs: nil		recordNumbers: true		fitting: true		sorted: false		from: self recordList.	hitList _ theList at: 1.	recordList _ theList at: 2.!getFromPastList	| specifier theList | 	"Answer the list for the hits in the db"	theList _ file 		field: self selectedField		vs: nil		recordNumbers: true		fitting: true		sorted: false		from: self lastRecordList.	hitList _ theList at: 1.	lastRecordList _ recordList.	recordList _ theList at: 2.!queryDatabase	| specifier theList | 	"Answer the list for the hits in the db"	specifier _ FixedFileFilter on: self selectedQuery.	specifier isEmpty ifTrue: [^false].	theList _ file 		field: self selectedField		vs: specifier		recordNumbers: true		fitting: true		sorted: false		from: nil.	hitList _ theList at: 1.	lastRecordList _ recordList.	recordList _ theList at: 2.	^true!queryDatabaseAgainstPresentList	| specifier theList | 	"Answer the list for the hits in the db"	specifier _ FixedFileFilter on: self selectedQuery.	specifier isEmpty ifTrue: [^false].	theList _ file 		field: self selectedField		vs: specifier		recordNumbers: true		fitting: true		sorted: false		from: self recordList.	hitList _ theList at: 1.	lastRecordList _ recordList.	recordList _ theList at: 2.	^true!queryDatabaseAgainstPresentListFrom: queryString	| specifier theList | 	"Answer the list for the hits in the db"	specifier _ FixedFileFilter on: queryString.	Cursor wait showWhile: [theList _ file 		field: self selectedField		vs: specifier		recordNumbers: true		fitting: true		sorted: false		from: self recordList].	hitList _ theList at: 1.	lastRecordList _ recordList.	recordList _ theList at: 2.! !!DataBase methodsFor: 'reporting'!report: dataItem update: aSuitcase	| maxClass theFieldCollection reportStringHolder inStream aTables text theNewFile runs theRecord s t | 	"produce a simple report"	maxClass _ Classification fromUser: dataItem title: 'Maximum Classification Level?'.	maxClass == nil ifTrue: [^false].		dataItem = maxClass ifFalse: [dataItem class: maxClass classification modifiers: maxClass modifiers].	theFieldCollection _ OrderedCollection new.	reportStringHolder _ self selectedReport.	inStream _ ReadStream on: reportStringHolder.	[inStream atEnd]		whileFalse: [theFieldCollection add: (inStream upTo: Character space) asSymbol].	aTables _ Tables new.	aTables widthArray: (Array new: theFieldCollection size).	(aTables widthInquiry: (self collectionFrom: reportStringHolder)) == nil ifTrue: [^false].	Cursor wait show.	aTables delimiter: Character space.	text _ aTables parse: reportStringHolder.	theNewFile _ (HeaderFileStream fileNamed: dataItem filename) writeShorten.	theNewFile writeHeaderFor: dataItem.	theNewFile nextPutAll: text string.	runs _ text runs.	aTables delimiter: Character cr.	recordList do: 		[:i | 		theRecord _ file record: i.		(maxClass contains: file classificationFromThisRecord)			ifTrue: 				[s _ WriteStream with: String new.				theFieldCollection do: 					[:field | 					contents _ file fieldFromThisRecord: field.					contents class == String ifFalse: [contents class == Classification							ifTrue: [contents _ contents displayString]							ifFalse: [contents _ contents printString]].					(t _ self stripSpaces: contents) = String new ifTrue: [t _ ' '].					s nextPutAll: t; nextPut: Character cr].				text _ aTables parse: s contents.				theNewFile nextPutAll: text string.				runs _ runs , text runs]].	theNewFile nextPut: (Character value: 255); nextPut: Character cr.	runs storeOn: theNewFile.	theNewFile close.	aSuitcase == nil ifFalse: [aSuitcase spare: aTables tabsArray].	Cursor normal show.	^true! !!DataBase methodsFor: 'private'!checkForSpaces: aString 	"this will take spaces out in a field name"	1 to: aString size do: [:each | (aString at: each)			= $  ifTrue: [aString at: each put: $-]].	^aString!collectionFrom: aString	"this routine will strip off trailing spaces from either a string or a collection of strings"	| index col start stop |	aString == nil ifTrue: [^nil].	col _ OrderedCollection new.	stop _ aString size.	start _ 1.	index _ 1.	[index <= stop]		whileTrue: [(aString at: index) = Character space						ifTrue: [col add: (Array with: (aString copyFrom: start to: index - 1)). start _ index + 1].					index _ index + 1].	col add: (Array with: (aString copyFrom: start to: stop)).	^col!doItContext	^nil!doItReceiver	^nil!fieldDBox	| answer return |	answer _ DBoxView				openFor: #(fill fill select )				title: 'Field Entry'				labels: (#(('Field Name' ) ('Field Length' ) (Type string number date time)))				defaults: (#('FieldName' '10' string )).	answer = nil ifTrue: [^answer].	return _ OrderedCollection new.	(answer at: 1) = String new ifTrue: [^nil]. 	(answer at: 2) asNumber = 0 ifTrue: [^nil].	return add: (self checkForSpaces: (answer at: 1)); add: (answer at: 2) asNumber; add: (answer at: 3).	^return!isUnlocked	^true!stripSpaces: aStringCollection	"this routine will strip off trailing spaces from either a string or a collection of strings"	| index eachString |	aStringCollection = nil ifTrue: [^self].	((aStringCollection isKindOf: String) or: [(aStringCollection isKindOf: Collection) not])		ifTrue: 			[eachString _ aStringCollection.			eachString class == String ifFalse: [eachString _ eachString printString].			index _ eachString size.			[(index > 0 and: [((eachString at: index) = Character space)])]				whileTrue: [index _ index - 1].			^eachString copyFrom: 1 to: index]		ifFalse: 			[1 to: (aStringCollection size) do: 				[:each | eachString _ aStringCollection at: each.				eachString class == String ifFalse: [eachString _ eachString printString].				index _ eachString size.				[index > 0 & ((eachString at: index) = Character space)]					whileTrue: [index _ index - 1].				eachString _ eachString copyFrom: 1 to: index. 				aStringCollection at: each put: eachString].			^aStringCollection]!updateClassification	| theClass | 	Cursor wait showWhile: [	theClass _ file classification.	topView suitcase classification: theClass.	topView suitcase accept.	topView classifyLabel: (theClass = Classification new ifTrue: [nil] ifFalse: [theClass])].	topView displayClassification! !!Encoder methodsFor: 'undeclared variables'!undeclared: name	| message messageLoc messageBox saveBits menu index |	Cursor normal show.	requestor selectVariable: name.	index _ (menu _ ActionMenu			labels:'temp{Declare as a temporary variable of the method.}class var{Declare as a class variable.}global{Declare as a global variable.}undeclared{Declare as an Undeclared variable.}correct it{Attempt to fix spelling.}abort{Abort compilation -- you fix it.}'			lines: #(4)			selectors: #(declareTemp: declareClassVar: declareGlobal: declareUndeclared: declareCorrect: declareFailed:))				startUp: #anyButton				withHeading: ' declare ' asText , (name contractTo: 20) asText allBold , ' as ' asText.	index = 0 ifTrue: [^ self declareFailed: name].	^ self perform: (menu selectorAt: index) with: name! !!RemoteString methodsFor: 'accessing'!string	"Answer the receiver's string if remote files are enabled."	| theFile |	(SourceFiles == nil or: [sourceFileNumber == nil]) ifTrue: [^String new].	theFile _ SourceFiles at: sourceFileNumber.	theFile == nil ifTrue: [^nil].	theFile position:		(sourceFileNumber < MinFileIndexQuadWordAligned			ifTrue: [(filePositionHi bitShift: 8) + filePositionLo.]			ifFalse: [(filePositionHi bitShift: 11) + (filePositionLo bitShift: 3).]		).	^theFile nextChunk! !!RemoteString methodsFor: 'private'!string: aString onFileNumber: anInteger toFile: aFileStream 	"Store this as the receiver's string if source files exist."	| pd pn |	pd _ 0.	pn _ aFileStream position.	(sourceFileNumber _ anInteger) == nil ifFalse:		[anInteger < MinFileIndexQuadWordAligned ifFalse:			[pd _ 7 - (pn - 1 \\ 8).			pn _ pn + pd bitShift: -3.			].		].	aFileStream nextPutAll: (String new: pd withAll: Character cr).	filePositionHi _ pn bitShift: -8.	filePositionLo _ pn bitAnd: 255.	aFileStream nextChunkPut: aString.! !!ChangeSet methodsFor: 'private'!fileOutClassChanges: class on: stream 	"Write out class changes.  i.e.  new class, definition, comment, renaming."	(self atClass: class includes: #add) ifTrue:		[stream cr.		class fileOutOn: stream.		stream cr.		^self atClass: class add: #add  "fileOut clears this!!"].	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: (self oldNameFor: class), ' rename: #', class name; cr].	(self atClass: class includes: #change) ifTrue:		[class sharedPools do: [:pool | (pool isKindOf: Pool) ifTrue: [class printSharedPoolChunk: pool name on: stream]]. 		stream emphasis: 5; nextChunkPut: class definition; cr; emphasis: 1].	(self atClass: class includes: #comment) ifTrue:		[class organization putCommentOnFile: stream			numbered: nil moveSource: false.		stream cr].	(self atClass: class includes: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !DataControl comment:'Copyright (c) 1986, 1987 Xerox Corporation.  All rights reserved.'!!DataControl methodsFor: 'access'!fileTypes	^fileTypes!linkTypeFor: aSymbol 	^((linkTypes indexOf: aSymbol) max: 1)!linkTypes	^linkTypes!numberOfSystemLinkTypes	^linkTypes size! !!DataControl methodsFor: 'associated file handling'!changeAssociation: currentFileName in: painInTheNeckFile to: newFileName	"painInTheNeckFile must be a preview, report, or map at this point.  Change the reference to currentFileName everywhere in the appropriate file to newFileName"	| englishDataType fileToChange newStream readStream aChunk numberLeftToRead |	Cursor read showWhile: [	englishDataType _ self giveMe: #englishString for: painInTheNeckFile.	fileToChange _ painInTheNeckFile.	englishDataType = #preview ifFalse: [fileToChange _ painInTheNeckFile, (self giveMe: #specialSuffixString for: englishDataType)].	newStream _ (FileStream fileNamed: 'CNVRTXXX.TMP') writeShorten.	readStream _ (FileStream fileNamed: fileToChange) readOnly.	numberLeftToRead _ readStream size.	[numberLeftToRead > 0] whileTrue:		[aChunk _ readStream next: (numberLeftToRead min: 7000).		newStream nextPutAll: (aChunk copyReplaceAll: currentFileName with: newFileName).		numberLeftToRead _ numberLeftToRead - 7000].	newStream close.	readStream close.	Disk removeKey: fileToChange ifAbsent: [].	Disk renameKey: newStream name newName: fileToChange]!createPkgFileFor: aDataItem	"create a package format file from all the files associated with aDataItem, return a package data item for it"	| pkgFile allFiles fns fnLeft pkgDataItem |	pkgFile _ MixedFileStream fileNamed: (Disk makeNewFileName: aDataItem label withSuffix: (self giveMe: #suffixString for: #package asString)).	pkgFile writeShorten; binary.	pkgDataItem _ DataItem type: #Item label: aDataItem label filename: pkgFile name atIndex: 0.	pkgFile writeHeaderFor: pkgDataItem.	allFiles _ self getFileNamesFor: aDataItem filename extended: true.	(DataMaster giveMe: #symbol for: aDataItem filename) = #map ifTrue:		[(self confirm: 'Include map hints and data?') ifFalse:			[allFiles _ allFiles select: [:i | ((i findString: (self mapSuffixFor: #mapHints) startingAt: 1) = 0 and: [i findString: (self mapSuffixFor: #mapData) startingAt: 1 = 0])]]].	allFiles do:		[:fn |		pkgFile text.		fns _ (FileStream fileNamed: fn) readOnly binary.		pkgFile nextPut: ${; nextPutAll: fn; nextPut: $|; nextPut: $|; nextPutAll: (fnLeft _ fns size) printString; nextPut: Character cr.		pkgFile binary.		[fns atEnd] whileFalse:			[pkgFile nextPutAll: (fns next: (fnLeft min: 51200)).			fnLeft _ fnLeft - (fnLeft min: 51200)].		fns close].	pkgFile close.	^pkgDataItem!getBasicAssociatedFilesOfTypes: theDataTypes localDirectory: localDirectory	"theDataTypes is a collection of english strings.  Look through all the files on the disk which may reference one of these types, and return a list of the basic files that are referenced"	| associatedFiles filesToLookIn listUsing |	((theDataTypes includes: #image asString)		or: [(theDataTypes includes: #map asString)			or: [(theDataTypes includes: #chart asString)]]) ifFalse: [^Array new].	listUsing _ localDirectory size = 0			ifTrue: [[:p | self getDiskList: p]] "trim directory info"			ifFalse: [[:p | Disk filesMatching: p]]. "get and keep directory info"	associatedFiles _ Set new.	filesToLookIn _ self trimList: (listUsing value: localDirectory, (String with: $*), (self giveMe: #suffixString for: #preview asString), (String with: $*)) for: #preview.	filesToLookIn do: [:file | associatedFiles addAll: (self previewGetAssociatedFilesFor: file extended: false)].	(theDataTypes includes: #image asString) ifTrue:		[filesToLookIn _ self trimList: (listUsing value: localDirectory, (String with: $*), (self giveMe: #suffixString for: #report asString), (String with: $*)) for: #report.		filesToLookIn do: [:file | associatedFiles addAll: (self reportGetAssociatedFilesFor: file extended: false)]].	^associatedFiles!getDiskList: testPattern 	"The argument, aString, consists a file name pattern.  (Patterns include the character $*.) Make my new list be those files on my directory whose names match the pattern.  Pattern matching currently assumes local disk directory. "	| newList outList i ch |	newList _ OrderedCollection new.	outList _ OrderedCollection new.	Cursor read showWhile:	[(testPattern includes: $*)		ifTrue: [newList addAll: (Disk filesMatching: testPattern)]		ifFalse: [newList add: testPattern].	newList do: 		[:listItem |			i _ listItem size.			[i = 1 or: [(ch _ listItem at: i - 1) = $/ or: [ch = $>]]]				whileFalse: [i _ i - 1].			outList add: (listItem copyFrom: i to: listItem size)]].	^outList!getFileNamesFor: fileName extended: extended	"return a list of the all the files associated with fileName"	| fileType checkFor theBasicFiles specialSuffix |	fileType _ self giveMe: #englishString for: fileName.	theBasicFiles _ OrderedCollection new.	theBasicFiles add: fileName.	extended ifTrue:		[specialSuffix _ self giveMe: #specialSuffixString for: fileType.		specialSuffix == nil ifFalse: [theBasicFiles add: fileName, specialSuffix].		checkFor _ fileType, 'GetAssociatedFilesFor:extended:'.		(self respondsTo: checkFor asSymbol) ifTrue: [theBasicFiles addAll: (self perform: checkFor asSymbol with: fileName with: true)]].	^theBasicFiles!makeDataItemFor: aFileName	| fs dataItem class endLabel startLabel | 	fs _ (HeaderFileStream fileNamed: aFileName) readOnly.	dataItem _ (fs hasHeader		ifTrue:			[class _ fs classAndModsFromHeader.			DataItem locked: false classification: (class at: 1) modifiers: (class at: 2) type: #Item label: fs labelFromHeader filename: aFileName bPointers: nil fPointers: nil atIndex: 0]		ifFalse: "backwards compatibility"			[(endLabel _ (aFileName findLast: [:c | c = $.]) - 1) < 1 ifTrue: [endLabel _ aFileName size].			startLabel _ ((aFileName findLast: [:c | c = $>]) + 1) max: 1.			DataItem type: #Item label: (aFileName copyFrom: startLabel to: endLabel) filename: aFileName atIndex: 0]).	fs close.	^dataItem!mapGetAssociatedFilesFor: fileName extended: extended	"return a list of the all the extra files associated with the map file fileName"	| readStream baseName controlName |	extended ifFalse: [^Array new].	controlName _ fileName, (self giveMe: #specialSuffixString for: #map asString).	(Disk includesKey: controlName) ifFalse: [^Array new].	Cursor read showWhile: [	readStream _ (FileStream fileNamed: controlName) readOnly.	5 timesRepeat: [readStream skipTo: $ ].	baseName _ String readFrom: readStream.	readStream close].	^Array with: baseName, (self mapSuffixFor: #mapHints) with: baseName, (self mapSuffixFor: #mapData)!mapSuffixFor: aSymbol	"return the extra special suffix for map files according to aSymbol"	aSymbol == #map ifTrue: [^self giveMe: #suffixString for: #map asString].	aSymbol == #mapControl ifTrue: [^self giveMe: #specialSuffixString for: #map asString].	aSymbol == #mapHints ifTrue: [^'.mapHints'].	aSymbol == #mapData ifTrue: [^'.mapData'].	aSymbol == #mapList ifTrue: [^'.lis'].	^String new!moveToMainDirectory: theItem overwrite: overwrite	"this assumes theItem is connected to a file on some local disk sub-directory, and should be moved to the main (non-sub) directory along with all its associated files"	| fullFilename shortName suffixSymbol suffixString checkFor dirName assocItem anotherSuffix | 	fullFilename _ theItem filename.	shortName _ (FileDirectory decomposeName: fullFilename) at: 'Name-Body'.	suffixSymbol _ self giveMe: #symbol for: shortName.	suffixString _ self giveMe: #suffixString for: suffixSymbol.	overwrite ifFalse: "we're going to have to pick a new name"		[(self giveMe: #englishString for: suffixSymbol) = #preview			ifTrue: "hack the suffix to agree with the original"				[suffixString _ self previewSuffixFor: #portrait.				(shortName findString: suffixString startingAt: 1) = 0 ifTrue:					[suffixString _ self previewSuffixFor: #landscape]].		shortName _ ((self giveMe: #englishString for: suffixSymbol) = #spreadsheet			ifTrue: [theItem label, suffixString]			ifFalse: [Disk makeNewFileName: theItem label withSuffix: suffixString])].	checkFor _ (self giveMe: #englishString for: suffixSymbol), 'GetAssociatedFilesFor:extended:'.	(self respondsTo: checkFor asSymbol) ifTrue:		[dirName _ ((dirName _ fullFilename findLast: [:c | c = $>]) = 0				ifTrue: [String new]				ifFalse: [fullFilename copyFrom: 1 to: dirName]).		(self perform: checkFor asSymbol with: fullFilename with: true) do:			[:assocFile |			(Disk includesKey: dirName, assocFile) ifTrue:				[assocItem _ self makeDataItemFor: dirName, assocFile.				self moveToMainDirectory: assocItem overwrite: overwrite.				assocItem filename = assocFile ifFalse: [self changeAssociation: assocFile in: fullFilename to: assocItem filename]]]].	Disk removeKey: shortName ifAbsent: [].	Disk renameKey: fullFilename newName: shortName.	(anotherSuffix _ self giveMe: #specialSuffixString for: suffixSymbol) == nil			ifFalse:			[Disk removeKey: shortName, anotherSuffix ifAbsent: [].			Disk renameKey: fullFilename, anotherSuffix newName: shortName, anotherSuffix].	theItem filename: shortName!previewGetAssociatedFilesFor: fileName extended: extended	"return a list of the the extra files associated with the preview file fileName.  If extended is true, get all the files (not just the basic one) for the associated files, too"	| theBasicFiles readStream imageCount n |	theBasicFiles _ OrderedCollection new.	(Disk includesKey: fileName) ifFalse: [^theBasicFiles].	Cursor read showWhile: [	readStream _ (HeaderFileStream fileNamed: fileName) readOnly.	(n _ readStream peek) == nil ifFalse: [n isDigit ifFalse: [readStream next]]. "skip over any l or p that indicates the new format"	imageCount _ Number readNumberFrom: readStream.	imageCount = 0 ifFalse:		[readStream skipTo: Character cr.		1 to: imageCount do: [:each | theBasicFiles addAll: (self getFileNamesFor: (readStream upTo: Character cr) extended: extended)]].	readStream close].	^theBasicFiles!previewSuffixFor: aSymbol	"return the extra special suffix for preview files according to aSymbol"	aSymbol == #portrait ifTrue: [^'.pvp'].	aSymbol == #landscape ifTrue: [^'.pvl'].	aSymbol == #backupText ifTrue: [^'.txt$$'].	aSymbol == #preview ifTrue: [^self giveMe: #suffixString for: #preview asString].	aSymbol == #textFile ifTrue: [^self giveMe: #specialSuffixString for: #preview asString].	^String new!reportGetAssociatedFilesFor: fileName extended: extended	"return a list of the the extra files associated with the report file fileName"	| theBasicFiles suffixFileName readStream lisFile |	theBasicFiles _ OrderedCollection new.	lisFile _ fileName, (self giveMe: #specialSuffixString for: #report asString).	(Disk includesKey: lisFile) ifFalse: [^theBasicFiles].	Cursor read showWhile: [	readStream _ (FileStream fileNamed: lisFile) readOnly.	[readStream atEnd] whileFalse: 			[readStream skipTo: $*.			theBasicFiles add: (readStream upTo: Character cr)].	readStream close].	^theBasicFiles!trimList: theList for: typeEnglishStringOrSymbol	"dump from theList the special suffixed files of type typeEnglishString, so only the basic files.  Maps get special treatment because the determining file of their presence is the .control file"	| theShorterList specialSuffixString origEnd englishSymbol mapSuffix |	specialSuffixString _ self giveMe: #specialSuffixString for: typeEnglishStringOrSymbol asString.	specialSuffixString == nil ifTrue: [^theList].	englishSymbol _ typeEnglishStringOrSymbol asSymbol.	mapSuffix _ self giveMe: #suffixString for: #map asString.	theShorterList _ OrderedCollection new.	theList do: 		[:listItem |		origEnd _ listItem size.		[origEnd = 1 or: [(listItem at: origEnd) = $.]] whileFalse: [origEnd _ origEnd - 1].		(origEnd _ listItem findString: specialSuffixString startingAt: origEnd) = 0			ifTrue: [(englishSymbol = #map and: [(listItem findString: mapSuffix startingAt: 1) ~= 0]) ifFalse: [theShorterList add: listItem]]			ifFalse: [englishSymbol = #map ifTrue: [theShorterList add: (listItem copyFrom: 1 to: origEnd - 1)]]].	^theShorterList!unpackPkgFile: pkgDataFilename intoDir: localDirectory	"unpack pkgDataItem into its constituent files and return the filename of the basic file"	| pkgFile fn fnLeft fns fileNames |	fileNames _ OrderedCollection new.	pkgFile _ (MixedFileStream fileNamed: pkgDataFilename) readOnly.	[pkgFile atEnd] whileFalse:		[pkgFile text.		pkgFile next = ${ ifTrue:			[fn _ pkgFile upTo: $|.			 pkgFile next. "eat second |"			 fnLeft _ (pkgFile upTo: Character cr) asNumber.			 fns _ (FileStream fileNamed: localDirectory, fn) binary.			 pkgFile binary.			 [fnLeft > 0] whileTrue:				[fns nextPutAll: (pkgFile next: (fnLeft min: 51200)).				fnLeft _ fnLeft - (fnLeft min: 51200)].			 fileNames addLast: fns name.			 fns close]].	pkgFile close.	^fileNames first! !!DataControl methodsFor: 'instance creation'!fileTypeString	"This is a list of the types of data items available from the info center. The positions of text and speadsheet must be 1 and 2 in the list. All others can be in any order. To add a new data type to the system add its definition to the dataTypeString. There are 10 fields used to define a data type. These fields are seperated by commas.	The 1st field is the data file suffix that will be used to identify the new data type.	The 2nd field, if needed, is used to define the suffix of any related file. If this is none, there are no related files.	The 3rd field is the english name of the data item. This is the name that will appear in labels and menus.	The 4th field is the Class name to send the open and create messages to.	The 5th field is the open message. If this is #default, viewSelection:withSuitcase: will use #openWithSuitcase.	The 6th field is the create message. If this is #none these items cannot be created from the information center. If this is #default, createItemOfType: will use #createAnalystDataItem:.	The 7th field is the hardcopy message. If this is #none these items cannot be hardcopied from the information center. If this is #default, hardcopyItemAtSelection: will use #hardcopyWithSuitcase:.	The 8th field is the icon character number. Use 0 for blank icon.	The 9th field is for indicating whether the base file of this type takes a Header, and whether classification can be set externally. Possible options currently are: #hdrIntC, #hdrExtC, #noHdr."	| dataTypeString | 	^dataTypeString _'text,none,text,AnnotationModel,default,default,default,235,hdrExtCss,none,spreadsheet,SpreadsheetView,default,default,none,239,hdrExtCeform,none,form,FormsView,default,default,none,246,hdrExtCmap,.control,map,MapEditor,default,none,default,236,hdrExtCimage,none,image,ImageEditor,default,none,default,237,hdrExtCdb,.queries,database,DataBase,default,default,none,240,hdrIntCchart,.dat,chart,ChartEditor,default,none,default,238,hdrExtCpress,none,press,BackgroundPrinter,hardcopyWithSuitcase:,none,default,244,noHdrinterpress,none,interpress,BackgroundPrinter,hardcopyWithSuitcase:,none,default,243,noHdroutline,.txt,outline,OutlineView,default,default,default,242,hdrIntCpv,.txt,preview,PreviewPageView,default,default,default,241,hdrExtCpvp,.txt,preview,PreviewPageView,default,default,default,241,hdrExtCpvl,.txt,preview,PreviewPageView,default,default,default,241,hdrExtCbb,.lis,report,AnnotationModel,openReportWithSuitcase:,default,default,245,hdrExtCpkg,none,package,DataMaster,none,none,none,247,hdrExtCfolder,none,none,ContainerModel,none,none,none,234,noHdrkeyword,none,none,ContainerModel,none,none,none,248,noHdr'"docs,none,document,DocumentView,default,default,default,250,hdrExtCicon,none,icon,IconEditor,default,default,none,249,hdrExtC"	"DataControl initialize"!initializeFileTypes	| dataTypeString readStream symbolCollection suffixCollection specialSuffixCollection englishCollection label temp classSymbolCollection openMessageCollection createMessageCollection hardcopyMessageCollection iconCharacterCollection hdrCCollection | 	dataTypeString _self fileTypeString.	readStream _ ReadStream on: dataTypeString from: 1 to: dataTypeString size.	symbolCollection _ OrderedCollection new.	suffixCollection _ OrderedCollection new.	specialSuffixCollection _ OrderedCollection new.	englishCollection _ OrderedCollection new.	classSymbolCollection _ OrderedCollection new.	openMessageCollection _ OrderedCollection new.	createMessageCollection _ OrderedCollection new.	hardcopyMessageCollection _ OrderedCollection new.	iconCharacterCollection _ OrderedCollection new.	hdrCCollection _ OrderedCollection new.	[readStream atEnd] whileFalse:		[symbolCollection add: (temp _ readStream upTo: $,) asSymbol.		suffixCollection add:  (String with: $.),temp.		(temp _ readStream upTo: $,) = 'none'			ifTrue:[specialSuffixCollection add: nil]			ifFalse:[specialSuffixCollection add: temp].		englishCollection add:  (readStream upTo: $,).		classSymbolCollection add:  (readStream upTo: $,) asSymbol.		openMessageCollection add:  (readStream upTo: $,) asSymbol.		createMessageCollection add: (readStream upTo: $,) asSymbol.		hardcopyMessageCollection add: (readStream upTo: $,) asSymbol.		iconCharacterCollection add: (readStream upTo: $,) asNumber.		hdrCCollection add: (readStream upTo: Character cr) asSymbol].	(fileTypes _ Array new: 10)		at: 1 put: symbolCollection asArray;		at: 2 put: suffixCollection asArray;		at: 3 put: specialSuffixCollection asArray;		at: 4 put: englishCollection asArray;		at: 5 put: classSymbolCollection asArray;		at: 6 put: openMessageCollection asArray;		at: 7 put: createMessageCollection asArray;		at: 8 put: hardcopyMessageCollection asArray;		at: 9 put: iconCharacterCollection asArray;		at: 10 put: hdrCCollection asArray.!setup	Smalltalk at: #DefaultCert put: 100.	Smalltalk at: #UserName ifAbsent: [Smalltalk at: #UserName put: nil].	Smalltalk at: #Wheel ifAbsent: [Smalltalk at: #Wheel put: true].	linkTypes _ OrderedCollection new.	linkTypes add:#contains; add: #keyword; add: #database.	whatYouWant _ OopConservingDictionary new.	whatYouWant at: #symbol put: 1.	whatYouWant at: #suffixString put: 2.	whatYouWant at: #specialSuffixString put: 3.	whatYouWant at: #englishString put: 4.	whatYouWant at: #className put: 5.	whatYouWant at: #openMethod put: 6.	whatYouWant at: #createMethod put: 7.	whatYouWant at: #hardcopyMethod put: 8.	whatYouWant at: #iconIndex put: 9.	whatYouWant at: #hdrCStatus put: 10.	self initializeFileTypes! !!DataControl methodsFor: 'file type access'!allFilesFor: theFileName	| theString theArray | 	theString _ (fileTypes at: 3) at: (self suffixIndexForFileName: theFileName).	theArray _ OrderedCollection with: theFileName.	theString == nil ifFalse:[theArray add: theFileName, theString].	^theArray!createItemArray	| createArray last | 	createArray _ OrderedCollection new.	1 to: (fileTypes at: 7) size do:		[:i | (((fileTypes at: 7) at: i) = #none or: [((fileTypes at: 4) at: i) = last])				ifFalse: [createArray add: (last _ (fileTypes at: 4) at: i)]].	^createArray!englishStrings	| createArray last | 	createArray _ OrderedCollection new.	(fileTypes at: 4) do:		[:es | (es = #none or: [es = last]) ifFalse: [createArray add: es. last _ es]].	^createArray!externalClassOn: inSyEsFn	"answer whether the classification may be externally set for the data type represented by inSyEsFn (an index, symbol, english string, or filename)"	^(self giveMe: #hdrCStatus for: inSyEsFn) = #hdrExtC!formFileName: fileName	| englishType fullName | 	"returns a fully expanded fileName for a form file or nil"	fullName _ nil.	englishType _ (fileTypes at: 4) at: (self suffixIndexForFileName: fileName).	(englishType = #image asString or: [englishType = #map asString or: [englishType = #chart asString]])		ifTrue: [fullName _ self getOldFileName: fileName].	^fullName!giveMe: what for: index	"This will return the 'what' corresponding to the supplied index, symbol, english string or filename.what is one of the following symbols #className		gets the Smalltalk classname for the indicated data type#openMethod		gets the open method for the indicated data type#createMethod		gets the create method for the indicated data type#hardcopyMethod	gets the hardcopy method for the indicated data type#iconIndex			gets the icon character Index for the indicated data type#suffixString		gets the file suffix string for the indicated data type#specialSuffixString		gets the subsidiary file suffix string (if any) for the indicated data type#englishString		gets the english string for the indicated data type#symbol			gets the symbol for the indicated data type#hdrCStatus		gets the header and class status symbol for the indicated data type"	| textIndex checkIndex |	checkIndex _ whatYouWant at: what.	(index isKindOf: Integer) ifTrue:[^(fileTypes at: checkIndex) at: index].	(index isKindOf: Symbol) ifTrue:[^(fileTypes at: checkIndex) at: (((fileTypes at: 1) indexOf: index) max: 1)].	textIndex _ ((fileTypes at: 4) indexOf: index).	textIndex = 0		ifTrue: [^(fileTypes at: checkIndex) at: (self suffixIndexForFileName: index)]		ifFalse:[^(fileTypes at: checkIndex) at: textIndex]!headerOKon: inSyEsFn	"answer whether it is ok to put a Header (see HeaderFileStream) on the base file for the data type represented by inSyEsFn (an index, symbol, english string, or filename)"	inSyEsFn == nil ifTrue: [^false].	^(self giveMe: #hdrCStatus for: inSyEsFn) ~= #noHdr!suffixIndexForFileName: theFileName	| end i ch | 	(end _ i _ theFileName size) < 1 ifTrue: [^1].	[i = 1 or: [(ch _ theFileName at: i) = $.]] whileFalse: [i _ i - 1. ch = $- ifTrue: [end _ i]].	^(((fileTypes at: 2) indexOf: (theFileName copyFrom: i to: end)) max: 1)!suffixIndexForIconIndex: iconIndex	^((fileTypes at: 9) indexOf: iconIndex) max: 1!thisFile: theFileName isKindOf: englishStringOrSymbol	theFileName == nil ifTrue:[^false].	^(self giveMe: #englishString for: theFileName) = (self giveMe: #englishString for: englishStringOrSymbol asString)! !!DataControl methodsFor: 'open data item'!backgroundPrintingAvailable: announce	"just because so many things need this"	(Smalltalk includesKey: #BackgroundPrinter) ifTrue: [^true].	announce ifTrue: [self booboo: 'There is no printing installed'].	^false!createItemOfType: fileEnglishString	| tempItem dataClass createMethod return | 	tempItem _ DataItem type: #Item label: fileEnglishString atIndex: 0.	(Smalltalk includesKey: (dataClass _ self giveMe: #className for: fileEnglishString))				ifFalse: [self booboo: 'Tool for ', fileEnglishString ,' is not installed'. ^ nil].	createMethod _ self giveMe: #createMethod for: fileEnglishString.	createMethod = #default ifTrue: [createMethod _ #createAnalystDataItem:].	^((Smalltalk at: dataClass) perform: createMethod with: tempItem)!findExistingOne: theSelection	| theSuitcase | 	self findTheOneByEvaluating:		[:each |		(each isKindOf: StandardSystemController)			and: [theSuitcase _ each view suitcase.				 theSuitcase ~~ nil and: [theSuitcase dataItem == theSelection or: [theSuitcase dataItem filename = theSelection filename]]]]!findTheOneByEvaluating: aBlock	ScheduledControllers scheduledControllers	do: [:each | (aBlock value: each)					ifTrue: [each centerCursorInView.							ScheduledControllers unschedule: each.							ScheduledControllers scheduleActive: each]].!formFromItem: theItem	| fullName picture fileName | 	(theItem == nil	or: [(fileName _ theItem filename) == nil		or: [(fullName _ DataMaster formFileName: fileName) == nil]])		ifTrue: [picture _ nil.]		ifFalse: [picture _ Form readFrom: fullName].	^picture!hardcopyItemInSuitcase: theSuitcase	| classSymbol theMethod theFileName | 	theFileName _ theSuitcase dataItem filename.	(Smalltalk includesKey: (classSymbol _ self giveMe: #className for: theFileName)) ifFalse: [^self booboo: (self giveMe: #englishString for: theFileName) ,' tool is not installed.'].	theMethod _ self giveMe: #hardcopyMethod for: theFileName.	theMethod =#none ifTrue:[^self booboo: 'Hardcopy not available for ',(self giveMe: #englishString for: theFileName)].	theMethod = #default ifTrue: [theMethod _ #hardcopyWithSuitcase:].	(Smalltalk at: classSymbol)  perform: theMethod with: theSuitcase!viewSelection: theSelection withSuitcase: aSuitcase	| theItem dataClass openMethod | 	self findExistingOne: theSelection.	theItem _ theSelection filename.	(Smalltalk includesKey: (dataClass _ self giveMe: #className for: theItem))			ifFalse: [self booboo: 'Tool for ', (self giveMe: #englishString for: theItem) ,' is not installed'. ^ nil].	Cursor execute show.	openMethod _ self giveMe: #openMethod for: theItem.	openMethod = #default ifTrue: [openMethod _ #openWithSuitcase:].	(Smalltalk at: dataClass) perform: openMethod with: aSuitcase.	Cursor normal show! !!Parser methodsFor: 'private'!makeNewSymbol: aString startingAt: start	| editor index menu sym oldText newText oldStream oldKey |	Symbol hasInterned: aString ifTrue: [:symbol | ^ symbol].	(editor _ self editor) isNil ifTrue: [^ aString asSymbol].	editor selectFrom: start to: self endOfLastToken.	Cursor normal show.	index _ (menu _ ActionMenu			labels:'proceed as is{Continue with execution.}correct it{Try to correct spelling.}abort{Abort compilation -- You fix it.}'			selectors: #(proceed correct abort))				startUp: #anyButton				withHeading: ' ' , (aString contractTo: 20) , ' is a new message '.	index = 0 ifTrue: [^ self notify: ''].	(menu selectorAt: index) == #proceed ifTrue: [^ aString asSymbol].	(menu selectorAt: index) == #correct ifTrue:		[sym _ Symbol correctMessage: aString.		sym == false ifTrue: [self notify: 'Couldn''t correct'. self abort].		sym == nil ifTrue: [self abort].		oldText _ editor selection.		sym isKeyword			ifTrue:				[newText _ oldText.				oldStream _ ReadStream on: aString.				sym keywords do:					[:newKey | oldKey _ (oldStream upTo: $:) , ':'.					oldKey = newKey ifFalse:						[newText _ newText copyReplaceAll: oldKey asText with: newKey asText]]]			ifFalse:				[newText _ oldText copyReplaceAll: aString asText with: sym asText].		self replaceEditSelectionWith: newText.		^ sym].	self abort! !Querier comment:'Copyright (c) Xerox Corporation, 1985, 1986.  All rights reserved.Querier views are used to construct query strings for FixedFiles.  A Querier is an unscheduled view which looks like a FillInTheBlank view, but which allows text to be entered (almost) only through its yellow-button menu.  For the exact syntax of fixed-file-filters, see class FixedFileFilter.Class variables:	ConjunctionList, ConjunctionMenu:  A list and PopUpMenu of the valid conjunctions.  The menu also includes the standard backspace/cancel.	OperatorList, OperatorMenu:  Same thing, with operators.	ValueMenu:  A PopUpMenu of: ''backspace\cancel\enter value''.Instance variables:	fieldList, typeList:  Lists of the field names, and field types (''number'' or ''string'' for each field).	fieldMenu:  A PopUpMenu of fields.	state:  The current state, which governs what type of thing should be input next. Values:			1:  Field name			2:  Operator			3:  Value			4:  Conjunction (or ''accept'')			-1:  Done with query (user accepted/cancelled)	queryStream:  A WriteStream of the user''s current input.	wordEnds:  A stack.  Values are indexes into queryStream at which ''words'' end.  Used by backSpace.	view:  The QuerierView associated with me.	currentField:  The index into fieldList of the last field entered.  Used when values are being entered so that I know what type of value to expect.'!!Querier methodsFor: 'menus'!menu	"return a PopUpMenu for use as the current menu."	^(Array with: fieldMenu		with: OperatorMenu		with: ValueMenu		with: ConjunctionMenu ) at: state!menuSelection: menu 	"Menu item #menu was selected. Let's do something with it."	| val isString |	menu = 1 ifTrue: [self backSpace. self changed. ^self]. "backspace"	menu = 2 ifTrue: [queryStream _ nil. state _ -1. ^self]. "cancel"	state = 4 & (menu = 3) ifTrue:  [state _ -1. ^self]. "accept"	wordEnds addLast: queryStream position.	queryStream isEmpty ifFalse: [queryStream space].	state = 1 ifTrue: 		[queryStream nextPutAll: (fieldList at: menu - 2).		 currentField _ menu - 2].	state = 2 ifTrue: [queryStream nextPutAll: (OperatorList at: menu - 2)].	state = 3 ifTrue: 		[(typeList at: currentField) = #classification			ifTrue:[(String with: $#), Classification fromUser displayString printOn: queryStream]			ifFalse:[isString _ (typeList at: currentField) = #number.		 val _ FillInTheBlank				request: 'Enter a ' , (typeList at: currentField), (String with: $:)				initialAnswer: (String with: $a with: $ ), (typeList at: currentField).		isString ifTrue: [val _ val asNumber].		val printOn: queryStream]].	state = 4 ifTrue: [queryStream nextPutAll: (ConjunctionList at: menu - 3)].	state _ state \\ 4 + 1.	self changed! !!Querier methodsFor: 'initialization'!initializeWithFields: fields types: types	"Create the lists of fields/types, and the menu of field names."	fieldList _ fields.	fieldMenu _ PopUpMenu new		labels: ('backspace\cancel\' withCRs), (self menuStringOnList: fields)		font: MenuFont		lines: #( 2 ).	typeList _ types.		queryStream _ WriteStream on: (String new: 40).	wordEnds _ OrderedCollection new.	state _ 1! !!Querier methodsFor: 'private'!backSpace	"Remove the last 'word' from the query stream."	wordEnds isEmpty ifFalse:		[ queryStream position: (wordEnds removeLast).		state _ state-1.		state=0 ifTrue: [state_4] ]!menuStringOnList: aList	"Construct a string for use by a PopUpMenu from a list."	| aStream |	aStream _ WriteStream on: (String new: 200).	aList do:		[:item | aStream nextPutAll: (item contractTo: 15); cr].	aStream isEmpty ifFalse: [aStream skip: -1].	^aStream contents! !!Querier methodsFor: 'accessing'!actionTaken	"Answer whether I am done."	^ state < 0!contents	"Return the current query string."	queryStream == nil ifTrue: [^nil] ifFalse: [^queryStream contents]!view: aQuerierView	view _ aQuerierView!wordEnds	"Return the word ends array."	^wordEnds! !SimpleQuerier comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987.  All rights reserved.'!!SimpleQuerier methodsFor: 'menus'!menu	"return a PopUpMenu for use as the current menu."	^fieldMenu!menuSelection: index	index == nil ifTrue:[^self].	index=1 ifTrue: [ self backSpace. self changed. ^self ].	"BackSpace"	index=2 ifTrue: [ queryStream _ nil. state _ -1. ^self ].	"Cancel"	index=3 ifTrue: [ state _ -1. ^self ].		"Accept"	wordEnds addLast: queryStream position.	queryStream isEmpty ifFalse: [queryStream space].	queryStream nextPutAll: (fieldList at: index-3). currentField _ index-3 .	self changed! !!SimpleQuerier methodsFor: 'initialization'!initializeWithFields: fields	"Create the lists of fields/types, and the menu of field names."	fieldList _ fields.	fieldMenu _ (ScrollMenu new		labels: ('backspace\cancel\ACCEPT\' withCRs), (self menuStringOnList: fields)		font: MenuFont		lines: #( 3 )) maxLines: 10.	queryStream _ WriteStream on: (String new: 40).	wordEnds _ OrderedCollection new.	state _ 1! !!SimpleQuerier methodsFor: 'private'!backSpace	"Remove the last 'word' from the query stream."	wordEnds isEmpty ifFalse:		[ queryStream position: (wordEnds removeLast)]! !DBoxQuerier comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DBoxQuerier methodsFor: 'menus'!menuSelection: menu 	"Menu item #menu was selected. Let's do something with it."	menu = 1 ifTrue:[self backSpace.			self changed.			^self].		"Backspace"	menu = 2 ifTrue:[queryStream _ WriteStream on: (String new: 40).			wordEnds _ OrderedCollection new.			self changed.			^self].		"Cancel"	wordEnds addLast: queryStream position.	queryStream isEmpty ifFalse: [queryStream space].	queryStream nextPutAll: (fieldList at: menu - 2).	currentField _ menu - 2.	self changed! !!DBoxQuerier methodsFor: 'initialization'!initializeWithFields: fields	"Create the lists of fields/types, and the menu of field names."	fieldList _ fields.	fieldMenu _ PopUpMenu new		labels: ('backspace\cancel\' withCRs), (self menuStringOnList: fields)		font: MenuFont		lines: #( 2 ).		queryStream _ WriteStream on: (String new: 40).	wordEnds _ OrderedCollection new.	state _ 1! !KeywordQuerier comment:'Copyright (c) Xerox Corporation, 1986, 1987.  All rights reserved.'!!KeywordQuerier methodsFor: 'access'!answers 	^answers! !!KeywordQuerier methodsFor: 'menus'!menu	"return a PopUpMenu for use as the current menu."	^(Array with: fieldMenu		with: LogicMenu ) at: state!menuSelection: index 	index == nil ifTrue: [^self].	index = 1 ifTrue: [self backSpace. self changed. ^self]. "backspace"	index = 2 ifTrue: [answers _ nil. state _ -1. ^self]. "cancel"	index = 3 ifTrue:  [state _ -1. ^self]. "accept"	wordEnds addLast: queryStream position.	queryStream isEmpty ifFalse: [queryStream space].	state = 1 ifTrue: 		[queryStream nextPutAll: (fieldList at: index - 3).		answers addLast: (fieldList at: index - 3).		 currentField _ index - 3].	state = 2 ifTrue: [queryStream nextPutAll: (LogicList at: index - 3).		answers addLast: (LogicList at: index - 3).].	state _ state \\ 2 + 1.	self changed! !!KeywordQuerier methodsFor: 'initialization'!backSpace	"Remove the last 'word' from the query stream."	wordEnds isEmpty ifFalse:		[ queryStream position: (wordEnds removeLast).		answers removeLast.		state _ state-1.		state=0 ifTrue: [state_2] ]!initializeWithFields: fields	"Create the lists of fields/types, and the menu of field names."	fieldList _ fields.	fieldMenu _ (ScrollMenu new		labels: ('backspace\cancel\ACCEPT\' withCRs), (self menuStringOnList: fields)		font: MenuFont		lines: #( 3 )) maxLines: 10.	queryStream _ WriteStream on: (String new: 40).	wordEnds _ OrderedCollection new.	answers _ OrderedCollection new.	state _ 1! !RS232DisplayLine comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.<string>	a String. Contains the characters in the line. Fixed length, padded with spaces.<lastLoc>	an Integer. The index in string of the laast character that has been put in it.<highlightColl>	an OrderedCollection of the highlights on the line where a highlight is an array #(s, e, t) where:			s is starting index in string			e is ending index in string			t is the type of highlight (currently only $H for reverse video, $U for underline).<pendingHighlight>	an Array which is an incomplete highlight (as defined above).  In other words, start and type are known, but the end is not. This is nil if none are incomplete.'!!RS232DisplayLine methodsFor: 'As yet unclassified'!at: i	^(string at: i)!at: i put: c	lastLoc < i ifTrue: [lastLoc _ i].	string at: i put: c!backSpace	"assumes writing at end of line"	lastLoc _ lastLoc - 1 max: 0!clearLine	lastLoc _ 0.	string _ string primReplaceFrom: 1 to: string size with: BlankString startingAt: BlankString size - string size.	highlightColl _ OrderedCollection new: 4!clearLineFrom: pos	| highlights | 	string primReplaceFrom: pos to: lastLoc with: BlankString startingAt: BlankString size - lastLoc + pos.	"pos to: lastLoc do: [:i | string at: i put: $ ]."	highlights _ OrderedCollection new.	highlightColl do: [:h |		(h at: 1) < pos ifTrue: "not deleted"			[(h at: 2) < pos ifFalse: [h at: 2 put: pos - 1 "shorten it"].			 highlights addLast: h]].	highlightColl _ highlights.	(pendingHighlight ~= nil and: [(pendingHighlight at: 1) >= pos])		ifTrue: [pendingHighlight _ nil]. "started beyond what is now end of line"	lastLoc _ pos - 1!endHighlightAt: pos	"end any highlight currently in progress. Answer whether such a highlight existed"	| pend | 	pend _ self pendingHighlightUpto: pos.	pendingHighlight _ nil. "since will add it to highlights if exists, nil this"	pend == nil ifFalse:		[highlightColl addLast: pend.		^ true].	^false!highlightColl	^highlightColl!initialize: length	lastLoc _ 0.	string _ (String new: length) primReplaceFrom: 1 to: length with: BlankString startingAt: 1.	highlightColl _ OrderedCollection new: 4!isBlank	1 to: lastLoc do: [:i | (string at: i) = $  ifFalse: [^false]].	(pendingHighlight == nil and: [highlightColl isEmpty]) ifFalse: [^false].	^true!lastLoc	^lastLoc!lastLoc: anInteger	| highlights pos last | 	lastLoc _ anInteger.	highlights _ highlightColl copy.	(pendingHighlight == nil or: [pos + 1 <= (pendingHighlight at: 1)])		ifFalse:			[last _ pendingHighlight copy.			last at: 2 put: pos.			highlights add: last].!pendingHighlightUpto: pos	"return nil if no highlight pending, otherwise - return the pending highlight in closed form ie. with end at pos"	| last |	(pendingHighlight == nil or: [pos + 1 <= (pendingHighlight at: 1)])		ifFalse: "convert pending highlight into a highlight upto pos"			[last _ pendingHighlight copy.			last at: 2 put: pos.			lastLoc < pos ifTrue: [lastLoc _ pos]. "bump this up so it will take care of underlines, too"			^last].	^nil!startHighlight: type at: pos	| pend | 	pend _ self pendingHighlightUpto: pos - 1.	pend == nil ifFalse: [highlightColl addLast: pend].	pendingHighlight _ nil. "since added it to highlights if exists, nil this"	(highlightColl isEmpty not		and: [(highlightColl last at: 2) >= (pos - 1)			and: [(highlightColl last at: 3) = type]])				ifTrue: [highlightColl last at: 2 put: pos]				ifFalse: [pendingHighlight _ Array with: pos with: nil with: type]!string	^string! !!BlockContext methodsFor: 'controlling'!join: aBlock"compute both self and aBlock simultaneously; return when both are done"	| s |	s _ Semaphore new.	[aBlock value. s signal] fork.	self value.	s wait! !!Paragraph methodsFor: 'accessing'!outputMedium	"Answer the outputMedium for the receiver.	As of 1/20/80, #Display, #PressPrinter, #DisplayPrinterWidths are the possibilities."		^outputMedium! !!Paragraph methodsFor: 'composition'!recomposeIn: compositionRect clippingBox: clippingRect 	"Set the composition rectangle for the receiver so that the lines wrap	within the rectangle, compositionRect, and the display of the text is	clipped by the rectangle, clippingRect."	clippingRect extent = self clippingRectangle extent		ifTrue:			[compositionRectangle _ compositionRect copy.			self updateCompositionHeight]		ifFalse:			[self compositionRectangle: compositionRect copy				text: text				style: textStyle				offset: offset				outputMedium: textStyle outputMedium				fitWidth: false].	clippingRectangle _ clippingRect copy! !!Paragraph methodsFor: 'selecting'!extendSelection: prevStartBlock to: prevStopBlock using: extendBlock	| dStart dStop startBlock stopBlock | 	"Answer with an Array of two CharacterBlocks that represent the text selection that the user makes. Allow for scrolling to extend selections."	startBlock _ prevStartBlock.	stopBlock _ prevStopBlock.	dStart _ (startBlock stringIndex - extendBlock stringIndex) abs.	dStop _ (stopBlock stringIndex - extendBlock stringIndex) abs.	dStart < dStop ifTrue:[startBlock _ extendBlock] ifFalse:[stopBlock _ extendBlock].	stopBlock = startBlock ifFalse: [self reverseFrom: startBlock to: stopBlock].	stopBlock < startBlock		ifTrue: [^Array with: stopBlock with: startBlock]		ifFalse: [^Array with: startBlock with: stopBlock]!mouseSelect: previousStartBlock to: previousStopBlock	"Answer with an Array of two CharacterBlocks that represent the text selection that the user makes. Allow for scrolling to extend selections."	| pivotBlock startBlock stopBlock showingCaret dy pt okToScroll scrollDelay word extendBlock |	Sensor leftShiftDown ifTrue:[^self extendSelection: previousStartBlock to: previousStopBlock using: (self characterBlockAtPoint: Sensor cursorPoint)].	startBlock _ stopBlock _ pivotBlock _ self characterBlockAtPoint: Sensor cursorPoint.	self displayCaretForBlock: pivotBlock.	showingCaret _ true.	okToScroll _ true.	scrollDelay _ Delay forMilliseconds: 250. "For Dorados"	[Sensor redButtonPressed] whileTrue: [		pt _ Sensor cursorPoint.		(okToScroll		 and: [(dy _ self dyForPoint: pt) ~= 0]) ifTrue: [			[okToScroll _ false. scrollDelay wait. okToScroll _ true]				forkAt: Processor userInterruptPriority.			showingCaret				ifTrue: [					self displayCaretForBlock: pivotBlock.					showingCaret _ false]				ifFalse: [self reverseFrom: startBlock to: pivotBlock].			self scrollBy: dy.			pt _ dy < 0				ifTrue: [clippingRectangle topLeft]				ifFalse: [clippingRectangle bottomRight].			pivotBlock _ self characterBlockForIndex: pivotBlock stringIndex.			startBlock _ pivotBlock ].		stopBlock _ self characterBlockAtPoint: pt.		stopBlock = startBlock ifFalse: [			showingCaret ifTrue: [				self displayCaretForBlock: pivotBlock. showingCaret _ false].			self reverseFrom: startBlock to: stopBlock.			startBlock _ stopBlock] ].	(showingCaret not and: [pivotBlock = stopBlock])		ifTrue: [self displayCaretForBlock: pivotBlock].	scrollDelay disable.	(previousStartBlock = previousStopBlock and:		[pivotBlock = stopBlock and: [stopBlock = previousStopBlock]])		ifTrue:  "select a word or bracketed range"			[word _ self selectWord: pivotBlock stringIndex.			word first = word last ifFalse:				[self displayCaretForBlock: pivotBlock.				pivotBlock _ self characterBlockForIndex: word first.				stopBlock _ self characterBlockForIndex: word last.				self reverseFrom: pivotBlock to: stopBlock]].	stopBlock < pivotBlock		ifTrue: [^Array with: stopBlock with: pivotBlock]		ifFalse: [^Array with: pivotBlock with: stopBlock]! !!Paragraph methodsFor: 'converting'!asForm	"Answer a new Form made up of the bits that represent the receiver''s	dispayable text."	| aForm saveDestinationForm |	aForm _ Form new extent: compositionRectangle extent.	saveDestinationForm _ destinationForm.	self displayOn: aForm		at: 0 @ 0		clippingBox: aForm boundingBox		rule: Form over		mask: Form black.	aForm offset: offset.	destinationForm _ saveDestinationForm.	^aForm!asPressParagraph	"Answer with a Paragraph with press dimensions (micas).  Composition rectangle is scaled by PressFile pressScale and destinationForm is set to PressPrinter DefaultFrame"	| pressParagraph pressCompositionRectangle pressTextStyle YOffset |	outputMedium = #PressPrinter		ifTrue:	["already a pressified paragraph" ^ self].	pressCompositionRectangle _		PressPrinter DefaultPageRectangle origin +			(compositionRectangle origin * PressFile pressScale)			extent:  compositionRectangle extent * PressFile pressScale.	pressTextStyle _ textStyle copy.	pressTextStyle outputMedium: #PressPrinter.	pressCompositionRectangle right:		(pressCompositionRectangle right min:			PressPrinter DefaultDoverRectangle right).	pressParagraph  _		Paragraph basicNew			compositionRectangle: pressCompositionRectangle text: text				style: pressTextStyle offset: 0@0 outputMedium: #PressPrinter					fitWidth: false.	YOffset _ PressPrinter DefaultDoverRectangle bottom -				pressCompositionRectangle bottom.					pressParagraph destinationForm: 		(PressPrinter DefaultDoverRectangle origin extent:			(pressCompositionRectangle right @ YOffset)).	pressParagraph clippingRectangle: pressCompositionRectangle.	^pressParagraph!asPrinterWidthsParagraph	"Answer with a copy of self with outputMedium = #DisplayPrinterWidths.  Composition and display are done on the basis of press dimensions (micas) and display is done to the alto dot closest to where the character would fall in the printer medium."	^ self basicNew		compositionRectangle: compositionRectangle		text: text	style: textStyle copy	offset: 0@0	outputMedium: #DisplayPrinterWidths	fitWidth: false! !Pool named: #TextConstants includes: #Justified!Pool named: #TextConstants includes: #LeftFlush!Pool named: #TextConstants includes: #CR!Pool named: #TextConstants includes: #RightFlush!Pool named: #TextConstants includes: #Centered!!Paragraph methodsFor: 'private'!leftMarginForCompositionForLine: lineIndex	"Build the left margin for composition of a line. 	Depends upon marginTabsLevel and the indent."	"Lines after CRs are indented according to firstIndent, others	are indented according to restIndent.  --Peter Alfke 9/84"	lineIndex > lastLine ifTrue:		[^ self leftMarginForCompositionIfFirst: true ]	ifFalse:		[^ self leftMarginForCompositionForStartIndex:			(lines at: lineIndex) first ]!leftMarginForCompositionForStartIndex: startIndex	"Build the left margin for composition of a line. 	Depends upon marginTabsLevel and the indent."	"Lines after CRs are indented according to firstIndent, others	are indented according to restIndent.  --Peter Alfke 9/84"	| scale charIndex |	outputMedium = #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	((firstIndent=restIndent) or:		"go fast normally"		[startIndex=1 or:			[(text at: startIndex-1) = Character cr]])		ifTrue: [^(firstIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]		ifFalse: [^(restIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]!leftMarginForCompositionIfFirst: aBoolean	"Tell indentation for a line which is either the first after a CR (aBoolean=true)	or not.        --Peter Alfke 9/84"	| scale |	outputMedium = #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	aBoolean		ifTrue: [^(firstIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]		ifFalse: [^(restIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]!leftMarginForDisplayForLine: lineIndex	"Build the left margin for display of a line.	Depends upon leftMarginForComposition, compositionRectangle left, the outputMedium and	the alignment."	| pad scale |	outputMedium = #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	(textStyle alignment = LeftFlush or: [textStyle alignment = Justified])		ifTrue: 			[^((compositionRectangle left * scale)				+ (self leftMarginForCompositionForLine: lineIndex))].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	( lineIndex <= lines size and: [(lines at: lineIndex) ~~ nil])		ifTrue: 			[pad _ (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad _ compositionRectangle width - firstIndent - rightIndent].	textStyle alignment = Centered 		ifTrue: 			[^((compositionRectangle left * scale)				+ (self leftMarginForCompositionForLine: lineIndex)) + (pad // 2)].	textStyle alignment = RightFlush 		ifTrue:			[^((compositionRectangle left * scale)				+ (self leftMarginForCompositionForLine: lineIndex)) + pad].	self error: ['no such alignment']!rightMarginForComposition	"Build the right margin for a line. 	Depends upon compositionRectangle width, marginTabsLevel, and right indent."	| scale |	outputMedium = #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	^(compositionRectangle width 		- (textStyle rightMarginTabAt: marginTabsLevel) - rightIndent) * scale!rightMarginForDisplay 	"Build the right margin for a line.	Depends upon compositionRectangle rightSide, marginTabsLevel, and right indent."	| scale |	outputMedium = #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	^(compositionRectangle right - 		rightIndent - (textStyle rightMarginTabAt: marginTabsLevel)) * scale!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work."	outputMedium = #PressPrinter		ifTrue:	["Don't change height for composition for printer."				^ self].	compositionRectangle height: textStyle lineGrid * lastLine.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle 					height: compositionRectangle height + textStyle lineGrid]!visibleRectangle	outputMedium = #PressPrinter		ifTrue:	[^ (clippingRectangle intersect: compositionRectangle) intersect: destinationForm]		ifFalse:	[^ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox]! !!Paragraph methodsFor: 'printing'!newPage: marginsRectangle"***for Press only, sets the composition and clipping rectangles in an obvious way.BEWARE that for Press, the destination form is a rectangle***"	compositionRectangle _ clippingRectangle _ destinationForm _ marginsRectangle!newPage: compRectangle in: destRectangle"***for Press only, sets the composition and clipping rectangles in an obvious way.BEWARE that for Press, the destination form is a rectangle***"	compositionRectangle _ clippingRectangle _ compRectangle.	destinationForm _ destRectangle!pressFile	"In a press paragraph form is the pressFile to which the paragraph has been directed."	^form!pressOn: aPressFile	"Put self onto a press file. Return top of last line printed or the interval of lines which didn't get printed because of page overflow. The alternative for printing when the paragraph has not already been converted, (it's outputMedium is not #PressPrinter) is more exemplary than useful."	| stopLine pressParagraph nextYOrInterval scanner |	outputMedium ~= #PressPrinter		ifTrue:	[pressParagraph _ self asPressParagraph.				[(nextYOrInterval _ pressParagraph pressOn: aPressFile)					isMemberOf: Interval]				whileTrue:					[aPressFile nextPage.					pressParagraph lines: (pressParagraph copyLines: nextYOrInterval).					pressParagraph						newPage: (PressPrinter DefaultDoverRectangle topLeft									@ nextYOrInterval size * pressParagraph lineGrid)						in: PressPrinter DefaultDoverRectangle]]		ifFalse:	[form _ aPressFile.	"Stretching it a bit, but think of the									form a variation of the destinationForm.									Save an instance variable, but it you really don't									like it, we'll add one."				scanner _ DisplayScanner new.				stopLine _ scanner					displayLines: (1 to: lastLine)					in: self					clippedBy: (self visibleRectangle).				stopLine > lastLine					ifTrue:	[^scanner lineY]					ifFalse:	[^ (stopLine to: lastLine)]].! !BigParagraph comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.I am a type of Paragraph for viewing large pieces of text.  I save time and oops by only composing the text currently being displayed; this makes me slower at scrolling (in fact, I can''t scroll back lines at all) but faster at updating the text.My major difference from a regular Paragraph is that my lines array always starts from the top of the displayed lines, not from the start of the text (i.e. ''lines at:1'' is the first displayed line).  My instance variables firstChar and lastChar keep track of what the first and last characters being displayed are.My instances obey most of Paragraph''s protocol, except:	* They have no idea how may lines long they are, and	* They will only print to the Display.Thus, they may/will give incorrect responses to the following messages:	compositionRectangle		Its height is meaningless.  Don''t move it to scroll text!!	height  (Error)	numberOfLines		Returns a usually inappropriate number, for use by CharacterBlockScanner.	outputMedium:		Error unless the argument is #Display.	boundingBox  (Error)	computeBoundingBox  (Error)	fit		Just flashes the window and returns.	asForm  (Error)	asPrinterWidthsParagraph  (Error)	lineIndexOfCharacterIndex		Returns -99 or lastLine+99 if the character is not displayed.	updateCompositionHeight  (Error)	pressOn:  (Error)	forPressWithText:style:compositionRectangle:  (Error)'!!BigParagraph methodsFor: 'accessing'!charactersShown	"How many characters are being shown?"	^ lastChar - firstChar +1!clippingRectangle: aRectangle 	"Set the rectangle, defined in absolute coordinates, whose intersection with the	destinationForm is the area in which the characters are constrained to display."	clippingRectangle _ aRectangle.	compositionRectangle notNil ifTrue:		[self compositionRectangle: compositionRectangle]!compositionRectangle: aRectangle	"Set the rectangle whose width is the dimension, modified by 	indents and tabsLevels, against which line wraparound is measured.	The height of the compositionRectangle is meaningless."	"compositionRectangle _ aRectangle.	compositionRectangle height: 0."	compositionRectangle _ Rectangle		origin: aRectangle left @ clippingRectangle top		extent: aRectangle width @ 0.	self composeAll!firstCharacter	"Answer the index in text of the first displayed character."	^firstChar!height	"My height is unknown."	self shouldNotImplement!numberOfLines	"KLUUUDGE!!!!  My total number of lines is unknown, so for 	CharacterBlockScanner I return a convenient half-truth.  If there is text	past the end of the clipping box, return some big number, else return the	number of lines displayed."	"self shouldNotImplement"	text size =0 ifTrue: [ ^0 ].	lastChar = text size		ifTrue: [ ^lastLine ]		ifFalse: [ ^8191 ]!replaceFrom: start to: stop with: aText displaying: displayBoolean 	"Replace the receiver's text starting at position start, stopping at stop, by the 	characters in aText. It is expected that most requirements for modifications 	to the receiver will call this code.  Certainly all cuts or pastes."	"not already composed?"	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex startLine stopLine replacementRange maxLine startIndex newLine done newStop obsoleteY newY upOrDown visibleRectangle moveRectangle |	64512 <= (text size + aText size - (stop - start + 1)) ifTrue: [SmalltalkSignal signal: #textTooLong]. "63K is safe number to stay below" 	lastLine = 0		ifTrue: 			[text				replaceFrom: start				to: stop				with: aText.			self composeAll.			displayBoolean				ifTrue: 					[self clearVisibleRectangle.					self displayLines: (1 to: lastLine)].			^self].	"1.  find the starting and stopping lines -- must be done before changing text!!"	"2.  Update the text."	"3.  how many characters being inserted or deleted -- negative if 	aText size is < characterInterval size."	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: (stop + 1).	text		replaceFrom: start		to: stop		with: aText.	replacementRange _ aText size - (stop - start + 1).	"no displayed characters changed -- changes before first displayed char?"	(stop + 1) <= firstChar		ifTrue: 			[firstChar _ firstChar + replacementRange.			lastChar _ lastChar + replacementRange.			1 to: lastLine do: [:each | lines at: each put: ((lines at: each) slide: replacementRange)].			stop + 1 = firstChar ifTrue: [^self moveDown: 1 grid: textStyle lineGrid display: true].			^self scrollTo: (start - 1 max: 1)"(stop min: lastChar)"].	"start > lastChar ifTrue: [^self scrollTo: start]. "	"save -- things get pretty mashed as we go along"	visibleRectangle _ self visibleRectangle.	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	maxLine _ self linesInWindow.	"Initialize a scanner."	compositionScanner _ CompositionScanner new in: self.	"If the starting line is not also the first line, then measuring must commence 	from line preceding the one in which characterInterval start appears.  For 	example, deleting a line with only a carriage return may move characters 	following the deleted portion of text into the line preceding the deleted line."	startLine = -99 | (startLine = (lastLine + 99))		ifTrue: 			[startIndex _ start.			firstLineIndex _ startLine _ 1]		ifFalse: [startIndex _ (lines at: firstLineIndex) first].	startLine > 1 & (startLine <= lastLine)		ifTrue: 			[newLine _ compositionScanner						composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.			(lines at: startLine - 1)				= newLine				ifFalse: 					["start in line preceding the one with the starting character"					startLine _ startLine - 1.					self lineAt: startLine put: newLine.					startIndex _ newLine last + 1]].	startIndex > text size		ifTrue: 			["nil lines after a deletion -- remeasure last line below"			self trimLinesTo: (firstLineIndex - 1 max: 0).			text size = 0				ifTrue: 					["entire text deleted -- clear visibleRectangle and return."					destinationForm						fill: self visibleRectangle						rule: rule						mask: Form white.					firstChar _ lastChar _ nil.					lastLine _ 0.					^self]				ifFalse: [firstLineIndex = 1						ifTrue:							[self scrollTo: (startIndex - 1 + replacementRange max: 1).							^self]]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [firstLineIndex > maxLine | (startIndex > text size)]]		whileFalse: 			[self lineAt: firstLineIndex put: (newLine _ compositionScanner							composeLine: firstLineIndex							fromCharacterIndex: startIndex							inParagraph: self).			[(lastLineIndex > obsoleteLastLine or: ["no more old lines to compare with?"				newLine last < (newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])				or: [done]]				whileFalse: [newStop = newLine last						ifTrue: 							["got the match"							upOrDown _ replacementRange < 0										ifTrue: [0]										ifFalse: [1].							"get source and dest y's for moving the unchanged 							lines "							obsoleteY _ self topAtLineIndex: lastLineIndex + upOrDown.							newY _ self topAtLineIndex: firstLineIndex + upOrDown.							stopLine _ firstLineIndex.							done _ true.							"Fill in the new line vector with the old unchanged 							lines. Update their starting and stopping indices 							on the way."							((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine)								do: [:upDatedIndex | self lineAt: (firstLineIndex _ firstLineIndex + 1) put: ((obsoleteLines at: upDatedIndex)											slide: replacementRange)].							"trim off obsolete lines, if any"							self trimLinesTo: (firstLineIndex min: maxLine)]						ifFalse: [lastLineIndex _ lastLineIndex + 1]].			startIndex _ newLine last + 1.			firstLineIndex _ firstLineIndex + 1]. 	done ifFalse: [self trimLinesTo: (firstLineIndex - 1 min: maxLine)].	"We may need to add some more lines at the bottom, if text was deleted."	firstLineIndex <= maxLine		ifTrue: 			[startIndex _ (lines at: lastLine) last + 1.			[firstLineIndex <= maxLine & (startIndex <= text size)]				whileTrue: 					[self lineAt: firstLineIndex put: (newLine _ compositionScanner									composeLine: firstLineIndex									fromCharacterIndex: startIndex									inParagraph: self).					startIndex _ newLine last + 1.					firstLineIndex _ firstLineIndex + 1].			self trimLinesTo: firstLineIndex - 1].	"Now fix the first and last character locations."	firstChar _ (lines at: 1) first.	lastChar _ (lines at: lastLine) last.	"Now the lines are up to date -- Whew!!.  What remains is to move the 	'unchanged' lines and display those which have changed."	displayBoolean		ifTrue: 			[done				ifFalse: ["If at the end of previous lines simply display lines from 					the line in 					which the first character of the replacement occured 					through the 					end of the paragraph."					self displayLines: (startLine to: (stopLine _ firstLineIndex min: lastLine))]				ifTrue: 					["Otherwise prepare to move the unchanged lines.  					moveRectangle defines the portion of the visibleRectangle 					containing the lines 					which may be moved en masse. 					Deletion -- moving 'up' the screen or ..."					moveRectangle _ visibleRectangle left @ (obsoleteY max: visibleRectangle top) corner: visibleRectangle corner.					"Insertion -- moving 'down' the screen. 					Shorten moveRectangle by height of insertion or ..."					obsoleteY <= newY						ifTrue: [moveRectangle corner: visibleRectangle corner + (0 @ (obsoleteY - newY))]						ifFalse: ["Deletion, 							and top of moveRectangle will fall above top of 							visibleRectangle.  Increase the origin of 							moveRectangle by the amount that would fall 							above (hence outside) 							the visibleRectangle."							newY < visibleRectangle top ifTrue: [moveRectangle origin: visibleRectangle left @ (obsoleteY + visibleRectangle top - newY)]].					"Move'em."					destinationForm						copyBits: moveRectangle						from: destinationForm						at: visibleRectangle left @ (newY max: visibleRectangle top)						clippingBox: visibleRectangle						rule: Form over						mask: Form black.					"Display the new lines."					self displayLines: (startLine to: stopLine).					"A deletion may have 'pulled' previously undisplayed lines 					into the visibleRectangle.  If so, display them."					newY < obsoleteY						ifTrue: [self displayLines: (lastLine - ((obsoleteY - newY)//textStyle lineGrid)									to: lastLine)]].			"If we have done a deletion, obsolete material may remain at the 			bottom of the visibleRectangle.  If so, clear it out."			obsoleteLastLine >= lastLine				ifTrue: 					[newY _ self bottomAtLineIndex: lastLine.					newY < visibleRectangle top						ifTrue: ["new lastLine is above visibleRectangle, 							clear entire visibleRectangle"							destinationForm								fill: visibleRectangle								rule: rule								mask: Form white]						ifFalse: [destinationForm								fill: ((visibleRectangle left @ newY extent: visibleRectangle extent)										intersect: visibleRectangle)								rule: rule								mask: Form white]]]!size	^ text size!string	^text == nil ifTrue: [String new] ifFalse: [text string]!text: aText 	"Set the argument, aText, to be the text for the receiver."	text _ aText.	firstChar _ nil.	self composeAll! !!BigParagraph methodsFor: 'display box access'!boundingBox	"I don't know how big my entire text is."	self shouldNotImplement!computeBoundingBox	"I don't know how big my entire text is."	self shouldNotImplement! !!BigParagraph methodsFor: 'composition'!composeAll	"Compose the visible text, starting at firstChar."	text size = 0 ifTrue:		[firstChar _ lastChar _ nil.		lastLine _ 0.		^0].	firstChar == nil ifTrue: [firstChar _ 1].	lines _ Array new: 32.	^self partialComposeFromY: 0 line: 1 char: firstChar!composeFrom: start to: stop	"compose and return some lines starting with start in text"	| lineIndex startIndex stopIndex compositionScanner newLine newLines |	lineIndex _ 1.	startIndex _ start.	stopIndex _ stop.	newLines _ OrderedCollection new.	compositionScanner _ CompositionScanner new in: self.	[stopIndex >= startIndex] whileTrue: 		[newLine _ compositionScanner composeLine: lineIndex 									fromCharacterIndex: startIndex 									inParagraph: self.		newLines add: newLine. 		startIndex _ newLine last + 1.		lineIndex _ lineIndex + 1].	startIndex > stopIndex ifTrue: [newLine stop: stopIndex].	^newLines!composeMoreLines: numberOfLines	"Compose numberOfLines more off the end of the currently visible text, return the number of lines actually composed"	| lineIndex startIndex stopIndex numActualLines continue compositionScanner newLine |	lineIndex _ lastLine + 1.	startIndex _ lastChar + 1.	stopIndex _ text size.	numActualLines _ 0.	continue _ true.	compositionScanner _ CompositionScanner new in: self.	[continue and: [stopIndex >= startIndex]] whileTrue: 		[newLine _ compositionScanner composeLine: lineIndex 									fromCharacterIndex: startIndex 									inParagraph: self.		continue _ (numActualLines _ numActualLines + 1) < numberOfLines.		self lineAt: lineIndex put: newLine. 		startIndex _ newLine last + 1.		lineIndex _ lineIndex + 1].	lastChar _ startIndex - 1.	self trimLinesTo: lineIndex - 1.	^numActualLines!partialComposeFromY: yPos line: lineStartIndex char: startCharIndex	"Compose the visible text, starting at firstChar."	| startIndex stopIndex lineIndex maximumRightX compositionScanner maxLineY totalLineY continue newLine grid |	grid _ textStyle lineGrid.	maxLineY _ self visibleRectangle height truncateTo: grid.    "How many lines fit in display"	lastLine _ 0.	maximumRightX _ 0.	lineIndex _ lineStartIndex.	startIndex _ startCharIndex.	stopIndex _ text size.	totalLineY _ yPos.	continue _ true.	compositionScanner _ CompositionScanner new in: self.	[continue and: [stopIndex >= startIndex]] whileTrue: 		[newLine _ compositionScanner composeLine: lineIndex 									fromCharacterIndex: startIndex 									inParagraph: self.		totalLineY _ totalLineY + grid.		continue _ totalLineY  < maxLineY.		self lineAt: lineIndex put: newLine. 		maximumRightX _ compositionScanner rightX max: maximumRightX.		startIndex _ (lines at: lineIndex) last + 1.		lineIndex _ lineIndex + 1].	firstChar _ (lines at: 1) first.	lastChar _ startIndex-1.	self trimLinesTo: lineIndex - 1.	^maximumRightX!recomposeIn: compositionRect clippingBox: clippingRect 	"Set the composition rectangle for the receiver so that the lines wrap	within the rectangle, compositionRect, and the display of the text is	clipped by the rectangle, clippingRect."	clippingRectangle _ clippingRect copy.	self compositionRectangle: compositionRect copy		text: text		style: textStyle		offset: offset		outputMedium: textStyle outputMedium		fitWidth: false.	self composeAll! !!BigParagraph methodsFor: 'character location'!characterBlockForIndex: targetIndex 	"Answer a CharacterBlock for character in the text at targetIndex.  The 	coordinates in the CharacterBlock will be appropriate to the intersection of	the destinationForm rectangle and the compositionRectangle.	Return a fairly off-the-wall value if the character is not displayed."	| index |	firstChar isNil ifTrue:		[ ^CharacterBlock			stringIndex: targetIndex			character: nil			topLeft: compositionRectangle origin			extent: 0 @ textStyle lineGrid ].	targetIndex < firstChar ifTrue:		[ ^CharacterBlock			stringIndex: targetIndex			character: (text at: targetIndex)			topLeft: clippingRectangle origin - (0@99)    "way up there"			extent: 0@0 ].	(targetIndex > lastChar) & (lastChar < text size) ifTrue:		[^CharacterBlock			stringIndex: targetIndex			character: (targetIndex <= text size				ifTrue: [text at: targetIndex]				ifFalse: [nil])			topLeft: clippingRectangle corner + (0@99)    "way down there"			extent: 0@0 ].	^CharacterBlockScanner new characterBlockForIndex: targetIndex in: self! !!BigParagraph methodsFor: 'selecting'!dyForPoint: pt	"See if pt is above or below clippingRectangle, return scroll amount"	| dy dyLim |	((dy _ pt y - clippingRectangle top) < 0 and:	[firstChar ~= 1]) ifTrue:		[^dy - textStyle lineGrid].	((dy _ pt y - clippingRectangle bottom) > 0 and: 	[lastChar ~= text size]) ifTrue:		[^dy + textStyle lineGrid].	^0! !!BigParagraph methodsFor: 'scrolling'!getBackwardsNumLines: numLinesNeed	| tryThisFirst magicalNumber aCharacterIndex para linesGot newLines |	magicalNumber _ self charactersShown // (lastLine - 3 max: 1).	aCharacterIndex _ firstChar - 1 - (numLinesNeed * magicalNumber).	[tryThisFirst _ "(aCharacterIndex isKindOf: LargePositiveInteger)		ifTrue: [self spacePriorTo: aCharacterIndex]		ifFalse: ["self logicalStartPriorTo: aCharacterIndex"]".	newLines _ self composeFrom: tryThisFirst to: (firstChar - 1 max: 1).	linesGot _ newLines size.	(linesGot >= numLinesNeed or: [tryThisFirst = 1])]		whileFalse: [aCharacterIndex _ tryThisFirst - (numLinesNeed - linesGot + 1 * magicalNumber)].	^newLines copyFrom: (linesGot - numLinesNeed + 1 max: 1) to: linesGot!logicalStartPriorTo: startIndex	| s | 	s _ text string.	startIndex - 1 to: 1 by: -1 do: [:i |		(s at: i) == CR ifTrue: [^i + 1]].	^1"self spacePriorTo: startIndex"!moveDown: linesToMove grid: lineGrid display: displayResults	| newTopLines linesMoved newLines |	firstChar = 1 ifTrue: [^self].	newTopLines _ self getBackwardsNumLines: linesToMove.	newLines _ Array new: ((clippingRectangle height truncateTo: lineGrid) // lineGrid).	linesMoved _ newTopLines size.	linesMoved + 1 to: newLines size do:		[:i | i - linesMoved > lastLine ifFalse: [newLines at: i put: (lines at: i - linesMoved)]].	1 to: linesMoved do: [:i | newLines at: i put: (newTopLines at: i)].	lines _ newLines.	lastLine _ lines size min: lastLine + linesMoved.	firstChar _ lines first first.	lastChar _ (lines at: lastLine) last.	"Scroll the lines that remain down, and display the new ones."	displayResults ifTrue:		[destinationForm 			copyBits: clippingRectangle			from: destinationForm			at: clippingRectangle origin + (0@(linesMoved*textStyle lineGrid))			clippingBox: clippingRectangle 			rule: Form over 			mask: Form black.		self displayLines: (1 to: linesMoved)]!moveUp: linesToMove grid: lineGrid	| actuallyMoved |	lastChar = text size ifTrue: [^self].  "already at end"	actuallyMoved _ self composeMoreLines: linesToMove.	actuallyMoved = 0 ifTrue: [^self].	(lastChar = text size and: [linesToMove > actuallyMoved]) ifTrue: [actuallyMoved _ actuallyMoved + 1].	1 to: lastLine - actuallyMoved do:		[:i | lines at: i put: (lines at: actuallyMoved + i)].	self trimLinesTo: lastLine - actuallyMoved.	firstChar _ lines first first.	lastChar _ (lines at: lastLine) last.	"Scroll the lines that will remain, and display the new ones."	destinationForm 		copyBits: (clippingRectangle origin + (0@(actuallyMoved * lineGrid))					corner: clippingRectangle corner)		from: destinationForm		at: clippingRectangle origin		clippingBox: clippingRectangle 		rule: Form over 		mask: Form black.	self displayLines: (lastLine - actuallyMoved to: lastLine)!scrollBy: height grid: lineGrid	"Scroll down if height is negative, otherwise up.  Height is the number of pixels to scroll"	| linesToMove |	(firstChar == nil or: [lastChar == nil]) ifTrue: [^self].	linesToMove _ ((height abs between: 0 and: lineGrid)			ifTrue: [1]			ifFalse: [(height abs truncateTo: lineGrid) // lineGrid]).	height < 0 ifTrue: [^self moveDown: linesToMove grid: lineGrid display: true].	self moveUp: linesToMove grid: lineGrid!scrollTo: aCharacterIndex	"Display me so the character in text at aCharacterIndex is the first character displayed."	| linesToMove linesNeeded linesSinceFound startIndex stopIndex compositionScanner newLine continue cutLines | 	text size = 0 ifTrue: [^self].	firstChar _		(aCharacterIndex = 1 ifTrue: [1]			ifFalse:				["(aCharacterIndex isKindOf: LargePositiveInteger)					ifTrue: [self spacePriorTo: aCharacterIndex]					ifFalse: ["self logicalStartPriorTo: aCharacterIndex"]"]).	linesNeeded _ self linesInWindow.	lines _ OrderedCollection new.	lastLine _ 0.	linesSinceFound _ 0.	startIndex _ firstChar.	stopIndex _ text size.	compositionScanner _ CompositionScanner new in: self.	[linesSinceFound < linesNeeded and: [stopIndex >= startIndex]] whileTrue: 		[newLine _ compositionScanner composeLine: 1 "it doesn't use it" 									fromCharacterIndex: startIndex 									inParagraph: self.		lines add: newLine. 		(linesSinceFound = 0 and: [newLine last < aCharacterIndex])				ifFalse: [linesSinceFound _ linesSinceFound + 1].		continue _ linesSinceFound >= linesNeeded.		startIndex _ newLine last + 1].	"take either the last linesNeeded lines, or if at end of text, whatever is available"	lines _ lines asArray.	linesSinceFound < linesNeeded		ifTrue: "ran into the end of text before the desired line got to the top"			[(cutLines _ lines size - linesNeeded + 1) > 0				ifTrue: "need to take off just enough lines to leave only one empty one at the bottom"					[lastLine _ linesNeeded - 1.					1 to: lastLine do: [:i | lines at: i put: (lines at: i + cutLines)]]				ifFalse:					[lastLine _ lines size.					cutLines < 0 ifTrue: "don't have enough lines for window"						[firstChar _ (lines at: 1) first.						self trimLinesTo: lastLine.						lastChar _ (lines at: lastLine) last.						self moveDown: cutLines abs grid: textStyle lineGrid display: false]]]		ifFalse: "will have a full window with the desired line at the top"			[lastLine _ linesNeeded.			(cutLines _ lines size - linesNeeded) > 0 ifTrue:					[1 to: linesNeeded do: [:i | lines at: i put: (lines at: i + cutLines)]]].	firstChar _ (lines at: 1) first.	self trimLinesTo: lastLine.	lastChar _ (lines at: lastLine) last.	self clearVisibleRectangle.	self displayLines: (1 to: lastLine)!selectAndScrollFrom: start to: stop	| totalLines startLineIndex stopLineIndex linesToMove usedStartLineIndex |	totalLines _ clippingRectangle height // textStyle lineGrid.	[startLineIndex _ self lineIndexOfCharacterIndex: start.	(startLineIndex > lastLine and: [startLineIndex ~= usedStartLineIndex])] whileTrue:		[lastChar = text size ifTrue: [^self].  "don't scroll off end!!"		"no old text remains; compute new text:"		 usedStartLineIndex _ startLineIndex.		 startLineIndex - lastLine > totalLines			ifTrue: [self scrollTo: (start min: text size - (self charactersShown //2))					"self partialComposeFromY: 0 line: 1 char: (lastChar + 1).					self clearVisibleRectangle.					self displayLines: (1 to: lastLine)"]			ifFalse: [self moveUp: startLineIndex - lastLine grid: textStyle lineGrid]].	"scroll the old lines of text and add new ones."	startLineIndex _ self lineIndexOfCharacterIndex: start.	stopLineIndex _ self lineIndexOfCharacterIndex: (stop min: text size).	linesToMove	_ (stopLineIndex <"=" lastLine or: [startLineIndex <= (lastLine //2)])		ifTrue: [0]		ifFalse: [startLineIndex - (lastLine//2) max: 0].	(startLineIndex <= lastLine and: [linesToMove > 0])		ifTrue: [self moveUp: linesToMove grid: textStyle lineGrid].!spacePriorTo: startIndex	| s | 	s _ text string.	startIndex - 1 to: 1 by: -1 do: [:i |		((s at: i) == Space or: [(s at: i) == CR]) ifTrue: [^i + 1]].	^1! !!BigParagraph methodsFor: 'indicating'!outline 	"Display a border around the visible area in which the receiver 	presents its text."	Display 		border: (clippingRectangle intersect: destinationForm boundingBox)		width: 2! !!BigParagraph methodsFor: 'utilities'!fit	"Eek!!  I shouldn't do this."	self flash! !!BigParagraph methodsFor: 'converting'!asForm	"I shouldn't do this."	self shouldNotImplement!asPressParagraph	"I shouldn't do this."	self shouldNotImplement! !!BigParagraph methodsFor: 'private'!alignFirstChar	"Make sure that firstChar falls at the beginning of a word."	[ firstChar=1 or: [(text at: firstChar-1) isSeparator] ] whileFalse:		[ firstChar _ firstChar-1 ]!bottomAtLineIndex: lineIndex	"bottom y of given line"	^clippingRectangle top + (lineIndex * textStyle lineGrid)!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint outputMedium: aSymbol fitWidth: aBoolean	| paddingDelta lineIndex |	compositionRectangle _ compositionRect copy.	text _ aText.	textStyle _ aTextStyle.	firstIndent _ textStyle firstIndent.	restIndent _ textStyle restIndent.	rightIndent _ textStyle rightIndent.	marginTabsLevel _ 0.	outputMedium _ aSymbol.	rule _ DefaultRule.	mask _ DefaultMask.	destinationForm _ Display.	lines _ Array new: 32.	lastLine _ 0.	offset _ aPoint	"...and don't recompose."!displayLines: linesInterval 	"We're pretty sure that all lines are visible, so display them"	| lineGrid visibleRectangle topY firstLineIndex lastLineIndex lastLineIndexBottom scanner |	lineGrid _ textStyle lineGrid.	visibleRectangle _ self visibleRectangle.	firstLineIndex _ linesInterval first max: 1.	lastLineIndex _ linesInterval last min: lastLine.	topY _ self topAtLineIndex: firstLineIndex.	lastLineIndexBottom _ self bottomAtLineIndex: lastLineIndex."Set boundingBox containing the lines in linesInterval to color for space surrounding the characters."	destinationForm	  fill: ((visibleRectangle left @ topY 				extent: visibleRectangle width @ (lastLineIndexBottom - topY))		  	intersect: visibleRectangle)	  rule: rule	  mask: Form white.	scanner _ DisplayScanner new.	"DisplayMode represents how the user wants the lines displayed. Options are: #preview or #display. If the outputMedium is #Display, then the DisplayMode is defaulted to #display. For #PressPrinter, it is #preview. For #DisplayPrinterWidths, it can be either one.""	(outputMedium == #DisplayPrinterWidths and: [self class displayMode == #display])		ifTrue: [scanner	  				displayLines: (firstLineIndex to: lastLineIndex)	  				in: self	  				boundedBy: visibleRectangle]		ifFalse: [scanner	  				displayLines: (firstLineIndex to: lastLineIndex)	  				in: self	  				clippedBy: visibleRectangle]."	scanner displayLines: (firstLineIndex to: lastLineIndex)	  		in: self	  		clippedBy: visibleRectangle.	lastLineIndex = lastLine		ifTrue: 		 [destinationForm		  fill: (visibleRectangle left @ lastLineIndexBottom 				extent: visibleRectangle width @					(visibleRectangle bottom - lastLineIndexBottom))		  rule: rule		  mask: Form white]!leftMarginForCompositionForLine: lineIndex	"Build the left margin for composition of a line. 	Depends upon marginTabsLevel and the indent."	^super leftMarginForCompositionForLine: lineIndex	"| scale |	outputMedium = #DisplayPrinterWidths		ifTrue:	[scale _ PressFile pressScale]		ifFalse:	[scale _ 1].	(firstChar = 1 and: [lineIndex = 1])		ifTrue: [^(firstIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]		ifFalse: [^(restIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]"!lineIndexOfCharacterIndex: characterIndex 	"line index for a given characterIndex"	firstChar == nil ifTrue: [^0].	characterIndex < firstChar ifTrue: [^-99].    "not visible -- above"	1 to: lastLine do: 		[:lineIndex | 		(lines at: lineIndex) last >= characterIndex ifTrue: [^lineIndex]].	characterIndex = (lastChar + 1) ifTrue: [^lastLine].	characterIndex > lastChar ifTrue: [^99 + lastLine].    "not visible -- below"!linesInWindow	"Return the number of lines that will fit in the visible window."	"^ (self visibleRectangle height asFloat / textStyle lineGrid) ceiling"^ ((self visibleRectangle height truncateTo: textStyle lineGrid) // textStyle lineGrid)!removeFirstChars: numberOfChars	"Remove a number of characters from the beginning of the receiver, adjusting the composition rectangle so the displayed text moves as little as possible.  Special kludge for TextCollectorController."	self replaceFrom: 1 to: numberOfChars with: Text new displaying: false.	firstChar <= numberOfChars		ifTrue:			[firstChar _ 1.			self composeAll; clearVisibleRectangle;				displayLines: (1 to: lastLine) ]		ifFalse:			[firstChar _ firstChar - numberOfChars]!repositionAt: aPoint clippingBox: clippingBox	compositionRectangle moveTo: aPoint.	self clippingRectangle: clippingBox.!topAtLineIndex: lineIndex 	"top y of given line"	^self bottomAtLineIndex: lineIndex - 1!updateCompositionHeight	"Don't do it!!"	self shouldNotImplement!visibleRectangle	^ (compositionRectangle left @ clippingRectangle top corner: compositionRectangle right @ clippingRectangle bottom) intersect: destinationForm boundingBox"clippingRectangle intersect: destinationForm boundingBox"! !!BigParagraph methodsFor: 'printing'!pressOn: aPressFile	"I shouldn't to this."	self shouldNotImplement! !StructureParagraph comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!StructureParagraph methodsFor: 'selecting'!reverseRectangle: aRectangle	"Highlight the part of aRectangle which is visible"	| rect rect2|	rect _ (aRectangle left -2 @(aRectangle top +2) corner: (aRectangle right + 2 @ aRectangle bottom))" intersect: self visibleRectangle".	destinationForm fill: rect rule: Form reverse mask: mask.	destinationForm fill: (rect moveBy: 1@-1) rule: Form reverse mask: mask.! !FieldParagraph comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!FieldParagraph methodsFor: 'accessing'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Before doing the replace, make sure that no protectedFields are being altered."	| size index replacementRange line |	size _ protectedFields size.	index _ 1.	[(index > size) or: [(protectedFields at: index) last >= start]]		whileFalse: [index _ index + 1].	index <= size ifTrue:		[((protectedFields at: index) first <= start or: [(protectedFields at: index) first <= stop])			ifTrue:				[((protectedFields at: index) first = start and: [stop + 1 = start and: [stop ~~ 0]])					ifFalse:    "don't let them replace"						[line _ self lineIndexOfCharacterIndex: start.						self displayLines: (line to: line).						^false]].		"slide all following fields over"		replacementRange _ aText size - (stop - start + 1).		index to: size do:			[:i |			protectedFields at: i put:				((protectedFields at: i) first + replacementRange					to: (protectedFields at: i) last + replacementRange)]].	super replaceFrom: start to: stop with: aText displaying: displayBoolean! !!FieldParagraph methodsFor: 'field access'!fieldEmphasis: aFontNumber	"Make all my protected fields appear in the font, aStrikeFont."	protectedFields do:		[:each |		text emphasizeFrom:			each first + ( (text at: each first) isSeparator ifTrue: [1] ifFalse: [0] )		to:			each last + ( (text at: each last) isSeparator ifTrue: [-1] ifFalse: [0] )		with: aFontNumber ]!nextOpenFieldAfter: pos	"Answer the next open (unprotected) interval after the position given."	| size index | 	(size _ protectedFields size) = 0 ifTrue:		[^ 1 to: text size]."find the first interval which ends after the position"	index _ 1.	[index > size or: [(protectedFields at: index) last >= pos]]		whileFalse:			[index _ index+1].	index = size ifTrue:		[^ (protectedFields at: index) last +1 to: text size].	index > size ifTrue:    "wrap-around"		[(protectedFields at: 1) first = 1			ifTrue: [index _ 1]			ifFalse: [^ 1 to: (protectedFields at: 1) first -1]].	^ (protectedFields at: index) last +1 to: (protectedFields at: index+1) first - 1!openFieldContaining: pos	"Answer the next open (unprotected) interval after the position given."	| size index |	(size _ protectedFields size) = 0 ifTrue:		[ ^ 1 to: text size ]."find the first interval which ends after the position"	index _ 1.	[ (index > size) or: [(protectedFields at: index) last >= pos] ]		whileFalse:			[ index _ index+1 ].	( index > size or: [(protectedFields at: index) first > pos] )		ifTrue:			[ index _ index-1 ].      "within open field, so select after previous one"	index = size ifTrue:    "else return next open field"			[ ^ (protectedFields at: index) last +1 to: text size ].	index > size ifTrue:    "wrap-around"		[ (protectedFields at: 1) first =1			ifTrue:				[ index _ 1 ]			ifFalse:				[ ^ 1 to: (protectedFields at: 1) first -1 ] ].	^ (protectedFields at: index) last +1 to: (protectedFields at: index+1) first -1!protectedFields	"Answer an OrderedCollection of my protected fields."	^ protectedFields!protectedFields: fieldList	"Set my protected fields to the intervals in the OrderedCollection I am passed."	protectedFields _ fieldList asOrderedCollection!setProtectedFields	"Try to set up the protected fields based on my string.	I will protect lines ending in colons."	| str start ch |	protectedFields _ OrderedCollection new.	str _ ReadStream on: text string.	start _ 1.	[str atEnd] whileFalse:		[ch _ str next.		start > 0 ifTrue:    "got a start; have we found the stop?"			[ch = $: ifTrue:    "indeed!!"				[ [(ch _ str peek)=Character space | (ch=Character tab)]					whileTrue: [str next].   "protect tabs/spaces, if any"				protectedFields add: (start to: str position).				start _ 0].			ch = Character cr ifTrue:				[start _ 0] ]		ifFalse:			[ch = Character cr ifTrue:				[start _ str position] ].		]!valueList	"Return an OrderedCollection of the values (text following fields)	in the paragraph."	| values last |	values _ OrderedCollection new.	protectedFields notNil ifTrue:		[1 to: protectedFields size do:			[ :i |			last _ (i=protectedFields size)				ifTrue: [text size] ifFalse: [(protectedFields at: i+1) first -1].			values add:				(text string					copyFrom: (protectedFields at: i) last +1 to: last) ] ].	^ values! !!FieldParagraph methodsFor: 'selecting'!selectWord: stringIndex	"Select the entire field (not a word)."	| field |	field _ self openFieldContaining: stringIndex.	^ field first to: field last +1! !!FieldParagraph methodsFor: 'private'!queryElementsFor: selectionIndex 	| numFields field return |	return _ Array new: 2. 	(numFields _ protectedFields size) = 0 ifTrue: [^1 to: text size].	field _ 1.	[field > numFields or: [(protectedFields at: field) last >= selectionIndex]]		whileFalse: [field _ field + 1].	(field > numFields or: [(protectedFields at: field) first > selectionIndex])		ifTrue: [field _ field - 1].	field = numFields		ifTrue: 			[return at: 1 put: (self trimName: (text copyFrom: (protectedFields at: field) first to: (protectedFields at: field) last)).			return at: 2 				put: (text copyFrom: (protectedFields at: field) last + 1 to: text size) asString.			^return].	field > numFields ifTrue: [(protectedFields at: 1) first = 1			ifTrue: [field _ 1]			ifFalse: 				[return at: 1 put: (self trimName: (text copyFrom: (protectedFields at: field) first to: (protectedFields at: field) last)).				return at: 2 put: (text copyFrom: 1 to: (protectedFields at: 1) first - 1) asString.				^return]].	return at: 1 put: (self trimName: (text copyFrom: (protectedFields at: field) first to: (protectedFields at: field) last)).	return at: 2 put: (text copyFrom: (protectedFields at: field) last + 1 to: (protectedFields at: field + 1) first - 1) asString.	^return!text: aText fields: fields emphasis: emphasis	text _ aText.	self protectedFields: fields.	self fieldEmphasis: emphasis.	self composeAll!trimName: aString 	| theStream outStream aStream char |	theStream _ ReadStream on: aString.	outStream _ WriteStream on: String new.	[theStream atEnd]		whileFalse: 			[char _ theStream next.			char = $: ifTrue: [^outStream contents].			char = Character cr | (char = Character space) ifFalse: [outStream nextPut: char]]! !!TextList methodsFor: 'private'!leftMarginForCompositionForLine: lineIndex	"Build the left margin for composition of a line. 	Depends upon marginTabsLevel and the indent.	Copy of original from Paragraph"	| scale |	outputMedium = #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	lineIndex = 1		ifTrue: [^(firstIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]		ifFalse: [^(restIndent + (textStyle leftMarginTabAt: marginTabsLevel)) * scale]! !PreviewPage comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.PreviewPage is a page layout system where the text may flow around rectangles (see class RectForm) to produce what-you-see-is-what-you-get print out either in press or in interpress format from the screen.  Instance Variables========[pageNumber] 			it is initialized to be 1 and always indicates the current page number.[pageNumberForm]		it is simply a form of the pageNumber so that it could be displayed at the page break box fast.  [charIndex]			 	it is an array that stores the first character position and the last character position of each composed page.  The character position is the character index in the text.[pageBreak]				it is also an array that keeps track of where the pageBreak is.  [justifyIndex]			it is an array where each element is the run array for the page.  It keeps track of all justification information for the text.[pictureLocation]			this variable is an array which keep a list of orderedCollections of the class RectForm.  Basically, the index to the pictureLocation will return an OrderedCollection of RectForm (pictures, rectangles, etc.) on the indexed page.[purgeList]				this variable keeps all information about the RectForms you have deleted from the screen.  Furthermore, it is accessed when the user ask to get a picture from a list.[rMargin]				this is the right margin for the line when composing.  [lMargin]				this is the left margin for the line when composing.  This information is then stored in the TextLineInterval for later use.[runs]					this variable is the run array for the whole text.  It keeps track of font and run informations.[pageRect]				this is actually the view insetDisplayBox but since the preview cannot talk to the view so I need to keep it around.[var]					it is a dictionary where more variables are kept.  		{defaultMargins}	it is the margin for the page usually 1 inch for the top, bottom, and left. .75 inch for the right margin.  This is kept in the press units where the users is in.		{bufferSize}		this is the size of the text where the program reads in to compose.  It should be noted that the size on every page may be much less than the bufferSize but you still need to take that much ext in.		{printerOffset}	this is the offset for various printer since each printer could start at different location on the paper this should accomodate the differences.  It defauls to 0@0.		{recompose}		this is the flag which tell the program whether or not to recompose the current page.   Recompose is true whern you do any operation that affects the size of the rectangles on the screen.		{normalMode}		this is also a flag that tells the program whether it is in the normal mode with text or the graphic layout mode where you only see pictures and rectangles.		{majorHeading}	this keep the majorHeading text.  When you do a hardcopy to the printer the program will ask the user for a majorHeading which the program will memorize.		{minorHeading}	see above, the same almost.		{columns}			this is the integer from 1 to 4 which is the number of columns of the current preview page.		{gutter}			this is the integer which defines the space in screen units between each column. 		{saved}			this is the flag which indicates whether to save the information or not.[diskFile]				this is the fileStream which points to the file on the disk (virtual memory!! Wow)classVariable======[Grid] 					this is the gridding of the preview page.  The vertical should always be 16 but the horizontal(x) could be any valid integer.'!!PreviewPage methodsFor: 'initialize-release'!getRuns: aFile 	| size pos run |	aFile position: (size _ aFile size) - 1.	pos _ size - 1.	[pos <= 0 | (aFile next asciiValue = 255)]		whileFalse: 			[pos _ pos - 1.			aFile position: pos].	aFile position: pos + 1.	run _ Compiler evaluate: (aFile next: size - pos - 1).	var at: #endText put: pos.	^run!growVariables	charIndex grow.	pictureLocation grow.	justifyIndex grow.	pageBreak grow.	(var at: #tabs) grow!initialize	| s originalTabs tabsArray | 	outputMedium _ #DisplayPrinterWidths.	textStyle outputMedium: #DisplayPrinterWidths; lineGrid: Grid y.	rule _ Form under.	charIndex _ Array new: 16.	pictureLocation _ Array new: 16.	justifyIndex _ Array new: 16.	pageBreak _ Array new: 16.	selectedList _ nil.	purgeList _ OrderedCollection new.	pageNumber _ 1.	pageNumberForm _ pageNumber printString asParagraph asForm.	(var _ OopConservingDictionary new)		at: #defaultMargins put: (DefaultMargins at: PressOrInterpress);		at: #printerOffset put: 0 @ 0;		at: #recompose put: false;		at: #majorHeading put: String new;		at: #minorHeading put: String new;		at: #columns put: 1;		at: #gutter put: 20;		at: #endText put: 0;		at: #saved put: true;		at: #grid put: Grid.	s _ textStyle class == PrintStyle ifTrue: [1] ifFalse: [79.375 * textStyle pressScale /72].	originalTabs _ textStyle tabsArray.	tabsArray _ Array new: 2.	1 to: tabsArray size do: [:i |		tabsArray at: i put: ((originalTabs at: i) *s) asInteger].	var at: #tabsArray put: (Array with: tabsArray with: (Array new: tabsArray size withAll: 1)).	var at: #tabUnit put: #points.	lMargin _ rMargin _ 0.	self resetTabs!initializeFirstPage	"just got the window open - need to initialize things"	| txtfname backtxtfname | 	txtfname _ (var at: #suitcase) dataItem filename, (DataMaster giveMe: #specialSuffixString for: #preview asString).	backtxtfname _ (var at: #suitcase) dataItem filename, (DataMaster previewSuffixFor: #backupText).	(Disk includesKey: backtxtfname) "is there a backup file there?"		ifTrue: [Disk removeKey: txtfname. "assume I crashed, replace the current .txt file with the backup one"				Disk renameKey: backtxtfname newName: txtfname].	(HeaderFileStream fileNamed: txtfname) removeHeader. "remove any header, new .txt file passed from text window would have"	(diskFile _ FileStream oldFileNamed: txtfname) readOnly.	runs ==nil ifTrue: [runs _ self getRuns: diskFile]. "need to get runs from here if brand new or old format preview"	(charIndex at: pageNumber) == nil "get text from diskFile"		ifTrue: [self getFileText]		ifFalse: [self getFileTextFrom: (charIndex at: pageNumber) first to: (charIndex at: pageNumber) last]!initTabsFrom: arrOfTabsInInches	"PreviewPage someInstance initTabsFrom: #(1 2)"	| inch tabsArray |	inch _ "79.375"72 * textStyle pressScale.	tabsArray _ Array new: arrOfTabsInInches size.	1 to: tabsArray size do: [:i |		tabsArray at: i put: ((arrOfTabsInInches at: i) * inch) asInteger].	var at: #tabsArray put: (Array with: tabsArray with: (Array new: tabsArray size withAll: 1)).	(var at: #tabPool) at: 1 put: (var at: #tabsArray)!nilAllFrom: int	| tabs |  	tabs _ var at: #tabs.	int to: charIndex size		do: [:i | charIndex at: i put: nil.				justifyIndex at: i put: nil.				pageBreak at: i put: nil.				tabs at: i put: nil].!nilCharacterIndexFrom: int 	int to: charIndex size do: 		[:i | charIndex at: i put: nil]!nilFrom: int	| tabs |  	tabs _ var at: #tabs.	int to: charIndex size		do: [:i | charIndex at: i put: nil.				justifyIndex at: i put: nil.				tabs at: i put: nil].	self findLastGraphicPage + 1 to: charIndex size		do: [:i | pageBreak at: i put: nil]!release	"the user has decided to close down the preview and no changes had been made.	 if there is a backup file (there shouldn't be), delete it.	 if this is a temporary preview, then delete both files"	| txtFileName | 	diskFile == nil ifFalse:		[txtFileName _ diskFile name.		diskFile close; release.		Disk removeKey: (var at: #suitcase) dataItem filename, (DataMaster previewSuffixFor: #backupText) ifAbsent: [].		((txtFileName findString: #TMPV asString startingAt: 1) ~= 0 and: [(var at: #suitcase) dataItem centerIndex = 0])			ifTrue: [Disk removeKey: (var at: #suitcase) dataItem filename ifAbsent: []. "destroy temporary files"					Disk removeKey: txtFileName ifAbsent: []]].	^true! !!PreviewPage methodsFor: 'accessing'!compositionRectangle: aRectangle	"this is here so that it does not compose twice when first started up"	compositionRectangle _ aRectangle!currentOption	| defaults margins constant |	defaults _ OrderedCollection new.	margins _ var at: #defaultMargins.	constant _ 79.375 * textStyle pressScale.	defaults add: (margins top / constant) printString; add: (margins bottom / constant) printString; add: (margins right / constant) printString; add: (margins left / constant) printString; add: (var at: #columns) printString; add: (var at: #gutter) printString; add: (var at: #tabUnit); add: ((var at: #grid) y asFloat / Grid y) printString.	^defaults!diskFile	^diskFile!diskFile: aFile	diskFile _ aFile!firstCharacter	"Answer the index in text of the first displayed character."	(charIndex at: pageNumber)		== nil		ifTrue: [^nil]		ifFalse: [^(charIndex at: pageNumber) first]!firstPageCharacter	^(lastLine = 0 or: [lines == nil or: [lines first == nil]])		ifTrue: [nil]		ifFalse: [lines first first]!lastPageCharacter	^(lines == nil		or: [lastLine = 0			or: [lastLine == nil or: [(lines at: lastLine) == nil]]])		ifTrue: [nil]		ifFalse: [(lines at: (lastLine min: self maxLines)) last]!margins	^lMargin@rMargin!maxLines	| colList | 	colList _ self getColumns.	^((colList at: 1) height // (var at: #grid) y) * colList size!pageNumber	^pageNumber!pageRect	^pageRect!pageRect: aRect	pageRect _ aRect!runs	^runs!textSize	^var at: #endText!var	^var! !!PreviewPage methodsFor: 'rectangle'!addRectangle: aRect	| r | 	(pictureLocation at: pageNumber) == nil		ifTrue: [pictureLocation at: pageNumber put: OrderedCollection new].	r _ RectForm rectangle: aRect.	(pictureLocation at: pageNumber) add: r.	var at: #recompose put: true; at: #saved put: false.	self updateRectForm: r!addRectangle: aRect form: picture fileName: fileName scale: aScale	| r | 	(pictureLocation at: pageNumber) == nil		ifTrue: [pictureLocation at: pageNumber put: OrderedCollection new].	r _ RectForm			rectangle: aRect			form: picture			fileName: fileName			scale: aScale.	(pictureLocation at: pageNumber) add: r.	var at: #recompose put: true; at: #saved put: false.	self updateRectForm: r!adjustRectangle: aRect 	"it takes an absolute screen coordinate and transform it into a relative    	paragraph clipping coordinate"	| rect off |	off _ clippingRectangle origin y - pageRect origin y rem: 8.	rect _ aRect translateBy: 0 - pageRect origin.	rect moveTo: (rect left / 16) rounded * 16 @ ((rect top / 16) rounded * 16) + (0@off).	"rect corner: ((rect right / 16) ceiling * 16 min: pageRect width)			@ ((rect bottom / 16) ceiling * 16 min: pageRect height // 16 * 16)."	^rect!changeRectangleAt: aPoint	| return | 	return _ self modifyRectangleContaining: aPoint.	self validateRectangle: (return at: 2) type: (return at: 1).	self updateRectForm: selectedList.!displayRectangleDots	| aRect |	aRect _ (selectedList translateBy: pageRect origin) insetBy: 4 @ 4.	Display fill: (self rectangleAt: aRect topCenter width: 8) rule: Form reverse mask: Form gray.	Display fill: (self rectangleAt: aRect rightCenter width: 8) rule: Form reverse mask: Form gray.	Display fill: (self rectangleAt: aRect leftCenter width: 8) rule: Form reverse mask: Form gray.	Display fill: (self rectangleAt: aRect bottomCenter width: 8) rule: Form reverse mask: Form gray.	Display fill: (self rectangleAt: aRect center width: 8) rule: Form reverse mask: Form gray!eraseRectangleOutside: aRect 	| firstCollections secondCollections temp |	(firstCollections _ OrderedCollection new) add: aRect.	secondCollections _ OrderedCollection new.	(pictureLocation at: pageNumber) == nil		ifFalse: [(pictureLocation at: pageNumber) do: 		[:each | 		firstCollections do: 			[:me | 			temp _ me areasOutside: (each translateBy: pageRect origin).			temp size > 1				ifTrue: [temp do: [:i | secondCollections add: i]]				ifFalse: [secondCollections add: me]].		firstCollections _ secondCollections copy.		secondCollections _ OrderedCollection new]].	firstCollections do: [:eachRect | Display white: eachRect]!getRectangle	| r |	r _ Rectangle fromUser: 8@8 gridOrigin: pageRect origin.	(r intersects: pageRect)		ifTrue: [r _ pageRect intersect: r]		ifFalse: [^false].	r _ r translateBy: 0 - pageRect origin."	(pictureLocation at: pageNumber) == nil		ifFalse: [(pictureLocation at: pageNumber)					do: [:any | (any opaque and: [(any rectangle intersects: r)]) ifTrue: [^false]]]."	self addRectangle: r.	^true!modifyRectangleContaining: aPoint	| aRect width r sides whereabouts pt one sideRect centerPt newRect thisPoint | 	width _ selectedList extent // 6.	aRect _ selectedList insetBy: width.	Display lightGray: (r _ selectedList translateBy: pageRect origin).	"sides contains top, bottom, left and right"	sides _ r areasOutside: (r insetBy: 2).	sides add: r.	whereabouts _ #(topCenter bottomCenter leftCenter rightCenter center).	1 to: whereabouts size do: [:i |		pt _ aRect perform: (whereabouts at: i).		(pt - width <= aPoint and: [aPoint < (pt + width)])			ifTrue: [Sensor cursorPoint: (r perform: (whereabouts at: i)).					sideRect _ sides at: i.					centerPt _ sideRect center.					[Sensor anyButtonPressed]						whileTrue: [thisPoint _ (Sensor cursorPoint - pageRect origin grid: 8@8) + pageRect origin."									thisPoint _ ((thisPoint x - pageRect left roundTo: 8) @ (thisPoint y - pageRect top roundTo: 8)) + pageRect origin."									Display flash: (sideRect _ (sides at: i) align: centerPt with: (i < 3 ifTrue: [centerPt x @ thisPoint y] ifFalse: [i < 5 ifTrue: [thisPoint x @ centerPt y] ifFalse: [thisPoint]]))].					newRect _					i = 5						ifTrue: [sideRect]						ifFalse: [(i = 1 or: [i = 3])									ifTrue: [sideRect origin - (2@2) corner: r corner]									ifFalse: [r origin corner: (sideRect corner + (2@2))]].					^Array with: (whereabouts at: i) with: newRect]].	^Array with: #center with: r!moveRectangle: aRect withIn: bRect grid: grid check: aBoolean 	"these are in turn of screen unit and will return the final origin position of 	the aRect in screen unit"	| offsetPoint highX highY offOrigin origin flag newRect |	offsetPoint _ bRect origin.	highX _ bRect width - aRect width.	highY _ bRect height - aRect height.	offOrigin _ bRect origin - aRect origin.	origin _ aRect extent // 2.	flag _ Sensor anyButtonPressed.	Sensor cursorPoint: aRect center.	[flag		ifTrue: [Sensor redButtonPressed]		ifFalse: [Sensor redButtonPressed not]]		whileTrue: 			[offsetPoint _ Sensor cursorPoint - bRect origin - origin.			offsetPoint x: ((offsetPoint x max: 0)					min: highX).			offsetPoint y: ((offsetPoint y max: 0)					min: highY).			offsetPoint _ offsetPoint // grid * grid.			Display				fill: (aRect translateBy: offsetPoint + offOrigin)				rule: Form reverse				mask: Form gray.			Display				fill: (aRect translateBy: offsetPoint + offOrigin)				rule: Form reverse				mask: Form gray].	newRect _ aRect translateBy: offsetPoint + offOrigin.	aBoolean		ifTrue: 			[flag _ true.			newRect _ newRect intersect: bRect.			(pageRect contains: newRect)				ifFalse: [^false].			newRect _ newRect translateBy: 0 - pageRect origin.			(pictureLocation at: pageNumber)				== nil ifFalse: [(pictureLocation at: pageNumber)					do: [:any | (any opaque and: [any rectangle intersects: newRect])							ifTrue: [^false]]]].	^newRect!rectangleAt: aPoint width: width	^aPoint - (width // 2) extent: width!releaseRectForm	selectedList _ nil.	(pictureLocation at: pageNumber)		== nil ifFalse: [(pictureLocation at: pageNumber)			do: [:each | each form == nil					ifFalse: 						[each form: nil]]]!resizeRectangle: aRect withGrid: grid 	"This will return a rectangle with the size which is the multiple of the grid"	| height width |	height _ (aRect height asFloat / grid y) ceiling * grid y.	width _ (aRect width asFloat / grid x) ceiling * grid x.	^Rectangle origin: aRect origin extent: width @ height!restoreRectForm	(pictureLocation at: pageNumber)		== nil ifFalse: [(pictureLocation at: pageNumber)			do: [:each | each fileName = String new					ifFalse: 						[each form: (Form readFrom: each fileName)]]]!selectFromPixList	| pixes label pix |	pixes _ pictureLocation at: pageNumber.	(pixes == nil or: [pixes isEmpty]) ifTrue: [^false].	label _ String new.	1 to: pixes size - 1 do: [:i |		(pixes at: i) form == nil			ifTrue: [label _ label, 'Rectangle ', i printString, (String with: $\)]			ifFalse: [label _ label, (pixes at: i) fileName, (String with: $\)]].	pixes last form == nil		ifTrue: [label _ label, 'Rectangle ', pixes size printString]		ifFalse: [label _ label, pixes last fileName].	pix _ (TreeMenu labels: label withCRs)			answers: pixes;			selectBlock: [:menu | 4 timesRepeat: [Display reverse: (menu answer rectangle translateBy: pageRect origin)]];			startUp: nil.	(pix = 0 or: [pix == nil])		ifFalse: 			[selectedList _ pix.			self updateRectForm: selectedList.			selectedList opaque ifFalse: [var at: #redisplay put: true].			Sensor cursorPoint: (selectedList rectangle translateBy: pageRect origin) center.			^true].	^false!updateForm	^selectedList form == nil		ifTrue: [nil]		ifFalse: [selectedList form: (Form readFrom: selectedList fileName).				self updateRectForm: selectedList.				selectedList fileName]!validateRectangle: newRect type: aSymbol	| r | 	((newRect left <= pageRect left	or: [newRect top <= pageRect top])		or: [newRect right >= pageRect right			or: [newRect bottom >= pageRect bottom]])		ifTrue: [^false].	r _ newRect translateBy: 0 - pageRect origin.	(aSymbol ~~ #center and: [selectedList form ~~ nil])		ifTrue: [(r contains: (selectedList offset extent: (selectedList formExtentScaled: true))) ifFalse: [^false]].	selectedList opaque		ifTrue: [(pictureLocation at: pageNumber)				do: [:each | (each opaque and: [each ~= selectedList])							ifTrue: [(r intersects: each rectangle)										ifTrue: [^false]]]].	selectedList rectangle = r		ifFalse: [Display white: (selectedList translateBy: pageRect origin).				aSymbol == #center					ifTrue: [selectedList offset: selectedList offset + (r origin - selectedList rectangle origin)].				selectedList _ selectedList rectangle: r.				selectedList opaque					ifTrue: [var at: #recompose put: true].				var at: #saved put: false.				self nilFrom: pageNumber + 1].	^true! !!PreviewPage methodsFor: 'page'!doPixAt: aPoint	| rectList |	(selectedList ~= nil and: [selectedList containsPoint: aPoint])		ifTrue: [^self changeRectangleAt: aPoint].	"check rectangles"	self toggleSelectedRectangle.	(pictureLocation at: pageNumber) do: [:each |		(each opaque and: [each containsPoint: aPoint])			ifTrue: [selectedList _ each.					self updateRectForm: each.					^true]].	selectedList _ nil.	^false!findPageBreak: where 	"this will set the page break to the line grid"	| line fChar lChar y |	y _ (var at: #grid) y.	(var at: #columns)		= 1		ifTrue: 			[line _ where // y.			line > lastLine ifTrue: [^where // y * y].			pageNumber = 1				ifTrue: 					[line = 0 ifTrue: [fChar _ 1. lChar _ 1] ifFalse:[fChar _ 1.					lChar _ (lines at: line) last]]				ifFalse: 					[line = 0 ifTrue: [fChar _ (charIndex at: pageNumber - 1) last + 1.					lChar _ fChar] ifFalse: [fChar _ (charIndex at: pageNumber - 1) last + 1.					lChar _ fChar + (lines at: line) last - 1]].			charIndex at: pageNumber put: (fChar to: lChar).			^line * y]		ifFalse: [^where // y * y]!gotoPage: page 	self setPageNumber: page.	self getFileTextFrom: (charIndex at: pageNumber) first to: (charIndex at: pageNumber) last.	self composeTextDisplay: true.	^true!ifPixContaining: aPoint	| rectList |	(selectedList ~= nil and: [selectedList containsPoint: aPoint])		ifTrue: [^true].	"check rectangles"	(rectList _ pictureLocation at: pageNumber) == nil ifTrue: [^false].	rectList do: [:each |		(each opaque and: [each containsPoint: aPoint])			ifTrue: [^true]].	^false!isThereANextPage	| addOne | 	addOne _ (charIndex at: pageNumber) last >= (var at: #endText).	^(addOne and: [pageNumber = self findLastGraphicPage]) not!nextPage	| addOne | 	addOne _ (charIndex at: pageNumber) last >= (var at: #endText).	self setPageNumber: pageNumber + 1.	self pageFlip: 1.	addOne		ifTrue: [text _ Text fromString: (String with: Character cr).				var at: #initTextSize put: 0]		ifFalse: [(charIndex at: pageNumber) == nil					ifTrue: [self getFileTextFrom: (charIndex at: pageNumber - 1) last + 1 to: -1]					ifFalse: [self getFileTextFrom: (charIndex at: pageNumber) first to: (charIndex at: pageNumber) last]].	self composeTextDisplay: true.	^addOne!pageBreak	| oldPlace top height y |	y _ (var at: #grid) y.	selectedList _ nil.	oldPlace _ pageBreak at: pageNumber.	top _ clippingRectangle top.	height _ clippingRectangle height // y * y.	Sensor anyButtonPressed ifFalse: [^false].	Cursor blank		showWhile: 			[self drawPageBreakLine: 2; drawPageBreakLine: 3.			"Sensor waitNoButton."			[Sensor noButtonPressed]				whileFalse: 					[self drawPageBreakLine: 3.					pageBreak at: pageNumber put: ((Sensor mousePoint y - top min: height)							max: y).					self drawPageBreakLine: 3].			self drawPageBreakLine: 3.			pageBreak at: pageNumber put: (self findPageBreak: (pageBreak at: pageNumber)).			self drawPageBreakLine: 1.			oldPlace = (pageBreak at: pageNumber)				ifTrue: 					[Cursor normal show.					^false]				ifFalse: 					["charIndex at: pageNumber put: (firstChar to: lastChar)."					self nilFrom: pageNumber + 1.					var at: #saved put: false]].	(var at: #columns) = 1		ifTrue: [oldPlace < (pageBreak at: pageNumber)				ifTrue: [(pageBreak at: pageNumber) // y <= lastLine						ifTrue: 							[self displayLines: (oldPlace // y to: (pageBreak at: pageNumber) // y)								at: clippingRectangle origin + (0 @ (oldPlace - y)).							self updateFrills]						ifFalse: [self recomposePage]]				ifFalse: 					[Display white: (pageRect origin x @ clippingRectangle origin y + (0 @ (pageBreak at: pageNumber)) corner: pageRect corner).					self updateFrills]]		ifFalse: [self recomposePage].	^true!pageBreakContains: aPoint	^((Rectangle origin: pageRect right @ clippingRectangle top + (-20 @ ((pageBreak at: pageNumber) - 10)) extent: 20 @ 19)		containsPoint: aPoint)!previousPage	(var at: #recompose)		ifTrue: [charIndex at: pageNumber put: nil.				var at: #recompose put: false].	pageNumber = 1		ifTrue: 			[self booboo: 'This is the first page!!'. ^false].	self setPageNumber: pageNumber - 1.	self pageFlip: -1.	self getFileTextFrom: (charIndex at: pageNumber) first to: (charIndex at: pageNumber) last.	self composeTextDisplay: true.	^true!scrollToPage: pgNumber	pgNumber = pageNumber ifTrue: [^false].	self checkRecompose.	pgNumber <= self lastPage ifTrue: [^self gotoPage: pgNumber].	^self composeUpto: pgNumber!setPageNumber: aNumber	self releaseRectForm. 	(pageNumber _ aNumber) > charIndex size ifTrue: [self growVariables].	pageNumberForm _ pageNumber printString asParagraph asForm.	self restoreRectForm.! !!PreviewPage methodsFor: 'justification'!doAlign: alignment from: start to: stop 	| begin end tempJustifications |	(self getCursor: alignment) show.	tempJustifications _ justifyIndex at: pageNumber.	tempJustifications == nil ifTrue: [tempJustifications _ RunArray new: self maxLines withAll: 3].	begin _ self lineIndexOfCharacterIndex: start.	end _ self lineIndexOfCharacterIndex: stop.	begin to: end do: [:eachLine | (lines at: eachLine) alignment: alignment].	tempJustifications	_ tempJustifications			copyReplaceFrom: begin			to: end			with: (RunArray new: end - begin + 1 withAll: alignment).	self updateFrills.	self repaintLines: (((begin - 1) max: 1) to: ((end + 1) min: lastLine)).	justifyIndex at: pageNumber put: tempJustifications.	var at: #saved put: false.	Cursor normal show.!getCursor: anInteger	anInteger = 1 ifTrue: [^Cursor extent: 16@16 fromArray: #(2r0000001110000002r0000001110000002r0000001110000002r0000001110000002r0010001110001002r0011001110011002r0011101110111002r1111111111111112r1111111111111112r0011101110111002r0011001110011002r0010001110001002r0000001110000002r0000001110000002r0000001110000002r000000111000000) offset: -7@-7].	anInteger = 2 ifTrue: [^Cursor extent: 16@16 fromArray: #(2r00000000000001112r00000000000001112r00000000000001112r00000000100001112r00000000110001112r00000000111001112r00000000111101112r11111111111111112r11111111111111112r00000000111101112r00000000111001112r00000000110001112r00000000100001112r00000000000001112r00000000000001112r0000000000000111) offset: -7@-7].	anInteger = 0 ifTrue: [^Cursor extent: 16@16 fromArray: #(2r11100000000000002r11100000000000002r11100000000000002r11100001000000002r11100011000000002r11100111000000002r11101111000000002r11111111111111112r11111111111111112r11101111000000002r11100111000000002r11100011000000002r11100001000000002r11100000000000002r11100000000000002r1110000000000000) offset: -7@-7].	anInteger = 3 ifTrue: [^Cursor extent: 16@16 fromArray: #(2r11000000000000112r11000000000000112r11000000000000112r11000100001000112r11001100001100112r11011100001110112r11111111111111112r11111111111111112r11011100001110112r11001100001100112r11000100001000112r11000000000000112r11000000000000112r11000000000000112r11000000000000112r1100000000000011) offset: -7@-7]! !!PreviewPage methodsFor: 'menu messages'!centerPicture	| r extent | 	selectedList form == nil		ifFalse: [r _ selectedList rectangle.				extent _ selectedList form extent * selectedList scale.				selectedList offset: r origin + (r width - extent x // 2 @ (r height - extent y // 2)).				self updateRectForm: selectedList].!editForm	| tabLabel headerStream theSuitcase theDataItem |	selectedList form == nil ifFalse:		[(headerStream _ HeaderFileStream fileNamed: selectedList fileName) readOnly.		(tabLabel _ headerStream labelFromHeader) == nil ifTrue: [tabLabel _ selectedList fileName copyUpTo: $.].		headerStream close.		DataMaster findTheOneByEvaluating: [:each |				(each isKindOf: StandardSystemController)					and: [theSuitcase _ each view suitcase.						 theSuitcase ~~ nil and: [theSuitcase dataItem filename = selectedList fileName]]].	theSuitcase _ Suitcase new packTheSuitcaseFrom: nil forItem: (theDataItem _ DataItem type: #Item label: tabLabel filename: selectedList fileName atIndex: 0).	DataMaster viewSelection: theDataItem withSuitcase: theSuitcase]!fitPicture	| aRect |	selectedList form == nil ifTrue: [^self].	selectedList opaque ifTrue: [var at: #recompose put: true].	var at: #saved put: false.	aRect _ Rectangle origin: selectedList offset + pageRect origin				extent: (selectedList formExtentScaled: true).	Display white: (selectedList translateBy: pageRect origin).	aRect _ self resizeRectangle: aRect withGrid: (8@8).	selectedList rectangle: (self adjustRectangle: aRect);			offset: selectedList rectangle origin.	self updateRectForm: selectedList.!getListPicture	| newList scrollList aList answer fileName aRect picture i scaleList off |	newList _ OrderedCollection new.	scrollList _ OrderedCollection new.	scaleList _ OrderedCollection new.	1 to: pictureLocation size do: [:each |		(aList _ pictureLocation at: each) == nil			ifFalse: 				[aList do: [:j |					j fileName = String new						ifFalse: [newList add: j fileName.								scrollList add: (each printString , '.  ' , j fileName) asSymbol.								scaleList add: j scale]]]].	i _ newList size.	purgeList do: [:each |		each fileName = String new			ifFalse: [newList add: each fileName.					scrollList add: ('** ' , each form printString asSymbol , '.  ' , each fileName) asSymbol.					scaleList add: each scale]].	newList size = 0		ifTrue: [^self booboo: 'There is no list yet!!'].	(answer _ (ScrollMenu new: 8 on: scrollList) startUp: #anyButton) == nil		ifTrue: [^false].	off _ clippingRectangle origin y - pageRect origin y rem: 8.	Sensor cursorPoint: pageRect center.	((fileName _ newList at: answer) isKindOf: Rectangle)		ifTrue: [aRect					_ self moveRectangle: (fileName moveTo: Sensor cursorPoint - (fileName extent // 2))						withIn: (pageRect origin + (0 @ off) corner: pageRect corner)						grid: 8 @ 8						check: true.				aRect = false ifTrue: [^false].				self addRectangle: aRect]		ifFalse: 			[picture _ Form readFrom: fileName.			aRect _ 0 @ 0 extent: (picture extent * (scaleList at: answer)) rounded.			aRect _ self resizeRectangle: aRect withGrid: (8@8).			aRect _ self moveRectangle: (aRect moveTo: Sensor cursorPoint - (aRect extent // 2))						withIn: (pageRect origin + (0 @ off) corner: pageRect corner)						grid: 8 @ 8						check: true.			aRect = false ifTrue: [^false].			self addRectangle: aRect				form: picture				fileName: fileName				scale: (scaleList at: answer)].	answer > i		ifTrue: [purgeList remove: (purgeList at: answer - i) ifAbsent: []].	^true!handlePicture: aPict withFileNamed: fileName 	| aRect temp scale off |	off _ clippingRectangle origin y - pageRect origin y rem: 8.	scale _ 1@1.	aPict extent x > pageRect extent x | (aPict extent y > pageRect extent y)		ifTrue: 			[self booboo: 'Picture too big, must be scaled!!'.			aRect _ Rectangle fromUserAspectRatio: aPict extent.			aRect moveTo: pageRect origin.			(aRect intersects: pageRect)				ifTrue: [aRect _ pageRect intersect: aRect].			aRect _ 0 @ 0 extent: aRect extent.			scale _ aRect width / aPict width asPoint.			temp _ self moveRectangle: (aRect moveTo: pageRect center - (aRect extent // 2))						withIn: (pageRect origin + (0 @ off) corner: pageRect corner)						grid: 8 @ 8						check: true.			temp = false				ifTrue: 					[purgeList add: (RectForm							rectangle: (self adjustRectangle: aRect)							form: pageNumber							fileName: fileName							scale: scale).					^false]]		ifFalse: 			[aRect _ 0 @ 0 extent: aPict extent.			aRect _ self resizeRectangle: aRect withGrid: (8@8).			Sensor cursorPoint: pageRect center - (aRect extent // 2).			temp _ self						moveRectangle: (aRect moveTo: Sensor cursorPoint)						withIn: (pageRect origin + (0 @ off) corner: pageRect corner)						grid: 8 @ 8						check: true.			temp = false				ifTrue: 					[purgeList add: (RectForm							rectangle: (self adjustRectangle: aRect)							form: pageNumber							fileName: fileName).					^false]].	self addRectangle: temp		form: aPict		fileName: fileName		scale: scale.	^true!hardcopy	^self hardcopy: self hardcopyOptions!hardcopy: options	^options == nil		ifTrue: [false]		ifFalse: [var at: #linesBetweenBorders put: (options at: 1) applicAnswers last.				textStyle class == PrintStyle					ifTrue: [self backgroundInterPressFrom: (options at: 2) to: (options at: 3) theBP: (options at: 1)]					ifFalse: [self backgroundPressFrom: (options at: 2) to: (options at: 3) theBP: (options at: 1)].				var removeKey: #linesBetweenBorders ifAbsent: [].				var removeKey: #borders ifAbsent: [].				true]!hardcopyOptions	| theBP first last default |	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^nil].	(default _ Array new: 5)		at: 1 put: 'all pages';		at: 2 put: (var at: #majorHeading);		at: 3 put: (var at: #minorHeading);		at: 4 put: 'none';		at: 5 put: '0.25'.	theBP _ BackgroundPrinter askQuestions:				((Array new: 5)					at: 1 put: default;					at: 2 put: #(select fill fill select select);					at: 3 put: #(('Print : ' 'this page' 'all pages' ) ('Major heading :' ) ('Minor heading :' ) ('Border :' 'none' 'single' 'double') ('Lines between borders :' '0.25' '0.5' '1' '1.5' '2'));					at: 4 put: (var at: #suitcase) classification;					at: 5 put: (var at: #suitcase) centerName;					yourself).	theBP == nil ifTrue: [^nil].	self checkBorderData: (theBP applicAnswers at: 4).	(theBP applicAnswers at: 1) = 'this page'		ifTrue: [first _ last _ pageNumber]		ifFalse: [first _ 1. last _ 99].	^Array with: theBP with: first with: last!killPictures	| label set aCopy |	purgeList size = 0 ifTrue: [^false].	label _ String new.	1 to: purgeList size - 1 do: [:each | label _ label, (purgeList at: each) fileName, (String with: Character cr)].	label _ label, purgeList last fileName.	set _ (TreeMenu labels: label) answers: purgeList; multipleStartUp.	set size = 0 ifTrue: [^false].	aCopy _ purgeList copy.	set do: [:each | aCopy remove: each ifAbsent: []].	purgeList _ aCopy.	^true!movePicture	| newRect |	selectedList form == nil ifTrue: [^self].	newRect _ pageRect origin + selectedList offset extent: (selectedList formExtentScaled: true)."	Sensor cursorPoint: pageRect origin + selectedList offset."	newRect _ self moveRectangle: (newRect" moveTo: pageRect origin + selectedList offset""Sensor cursorPoint")					withIn: (selectedList translateBy: pageRect origin)					grid: 1 @ 1					check: false.	newRect = false ifTrue: [^self].	selectedList offset: newRect origin - pageRect origin.	self updateRectForm: selectedList.!properties	| answer opaque |	opaque _ selectedList opaque.	answer _ DBoxView				openFor: #(select select select )				title: 'Selection Properties'				labels: #(('Rectangle Border:' on off ) ('Picture Border:' on off ) ('Opaque:' on off ) )				defaults: selectedList properties.	answer == nil		ifFalse: [selectedList rBorder: ((answer at: 1) == #on).				selectedList pBorder: ((answer at: 2) == #on).				opaque == ((answer at: 3) == #on)					ifFalse: [selectedList opaque: opaque not.							var at: #recompose put: true].				var at: #saved put: false.				self updateRectForm: selectedList]!redisplay	var at: #redisplay put: true.	^self checkRecompose!removeRectangle	| newList rect |	selectedList fileName = String new		ifFalse: [purgeList add: (selectedList copy form: pageNumber)].	newList _ (pictureLocation at: pageNumber) remove: selectedList; yourself.	Display white: (rect _ selectedList translateBy: pageRect origin).	pictureLocation at: pageNumber put: newList.	selectedList opaque		ifTrue: [var at: #recompose put: true]		ifFalse: [self repaintLines: (self linesSelected: (Array with: rect)).				var removeKey: #redisplay ifAbsent: []].	var at: #saved put: false.		selectedList _ nil.!scalePicture: anIndex	"1: fit scaling; 2: proportional scaling and 3: unscaling"	| rect scale off newRect pix |	(pix _ selectedList form) == nil ifTrue: [^self].	anIndex = 3		ifTrue: [pix width > pageRect width | (pix height > pageRect height)					ifTrue: [self booboo: 'Won''t fit on page !!!! Picture cannot be unscaled !!'.							^false].				rect _ (selectedList offset extent: (selectedList formExtentScaled: false)).				scale _ 1@1]		ifFalse: [anIndex = 1					ifTrue: [rect _ Rectangle fromUser.							scale _ rect width / pix width @ (rect height / pix height)]					ifFalse: [rect _ Rectangle fromUserAspectRatio: pix extent.							scale _ rect width / pix width @ (rect width / pix width)].				rect moveTo: pageRect origin.				(pageRect contains: rect)					ifFalse: [rect width > pageRect width								ifTrue: [rect extent: pageRect width @ (pix height * (pageRect width / pix width) asFloat rounded)]								ifFalse: [rect extent: (pix width * (pageRect height / pix height) asFloat) rounded @ pageRect height]]].	rect _ 0 @ 0 extent: rect extent.	off _ clippingRectangle origin y - pageRect origin y rem: 8.	Sensor cursorPoint: pageRect center - (rect extent // 2).	rect _ self moveRectangle: (rect moveTo: Sensor cursorPoint)			withIn: (pageRect origin + (0 @ off) corner: pageRect corner)			grid: 8 @ 8			check: false.	rect = false		ifTrue: [self updateRectForm: selectedList.				^false].	rect _ rect translateBy: 0 - pageRect origin.	selectedList opaque		ifTrue: [(pictureLocation at: pageNumber)				do: [:each | (each opaque and: [each ~= selectedList])							ifTrue: [(rect intersects: each rectangle)										ifTrue: [self updateRectForm: selectedList. ^false]]].				var at: #recompose put: true].	var at: #saved put: false.	Display white: (selectedList translateBy: pageRect origin).	newRect _ self adjustRectangle: (rect translateBy: pageRect origin).	selectedList scale: scale; offset: newRect origin; rectangle: newRect.	self updateRectForm: selectedList.	^true!setOption: newOption	| margins constant newCol newGutter changeFlag newGrid |	constant _ 79.375 * textStyle pressScale.	newCol _ (newOption at: 5) asNumber.	newGutter _ (newOption at: 6) asNumber.	margins	_ ((((newOption at: 4) asNumber min: 4) max: 0.75) * constant) @ ((((newOption at: 1) asNumber min: 4) max: 0.75) * constant)			corner: ((((newOption at: 3) asNumber min: 4) max: 0.75) * constant) @ ((((newOption at: 2) asNumber min: 4) max: 0.75) * constant).	newGrid _ Grid x @ (((newOption at: 8) asNumber * Grid y) asInteger).	(changeFlag _ (var at: #defaultMargins) ~= margins)		ifTrue: [var at: #defaultMargins put: margins.				self setRect: pageRect]		ifFalse: [changeFlag				_ (var at: #columns) ~= newCol						or: [(var at: #gutter) ~= newGutter							or: [(var at: #grid) ~= newGrid]]].	var at: #saved put: false; 		at: #columns put: newCol; 		at: #gutter put: newGutter; 		at: #tabUnit put: (newOption at: 7); 		at: #grid put: newGrid.	^changeFlag!showJustify	| aRect bRect mode aList off y |	(justifyIndex at: pageNumber) == nil ifTrue: [^true].	aList _ self getColumns.	off _ 0.	y _ (var at: #grid) y.	aList do: [ : each |	aRect _ each origin - (4 @ 0) extent: 2 @ y.	bRect _ each topRight + (2 @ 0) extent: 2 @ y.	1 + off to: ((pageBreak at: pageNumber) // y + off min: lastLine) do: 		[:i | 		(mode _ lines at: i) == nil ifTrue: [^true].		mode _ mode alignment.		mode < 2 ifTrue: [Display				fill: aRect				rule: Form reverse				mask: Form black].		mode = 2 | (mode = 1) ifTrue: [Display				fill: bRect				rule: Form reverse				mask: Form black].		aRect moveBy: 0 @ y.		bRect moveBy: 0 @ y].		off _ off + ((pageBreak at: pageNumber) // y)].	^true!showReal	| scale aRect temp |	(scale _ selectedList scale) = (1@1) ifTrue: [^false].	Display gray: (selectedList translateBy: pageRect origin).	selectedList pBorder		ifTrue: [(temp _ selectedList form deepCopy) borderWidth: 2]		ifFalse: [temp _ selectedList form].	temp		displayOn: Display		at: pageRect origin + selectedList offset		clippingBox: (selectedList translateBy: pageRect origin)		rule: Form over		mask: Form black.	self booboo: 'This is the scaled image!!'.	self updateRectForm: selectedList.	^true! !!PreviewPage methodsFor: 'marker adjustment'!computeMarkerRegion: scrollBarHeight	| lastComposedPage lastGraphicPage | 	^(charIndex at: pageNumber) == nil		ifTrue: [0]		ifFalse: [lastGraphicPage _ self findLastGraphicPage.				lastComposedPage _ self lastPage.				(charIndex at: lastComposedPage) last >= self totalText					ifTrue: [scrollBarHeight // lastGraphicPage]					ifFalse: [scrollBarHeight * 0.9 // lastGraphicPage]]!totalText	^(var at: #endText) -  (var at: #initTextSize) + text size! !!PreviewPage methodsFor: 'private'!displayLines: linesInterval at: aPoint 	"We're pretty sure that all lines are visible, so display them."	| topY firstLineIndex lastLineIndex lastLineIndexBottom scanner |	firstLineIndex _ linesInterval first max: 1.	lastLineIndex _ linesInterval last min: lastLine.	topY _ aPoint y.	lastLineIndexBottom _ topY + (lastLineIndex - firstLineIndex * (var at: #grid) y).	"Set boundingBox containing the lines in linesInterval to color for space 	surrounding the characters."	destinationForm		fill: ((pageRect left @ topY extent: pageRect width @ (lastLineIndexBottom - topY))				intersect: pageRect)		rule: rule		mask: Form white.	scanner _ PreviewDisplayScanner new.	"DisplayMode represents how the user wants the lines displayed. Options are: 	#preview or #display. If the outputMedium is #Display, then the 	DisplayMode is defaulted to #display. For #PressPrinter, it is #preview. 	For #DisplayPrinterWidths, it can be either one."	scanner		displayLines: (firstLineIndex to: lastLineIndex)		in: self		clippedBy: pageRect		at: aPoint!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger mask: aForm	"Default display message when aDisplayPoint is in absolute screen 	coordinates. "	destinationForm _ aDisplayMedium.	clippingRectangle _ clipRectangle.	rule _ ruleInteger.	mask _ aForm.	compositionRectangle moveTo: aDisplayPoint.	(lastLine == nil or: [lastLine < 1])		ifTrue: [self initializeFirstPage.				self composeTextDisplay: true]!displayPageText	| off linesPerCol |	off _ 1.	Display white: pageRect.	self displayTextFrame.	self updateFrills.	linesPerCol _ (pageBreak at: pageNumber) // (var at: #grid) y.	self getColumns do: 		[:each | 		self displayLines: (off to: off + linesPerCol - 1)			at: each origin.		off _ off + linesPerCol].	^true!displayTextFrame	self getColumns do: 		[:each | 		Display black: (each origin - 1 corner: each topRight + (1 @ 0)).		Display black: (each origin - 1 corner: each bottomLeft).		Display black: (each topRight - (0 @ 1) corner: each bottomRight + 1).		Display black: (each bottomLeft - (1 @ 0) corner: each bottomRight + 1)]!drawPageBreakLine: mode 	"1.  draw black over.  2.  draw white over.  3. draw black inverse"	| displayLine aRect r pgLine |	(pageBreak at: pageNumber) == nil		ifTrue: [pageBreak at: pageNumber						put: clippingRectangle height // (var at: #grid) y * (var at: #grid) y].	pgLine _ pageBreak at: pageNumber.	aRect _ Rectangle origin: (pageRect right - 20@ (clippingRectangle top + pgLine - 10))					extent: 20 @ 21.	displayLine _ Rectangle origin: (pageRect left @ (clippingRectangle top + pgLine))					extent: pageRect width - 20 @ 1.	mode = 1		ifTrue: 			[Display black: displayLine. Display black: aRect.			(var at: #recompose)				ifTrue: [r _ Form reverse]				ifFalse: 					[Display white: (aRect insetBy: 1 @ 1).					r _ Form over].			pageNumberForm				displayOn: Display				at: aRect origin + (20 - pageNumberForm width // 2 @ 1)				clippingBox: pageRect				rule: r				mask: Form black]		ifFalse: [mode = 2				ifTrue: [Display white: displayLine. Display white: aRect]				ifFalse: [Display						fill: displayLine						rule: Form reverse						mask: Form black;						fill: aRect						rule: Form reverse						mask: Form black]]!findLastGraphicPage	pictureLocation size		to: self lastPage		by: -1		do: [:each | (pictureLocation at: each)				== nil ifFalse: [^each]].	^self lastPage!findLastLine: anIndex 	| index |	index _ anIndex - (charIndex at: pageNumber) first + 1.	1 to: lines size do: [:each | (lines at: each)			== nil			ifTrue: [^clippingRectangle height // (var at: #grid) y]			ifFalse: [((lines at: each) last >= index and: [(lines at: each) first <= index])					ifTrue: [^each]]].	^clippingRectangle height // (var at: #grid) y!getColumns	| columns gutter rect aList |	(pageBreak at: pageNumber) == nil		ifTrue: [pageBreak at: pageNumber						put: clippingRectangle height // (var at: #grid) y * (var at: #grid) y].	columns _ var at: #columns.	gutter _ var at: #gutter.	rect _ clippingRectangle origin extent: clippingRectangle width - (gutter * (columns - 1)) // columns @ (pageBreak at: pageNumber).	aList _ OrderedCollection new.	1 to: columns do: [:i | aList add: (rect translateBy: rect width + gutter * (i - 1) @ 0)].	^aList!getFileTextFrom: start to: stop 	"this routine will get text in the diskFile and then update the text"	"if the stop = -1 that means get a buffer text of say 2000 characters"	| realStart realStop strings |	(var at: #updateFile ifAbsent: [false]) ifTrue: [self backupText].	Cursor read		showWhile: 			[start < 1				ifTrue: [realStart _ 1]				ifFalse: [realStart _ start]. 			stop = -1				ifTrue: [realStop _ (var at: #endText)								min: start + BufferSize]				ifFalse: [realStop _ ((stop max: (start + BufferSize)) min: (var at: #endText))].			diskFile reset; position: start - 1.			strings _ diskFile next: realStop - realStart + 1.			(runs == nil or: [runs size = 0])				ifTrue: [text _ strings asText]				ifFalse: [text _ Text string: strings runs: (runs copyFrom: realStart to: realStop)]].	var at: #initTextSize put: text size!lastPage	"This message returns the very last page that has been composed."	2 to: charIndex size do: [:each |		(charIndex at: each) == nil ifTrue: [^each - 1]].	^charIndex size!leftMarginForCompositionForLine: lineIndex	^ (super leftMarginForCompositionForLine: lineIndex) +lMargin!leftMarginForDisplayForLine: lineIndex 	"0=left,1=centered,2=right,3=justified"	| mode line |	lineIndex > lastLine ifTrue: [^super leftMarginForDisplayForLine: lastLine].	mode _ (line _ lines at: lineIndex) alignment. 	mode = 0 | (mode = 3) ifTrue: [^(super leftMarginForDisplayForLine: lineIndex)			+ line lMargin].	mode = 1 ifTrue: [^(super leftMarginForDisplayForLine: lineIndex)			+ line lMargin + (line paddingWidth // 2)].	mode = 2 ifTrue: [^(super leftMarginForDisplayForLine: lineIndex)			+ line lMargin + line paddingWidth]!pageFlip: aNumber 	"This is a visual illustration of flipping a page.	aNumber = 1 then flip up else flip down"	| frac rect |	selectedList _ nil.	frac _ (pageRect height / pageRect width) asFloat.	1		to: pageRect width		by: 48		do: 			[:i | 			aNumber = 1				ifTrue: [rect _ Rectangle origin: pageRect corner - (i @ (i asFloat * frac) rounded) corner: pageRect corner]				ifFalse: [rect _ Rectangle origin: pageRect origin extent: i @ (i asFloat * frac) rounded].			Display lightGray: rect].	Display white: pageRect!rightMarginForComposition: lineIndex	"Build the right margin for a line. 	Depends upon compositionRectangle width, marginTabsLevel, and right indent."	| scale |	outputMedium == #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	^((compositionRectangle width		- (textStyle rightMarginTabAt: marginTabsLevel) - rightIndent) * scale) -  rMargin!setRect: rect	| margins aRect min scale |	margins _ var at: #defaultMargins.	min _ MinMargins at: PressOrInterpress.	scale _ textStyle pressScale.	aRect _ rect origin + (margins left - min left @ (margins top - min top) // scale) corner: rect corner - (margins right - min right @ (margins bottom - min bottom) // scale).	pageRect _ rect. 	clippingRectangle _ aRect. 	compositionRectangle _ (aRect insetBy: 6 @ 0).!toggleSelectedRectangle	| aRectForm |	selectedList == nil		ifFalse: 			[aRectForm _ selectedList copy. 			selectedList _ nil.			self updateRectForm: aRectForm.			self drawPageBreakLine: 1]!updateFrills	(pictureLocation at: pageNumber)		== nil ifFalse: [(pictureLocation at: pageNumber)			do: [:each | self updateRectForm: each]].	self drawPageBreakLine: 1!updateRectForm: aRF 	| aRect temp scale selected borderWidth pixRect |	selected _ selectedList = aRF.	aRect _ aRF translateBy: pageRect origin.	selected		ifTrue: [Display gray: aRect]		ifFalse: [Display white: aRect].	aRF form == nil ifFalse: [((scale _ aRF scale) = 1 or: [scale = (1 @ 1)])			ifTrue: 				[aRF pBorder					ifTrue: [(temp _ aRF form deepCopy) borderWidth: 2]					ifFalse: [temp _ aRF form].				temp					displayOn: Display					at: pageRect origin + aRF offset					clippingBox: (aRF translateBy: pageRect origin)					rule: Form over					mask: Form black]			ifFalse: 				[pixRect _ ((aRF offset extent: (aRF formExtentScaled: true) rounded)							intersect: aRF rectangle)							translateBy: pageRect origin.				Display black: pixRect.				aRF pBorder					ifTrue: [Display lightGray: (pixRect insetBy: 2 @ 2)]					ifFalse: [Display lightGray: (pixRect insetBy: 1 @ 1)].				(aRF scale x = aRF scale y					ifTrue: ['Scaled Image/Prop.']					ifFalse: ['Scaled Image/Fit ']) asDisplayText displayAt: aRF rectangle origin + pageRect origin + 2]].	aRF rBorder		ifTrue: [borderWidth _ 2]		ifFalse: [borderWidth _ 1].	Display black: (aRect origin extent: borderWidth @ aRect height).	Display black: (aRect origin extent: aRect width @ borderWidth).	Display black: (aRect bottomLeft - (0 @ borderWidth) extent: aRect width @ borderWidth).	Display black: (aRect topRight - (borderWidth @ 0) extent: borderWidth @ aRect height).	selected ifTrue: [self displayRectangleDots].	self drawPageBreakLine: 1! !!PreviewPage methodsFor: 'composition'!checkAndSetMargin: yPos in: i	| rectList theRect width scale rect | 	(rectList _ (pictureLocation at: pageNumber)) == nil ifTrue: [^true].	theRect _ Rectangle origin: i origin + (0@yPos) extent: i width @ (var at: #grid) y.	theRect _ theRect translateBy: (0 - pageRect origin).	scale _ textStyle pressScale.	rectList do: 		[:each |		(each opaque and: [(rect _ each rectangle) intersects: theRect])			ifTrue: 				[(rect contains: theRect) ifTrue: [lMargin _ i width + 1 * scale. ^self].				rect center x >= theRect center x					ifTrue: [rMargin _ (theRect right - rect left max: rMargin // scale)									* scale]					ifFalse: [lMargin _ (rect right - theRect left max: lMargin // scale)									* scale]]].!checkJustify	| justify |	(justify _ justifyIndex at: pageNumber) == nil"		ifTrue: [justifyIndex at: pageNumber put: (RunArray new: lastLine withAll: 3)]"		ifFalse: [1 to: lastLine do: [:i | (lines at: i)					alignment: (justify at: i)]]!checkRecompose	^(var at: #recompose)		ifTrue: [self recomposePage.				var removeKey: #redisplay ifAbsent: [].				true]		ifFalse: [(var includesKey: #redisplay)					ifTrue: [self displayPageText.							var removeKey: #redisplay].				false]!composeEndPages	| totalSize i |	self checkRecompose.	totalSize _ var at: #endText.	(charIndex at: pageNumber) last = totalSize		ifTrue: [^false]		ifFalse: 			[Sensor waitNoButton.			Cursor wait				showWhile: 					[self drawPageBreakLine: 2.					self releaseRectForm.					i _ self lastPage.					(charIndex at: i) last = totalSize						ifTrue: [^self gotoPage: i]						ifFalse: 							[pageNumber _ i.							[totalSize > (charIndex at: pageNumber) last & Sensor anyButtonPressed not]								whileTrue: 									[(pageNumber _ pageNumber + 1) > charIndex size ifTrue: [self growVariables].									pageNumberForm _ pageNumber printString asParagraph asForm.									self getFileTextFrom: (charIndex at: pageNumber - 1) last + 1 to: -1.									self composeTextDisplay: false.									self drawPageBreakLine: 1]].					self restoreRectForm.					^self displayPageText]]!composePageNumbered: pgNo	| newPage pg |  	pgNo = 0		ifTrue: [self nilAllFrom: 1.				pg _ 1]		ifFalse: [self nilFrom: pgNo + 1.				pg _ pgNo].	(newPage _ pg ~= pageNumber)		ifTrue: 			[self setPageNumber: pg.			self getFileText].	self composeTextDisplay: true.	^newPage!composeTextDisplay: displayIt	| colList interval maximumLine lineIndex displayLine startIndex stopIndex maximumRightX yPos compositionScanner temp ff fChar lead maxLinesPerColumn aRect tabPool tabs tempTab newLast |	Cursor wait show.	text size = 0		ifTrue: 			[charIndex at: pageNumber put: (0 to: 0).			lastLine _ 0.			Cursor normal show.			Display white: pageRect.			self displayTextFrame. self updateFrills.			^0].	colList _ self getColumns.	interval _ OrderedCollection new.	maximumLine _ 0.	lead _ (var at: #grid) y.	maxLinesPerColumn _ (colList at: 1) height // lead.	lines _ Array new: (maxLinesPerColumn * colList size).	lineIndex _ displayLine _ startIndex _ 1.	fChar _ pageNumber = 1 ifTrue: [1] ifFalse: [(charIndex at: pageNumber - 1) last + 1].	stopIndex _ text size.	lastLine _ maximumRightX _ yPos _ rMargin _ lMargin _ 0.	compositionScanner _ PreviewCompositionScanner new in: self.	tabPool _ var at: #tabPool.	tabs _ (var at: #tabs) at: pageNumber.	tabs == nil ifTrue: [tabs _ RunArray new: self maxLines withAll: 1].	ff _ false.	colList do: 		[:i | 		yPos _ i top - clippingRectangle top.		maximumLine _ maximumLine + maxLinesPerColumn.		aRect _ i insetBy: 6 @ 0.		[ff or: [lineIndex > maximumLine | (startIndex > stopIndex)]]			whileFalse: 				[self checkAndSetMargin: yPos in: i.				tempTab == (tabs at: lineIndex)					ifFalse: [tempTab _ (tabs at: lineIndex).							compositionScanner setTabs: (tabPool at: tempTab)].				temp _ compositionScanner							composeLine: lineIndex							fromCharacterIndex: startIndex							inParagraph: self							with: aRect.				lineIndex > lastLine ifTrue: [lastLine _ lineIndex].				lines at: lineIndex put: temp.				lMargin _ rMargin _ 0.				yPos _ yPos + lead.				maximumRightX _ compositionScanner rightX max: maximumRightX.				startIndex _ temp last + 1.				lineIndex _ lineIndex + 1.				ff _ startIndex > 1 and: [(text at: (startIndex - 1)) = Ctrlf]].		displayIt ifTrue: 			[interval add: (displayLine to: lineIndex - 1).			displayLine _ lineIndex]].	newLast _ fChar + startIndex - 2.	(lineIndex - 1 < lines size and: [(var at: #endText) > newLast and: [ff not]])		ifTrue: ["BufferSize isn't big enough, couldn't fill the page - go get more and try again"				BufferSize _ BufferSize + 1000.				self getFileText.				^self composeTextDisplay: displayIt].	self checkJustify.	displayIt ifTrue:			[Display white: pageRect.			self displayTextFrame.			self updateFrills.			1 to: colList size 				do: [:i | self displayLines: (interval at: i) at: (colList at: i) origin]].	charIndex at: pageNumber put: (fChar to: newLast).	(charIndex size > pageNumber		and: [(charIndex at: pageNumber + 1) ~~ nil			and: [(charIndex at: pageNumber + 1) first ~= (newLast + 1)]])		ifTrue: [self nilFrom: pageNumber + 1].	Cursor normal show.	^maximumRightX!composeUpto: pgNumber	| totalSize i |	totalSize _ var at: #endText.	(charIndex at: pageNumber) last = totalSize		ifTrue: [^false]		ifFalse: 			[Cursor wait showWhile: 				[self drawPageBreakLine: 2.				i _ self lastPage.				(charIndex at: i) last >= totalSize					ifTrue: [^self gotoPage: i]					ifFalse: [self releaseRectForm.							pageNumber _ i.							[totalSize > (charIndex at: pageNumber) last and: [pageNumber < pgNumber]]								whileTrue: 									[(pageNumber _ pageNumber + 1) > charIndex size ifTrue: [self growVariables].									pageNumberForm _ pageNumber printString asParagraph asForm.									self getFileTextFrom: (charIndex at: pageNumber - 1) last + 1 to: -1.									self composeTextDisplay: false.									self drawPageBreakLine: 1]].					self restoreRectForm.					^self displayPageText]]!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint outputMedium: aSymbol fitWidth: aBoolean	| paddingDelta lineIndex |	"I have changed from default form to Form under"	compositionRectangle _ compositionRect copy.	text _ aText.	textStyle _ aTextStyle.	firstIndent _ textStyle firstIndent.	restIndent _ textStyle restIndent.	rightIndent _ textStyle rightIndent.	marginTabsLevel _ 0.	outputMedium _ aSymbol.	lines _ Array new: 55.	lastLine _ 0.	rule _ Form under.	mask _ DefaultMask.	destinationForm _ Display.	offset _ aPoint	"...and don't recompose."!getFileText	pageNumber = 1		ifTrue: [self getFileTextFrom: 1 to: -1]		ifFalse: [self getFileTextFrom: (charIndex at: pageNumber - 1) last + 1 to: -1]!recomposeAll	(charIndex at: pageNumber) == nil		ifTrue: [self getFileText]		ifFalse: [self getFileTextFrom: (charIndex at: pageNumber) first to: -1].	self composeTextDisplay: false!reComposeFrom: startLine to: endLine	"editChanges on the current page is saved as an array of startCharIndex, stopCharIndex and replacing text. This routine attempts to compose as little as possible	 within the given range of lines (startLine to: endLine)."	| newLines startLineIndex editChanges startOfOldText stopOfOldText replacingText paraEndIndex allLines lineIndex lastCharIndex fChar newLastLine even size |	lineIndex _ endLine + 1.	startLineIndex _ startLine.	startOfOldText _ (lines at: startLine) first.	stopOfOldText _ (lines at: endLine) last.	replacingText _ text copyFrom: startOfOldText to: stopOfOldText.	newLines _ self quickComposing: replacingText startLine: startLineIndex.	size _ newLines size.	allLines _ OrderedCollection new.	1 to: startLineIndex - 1 do: [:i | allLines add: (lines at: i)].	1 to: size do: [:i | allLines add: ((newLines at: i) adjustBy: startOfOldText - 1)].	even _ lineIndex - startLine = size.	even		ifTrue: [lastCharIndex _ allLines last last - stopOfOldText.				[lineIndex <= lastLine]					whileTrue: [allLines add: ((lines at: lineIndex) adjustBy: lastCharIndex).								lineIndex _ lineIndex + 1]]		ifFalse: ["either more or less lines. Recompose if necessary."				self nilCharacterIndexFrom: pageNumber + 1.				self extendComposingStartingAt: lineIndex addTo: allLines].	lastLine > allLines size		ifTrue: [lastCharIndex _ allLines size > 0 ifTrue: [allLines last last] ifFalse: [0].				replacingText _ text copyFrom: lastCharIndex + 1 to: text size.				newLines _ self quickComposing: replacingText startLine: allLines size + 1.				newLines do: [:i | allLines add: (i adjustBy: lastCharIndex)]].	lastLine > allLines size ifTrue: [self eraseLines: (allLines size + 1 to: lastLine + 1)].	lastLine _ allLines size min: (((pageBreak at: pageNumber) // (var at: #grid) y) * (var at: #columns)).	lines _ allLines asArray.	self checkJustify.	var at: #recompose put: false.	fChar _ pageNumber = 1				ifTrue: [1] ifFalse: [(charIndex at: pageNumber - 1) last +1].	lastLine > 0		ifTrue: [charIndex at: pageNumber put: (fChar to: fChar + (lines at: lastLine) last - 1)].	^Array with: even with: size!recomposePage	"this will recompose the current page number and erase all composed info.  from current page and on""MessageTally spyOn: [] to: 'recomposeTally.spy'."	(var at: #recompose)		ifTrue: [self nilFrom: pageNumber + 1.				var at: #recompose put: false].	self composeTextDisplay: true! !!PreviewPage methodsFor: 'editing'!eraseLines: anInterval	| aList off start end constantY maxLines startCol endCol relStart relEnd each rect |	aList _ self getColumns.	start _ anInterval first.	end _ anInterval last.	constantY _ (var at: #grid) y.	maxLines _ (pageBreak at: pageNumber) // constantY.	startCol _ start - 1 //maxLines + 1.	endCol _ (end - 1 // maxLines + 1) min: aList size.	relStart _ start - (maxLines * (startCol - 1)).	startCol to: endCol do: [:i |		off _ maxLines * (i - 1).		relStart _ relStart + off.		relEnd _ end min: (off + maxLines).		each _ aList at: i.		rect _ (each origin + (0@((relStart - off - 1) * constantY))) extent: (each width @ ((relEnd - relStart + 1) * constantY)).		relEnd = lastLine ifTrue: [rect _ rect origin corner: (rect corner + (0@10))].		"Display white: rect."		self eraseRectangleOutside: rect.		relStart _ 1].!extendComposingStartingAt: lineIndex addTo: allLines	| endLineIndex startLineIndex adjustAmount replacingText newLines lastCharIndex | 	endLineIndex _ lineIndex - 1.	[startLineIndex _ endLineIndex + 1.	startLineIndex <= lastLine and: [startLineIndex > 0]]	whileTrue:	[endLineIndex _ self lineIndexOfParaEndStartAt: startLineIndex.	((self linesIntersectPix: (allLines size + 1 to: (allLines size + endLineIndex - startLineIndex + 1)))	or: [self linesNeedRecomposing: (startLineIndex to: endLineIndex)])		ifTrue: [	adjustAmount _ allLines last last.				lastCharIndex _ (lines at: endLineIndex) last.				replacingText _ text copyFrom: (lines at: startLineIndex) first to: lastCharIndex.				replacingText isEmpty ifFalse:				[replacingText last= CR					ifFalse: [replacingText _ replacingText, (text copyFrom: lastCharIndex + 1 to: (self paraEndStartingAt: lastCharIndex + 1))].				newLines _ self quickComposing: replacingText startLine: allLines size + 1.				newLines do: [:i | allLines add: (i adjustBy: adjustAmount)]]]		ifFalse: [adjustAmount _ allLines last last - (lines at: startLineIndex) first + 1.				[startLineIndex <= endLineIndex]					whileTrue: [allLines add: ((lines at: startLineIndex) adjustBy: adjustAmount).								startLineIndex _ startLineIndex + 1]]]!lineIndexOfParaEndStartAt: startLineIndex	| paraEndIndex | 	paraEndIndex _ self paraEndStartingAt: (lines at: startLineIndex) first.	^(self pickupOldFrom: paraEndIndex + 1 beginLineIndex: startLineIndex) - 1!linesIntersectPix: anInterval	| aList off start end constantY maxLines startCol endCol relStart relEnd each rect pix areas |	(pix _ pictureLocation at: pageNumber) ==nil ifTrue: [^false].	aList _ self getColumns.	start _ anInterval first.	end _ anInterval last.	constantY _ (var at: #grid) y.	maxLines _ (pageBreak at: pageNumber) // constantY.	startCol _ start - 1 //maxLines + 1.	endCol _ (end - 1 // maxLines + 1) min: aList size.	relStart _ start - (maxLines * (startCol - 1)).	areas _ OrderedCollection new.	off _ 0.	startCol to: endCol do: [:i |		relEnd _ end min: (off + maxLines).		each _ aList at: i.		rect _ (each origin "- (0@clippingRectangle top)"+ (0@((relStart - off - 1) * constantY))) extent: (each width @ ((relEnd - relStart + 1) * constantY)).		areas add: rect.		off _ maxLines + off.		relStart _ off + 1].	pix do: [:r | areas do: [:paraRect | (paraRect intersects: (r translateBy: pageRect origin)) ifTrue: [^true]]].	^false!linesNeedRecomposing: anInterval	anInterval do: [:i | (lines at: i) margins = (0@0) ifFalse: [^true]].	^false!linesSelected: rects	| off startPt endPt aList startClip startCol endClip endCol begin end |	(rects == nil or: [rects isEmpty]) ifTrue: [^false].	startPt _ rects first origin.	endPt _ rects last corner - (1@1).	aList _ self getColumns.	1 to: aList size	do: [:i |	((aList at: i) containsPoint: startPt) ifTrue: [startClip _ aList at: i. startCol _ i].			 ((aList at: i) containsPoint: endPt) ifTrue: [endClip _ aList at: i. endCol _ i]].	startCol == nil		ifTrue: [startCol _ 1. startClip _ aList first].	endCol == nil		ifTrue: [endCol _ aList size.				endClip _ aList last]."	(startCol == nil or: [endCol == nil])		ifTrue: [^false]."	off _ startCol - 1 * ((pageBreak at: pageNumber) // (var at: #grid) y).	begin _ startPt y - startClip top// (var at: #grid) y + 1 + off.	off _ endCol - 1 * ((pageBreak at: pageNumber) // (var at: #grid) y).	end _ endPt y - endClip top // (var at: #grid) y + 1 + off min: lastLine.	^Interval from: begin to: end!paraEndStartingAt: startIndex	| paraEndIndex | 	paraEndIndex _ text findString: (String with: Character cr) startingAt: startIndex.	paraEndIndex = 0 ifTrue: [paraEndIndex _ text size].	^paraEndIndex!partialComposeFrom: startLine to: endLine 	"editChanges on the current page is saved as an array of startCharIndex, stopCharIndex and replacing text. This routine attempts to compose as little as possible	 within the given range of lines (startLine to: endLine)."	| newLines startLineIndex editChanges startOfOldText stopOfOldText replacingText paraEndIndex allLines lineIndex lastCharIndex fChar newLastLine even size chInterval |	lineIndex _ endLine + 1.	startLineIndex _ startLine.	editChanges _ var at: #editChanges.	startOfOldText _ editChanges at: 1.	stopOfOldText _ editChanges at: 2.	replacingText _ editChanges at: 3.	(replacingText size = 0 or: [replacingText last ~= Character cr])		ifTrue: ["will attempt to compose up to the paragraph end."				paraEndIndex _ self paraEndStartingAt: stopOfOldText + 1.				replacingText _ replacingText, (text copyFrom: stopOfOldText + 1 to: paraEndIndex).				stopOfOldText _ paraEndIndex.				editChanges at: 2 put: stopOfOldText.				editChanges at: 3 put: replacingText.				var at: #editChanges put: editChanges.				lineIndex _ self pickupOldFrom: stopOfOldText + 1 beginLineIndex: lineIndex].	newLines _ self quickComposing: replacingText startLine: startLineIndex.	size _ newLines size.	allLines _ OrderedCollection new.	1 to: startLineIndex - 1 do: [:i | allLines add: (lines at: i)].	1 to: size do: [:i | allLines add: ((newLines at: i) adjustBy: startOfOldText - 1)].	even _ lineIndex - startLine = size.	even		ifTrue: [lastCharIndex _ allLines last last - stopOfOldText.				[lineIndex <= lastLine]					whileTrue: [allLines add: ((lines at: lineIndex) adjustBy: lastCharIndex).								lineIndex _ lineIndex + 1]]		ifFalse: ["either more or less lines. Recompose if necessary."				self extendComposingStartingAt: lineIndex addTo: allLines].	text _ text replaceFrom: startOfOldText to: stopOfOldText with: replacingText.	fChar _ pageNumber = 1				ifTrue: [1] ifFalse: [(charIndex at: pageNumber - 1) last +1].	lastLine > allLines size		ifTrue: [lastCharIndex _ (allLines size > 0 ifTrue: [allLines last last] ifFalse: [0]).				((text size - lastCharIndex < ((lastLine - allLines size + 1) * (lastCharIndex // (allLines size max: 1) min: 80))) and: [(var at: #endText) > (fChar + BufferSize - 1)])					ifTrue: [self backupText.							self getFileText].				replacingText _ text copyFrom: lastCharIndex + 1 to: text size.				newLines _ self quickComposing: replacingText startLine: allLines size + 1.				newLines do: [:i | allLines add: (i adjustBy: lastCharIndex)]].	lastLine > allLines size ifTrue: [self eraseLines: (allLines size + 1 to: lastLine + 1)].	lastLine _ allLines size min: (((pageBreak at: pageNumber) // (var at: #grid) y) * (var at: #columns)).	lines _ allLines asArray.	self checkJustify.	var at: #recompose put: false.	lastLine > 0		ifTrue: [charIndex at: pageNumber put: (fChar to: fChar + (lines at: lastLine) last - 1).				(charIndex size >= (pageNumber + 1)						and: [(chInterval _ charIndex at: (pageNumber + 1)) ~~ nil						and: [chInterval first ~= ((charIndex at: pageNumber) last + 1)]])					ifTrue: [self nilCharacterIndexFrom: pageNumber + 1]].	^Array with: even with: size!pickupOldFrom: startCharIndex beginLineIndex: lineIndex	"look for the line which starts on charIndex. Start looking from lineIndex."	startCharIndex > (lines at: lastLine) last		ifTrue: [^lastLine + 1].	lineIndex to: lastLine do: [:i | (lines at: i) first = startCharIndex ifTrue: [^i]].	^0!quickComposing: aText startLine: startLineIndex	| maximumLine newLines lineIndex startIndex stopIndex tempLastLine maximumRightX yPos compositionScanner ff newLine aList maxLines startCol col tabPool tabs r tempTab | 	newLines _ OrderedCollection new.	aText size = 0 ifTrue: [^newLines].	lineIndex _ startLineIndex.	aList _ self getColumns.	startIndex _ 1.	stopIndex _ aText size.	tempLastLine _ maximumRightX _ rMargin _ lMargin _ 0.	maxLines _ (aList at: 1) height // (var at: #grid) y.	startCol _ startLineIndex - 1 //maxLines + 1.	yPos _ (startLineIndex - (maxLines * (startCol - 1)) - 1) * (var at: #grid) y.	var at: #savedText put: text.	text _ aText.	maximumLine _ (startCol - 1)*maxLines.	compositionScanner _ PreviewCompositionScanner new in: self.	tabPool _ var at: #tabPool.	tabs _ (var at: #tabs) at: pageNumber.	tabs == nil ifTrue: [tabs _ RunArray new: self maxLines withAll: 1].	ff _ false.	startCol to: aList size do: 		[:i | 		col _ aList at: i.		r _ col insetBy: 6 @ 0.		yPos _ yPos + (col top - clippingRectangle top).		maximumLine _ maximumLine + (col height // (var at: #grid) y).		[ff or: [lineIndex > maximumLine or: [startIndex > stopIndex]]]			whileFalse: 				[self checkAndSetMargin: yPos in: col.				tempTab == (tabs at: lineIndex)					ifFalse: [tempTab _ (tabs at: lineIndex).							compositionScanner setTabs: (tabPool at: tempTab)].				newLine _ compositionScanner							composeLine: lineIndex							fromCharacterIndex: startIndex							inParagraph: self							with: r.				tempLastLine > lineIndex ifTrue: [tempLastLine _ lineIndex].				newLines add: newLine.				lMargin _ rMargin _ 0.				yPos _ yPos + (var at: #grid) y.				maximumRightX _ compositionScanner rightX max: maximumRightX.				startIndex _ newLine last + 1.				lineIndex _ lineIndex + 1.				ff _ startIndex > 1 and: [(aText at: (startIndex - 1)) = Ctrlf]].		yPos _ 0].	text _ var at: #savedText.	var removeKey: #savedText.	^newLines!recordChange: aText from: start to: stop 	| changesOfThisPage |	changesOfThisPage _ Array with: start with: stop with: aText.	var at: #editChanges put: changesOfThisPage.!repaintLines: anInterval 	| aList off start end constantY maxLines startCol endCol relStart relEnd each rect |	aList _ self getColumns.	start _ anInterval first.	end _ anInterval last.	constantY _ (var at: #grid) y.	maxLines _ (pageBreak at: pageNumber)				// constantY.	startCol _ start - 1 // maxLines + 1.	endCol _ end - 1 // maxLines + 1 min: aList size.	relStart _ start - (maxLines * (startCol - 1)).	startCol to: endCol do: 		[:i | 		off _ maxLines * (i - 1).		relStart _ relStart + off.		relEnd _ end min: off + maxLines.		each _ aList at: i.		rect _ each origin + (0 @ (relStart - off - 1 * constantY)) extent: each width @ (relEnd - relStart + 1 * constantY).		relEnd = lastLine ifTrue: [rect _ rect origin corner: rect corner + (0 @ 10)].		self eraseRectangleOutside: (rect origin + (0 @ 2) corner: rect corner).		self displayLines: (relStart to: (relEnd min: lastLine))			at: rect origin.		relStart _ 1]! !!PreviewPage methodsFor: 'tabs'!displayTabsFrom: start to: stop edit: allowEdit	| aTabView origin rect svForm lineGrid tempTabs index temp startLine stopLine tabs flag |	flag _ false.	tempTabs _ (var at: #tabs) at: pageNumber.	tempTabs == nil ifTrue: [tempTabs _ RunArray new: lastLine withAll: 1].	startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	(tabs _ (var at: #tabs) at: pageNumber) == nil 		ifTrue: [tabs _ 1] 		ifFalse: [tabs _ tabs at: startLine].	(index _ self getTabIndex: tabs) ~= nil ifTrue: 		[allowEdit			ifTrue:				[Cursor origin showWhile: [origin _ Sensor waitButton].				lineGrid _ (var at: #grid) y.				origin _ compositionRectangle origin + (origin - compositionRectangle origin // lineGrid * lineGrid).				rect _ clippingRectangle origin x @ origin y extent: clippingRectangle width - 6 @ 144.				svForm _ Form fromDisplay: rect.				(aTabView _ PreviewTabView						openOn: ((var at: #tabPool) at: index)						at: rect origin						width: rect width						rulerUnit: (var at: #tabUnit)						tabConversion: textStyle pressScale) display.				aTabView controller startUp.				svForm displayOn: Display at: rect origin.				temp _ aTabView returnTabs.				aTabView release]			ifFalse:				[temp _ (var at: #tabPool) at: index.				temp _ Array with: temp first copy with: temp last copy with: false].		flag _ self updateTabs: tempTabs at: index by: temp from: startLine to: stopLine].	^flag!getTabCursor^Cursor extent: 16@16 fromArray: #(2r1111110000000002r0011000000000002r0011000000000002r0011000000000002r0011000000000002r0011011111000002r0001100000110002r0001101110110002r0001100000110002r0001100000110002r0000001111111002r0000001100000112r0000001111111002r0000001100000112r0000001100000112r000000111111100) offset: -7@-7!getTabIndex: startIndex	| tabSize origin bigForm temp stringForm index titleForm tabs strip pos scale aTabBar s rect lineGrid current answer |	index _ #(inch cm picas points ) indexOf: (var at: #tabUnit).	temp _ (PreviewTabView rulers at: index) copy.	titleForm _ Form extent: clippingRectangle width - 6 @ 52.	temp destForm: titleForm.	temp clipX: 0; clipY: 0; clipWidth: clippingRectangle width - 6; clipHeight: 52; destOrigin: 0 @ 0; copyBits.	tabSize _ (var at: #tabPool) size.	s _ textStyle pressScale.	bigForm _ Form extent: clippingRectangle width - 6 @ (tabSize * 20).	rect _ (0 @ 19) corner: (clippingRectangle width - 6 @ 20).	1 to: tabSize do: 		[:i | 		current _ startIndex - 2 + i \\ tabSize + 1.		tabs _ (var at: #tabPool) at: current.		(strip _ Form extent: clippingRectangle width - 6 @ 20) fill: rect rule: Form over mask: Form black.		stringForm _ ((var at: #tabNames) at: current) asForm.		strip			copyBits: (0 @ 0 extent: stringForm extent)			from: stringForm			at: strip width - stringForm width @ 0			clippingBox: strip computeBoundingBox			rule: Form over			mask: Form black.		1 to: (tabs at: 1) size do: 			[:j | 			pos _ ((tabs at: 1) at: j) // s.			aTabBar _ (PreviewTabView tabBarArray at: ((tabs at: 2) at: j)) copy.			aTabBar destForm: strip.			aTabBar destOrigin: pos @ 0; copyBits].		bigForm			copyBits: (0 @ 0 extent: strip extent)			from: strip			at: 0 @ (i - 1 * 20)			clippingBox: bigForm computeBoundingBox			rule: Form over			mask: Form black].	origin _ Sensor cursorPoint.	lineGrid _ (var at: #grid) y.	origin _ compositionRectangle origin + (origin - compositionRectangle origin // lineGrid * lineGrid).	rect _ clippingRectangle origin x @ origin y extent: clippingRectangle width - 6 @ 144.	Sensor cursorPoint: rect origin + (bigForm width // 2 @ 0).	answer _ (ScrollMenu new form: bigForm height: 20; maxLines: 5; title: titleForm)		startUp: #redButton.	answer == nil 		ifTrue: [^nil] 		ifFalse: [^answer + startIndex - 2 \\ tabSize + 1]!resetTabs	"These things are for multiple tabbing purpose"	var		at: #tabs put: (Array new: 16);		at: #tabPool put: (OrderedCollection new);		at: #tabNames put: (OrderedCollection new).	(var at: #tabPool) add: (var at: #tabsArray).	(var at: #tabNames) add: 'Default Tab Setting'.	^true!showTabs	| tabs aList off y aRect index |	(tabs _ (var at: #tabs) at: pageNumber) == nil ifTrue: [^true].	aList _ self getColumns.	off _ 0.	y _ (var at: #grid) y.	aList do: 		[:each | 		aRect _ each origin - (16 @ 0) extent: 16 @ y.		1 + off to: ((pageBreak at: pageNumber) // y + off min: lastLine)			do: 				[:i | 				index _ (tabs at: i) printString asForm.				index					displayOn: Display					at: aRect origin - (0 @ 1)					clippingBox: aRect					rule: Form reverse					mask: Form black.				aRect moveBy: 0 @ y].		off _ off + ((pageBreak at: pageNumber) // y)].	^true!tabs	^var at: #tabsArray!updateTabs: oldTabs at: tabIndex by: newTabs from: startLine to: stopLine 	| realTabs name index theTabs i val even flag |	realTabs _ Array with: (newTabs at: 1) with: (newTabs at: 2).	"true = new, false = apply, nil = bail out"	(newTabs at: 3) == nil ifTrue: [^false].	(newTabs at: 3)		ifTrue: 			[(var at: #tabPool) add: realTabs.			(var at: #tabNames) add: (FillInTheBlank request: 'Enter the name for the new tab').			index _ (var at: #tabPool) size]		ifFalse: [index _ tabIndex].	theTabs _ oldTabs				copyReplaceFrom: startLine				to: stopLine				with: (RunArray new: stopLine - startLine + 1 withAll: index).	(var at: #tabs) at: pageNumber put: theTabs.	((newTabs at: 3) or: [((var at: #tabPool) at: index) = realTabs])		ifTrue: 			[even _ self reComposeFrom: startLine to: stopLine.			self repaintLines: ((startLine - 1 max: 1) to: ((even at: 1)						ifTrue: [startLine + (even at: 2) + 1 min: lastLine]						ifFalse: [lastLine])).			^false]		ifFalse: 			[(var at: #tabPool) at: index put: realTabs.			"go find the first page with the tab!!"			i _ 1.			[val _ ((var at: #tabs) at: i).			val == nil 				ifTrue: [index ~= 1] 				ifFalse: [val _ val values.						(val indexOf: index) = 0]]						whileTrue: [i _ i + 1].			^i" ~= pageNumber.			self composePageNumbered: i.			^flag"]! !!PreviewPage methodsFor: 'press printing'!applyFont: fontIndex in: aFile 	| displayFont font |	displayFont _ textStyle fontAt: fontIndex.	font _ PressFont fontName: displayFont name.	var at: #printerSpace put: (font widthOf: Character space).	font emphasis: (displayFont emphasis bitAnd: NonFaceEmphasisMask).	aFile		selectFontCode: fontIndex		style: textStyle		rotation: (clippingRectangle width > clippingRectangle height ifTrue: [5400] ifFalse: [0]).	^(displayFont emphasis bitAnd: 4) = 4!backgroundPressFrom: startPgNo to: endPgNo theBP: theBP 	| ans savedPgNo savedLines savedLastLine savedPageBreak pressPrinter aFile savedText lastPage landscape |	(startPgNo > endPgNo or: [startPgNo < 1])		ifTrue: [^false].	self checkRecompose.	ans _ Disk makeNewFileName: theBP pressFileName withSuffix: (DataMaster giveMe: #suffixString for: #press asString).	savedPgNo _ pageNumber.	savedLines _ lines.	savedLastLine _ lastLine.	savedPageBreak _ pageBreak.	savedText _ text.	Cursor wait		showWhile: 			[pressPrinter _ (FileStream fileNamed: ans) asPressPrinter.			aFile _ pressPrinter pressFile.			pressPrinter startAtPageNo: theBP startPage.			pressPrinter useHeadings: (self getHeadingArray: theBP). 			pageNumber _ startPgNo - 1.			landscape _ (diskFile name findString: (DataMaster previewSuffixFor: #landscape) startingAt: 1) ~= 0.	"pageRect width > pageRect height"			landscape				ifTrue: 					[var at: #BP put: theBP.					self createHeader.					self pressNextPage: aFile pageNumber: theBP startPage].			[(pageNumber _ pageNumber + 1) >= charIndex size ifTrue: [self growVariables].			pageNumber = startPgNo & (pageNumber = savedPgNo) ifFalse: [Cursor execute showWhile: [self recomposeAll]].			self pressText: aFile.			self printForm: aFile.			(charIndex at: pageNumber) last >= (var at: #endText) or: [pageNumber >= endPgNo]]				whileFalse: [landscape						ifTrue: 							[aFile closePage.							self pressNextPage: aFile pageNumber: ((theBP startPage) + pageNumber)]						ifFalse: [pressPrinter nextPage]].			startPgNo = endPgNo				ifFalse: 					[lastPage _ self findLastGraphicPage.					lastPage > pageNumber ifTrue: [pageNumber + 1 to: lastPage do: 							[:each | 							pageNumber _ each.							pressPrinter nextPage.							self printForm: aFile]]].			pressPrinter close.			pageNumber _ savedPgNo.			pageNumberForm _ pageNumber printString asParagraph asForm.			pageBreak _ savedPageBreak.			"firstChar _ (charIndex at: pageNumber) first. 			lastChar _ (charIndex at: pageNumber) last."			lines _ savedLines.			lastLine _ savedLastLine.			text _ savedText].	landscape ifTrue: [var removeKey: #BP; removeKey: #headerText; removeKey: #headerLine].	theBP pressFileName: ans; pressFileCreated: true; queueData: nil callOnTurn: nil!checkForTab: delimitorTypes from: count in: aFile	count + 1 to: delimitorTypes size do: [ : i | ((delimitorTypes at: i) = #tab or: [(delimitorTypes at: i) = #runTab]) ifTrue: [^aFile resetSpace]]!createHeader	| string classification major minor newText newParagraph compositionScanner newLines startIndex |	(classification _ (var at: #suitcase) classification hardcopyString) == nil ifTrue: [classification _ String new].	major _ var at: #majorHeading.	minor _ var at: #minorHeading.	newText _ (classification, (String with: Character cr), major, (String with: Character cr), minor, (String with: Character cr)).	newParagraph _ Paragraph				withText: newText asText				style: textStyle				compositionRectangle: compositionRectangle				clippingRectangle: clippingRectangle.	compositionScanner _ PreviewCompositionScanner new initializeFromParagraph: newParagraph clippedBy: newParagraph clippingRectangle.	newLines _ Array new: 3.	startIndex _ 1.	1 to: 3 do: 		[:i | 		newLines at: i put: (compositionScanner				composeLine: i				fromCharacterIndex: startIndex				inParagraph: self				with: (clippingRectangle insetBy: 6 @ 0)).		startIndex _ (newLines at: i) last + 1.		(newLines at: i) alignment: 0].	(newLines at: 1) alignment: 1.	var at: #headerText put: newText.	var at: #headerLine put: newLines.	^newLines!findExtentInLine: line with: count 	count = 1		ifTrue: [^(line delimitorPositions at: count)				- line lMargin + (line alignment = 3					ifTrue: [line internalSpaces = 0							ifTrue: [0]							ifFalse: [(line delimitorSpaceCounts at: count)									* line paddingWidth // line internalSpaces]]					ifFalse: [0])]		ifFalse: [^(line delimitorPositions at: count)				- (line delimitorPositions at: count - 1) + (line alignment = 3					ifTrue: [line internalSpaces = 0							ifTrue: [0]							ifFalse: [(line delimitorSpaceCounts at: count)									- (line delimitorSpaceCounts at: count - 1) * line paddingWidth // line internalSpaces]]					ifFalse: [0])]!getHeadingArray: theBP 	^Array		with: ((var at: #suitcase)  classification hardcopyString = String new ifFalse: [(var at: #suitcase)  classification hardcopyString asText])		with: ((theBP applicAnswers at: 2) == nil				ifFalse: 					[var at: #majorHeading put: (theBP applicAnswers at: 2).					(theBP applicAnswers at: 2) asText])		with: ((theBP applicAnswers at: 3) == nil				ifFalse: 					[var at: #minorHeading put: (theBP applicAnswers at: 3).					(theBP applicAnswers at: 3) asText])!pressNextPage: aFile pageNumber: pg	"1 inch = 2540 press point"	| minX y newLine newText height x string |	aFile		selectFontCode: 1		style: textStyle		rotation: 5400.	minX _ (var at: #defaultMargins) left + (var at: #printerOffset) x + 192.	newLine _ var at: #headerLine.	newText _ var at: #headerText.	height _ 12 * textStyle pressScale.	pg <= 1		ifFalse: 			[string _ pg printString.			x _ 26670 - (var at: #defaultMargins) right - (176 * string size).			y _ 27305 - height.			self translate: x @ y in: aFile.			aFile showCharacters: string size; nextPutAll: string].	y _ 27305.	pg <= 1		ifTrue: 			[x _ self						setX: (newLine at: 1) lMargin + minX						withLine: (newLine at: 1)						inFile: aFile.			self translate: x @ y in: aFile.			string _ newText copyFrom: (newLine at: 1) first to: (newLine at: 1) last.			string _ string last asciiValue = 13						ifTrue: [string copyFrom: 1 to: string size - 1]						ifFalse: [string].			aFile showCharacters: string size; nextPutAll: string]		ifFalse: [newLine do: 				[:each | 				x _ self							setX: each lMargin + minX							withLine: each							inFile: aFile.				self translate: x @ y in: aFile.				string _ newText copyFrom: each first to: each last.				string _ string last asciiValue = 13							ifTrue: [string copyFrom: 1 to: string size - 1]							ifFalse: [string].				aFile showCharacters: string size; nextPutAll: string.				y _ y - height]].	x _ self				setX: (newLine at: 1) lMargin + minX				withLine: (newLine at: 1)				inFile: aFile.	self translate: x @ 7620 in: aFile.	string _ newText copyFrom: (newLine at: 1) first to: (newLine at: 1) last.	string _ string last asciiValue = 13				ifTrue: [string copyFrom: 1 to: string size - 1]				ifFalse: [string].	aFile showCharacters: string size; nextPutAll: string!pressSingleLine: line in: aFile 	| underLine x minX stringSize spaces startPoint extent delimitorPositions right underLineCollection changeFlag widthOfColumn y scale |	widthOfColumn _ var at: #widthOfColumn.	minX _ var at: #minX.	right _ var at: #right.	y _ var at: #y.	scale _ textStyle pressScale.	startPoint _ line first.	delimitorPositions _ line delimitorPositions.	underLineCollection _ OrderedCollection new.	underLine _ var at: #underLine.	x _ self setX: line lMargin + minX withLine: line inFile: aFile.	"aFile setX: x"self translate: x@y in: aFile.	1 to: line delimitorCount do: 		[:count | 		(stringSize _ line countsBetweenDelimitors at: count) > 0			ifTrue: 				[self checkForTab: line delimitorTypes from: count in: aFile.				spaces _ self putCharFrom: startPoint size: stringSize inFile: aFile.				underLine					ifTrue: 						[extent _ self findExtentInLine: line with: count.						x + extent > (right - line rMargin) ifTrue: [extent _ right - line rMargin - x].						underLineCollection add: (x @ (y - 64) extent: extent @ 32)]].		startPoint _ (line delimitorIndices at: count) + 1.		((changeFlag _ line delimitorTypes at: count) = #run or: [changeFlag = #runTab])			ifTrue: 				[underLine _ self applyFont: (text emphasisAt: startPoint) in: aFile.				var at: #underLine put: underLine.				underLine					ifTrue: 						[x _ (delimitorPositions at: count)									+ minX + (line alignment = 3										ifTrue: [line internalSpaces = 0												ifTrue: [0]												ifFalse: [(line delimitorSpaceCounts at: count)														* line paddingWidth // line internalSpaces]]										ifFalse: [0]).						x _ self setX: x withLine: line inFile: aFile]].		changeFlag = #tab | (changeFlag = #runTab)			ifTrue: 				[x _ self setX: (delimitorPositions at: count) + minX withLine: line inFile: aFile.				"aFile setX: x"self translate: x@y in: aFile]].	line delimitorCount = 0 ifTrue: [count _ 1].	(stringSize _ line last - startPoint + 1) = 0 | (line first = line last)		ifFalse: 			[spaces _ self putCharFrom: startPoint size: stringSize inFile: aFile.			underLine				ifTrue: 					[extent _ widthOfColumn - (delimitorPositions at: count) - line rMargin.					line delimitorCount = 0						ifTrue: [line alignment = 3 & (line internalSpaces ~= 0) ifFalse: [extent _ extent - line lMargin - line paddingWidth - (spaces * (var at: #printerSpace))]]						ifFalse: 							[extent _ extent - (line internalSpaces = 0											ifTrue: [0]											ifFalse: [(line delimitorSpaceCounts at: count)													* line paddingWidth // line internalSpaces]).							line alignment = 3 & (line internalSpaces ~= 0) ifFalse: [extent _ extent - line paddingWidth - ((var at: #printerSpace)												* (spaces - 1 max: 0))]].					x + extent > (right - line rMargin) ifTrue: [extent _ right - line rMargin - x].					extent < 0 ifTrue: [extent _ 0].					underLineCollection add: (x @ (y - 64) extent: extent @ 32)]].	clippingRectangle width > clippingRectangle height ifTrue: [underLineCollection do: [:each | self translate: each origin in: aFile. aFile setX: (aFile currentX - each height); showRectangleExtent: (each extent y @ each extent x)]] ifFalse: [underLineCollection do: [:each | aFile setPoint: each origin; showRectangleExtent: each extent]]!pressText: aFile 	| aList off margins height widthOfColumn y minX right lineOffset line |	text size = 0 ifTrue: [^self].	aList _ self getColumns.	off _ var at: #printerOffset.	margins _ var at: #defaultMargins.	height _ (var at: #grid) y * textStyle pressScale.	var at: #underLine put: (self applyFont: (text emphasisAt: 1) in: aFile).	1 to: (var at: #columns)		do: 			[:column | 			y _ 27940 - margins top - off y.			widthOfColumn _ (aList at: column) width - 12 * textStyle pressScale.			minX _ margins left + off x + 192 + ((aList at: column) left - clippingRectangle left * textStyle pressScale).			right _ minX + widthOfColumn.			lineOffset _ column - 1 * ((pageBreak at: pageNumber) // (var at: #grid) y).			var at: #widthOfColumn put: widthOfColumn.			var at: #minX put: minX.			var at: #right put: right.			1 to: ((pageBreak at: pageNumber) // (var at: #grid) y min: lines size) do: 				[:linePosition | 				(line _ lines at: linePosition + lineOffset) == nil ifTrue: [^self].				aFile resetSpace.				y _ y - height.				"aFile setY: y."				var at: #y put: y.				self pressSingleLine: line in: aFile]].	var removeKey: #widthOfColumn.	var removeKey: #minX.	var removeKey: #y.	var removeKey: #right.	var removeKey: #underLine!printForm: aFile 	| picture p off aPoint landscape scale |	(pictureLocation at: pageNumber) == nil ifTrue: [^self].	landscape _ pageRect height > pageRect width ifTrue: [3] ifFalse: [8].	off _ var at: #printerOffset.	(pictureLocation at: pageNumber)		do: 			[:each | 			each fileName = String new				ifFalse: 					[each form == nil						ifTrue: [picture _ Form readFrom: each fileName]						ifFalse: [picture _ each form].					p _ each offset.					each pBorder ifTrue: [self putRect: each rectangle in: aFile].					aPoint _ off x + (MinMargins at: PressOrInterpress) left + (each rectangle origin x * 32) @ (27940 - off y - (MinMargins at: PressOrInterpress) top - (each rectangle origin y + each rectangle height * 32)).					scale _ 32 @ 32 * (each scale x asFloat @ each scale y asFloat).					self translate: aPoint in: aFile.					aFile						printDots: picture bits						width: picture width						window: picture boundingBox						bitsPerPixel: 1						opaque: false						direction: landscape						scaleWidth: scale x						scaleHeight: scale y].			each rBorder ifTrue: [self putRect: each rectangle in: aFile]]!putCharFrom: startPoint size: stringSize inFile: aFile 	| string i |	string _ (String new: stringSize)				primReplaceFrom: 1				to: stringSize				with: text string				startingAt: startPoint.	string _ string last asciiValue = 13				ifTrue: [string copyFrom: 1 to: string size - 1]				ifFalse: [string]. 	aFile showCharacters: string size; nextPutAll: string.	i _ 0.	string reverseDo: [ : each | each asciiValue = 32 ifTrue: [i _ i + 1] ifFalse: [^i]].	^i!putRect: aRect in: aFile 	| rectangle p margins min h scale landscape aPoint |	landscape _ clippingRectangle width > clippingRectangle height and: [true].	offset _ var at: #printerOffset.	margins _ var at: #defaultMargins.	min _ MinMargins at: PressOrInterpress.	h _ 27940.	scale _ textStyle pressScale.	rectangle _ Rectangle origin: aRect origin extent: 2 @ aRect height.	p _ rectangle origin.	aPoint _ min left + offset x + (p x * 32) @ (h - offset y - min top - (p y + rectangle height * 32)).	self translate: aPoint in: aFile.	landscape		ifTrue: [aFile setX: (aFile currentX - (rectangle height * scale)). aFile showRectangleExtent: rectangle extent y @ rectangle extent x * scale]		ifFalse: [aFile showRectangleExtent: rectangle extent * scale].	rectangle _ Rectangle origin: aRect origin extent: aRect width @ 2.	p _ rectangle origin.	aPoint _ min left + offset x + (p x * scale) @ (h - offset y - min top - (p y + rectangle height * scale)).	self translate: aPoint in: aFile.	landscape		ifTrue: [aFile setX: (aFile currentX - (rectangle height * scale)). aFile showRectangleExtent: rectangle extent y @ rectangle extent x * scale]		ifFalse: [aFile showRectangleExtent: rectangle extent * scale].	rectangle _ Rectangle origin: aRect topRight - (2 @ 0) extent: 2 @ aRect height.	p _ rectangle origin.	aPoint _ min left + offset x + (p x * scale) @ (h - offset y - min top - (p y + rectangle height * scale)).	self translate: aPoint in: aFile. 	landscape		ifTrue: [aFile setX: (aFile currentX - (rectangle height * scale)). aFile showRectangleExtent: rectangle extent y @ rectangle extent x * scale]		ifFalse: [aFile showRectangleExtent: rectangle extent * scale].	rectangle _ Rectangle origin: aRect bottomLeft - (0 @ 2) extent: aRect width @ 2.	p _ rectangle origin.	aPoint _ min left + offset x + (p x * scale) @ (h - offset y - min top - (p y + rectangle height * scale)).	self translate: aPoint in: aFile.	landscape		ifTrue: [aFile showRectangleExtent: rectangle extent y @ rectangle extent x * scale]		ifFalse: [aFile showRectangleExtent: rectangle extent * scale]!setX: x withLine: line inFile: aFile 	| mode t |	(mode _ line alignment) = 1 ifTrue: [^x + (line paddingWidth // 2)].	mode = 2 ifTrue: [^x + line paddingWidth].	mode = 3 ifTrue: [line internalSpaces = 0 ifFalse: [clippingRectangle width > clippingRectangle height				ifTrue: [aFile setSpaceY: (var at: #printerSpace)								+ (line paddingWidth // line internalSpaces)]				ifFalse: [aFile setSpaceX: (var at: #printerSpace)							+ (line paddingWidth // line internalSpaces)]]].	"mode = 3 ifTrue: [aFile setSpaceX: (var at: #printerSpace) 	+  line justifiedPad]."	^x!translate: aPoint in: aFile 	| off margins originY originX desX desY offPoint |	offPoint _ 635@-317.	clippingRectangle width > clippingRectangle height		ifTrue: 			[off _ var at: #printerOffset.			margins _ var at: #defaultMargins.			"height _ (var at: #grid) y * textStyle pressScale."			originY _ 27940 - margins top - off y + offPoint y.			originX _ margins left + off x + 192 + offPoint x.			desX _ "21590 - margins top - off y"originX + off x.			desY _ "originY"margins bottom + off y.			"aFile setPoint: desX + (aPoint y - originY) @ (desY - (aPoint x - originX))"			aFile setPoint: desX - (aPoint y - originY) @ (desY + (aPoint x - originX))]		ifFalse: [aFile setPoint: aPoint]! !!PreviewPage methodsFor: 'interpress printing'!backgroundInterPressFrom: startPgNo to: endPgNo theBP: theBP 	| savedPageBreak |	(startPgNo > endPgNo or: [startPgNo < 1])		ifTrue: [^false].	((var at: #recompose) and: [startPgNo <= pageNumber and: [pageNumber <= endPgNo]])		ifTrue: [self recomposePage].	var at: #savedPgNo put: pageNumber.	var at: #savedLines put: lines.	var at: #savedLastLine put: lastLine.	var at: #savedText put: text.	savedPageBreak _ pageBreak.	pageNumber _ startPgNo.	self createInterpressMaster: theBP to: endPgNo thisPageOnly: (startPgNo = endPgNo).	pageNumber _ var at: #savedPgNo.	lines _ var at: #savedLines.	lastLine _ var at: #savedLastLine.	text _ var at: #savedText.	var removeKey: #savedPgNo; removeKey: #savedLines; removeKey: #savedLastLine; removeKey: #savedText.	pageBreak _ savedPageBreak.!checkBorderData: answer	| ans border types labels defaults |	ans _ answer at: 1.	ans = $n		ifTrue: ["none"]		ifFalse: [ans = $s					ifTrue: [labels _ #(#('Width :' '1' '2' '3' '4' '5' '6' '7' '8' '9')).							types _ #(select).							defaults _ #('1')]					ifFalse: [labels _ #(#('Inner width :' '1' '2' '3' '4' '5' '6' '7' '8' '9') #('Outer width :' '1' '2' '3' '4' '5' '6' '7' '8' '9')).							types _ #(select select).							defaults _ #('1' '1')].							border _ DBoxView openFor: types title: 'Border Width in Pixels' labels: labels defaults: defaults.				border == nil					ifTrue: [^self booboo: 'Missing information ... border(s) will not be printed !!!!']					ifFalse: [var at: #borders put: border]]!composePage: pgNo	self lastPage to: pgNo - 1 do: [:pg |		(charIndex at: pg) == nil			ifTrue: [pageNumber _ pg.					self recomposeAll]].	pageNumber _ pgNo.	pageNumber = (var at: #savedPgNo ifAbsent: [0])		ifTrue: [text _ var at: #savedText.				lines _ var at: #savedLines.				lastLine _ var at: #savedLastLine]		ifFalse: [self recomposeAll]!createInterpressMaster: theBP to: endPgNo thisPageOnly: aBoolean	| ans master array endOfText landscape |	array _ Array new: 3.	array at: 1 put: ((var at: #suitcase) classification hardcopyString);		at: 2 put: (theBP applicAnswers at: 2);		at: 3 put: (theBP applicAnswers at: 3).	(array at: 2) == nil ifFalse: [var at: #majorHeading put: (array at: 2)].	(array at: 3) == nil ifFalse: [var at: #minorHeading put: (array at: 3)].	var at: #linesBetweenBorders put: theBP applicAnswers last.	landscape _ (diskFile name findString: (DataMaster previewSuffixFor: #landscape) startingAt: 1) ~= 0.	"pageRect width > pageRect height"	Cursor wait showWhile: 		[ans _ Disk makeNewFileName: theBP pressFileName withSuffix: (DataMaster giveMe: #suffixString for: #interpress asString).		master _ Interpress					withText: Text new					printStyle: textStyle					hardCopyOnFileNamed: ans.		master margins: self defaultMargins;			lineGrid: (var at: #grid) y * textStyle pressScale;			pageNumber: pageNumber + theBP startPage - 1;			heading: array.		master beginPageBodies.		endOfText _ false.		[endOfText or: [pageNumber > endPgNo]]			whileFalse: 				[Cursor execute showWhile: [self composePage: pageNumber].				master					text: text;					beginOnePageBodyLandscape: landscape.				self printPixOnMaster: master page: pageNumber.				self printTextOnMaster: master.				master endOnePageBody.				endOfText _ (charIndex at: pageNumber) last >= (var at: #endText).				pageNumber _ pageNumber + 1.				pageNumber > charIndex size ifTrue: [self growVariables]].		aBoolean			ifFalse: [pageNumber to: (self findLastGraphicPage)						do: [:pgIndex |	master beginOnePageBodyLandscape: landscape.										self printPixOnMaster: master page: pgIndex.										master endOnePageBody]].		master endPageBodies].	theBP pressFileName: ans; pressFileCreated: true; queueData: nil callOnTurn: nil!defaultMargins	^(var at: #defaultMargins) origin		extent: compositionRectangle extent * textStyle pressScale!printBorder: master	| scale realOffset aForm r scaleFactor origin printerRect rectCol borders i |	borders _ var at: #borders.	scale _ textStyle pressScale.	realOffset _ (var at: #defaultMargins) origin.	i _ 0.	r _ -6@0 extent: clippingRectangle extent"translateBy: (-6@0)".	[i < borders size]	whileTrue:  [i _ i + 1.				rectCol _ (r expandBy: (borders at: i) asNumber) areasOutside: r.				rectCol do: [:printerRect |					master printRectangle: (printerRect scaleBy: scale) translateBy: realOffset].				r _ r expandBy: (borders at: i) asNumber + ((var at: #linesBetweenBorders) asNumber * (var at: #grid) y)].!printPixOnMaster: master page: pgIndex	| col |	col _ pictureLocation at: pgIndex.	(var includesKey: #borders)		ifTrue: [self printBorder: master].	col == nil		ifFalse: [self printPixOnMaster: master					page: pgIndex					collection: (col select: [:each | each opaque not]).				self printPixOnMaster: master					page: pgIndex					collection: (col select: [:each | each opaque])].!printPixOnMaster: master page: pgIndex collection: col	| scale realOffset aForm r scaleFactor origin printerRect rectCol |	scale _ textStyle pressScale.	realOffset _ (MinMargins at: PressOrInterpress) origin.	col == nil ifFalse: [	col do: [:rectForm |		rectForm rBorder			ifTrue: [r _ rectForm translateBy: (-6@0).					rectCol _ r areasOutside: (r insetBy: 2).					rectCol do: [:printerRect |						master printRectangle: (printerRect scaleBy: scale)								translateBy: realOffset]].		aForm _ rectForm getForm.		aForm == nil			ifFalse: [scaleFactor _ rectForm scale.					origin _ rectForm offset.					rectForm pBorder						ifTrue: [r _ (origin extent: (aForm extent scaleBy: scaleFactor)) translateBy: (-6@0) .								rectCol _ r areasOutside: (r insetBy: 2).								rectCol do: [:printerRect |									master printRectangle: (printerRect scaleBy: scale)											translateBy: realOffset]].					master printFullForm: aForm							scale: scale*(scaleFactor y@scaleFactor x)							setPos: ((origin - (6@0) * scale) + realOffset)]]]!printTextOnMaster: master	| rectCol scale lineIndex rect left |	rectCol _ self getColumns.	scale _ textStyle pressScale.	lineIndex _ 0.	left _ compositionRectangle left.	1 to: rectCol size do: [:i |		rect _ (rectCol at: i) insetBy: 6@0.		master makePageContents: lines			from: lineIndex + 1			to: (lineIndex _ (lineIndex + (rect height //(var at: #grid) y)) min: lastLine)			left: (rect left - left * scale)			width: (rect width * scale)].! !!PreviewPage methodsFor: 'file in/out'!array: anArray out: aFile	aFile nextPutAll: anArray size printString; nextPut: Delimiter.	1 to: anArray size do: [ : i | 		aFile 			nextPutAll: (anArray at: i) printString; nextPut: Delimiter]!arrayIn: aFile	| size array temp | 	size _ Integer readFrom: aFile.	aFile next.	array _ Array new: size.	1 to: size do:		[:i | ((temp _ aFile upTo: Delimiter) sameAs: #nil)				ifFalse: [array at: i put: temp asNumber]]. 	^array!interval: anInterval out: aFile	aFile 		nextPutAll: anInterval first printString; nextPut: Delimiter; 		nextPutAll: anInterval last printString; nextPut: Delimiter!point: aPoint out: aFile	aFile 		nextPutAll: aPoint x printString; nextPut: Delimiter; 		nextPutAll: aPoint y printString; nextPut: Delimiter!pointIn: aFile	| temp result | 	temp _ Point new.	temp x: ((result _ aFile upTo: Delimiter) asNumber).	temp y: ((result _ aFile upTo: Delimiter) asNumber).	^temp!rect: aRect out: aFile	self point: aRect origin out: aFile.	self point: aRect extent out: aFile!rectIn: aFile	| temp | 	(temp _ Rectangle new) origin: (self pointIn: aFile).	temp extent: (self pointIn: aFile).	^temp!runs: aRun out: aFile	aRun == nil		ifTrue: [aFile nextPut: $0.				aFile nextPut: Delimiter]		ifFalse: [aFile nextPutAll: aRun runs size printString; nextPut: Delimiter.				1 to: aRun runs size do: [ : i | 					aFile 						nextPutAll: (aRun runs at: i) printString; nextPut: Delimiter;						nextPutAll: (aRun values at: i) printString; nextPut: Delimiter]]!runsIn: aFile	| size newRuns newValues | 	size _ Integer readFrom: aFile.	aFile next.	size = 0 ifTrue: [^nil].	newRuns _ Array new: size.	newValues _ Array new: size.	1 to: size do: [ : i | 		newRuns at: i put:  (Integer readFrom: aFile).		aFile next.		newValues at: i put:  (Integer readFrom: aFile).		aFile next].	^RunArray runs: newRuns values: newValues!tabArray: anArray out: aFile 	| size size2 |	size _ (anArray at: 1) size.	aFile nextPutAll: size printString; nextPut: Delimiter.	1 to: size do: [:i |		aFile nextPutAll: ((anArray at: 1) at: i) printString; nextPut: Delimiter.		aFile nextPutAll: ((anArray at: 2) at: i) printString; nextPut: Delimiter]!tabArrayIn: aFile 	| size array2 array1 |	size _ (aFile upTo: Delimiter) asNumber.	array1 _ Array new: size.	array2 _ Array new: size.	1 to: size do: [:i | 		array1 at: i put: (aFile upTo: Delimiter) asNumber.		array2 at: i put: (aFile upTo: Delimiter) asNumber].	^Array with: array1 with: array2!tabNames: anArray out: aFile 	| size |	size _ anArray size.	aFile nextPutAll: size printString; nextPut: Delimiter.	1 to: size do: [:i |		aFile nextPutAll: (anArray at: i); nextPut: Delimiter]!tabNamesIn: aFile 	| size collection |	size _ (aFile upTo: Delimiter) asNumber.	collection _ OrderedCollection new.	1 to: size do: [:i | collection add: (aFile upTo: Delimiter)].	^collection!tabPool: aPool out: aFile 	| poolSize |	poolSize _ aPool size.	aFile nextPutAll: poolSize printString; nextPut: Delimiter.	1 to: poolSize do: [:i | self tabArray: ((var at: #tabPool) at: i) out: aFile]!tabPoolIn: aFile 	| poolSize collections temp |	poolSize _ (aFile upTo: Delimiter) asNumber.	collections _ OrderedCollection new.	1 to: poolSize do: 		[:i | 		temp _ self tabArrayIn: aFile.		collections add: temp].	^collections!tabs: anArray out: aFile 	| taken |	aFile nextPutAll: anArray size printString; nextPut: Delimiter.	taken _ self findLastGraphicPage.	aFile nextPutAll: taken printString; nextPut: Delimiter.	1 to: taken do: [:i | self runs: ((var at: #tabs) at: i) out: aFile]!tabsIn: aFile	| size array temp taken | 	size _ Integer readFrom: aFile.	aFile next.	array _ Array new: size.	taken _ Integer readFrom: aFile.	aFile next.	1 to: taken do:		[:i | temp _ self runsIn: aFile.			array at: i put: temp]. 	^array!var: aVar out: aFile	"VarSaveList is supposed to be  #(gutter endText columns minorHeading majorHeading tabUnit grid printerOffset defaultMargins tabsArray tabs tabPool tabNames)."	VarSaveList size storeOn: aFile.	aFile nextPut: Delimiter.	1 to: 3 do: [ : i |	aFile nextPutAll: (VarSaveList at: i) printString; nextPut: Delimiter. 		aFile nextPutAll: (aVar at: (VarSaveList at: i)) printString; nextPut: Delimiter].		4 to: 5 do: [ : i |	aFile nextPutAll: (VarSaveList at: i) printString; nextPut: Delimiter. 		 aFile nextPutAll: (aVar at: (VarSaveList at: i)) ; nextPut: Delimiter].	aFile nextPutAll: #tabUnit printString; nextPut: Delimiter.			aFile nextPutAll: (aVar at: (VarSaveList at: 6)) printString; nextPut: Delimiter.		7 to: 8 do: [ : i |	aFile nextPutAll: (VarSaveList at: i) printString; nextPut: Delimiter. 		 self point: (aVar at: (VarSaveList at: i)) out: aFile].	aFile nextPutAll: (VarSaveList at: 9) printString; nextPut: Delimiter. 	self rect: (aVar at: (VarSaveList at: 9)) out: aFile.	aFile nextPutAll: #tabsArray printString; nextPut: Delimiter.	self tabArray: (aVar at: (VarSaveList at: 10)) out: aFile.	aFile nextPutAll: #tabs printString; nextPut: Delimiter.	self tabs: (aVar at: #tabs) out: aFile.	aFile nextPutAll: #tabPool printString; nextPut: Delimiter.	self tabPool: (aVar at: #tabPool) out: aFile.	aFile nextPutAll: #tabNames printString; nextPut: Delimiter.	self tabNames: (aVar at: #tabNames) out: aFile!varIn: aFile"VarSaveList is supposed to be  #(bufferSize gutter endText columns minorHeading majorHeading tabUnit grid printerOffset defaultMargins minMargins tabsArray tabs tabPool tabNames)."	| dict size theKey | 	dict _ OopConservingDictionary new.	size _ (aFile upTo: Delimiter) asNumber.	1 to: size do: [ : i | theKey _ (aFile upTo: Delimiter) asSymbol.		theKey ==#bufferSize			ifTrue: [aFile upTo: Delimiter.					"dict at: theKey put: (aFile upTo: Delimiter) asNumber"].		theKey ==#gutter ifTrue: [dict at: theKey put: (aFile upTo: Delimiter) asNumber].		theKey ==#endText ifTrue: [dict at: theKey put: (aFile upTo: Delimiter) asNumber].		theKey ==#columns ifTrue: [dict at: theKey put: (aFile upTo: Delimiter) asNumber].		theKey ==#minorHeading ifTrue: [dict at: theKey put: (aFile upTo: Delimiter)].		theKey ==#majorHeading ifTrue: [dict at: theKey put: (aFile upTo: Delimiter)].		theKey ==#tabUnit ifTrue: [dict at: theKey put: (aFile upTo: Delimiter) asSymbol].		theKey ==#grid ifTrue: [dict at: theKey put: (self pointIn: aFile)].		theKey ==#printerOffset ifTrue: [dict at: theKey put: (self pointIn: aFile)].		theKey ==#defaultMargins ifTrue: [dict at: theKey put: (self rectIn: aFile)].		theKey ==#minMargins			ifTrue: [self rectIn: aFile.					"dict at: theKey put: (self rectIn: aFile)"].		theKey ==#tabsArray ifTrue: [dict at: theKey put: ( self tabArrayIn: aFile)].		theKey ==#tabs ifTrue: [dict at: theKey put: (self tabsIn: aFile)].		theKey ==#tabPool ifTrue: [dict at: theKey put: (self tabPoolIn: aFile)].		theKey ==#tabNames ifTrue: [dict at: theKey put: (self tabNamesIn: aFile)]].	^dict! !!PreviewPage methodsFor: 'store/retrieve'!backupText	"Something has been changed and we need to write it out before we lose the context of the changes."	| txtFileName backupTxtName newTxtFile fromFile |	txtFileName _ diskFile name.	backupTxtName _ (var at: #suitcase) dataItem filename, (DataMaster previewSuffixFor: #backupText).	(Disk includesKey: backupTxtName)		ifFalse: [diskFile close. "don't have backup yet, create one"				Disk copy: txtFileName to: backupTxtName.				diskFile _ (FileStream fileNamed: txtFileName) readOnly].	newTxtFile _ (FileStream fileNamed: 'PRVWXXXX.TMP') writeShorten.	self writeCurrentTextOn: newTxtFile from: diskFile saveRuns: false.	Disk removeKey: txtFileName.	Disk renameKey: newTxtFile name newName: txtFileName.	diskFile _ (FileStream oldFileNamed: txtFileName) readOnly.	var at: #initTextSize put: text size.	(var includesKey: #updateFile) ifTrue: [var removeKey: #updateFile].!putImageHeader: aFile 	"It is used in the store routine to put the names of all images at the beginning of the file"	| names |	names _ OrderedCollection new.	pictureLocation do: [:each |		each == nil			ifFalse: [each do: [:i | i fileName == nil | (i fileName = String new)									ifFalse: [names add: i fileName]]]].	aFile nextPutAll: names size printString; nextPut: Character cr.	names do: [:each | aFile nextPutAll: each; nextPut: Character cr]!restoreText	"the user asked to go back to what was last saved, so get back the original text from the backup file"	| txtFileName backupTxtName | 	txtFileName _ diskFile name.	backupTxtName _ (var at: #suitcase) dataItem filename, (DataMaster previewSuffixFor: #backupText).	(Disk includesKey: backupTxtName)		ifTrue: [Disk removeKey: txtFileName.				Disk renameKey: backupTxtName newName: txtFileName].	diskFile _ (FileStream oldFileNamed: txtFileName) readOnly.	self nilFrom: 1.	self setPageNumber: 1.	runs _ self getRuns: diskFile.	self getFileTextFrom: 1 to: -1.!restoreThenRelease	"the user wants to close the preview without saving the changes that were made since last saved.	 So if there is a backup .txt$$ file, make it be the .txt file.	 If this was a temporary preview that hasn't been saved, then delete both the files"	| txtFileName backupTxtName | 	diskFile == nil		ifFalse: [txtFileName _ diskFile name.				backupTxtName _ (var at: #suitcase) dataItem filename, (DataMaster previewSuffixFor: #backupText).				(Disk includesKey: backupTxtName)					ifTrue: [Disk removeKey: txtFileName.							Disk renameKey: backupTxtName newName: txtFileName].				diskFile close; release.				((txtFileName findString: #TMPV asString startingAt: 1) ~= 0 and: [(var at: #suitcase) dataItem centerIndex = 0])					ifTrue: [Disk removeKey: (var at: #suitcase) dataItem filename ifAbsent: []. "destroy temporary files"							Disk removeKey: txtFileName ifAbsent: []]].	^true!retBlockNew: aFileStream	| temp size arraySize howMany | 	"read in character indices"	arraySize _ Integer readFrom: aFileStream.	aFileStream next.	howMany _ Integer readFrom: aFileStream.	aFileStream next.	charIndex _ Array new: arraySize.	1 to: howMany do:		[:i | charIndex at: i put: (Interval from: (aFileStream upTo: Delimiter) asNumber to: (aFileStream upTo: Delimiter) asNumber)].	"read in justification indices"	justifyIndex _ Array new: arraySize.	1 to: howMany do: [:i | justifyIndex at: i put: (self runsIn: aFileStream)].	howMany _ Integer readFrom: aFileStream.	aFileStream next.	arraySize _ arraySize max: howMany.	"read in page breaks"	pageBreak _ Array new: arraySize.	1 to: howMany do: [:i |		aFileStream peek = $n			ifTrue: [aFileStream upTo: Delimiter]			ifFalse: [pageBreak at: i put: (aFileStream upTo: Delimiter) asNumber]].	"read in picture locations"	pictureLocation _ Array new: arraySize.	1 to: howMany do:		[:i | aFileStream peek == Delimiter			ifTrue: [aFileStream upTo: Delimiter]			ifFalse: [size _ Integer readFrom: aFileStream.					aFileStream next.					temp _ OrderedCollection new.					size timesRepeat: [temp add: (RectForm readFrom: aFileStream delimiter: Delimiter)].					pictureLocation at: i put: temp]]!retBlockOld: aFileStream	"read in character indices"	| temp | 	charIndex _ Array new: (Integer readFrom: aFileStream).	aFileStream next.	1 to: charIndex size do:		[:i | ((temp _ aFileStream upTo: Delimiter) sameAs: #nil)				ifFalse: [charIndex at: i put: (Compiler evaluate: temp)]].	"read in page breaks"	pageBreak _ Array new: (Integer readFrom: aFileStream).	aFileStream next.	1 to: pageBreak size do:		[:i | ((temp _ aFileStream upTo: Delimiter) sameAs: #nil)				ifFalse: [pageBreak at: i put: temp asNumber]].	"read in justification indices"	justifyIndex _ Array new: (Integer readFrom: aFileStream).	aFileStream next.	1 to: justifyIndex size do:		[:i | ((temp _ aFileStream upTo: Delimiter) sameAs: #nil)				ifFalse: [justifyIndex at: i put: (Compiler evaluate: temp)]].	"read in picture locations"	pictureLocation _ Array new: (Integer readFrom: aFileStream).	aFileStream next.	1 to: pictureLocation size do:		[:i | ((temp _ aFileStream upTo: Delimiter) sameAs: #nil) ifFalse:				[pictureLocation at: i put: (Compiler evaluate: temp).				(pictureLocation at: i) do:					[:j | j opaque: true.						j scale == nil ifTrue: [j scale: 1@1]]]]!retrieve	| filename aFile actualStream flag orientation |	filename _ (var at: #suitcase) dataItem filename.	(aFile _ HeaderFileStream oldFileNamed: filename) readOnly.	aFile size = 0		ifTrue: [aFile close.			^false].	Cursor wait showWhile:		[(var at: #suitcase) updateFromHeaderIn: aFile.		actualStream _ aFile fileStream.		(flag _ (actualStream peek isDigit) not) ifTrue: [orientation _ actualStream next].		(Integer readFrom: actualStream)+ 1 timesRepeat: [actualStream skipTo: Character cr].		flag ifTrue: [self retrieveNew: actualStream] ifFalse: [self retrieveOld: actualStream].		aFile close.		var at: #recompose put: false.		self restoreRectForm]!retrieveNew: aFile 	| temp s twoMicasUnit |	s _ textStyle pressScale.	self retBlockNew: aFile.	purgeList _ OrderedCollection new.	runs _ self runsIn: aFile.	pageRect _ self rectIn: aFile.	temp _ self varIn: aFile.	var keysDo: [:key | (temp includesKey: key) ifTrue: [var at: key put: (temp at: key)]].	var at: #defaultMargins put: ((temp at: #defaultMargins) origin * s corner: (temp at: #defaultMargins) corner * s).	twoMicasUnit _ textStyle class == PrintStyle ifTrue: [1] ifFalse: [2].	var at: #tabsArray put:		  (Array with: ((var at: #tabsArray) first collect: [:each | each * twoMicasUnit])				with: (var at: #tabsArray) last)!retrieveOld: actualStream 	| temp s twoMicasUnit |	s _ textStyle pressScale.	Integer readFrom: actualStream. "dump old page number"	actualStream next. "eat it"	self retBlockOld: actualStream.	purgeList _ Compiler evaluate: (actualStream upTo: Delimiter).	actualStream upTo: Delimiter. "eat the runs, the ones in the text file are more reliable"	"runs _ Compiler evaluate: (actualStream upTo: Delimiter)."	pageRect _ Compiler evaluate: (actualStream upTo: Delimiter).	temp _ Compiler evaluate: (actualStream upTo: Delimiter).	var keysDo: [:key | (temp includesKey: key)			ifTrue: [var at: key put: (temp at: key)]].	var at: #defaultMargins put: ((temp at: #defaultMargins) origin * s corner: (temp at: #defaultMargins) corner * s).	twoMicasUnit _ textStyle class == PrintStyle				ifTrue: [1]				ifFalse: [2].	((var at: #tabsArray) first isKindOf: Array)		ifTrue: [var at: #tabsArray					put: (Array with: ((var at: #tabsArray) first collect: [:each | each * twoMicasUnit])							with: (var at: #tabsArray) last)]		ifFalse: [var at: #tabsArray put: (Array with: (var at: #tabsArray) with: (Array new: (var at: #tabsArray) size withAll: 1))].	(var at: #tabPool) at: 1 put: (var at: #tabsArray)!saveText	"the user has decided to save it, here we save the text"	| txtFileName newTxtFile backupTxtName |	txtFileName _ diskFile name.	backupTxtName _ (var at: #suitcase) dataItem filename, (DataMaster previewSuffixFor: #backupText).	newTxtFile _ (FileStream fileNamed: 'PRVWXXXX.TMP') readWriteShorten.	self writeCurrentTextOn: newTxtFile from: diskFile saveRuns: true.	Disk removeKey: txtFileName.	Disk renameKey: newTxtFile name newName: txtFileName.	Disk removeKey: backupTxtName ifAbsent: []. "delete any former backup file - this leaves us in a state as if we'd just opened the pv"	diskFile _ (FileStream oldFileNamed: txtFileName) readOnly.	var at: #initTextSize put: text size.	(var includesKey: #updateFile) ifTrue: [var removeKey: #updateFile].!store	| aFile temp s twoMicasUnit actualStream |"	(var at: #saved) ifTrue: [^self]."	self checkRecompose.	var at: #saved put: true.	s _textStyle pressScale.	Cursor wait		showWhile: 			[temp _ selectedList copy.			self releaseRectForm.			selectedList _ temp copy.			aFile _ (HeaderFileStream fileNamed: (var at: #suitcase) dataItem filename) writeShorten.			aFile writeHeaderFor: (var at: #suitcase) dataItem.			actualStream _ aFile fileStream. "so as to go a little faster, since are just storing on a non-mixed file"			"Doing the real thing now!!"			pageRect width < pageRect height 				ifTrue: [actualStream nextPut: $P] 				ifFalse: [actualStream nextPut: $L].			self putImageHeader: actualStream.			self storeBlockNew: actualStream.			self runs: runs out: actualStream.			self rect: pageRect out: actualStream.			(temp _ var copy) removeKey: #suitcase.			temp at: #defaultMargins put: (((temp at: #defaultMargins) origin / s) corner: ((temp at: #defaultMargins) corner / s)).			twoMicasUnit _ textStyle class == PrintStyle ifTrue: [1] ifFalse: [2].			temp at: #tabsArray put: (Array with: ((temp at: #tabsArray) first collect: [:each | each / twoMicasUnit]) with: (temp at: #tabsArray) last).			self var: temp out: actualStream.			aFile close.			self restoreRectForm].!storeBlock: aFileStream	"store character indices"	aFileStream nextPutAll: charIndex size printString; nextPut: Delimiter.	1 to: charIndex size do: 		[:i | (charIndex at: i) storeOn: aFileStream.			aFileStream nextPut: Delimiter].	"store page breaks"	aFileStream nextPutAll: pageBreak size printString; nextPut: Delimiter.	1 to: pageBreak size do: 		[:i | (pageBreak at: i) storeOn: aFileStream.			aFileStream nextPut: Delimiter].	"store justification indices"	aFileStream nextPutAll: justifyIndex size printString; nextPut: Delimiter.	1 to: justifyIndex size do: 		[:i | (justifyIndex at: i) storeOn: aFileStream.			aFileStream nextPut: Delimiter].	"store picture locations breaks"	aFileStream nextPutAll: pictureLocation size printString; nextPut: Delimiter.	1 to: pictureLocation size do: 		[:i | (pictureLocation at: i) storeOn: aFileStream.			aFileStream nextPut: Delimiter]!storeBlockNew: aFileStream 	| temp arraySize |	aFileStream nextPutAll: charIndex size printString; nextPut: Delimiter.	aFileStream nextPutAll: (arraySize _ self lastPage) printString; nextPut: Delimiter.	"store character indices"	1 to: arraySize do: [:i | self interval: (charIndex at: i) out: aFileStream].	"store justification indices"	1 to: arraySize do: [:i | self runs: (justifyIndex at: i) out: aFileStream].	aFileStream nextPutAll: (arraySize _ self findLastGraphicPage) printString; nextPut: Delimiter.	"store page breaks"	1 to: arraySize do: [:i | aFileStream nextPutAll: (pageBreak at: i) printString; nextPut: Delimiter].	"store picture locations breaks"	1 to: arraySize do: [:i |		(pictureLocation at: i) == nil			ifTrue: [aFileStream nextPut: Delimiter]			ifFalse: [temp _ pictureLocation at: i.					aFileStream nextPutAll: temp size printString; nextPut: Delimiter.					temp do: [:each | each writeTo: aFileStream delimiter: Delimiter]]]! !!PreviewPage methodsFor: 'direct editing'!bottomAtLineIndex: aLineIndex	^(self topAtLineIndex: aLineIndex) + (var at: #grid) y!characterBlockAtPoint: aPoint	| colRect x y cols colIndex off lineIndex linesPerCol lastCol gutter verGutter lineGrid |  	"Answer a CharacterBlock for characters in the text at point aPoint.  	It is assumed that aPoint has been transformed into coordinates appropriate to 	the receiver's destinationForm rectangle and the compositionRectangle."	cols _ self getColumns.	lineGrid _ (var at: #grid) y.	linesPerCol _ (pageBreak at: pageNumber) // lineGrid.	lastCol _ (lastLine min: self maxLines) - 1 // linesPerCol + 1.	x _ (aPoint x max: cols first left) min: (cols at: lastCol) right.	gutter _ (var at: #gutter) // 2.	1 to: lastCol do: [:ithCol |		((x <= ((cols at: ithCol) right + gutter))		and: [ (x >= ((cols at: ithCol) left - gutter))])			ifTrue: [colIndex _ ithCol. colRect _ cols at: ithCol]].	verGutter _ lineGrid//2.	y _ ((aPoint y max: cols first top) min: cols last bottom) // verGutter * verGutter.	aPoint y > colRect bottom		ifTrue: [	off _ colIndex - 1 * linesPerCol.				lineIndex _ (y - colRect top // lineGrid + 1 + off) min: lastLine.				^PreviewCharacterBlockScanner new characterBlockForIndex: (lines at: lineIndex) last in: self].	y < colRect top		ifTrue: [y _ colRect top]		ifFalse: [y > colRect bottom ifTrue: [y _ colRect bottom - 1]].	^PreviewCharacterBlockScanner new			characterBlockAtPoint: x@y			in: self			within: colRect!characterBlockForIndex: theCharIndex 	"Answer a CharacterBlock for character in the text at targetIndex.  The 	coordinates in the CharacterBlock will be appropriate to the intersection of the  	destinationForm rectangle and the compositionRectangle."	| firstChar lastChar targetIndex |	targetIndex _ theCharIndex.	(firstChar _ self firstPageCharacter) isNil ifTrue:		[ ^CharacterBlock			stringIndex: targetIndex			character: nil			topLeft: compositionRectangle origin			extent: 0 @ (var at: #grid) y ].	targetIndex < firstChar ifTrue:		[ ^CharacterBlock			stringIndex: targetIndex			character: (text at: targetIndex)			topLeft: clippingRectangle origin - (0@99)    "way up there"			extent: 0@0 ].	(targetIndex > (lastChar _ self lastPageCharacter))" & (lastChar < text size)" ifTrue:		[targetIndex _ lastChar + 1.		"^CharacterBlock			stringIndex: lastChar + 1			character: (lastChar < text size				ifTrue: [text at: lastChar + 1]				ifFalse: [nil])			topLeft: clippingRectangle corner + (0@99)			extent: 0@0"].	^PreviewCharacterBlockScanner new characterBlockForIndex: targetIndex in: self!charactersShown	| charInv | 	charInv _ charIndex at: pageNumber.	^charInv last - charInv first + 1!checkLayoutSaved	^var at: #saved!colContainsLine: aLineIndex 	| linesPerCol |	linesPerCol _ (pageBreak at: pageNumber) // (var at: #grid) y.	^self getColumns at: (aLineIndex - 1 // linesPerCol + 1)!collectRectsFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| start stop aList beginCol beginRect endCol endRect startX stopX gutter r currentRects inset |	characterBlock1 = characterBlock2 ifTrue: [^OrderedCollection new].	inset _ compositionRectangle left - clippingRectangle left.	characterBlock1 stringIndex < characterBlock2 stringIndex		ifTrue: [start _ characterBlock1. stop _ characterBlock2]		ifFalse: [start _ characterBlock2. stop _ characterBlock1].	aList _ self getColumns.	startX _ start origin x.	stopX _ stop corner x min: aList last right.	gutter _ (var at: #gutter) // 2.	1 to: aList size do: [:ithCol |		r _ aList at: ithCol.		(startX <= (r right + gutter) and: [ (startX >= (r left - gutter))])			ifTrue: [beginCol _ ithCol. beginRect _ r].		(stopX <= (r right + gutter) and: [ (stopX >= (r left - gutter))])			ifTrue: [endCol _ ithCol. endRect _ r]].	currentRects _ OrderedCollection new.	beginCol = endCol		ifTrue: [start top = stop top					ifTrue: [currentRects add: (start origin corner: stop bottomLeft)]					ifFalse: [currentRects add: (start origin corner: (beginRect right - inset @ start bottom)).							currentRects add: (beginRect left + inset @ start bottom corner: beginRect right - inset @ stop top).							currentRects add: (beginRect left + inset @stop top corner: stop bottomLeft)]]		ifFalse: [currentRects add: (start origin corner: (beginRect right - inset  @ start bottom)).				currentRects add: ((beginRect left @start bottom corner: beginRect corner) insetBy: (inset @ 0)).				beginCol + 1 to: endCol - 1 do: [:ith | currentRects add: ((aList at: ith) insetBy: (inset @ 0))].				currentRects add: ((endRect origin corner: (endRect right@stop top)) insetBy: (inset @ 0)).				currentRects add: (endRect left + inset @ stop top corner: stop bottomLeft)].	^currentRects!displayCaretForBlock: aCharacterBlock	"Show caret at proper place for aCharacterBlock"	self displayCaretAt: (aCharacterBlock bottomLeft - (0@(textStyle baseline + 3)))!lastLine	^lastLine!lineForFastTypeinFrom: startBlock	| x gutter theCols theCol lineArea rectList theRect rect |	x _ startBlock origin x.	gutter _ (var at: #gutter) // 2.	theCols _ self getColumns.	theCol _ theCols at: (theCols findFirst: [:aCol | ((aCol right + gutter > x) & (x >= (aCol left - gutter)))]).	lineArea _ (startBlock left max: theCol left)@startBlock top corner: theCol right @ startBlock bottom.	(rectList _ (pictureLocation at: pageNumber)) == nil ifTrue: [^lineArea].	theRect _ lineArea translateBy: (0 - pageRect origin).	rectList do: 		[:each | 		(each opaque and: [theRect right > (rect _ each rectangle) left])			ifTrue:				[theRect right: rect left - 1.				lineArea _ theRect translateBy: pageRect origin.				^lineArea]].	^lineArea!lineIndexOfPoint: aPoint	| aList startClip startCol off x gutter |	aList _ self getColumns.	x _ aPoint x.	gutter _ (var at: #gutter) // 2.	1 to: aList size do: [:i |		(((aList at: i) right + gutter >= x) and: [ (x >= ((aList at: i) left - gutter))])			ifTrue: [startClip _ aList at: i. startCol _ i]].	off _ startCol - 1 * ((pageBreak at: pageNumber) // (var at: #grid) y).	^(aPoint y - startClip top// (var at: #grid) y + 1 + off) min: lastLine!mouseSelect: previousStartBlock to: previousStopBlock	"Answer with an Array of two CharacterBlocks that represent the text selection that the user makes."	| pivotBlock startBlock stopBlock showingCaret word extendBlock oldRects currentRects |	Sensor leftShiftDown ifTrue:[^self extendSelection: previousStartBlock to: previousStopBlock using: (self characterBlockAtPoint: Sensor cursorPoint)].	startBlock _ stopBlock _ pivotBlock _ self characterBlockAtPoint: Sensor cursorPoint.	self displayCaretForBlock: pivotBlock.	showingCaret _ true.	oldRects _ OrderedCollection new.	[Sensor redButtonPressed] whileTrue: [		stopBlock _ self characterBlockAtPoint: Sensor cursorPoint.		stopBlock = startBlock ifFalse: [			showingCaret ifTrue: [				self displayCaretForBlock: pivotBlock. showingCaret _ false].			currentRects _ self collectRectsFrom: pivotBlock to: stopBlock.			oldRects do: [:r |				(currentRects includes: r)					ifFalse: [Display fill: r rule: Form reverse mask: Form black]].			currentRects do: [:r |				(oldRects includes: r)					ifFalse: [Display fill: r rule: Form reverse mask: Form black]].		oldRects _ currentRects.		startBlock _ stopBlock] ].	(showingCaret not and: [pivotBlock = stopBlock])		ifTrue: [self displayCaretForBlock: pivotBlock].	(previousStartBlock = previousStopBlock and:		[pivotBlock = stopBlock and: [stopBlock = previousStopBlock]])		ifTrue:  "select a word or bracketed range"			[word _ self selectWord: pivotBlock stringIndex.			word first = word last ifFalse:				[self displayCaretForBlock: pivotBlock.				pivotBlock _ self characterBlockForIndex: word first.				stopBlock _ self characterBlockForIndex: word last.				self reverseFrom: pivotBlock to: stopBlock]].	stopBlock < pivotBlock		ifTrue: [^Array with: stopBlock with: pivotBlock]		ifFalse: [^Array with: pivotBlock with: stopBlock]!replaceFrom: start to: stop with: someText	| realStart realStop even startLine stopLine priorText postText atEnd | 	lastLine = 0		ifTrue: [text _ someText.				self composeTextDisplay: true.				^lastLine = self maxLines].	startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	realStart _ (lines at: startLine) first.	realStop _ (lines at: stopLine) last.	startLine > 1		ifTrue: [startLine _ startLine - 1.				realStart _ (lines at: startLine) first].	priorText _ text copyFrom: realStart to: start - 1.	postText _ text copyFrom: stop + 1 to: realStop.	(realStart = 1 and: [realStop = text size and: [(priorText isEmpty and: [postText isEmpty]) and: [someText isEmpty and: [realStop < BufferSize]]]])		ifTrue: [pageNumber > 1					ifTrue: [text _ Text new.							self nilFrom: pageNumber. ^true].				postText _ Text string: (String with: Character space) emphasis: (Smalltalk at: #UserFont ifAbsent: [1])].	self recordChange: priorText, someText, postText from: realStart to: realStop.	even _ self partialComposeFrom: startLine to: stopLine.	(even at: 1)		ifTrue: [stopLine _ startLine + (even at: 2)]		ifFalse: [stopLine _ lastLine max: stopLine].	self repaintLines: (startLine to: stopLine).	var at: #editChanges put: nil.	var removeKey: #editChanges.	var at: #updateFile put: true.	^lastLine = self maxLines!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| start stop aList beginCol beginRect endCol endRect startX stopX gutter r inset |	characterBlock1 = characterBlock2 ifTrue: [^self].	inset _ compositionRectangle left - clippingRectangle left.	characterBlock1 stringIndex < characterBlock2 stringIndex		ifTrue: [start _ characterBlock1. stop _ characterBlock2]		ifFalse: [start _ characterBlock2. stop _ characterBlock1].	aList _ self getColumns.	startX _ start origin x.	stopX _ stop corner x.	gutter _ (var at: #gutter) // 2.	1 to: aList size do: [:ithCol |		r _ aList at: ithCol.		(startX <= (r right + gutter) and: [ (startX >= (r left - gutter))])			ifTrue: [beginCol _ ithCol. beginRect _ r].		(stopX <= (r right + gutter) and: [ (stopX >= (r left - gutter))])			ifTrue: [endCol _ ithCol. endRect _ r]].	beginCol = endCol		ifTrue: [start top = stop top					ifTrue: [self reverseRectangle: (start origin corner: stop bottomLeft)]					ifFalse: [self reverseRectangle: (start origin corner: (beginRect right - inset  @ start bottom)).							self reverseRectangle: ((beginRect left@start bottom corner: beginRect right@stop top) insetBy: (inset @ 0)).							self reverseRectangle: (beginRect left + inset @stop top corner: stop bottomLeft)]]		ifFalse: [self reverseRectangle: (start origin corner: (beginRect right - inset @ start bottom)).				self reverseRectangle: ((beginRect left@start bottom corner: beginRect corner) insetBy: (inset @ 0)).				beginCol + 1 to: endCol - 1 do: [:ith | self reverseRectangle: ((aList at: ith) insetBy: (inset @ 0))].				self reverseRectangle: ((endRect origin corner: (endRect right@stop top)) insetBy: (inset @ 0)).				self reverseRectangle: (endRect left + inset @stop top corner: stop bottomLeft)].!selectWord: stringIndex	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string _ text string copyFrom: 1 to: self lastPageCharacter.	here _ stringIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^ 1 to: string size" + 1"].	leftDelimiters _ '([{<''"'.	rightDelimiters _ ')]}>''"'.	openDelimiter _ string at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start _ here.			direction _ 1.			here _ here - 1.			closeDelimiter _ rightDelimiters at: match]		ifFalse: 			[openDelimiter _ string at: here.			match _ rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop _ here - 1.					direction _ -1.					closeDelimiter _ leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction _ -1]].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar _ string at: (here _ here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start _ 1.									"go right if hit string start"									direction _ 1]]						ifFalse: [direction < 0								ifTrue: 									[start _ here + 1.									"go right if hit non-token"									direction _ 1]								ifFalse: [level _ 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level _ level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level _ level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [^ start to: here]		ifFalse: [^ here + 1 to: stop + 1]!startEditWith: anEditController	var at: #editController put: anEditController.	var at: #textDiff put: 0!topAtLineIndex: aLineIndex	| linesPerCol grid | 	grid _ (var at: #grid) y.	linesPerCol _ (pageBreak at: pageNumber) // grid.	^clippingRectangle top + ((aLineIndex - 1 \\ linesPerCol)  * grid)!writeCurrentTextOn: toFile from: fromFile saveRuns: saveRunsIfTrue	| endText startIndex stopIndex total |	endText _ var at: #endText.	(charIndex at: pageNumber) == nil		ifTrue: [pageNumber = 1 ifTrue: [startIndex _ 1] ifFalse: [startIndex _ (charIndex at: pageNumber - 1) last + 1]]		ifFalse: [startIndex _ (charIndex at: pageNumber) first].	stopIndex _ startIndex + (var at: #initTextSize) - 1"BufferSize min: endText".	runs _ runs copyReplaceFrom: startIndex to: stopIndex with: text runs.	toFile reset.	fromFile reset.	total _ startIndex - 1 max: 0.	[30000 < total] whileTrue:		[toFile nextPutAll: (fromFile next: 30000).		total _ total - 30000].	total > 0 ifTrue: [toFile nextPutAll: (fromFile next: total)].	toFile nextPutAll: text string.	stopIndex < endText		ifTrue: [fromFile position: stopIndex.				total _ endText - stopIndex.				[30000 < total] whileTrue:					[toFile nextPutAll: (fromFile next: 30000).					total _ total - 30000].				total > 0 ifTrue: [toFile nextPutAll: (fromFile next: total)]].	var at: #endText put: toFile position.	saveRunsIfTrue		ifTrue: [toFile nextPut: (Character value: 255); nextPut: Character cr.				runs storeOn: toFile].	toFile close.	fromFile close! !!LinearFit methodsFor: 'press printing'!hardcopyOn: pressFile	self hardcopyOn: pressFile roundEnds: false!hardcopyOn: pressFile roundEnds: round	| radius p1 p2 normal lastNormal |	radius _ pressFile scale*self form width/2.	lastNormal _ nil.	1 to: collectionOfPoints size-1 do:		[:k |		p1 _ pressFile transformPoint: (self at: k).		p2 _ pressFile transformPoint: (self at: k+1).		normal _ p1 = p2 ifTrue: [0@0] ifFalse: [(p2-p1) normal * radius].		lastNormal notNil ifTrue:			[pressFile showObject:				[pressFile moveTo: p1 + lastNormal.				pressFile drawTo: p1 + normal.				pressFile drawTo: p1 - normal.				pressFile drawTo: p1 - lastNormal.				pressFile drawTo: p1 + lastNormal]].		pressFile showObject:			[pressFile moveTo: p1 + normal.			pressFile drawTo: p2 + normal.			pressFile drawTo: p2 - normal.			pressFile drawTo: p1 - normal.			pressFile drawTo: p1 + normal].		lastNormal _ normal].	round ifTrue:		[pressFile showDiscAt: (pressFile transformPoint: self first) radius: radius.		pressFile showDiscAt: (pressFile transformPoint: self last) radius: radius]! !SortedLinearFit comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!SortedLinearFit methodsFor: 'points'!initializeCollectionOfPoints	collectionOfPoints _ SortedCollection new.	collectionOfPoints sortBlock: [:first :second | first x <= second x]!initializeCollectionOfPoints: anInteger	collectionOfPoints _ SortedCollection new: anInteger.	collectionOfPoints sortBlock: [:first :second | first x <= second x]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm 	"Method for display of a Spline curve approximated by straight line 	segments. "	| pen steps a b c d t |	pen _ Pen new.	pen sourceForm: self form.	pen combinationRule: anInteger.	pen mask: aForm.	pen destForm: aDisplayMedium.	pen frame: clipRect.	pen down.	pen place: self first rounded.	1 to: self size - 1 do: 		[:k | 		"for each knot"		"taylor series coefficients"		d _ self at: k.		c _ (derivatives at: 1) at: k.		b _ ((derivatives at: 2) at: k) / 2.0.		a _ ((derivatives at: 3) at: k) / 6.0.		"guess stepping parameter"		steps _ ((derivatives at: 2) at: k) abs 					+ ((derivatives at: 2) at: k + 1) abs.		steps _ 7 max: steps x + steps y // 100.		1 to: steps do: 			[:j | 			t _ j asFloat / steps.			pen goto: (a * t + b * t + c * t + d) rounded].		pen goto: (self at: k + 1) rounded]! !!Spline methodsFor: 'press printing'!hardcopyOn: pressFile	self hardcopyOn: pressFile roundEnds: false!hardcopyOn: pressFile roundEnds: round	| radius derivScale derivs knot steps |	radius _ pressFile scale*self form width/2.	derivScale _ (1@-1)*pressFile scale.		"flip y for pressFile"	1 to: collectionOfPoints size-1 do:		[:k |		knot _ pressFile transformPoint: (self at: k).		derivs _ self derivativePointsAt: k.		steps _ (derivs at: 2) abs + ((derivatives at: 2) at: k+1) abs.		steps _ 1 max: (steps x + steps y) // 20.		"guess stepping parameter"		derivs _ derivs collect: [:pt | pt*derivScale].		pressFile showCurve: derivs at: knot halfWidth: radius steps: steps].	round ifTrue:		[pressFile showDiscAt: (pressFile transformPoint: self first) radius: radius.		pressFile showDiscAt: (pressFile transformPoint: self last) radius: radius]! !SortedSpline comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!SortedSpline methodsFor: 'points'!initializeCollectionOfPoints	collectionOfPoints _ SortedCollection new.	collectionOfPoints sortBlock: [:first :second | first x <= second x]!initializeCollectionOfPoints: anInteger	collectionOfPoints _ SortedCollection new: anInteger.	collectionOfPoints sortBlock: [:first :second | first x <= second x]! !NewArc comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!NewArc methodsFor: 'accessing'!beginAngle	"return the value to be used as the beginAngle of the circle the arc will be a subset of"	^beginAngle!beginAngle: anAngle	"set the value to be used as the beginAngle of the circle the arc will be a subset of"	beginAngle _ anAngle!center	"return the value to be used as the center of the circle the arc will be a subset of"	^center!center: aPoint	"set the value to be used as the center of the circle the arc will be a subset of"	center _ aPoint!center: aPoint radius: anInteger 	center _ aPoint.	radius _ anInteger!endAngle	"return the value to be used as the endAngle of the circle the arc will be a subset of"	^endAngle!endAngle: anAngle	"set the value to be used as the endAngle of the circle the arc will be a subset of"	endAngle _ anAngle!radius	"return the value to be used as the radius of the circle the arc will be a subset of"	^radius!radius: aLength	"set the value to be used as the radius of the circle the arc will be a subset of"	radius _ aLength! !!NewArc methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm 	| numOfSegs angle line xn yn xn1 yn1 sin cos |	(line _ Line new) form: self form.	numOfSegs _ (endAngle - beginAngle) * 7.63944 rounded. 		"(2.0 * Float pi)  * 48 rounded"	xn _ beginAngle cos * radius.	yn _ beginAngle  sin * radius.	angle _ numOfSegs = 0			ifTrue: [0] ifFalse: [(endAngle - beginAngle) / numOfSegs].	sin _ angle sin.	cos _ angle cos.	0 to: numOfSegs do:		[ :i |			xn1 _ xn * cos - (yn * sin).			yn1 _ yn * cos + (xn * sin).			line beginPoint: center + (xn rounded @ yn rounded); endPoint: center + (xn1 rounded@ yn1 rounded);				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				mask: aForm.			xn _ xn1.			yn _ yn1]!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm 	| newArc tempCenter |	tempCenter _ aTransformation applyTo: self center.	(newArc _ Arc new) center: tempCenter x truncated @ tempCenter y truncated; beginAngle: self beginAngle; endAngle: self endAngle; radius: (self radius * aTransformation scale x) truncated; form: self form;		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		mask: aForm! !NewCircle comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!NewCircle methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger mask: aForm 	self beginAngle: 0; endAngle: 6.28318."2 * Float pi "	super		displayOn: aDisplayMedium		at: aPoint		clippingBox: clipRect		rule: anInteger		mask: aForm!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger mask: aForm 	self beginAngle: 0; endAngle: 6.28318."2 * Float pi "	super		displayOn: aDisplayMedium		transformation: aTransformation		clippingBox: clipRect		rule: anInteger		mask: aForm!fillSegmentFrom: startAngle to: stopAngle onForm: aForm withColor: aMask 	"this is a fast filling method to allow the user to fill the area 	 within a given circle from startAngle to stopAngle. this will  	display on aForm in the color aMask."	| circumferencePoint theLine theArc theTempForm |	theTempForm _ Form extent: self computeBoundingBox extent x asInteger + 2 @ (self computeBoundingBox extent y asInteger + 2).	(theLine _ Line new) beginPoint: theTempForm computeBoundingBox center.	(circumferencePoint _ Point new) x: theLine beginPoint x + (radius * startAngle cos); y: theLine beginPoint y + (radius * startAngle sin).	theLine endPoint: circumferencePoint;		displayOn: theTempForm		at: 0 @ 0		clippingBox: theTempForm computeBoundingBox		rule: Form over		mask: Form black.	circumferencePoint x: theLine beginPoint x + (radius * stopAngle cos); y: theLine beginPoint y + (radius * stopAngle sin).	theLine endPoint: circumferencePoint;		displayOn: theTempForm		at: 0 @ 0		clippingBox: theTempForm computeBoundingBox		rule: Form over		mask: Form black.	(theArc _ NewArc new) form: (Form new extent: 1 @ 1) black; radius: radius; center: theTempForm computeBoundingBox center" - 1"; beginAngle: startAngle; endAngle: stopAngle;		displayOn: theTempForm		at: 0 @ 0		clippingBox: theTempForm computeBoundingBox		rule: Form over		mask: Form black.	theTempForm convexShapeFill: aMask;		displayOn: aForm		at: center - (self computeBoundingBox extent / 2)		clippingBox: (aForm computeBoundingBox expandBy: 2)		rule: Form under		mask: Form black! !!NewCircle methodsFor: 'accessing'!computeBoundingBox	^center - radius extent: (radius * 2) asPoint! !!Form methodsFor: 'displaying'!drawSegLine: sourceForm from: beginPoint to: endPoint clippingBox: clipRect rule: anInteger mask: aForm segmentLength: segLen		| dotSetter |	"set up an instance of BitBlt for display"	dotSetter _ BitBlt		destForm: self		sourceForm: sourceForm		halftoneForm: aForm		combinationRule: anInteger		destOrigin: beginPoint		sourceOrigin: 0 @ 0		extent: sourceForm extent		clipRect: clipRect.	dotSetter drawFrom: beginPoint to: endPoint segmentLength: segLen! !!Form methodsFor: 'display box access'!computeBoundingBox	^ Rectangle new origin: 0@0 corner: width@height	"^0 @ 0 extent: width @ height"! !!Form methodsFor: 'pattern'!valueAt: aPoint put: aBit	| loc word |	loc _ (width + 15 // 16)*(aPoint y) + (aPoint x // 16) +1.	loc <1	ifFalse:[ word _ bits at: loc.		aBit = 1 ifTrue:			[bits at: loc put: (word bitOr: (1 bitShift: 15 - (aPoint x \\ 16))) ]		ifFalse:			[bits at: loc put: (word bitAnd: (1 bitShift: 15 - (aPoint x \\ 16)) bitInvert) ]]! !!Form methodsFor: 'coloring'!fill: aRectangle rule: anInteger mask: aForm 	"Replace a rectangular area of the receiver with the pattern described by aForm 	according to the rule anInteger."	| box |	box _ self boundingBox.	"Make up a BitBlt table and copy the bits"	(BitBlt 		destForm: self		sourceForm: nil		halftoneForm: aForm		combinationRule: anInteger		destOrigin: aRectangle origin		sourceOrigin: box origin		extent: aRectangle extent		clipRect: box) copyBits! !!Form methodsFor: 'fileIn/Out'!writeAsDataItem: dataItem 	"Saves the receiver on the file fileName in the format--fileCode, extent, offset, bits."	| file fileCode |	fileCode _ 1.	"This indicates that the instance is a Form.  Should probably be changed 	when better methods for permanent storage are devised."	file _ (HeaderFileStream fileNamed: dataItem filename) binary; writeShorten.	Cursor write showWhile:		[		file writeHeaderFor: dataItem.		file			nextWordPut: fileCode;			nextWordPut: width;			nextWordPut: height;			nextWordPut: offset x;			nextWordPut: offset y.		bits toFileStream: file.		].	file close!writeCAIS: fileName	"Create a compressed AIS file containing the receiver."	| file line lineBlt store reverse |	file _ (FileStream fileNamed: fileName) binary.	file nextWordPut: 8r102252. 	"AIS password"	file nextWordPut: 10. 	"header length in words"	file nextWordPut: (1 bitShift: 10) + 7. 	"type | length"	file nextWordPut: height.	file nextWordPut: width.	file nextWordPut: 3. 		"scan direction"	file nextWordPut: 1. 		"samples/pixel"	file nextWordPut: 2. 		"coding type: CompressedArray"	file nextWordPut: 1. 		"bits/sample"	file nextWordPut: 0. 		"end of header"	store _ Form over.	reverse _ Form reverse.	line _ Form byteScanLineOfWidth: width.	lineBlt _ BitBlt destForm: line sourceForm: self		halftoneForm: nil combinationRule: store		destOrigin: 0@0 sourceOrigin: 0@0		extent: width@1 clipRect: line boundingBox. 	line black. 	"start reversed since AIS considers 0=black"	0 to: height-1 do:		[:y |		lineBlt sourceY: y; combinationRule: reverse; copyBits. 	"xor with previous line"		line bits runEncodeOn: file.					"and run-encode the bytes"		lineBlt combinationRule: store; copyBits. 		"copy next previous line"		].	^file close!writeOnStream: fileStream	"Saves the receiver on the fileStream in the format--fileCode, extent, offset, bits."	| file fileCode |	fileCode _ 1.	"This indicates that the instance is a Form.  Should probably be changed 	when better methods for permanent storage are devised."	fileStream binary.	Cursor write showWhile:		[		fileStream			nextWordPut: fileCode;			nextWordPut: width;			nextWordPut: height;			nextWordPut: offset x;			nextWordPut: offset y.		bits toFileStream: fileStream.		].	fileStream text! !!Form methodsFor: 'editing'!edit	"Start up an instance of the ImageEditor on this form. Typically the form 	is not visible on the screen. The editor menu is located at the bottom of 	the form editing frame. The form is displayed centered in the frame. 	YellowButtonMenu accept is used to modify the form to reflect the 	changes made on the screen version; cancel restores the original form to 	the screen. Note that the changes are clipped to the original size of the 	form."	ImageEditor openOnForm: self!editAt: originPoint 	"Start up an instance of the ImageEditor on this form in an area whose 	top left corrner is originPoint. Typically the form is not visible on the 	screen. The editor menu is located at the bottom of the form editing 	frame. The form is displayed centered in the frame. YellowButtonMenu 	accept is used to modify the form to reflect the changes made on the 	screen version; cancel restores the original form to the screen. Note that 	the changes are clipped to the original size of the form."	ImageEditor openOnForm: self at: originPoint! !!Form methodsFor: 'private'!isAllWhite	| newSize newForm aBitBlt count |	(bits at: 1) = 0 ifFalse: [^false].	bits size < 257 ifTrue:		[		bits do: [:data | data = 0 ifFalse: [^false]].		^true		].	newSize _ (bits size bitShift: -4).	newForm _ Form new extent: 16 @ newSize.	aBitBlt _ BitBlt		destForm: newForm		sourceForm: (Form new extent: 16 @ (bits size) offset: 0@0 bits: bits)		halftoneForm: nil		combinationRule: Form under		destOrigin: 0 @ 0		sourceOrigin: 0 @ 0		extent: 16 @ newSize		clipRect: newForm boundingBox.	0 to: (bits size -1) by: newSize do:		[:sourceY |		aBitBlt sourceY: sourceY.		aBitBlt copyBits.		].	^newForm isAllWhite! !!Form methodsFor: 'press printing'!hardcopy	"This method is useful for getting hardcopy of individual forms.  Insert the receiver centered in a one page pressFile named 'form.press'.  Answers the pressFile."	^self hardcopyOnFileNamed: 'form.press'!hardcopyOnFileNamed: fileName	"This method is useful for getting hardcopy of individual forms.  Insert the receiver in a one page pressFile centered on the page.  Answers the pressFile."	| scale |	scale _ PressPrinter DefaultPageRectangle extent//self extent.	scale _ scale x min: scale y.	scale _ scale min: 32.	"default scale, works for Spruce printers"	^self hardcopyOnFileNamed: fileName scale: scale landscape: false!hardcopyOnFileNamed: fileName scale: scale landscape: landscapeIfTrue	"This method is useful for getting hardcopy of individual forms.  Insert the receiver in a one page pressFile centered on the page in either portrait or landscape mode.  scale is is micas per dot (32 for screen resolution).  Answers the pressFile."	| pressFile extent pressOrigin |	extent _ landscapeIfTrue ifTrue: [self extent transpose] ifFalse: [self extent].	pressOrigin _ PressPrinter DefaultPageRectangle center - (extent//2*scale).	pressOrigin >= (0@0) ifFalse: [self error: 'scale too large--form lies off page'].	pressFile _ PressFile fileNamed: fileName.	pressFile		scale: scale;		setPoint: pressOrigin rounded;		printForm: self opaque: false landscape: landscapeIfTrue;		close.	^pressFile! !!DisplayScreen methodsFor: 'displaying'!outline: rectBlock while: durationBlock width: borderWidth halftone: halftone 	"Display an evolving rectangle dynamically. rectBlock supplies a rectangle, durationBlock supplies true,  	then false to terminate."	| rect edges q newRect |	[	rect _ rectBlock value rounded.		edges _ (rect expandBy: borderWidth) areasOutside: rect.		edges do: [:edge | Display fill: edge rule: Form reverse mask: halftone].		[(q _ durationBlock value) and: [rect = (newRect _ rectBlock value rounded)]] whileTrue: [].		edges do: [:edge | Display fill: edge rule: Form reverse mask: halftone].		q ] whileTrue: [].	^rect!zoom: startRect to: stopRect speed: pixelsPerSecond	"Display an evolving rectangle dynamically. We would like to show each intermediate rectangle such that the fastest edge moves at a constant desired speed. In practice, we may have to skip some rectangles in order to keep up"	| originDelta cornerDelta nSteps period currentOrigin currentCorner step nextTime overtime samples stepRate | 	originDelta _ stopRect origin - startRect origin.	cornerDelta _ stopRect corner - startRect corner.	stepRate _ pixelsPerSecond//1000 max: 1.			"minimum pixels/sample"	period _ stepRate*1000//pixelsPerSecond max: 1.	"msec per sample"		"maximum number of positions for the fastest edge"	nSteps _ ((originDelta x abs max: originDelta y abs)				max: (cornerDelta x abs max: cornerDelta y abs)) // stepRate.		"position increment for each corner"	originDelta _ originDelta / nSteps asFloat.	cornerDelta _ cornerDelta / nSteps asFloat.	currentOrigin _ startRect origin.	currentCorner _ startRect corner.	step _ 0.	nextTime _ Time millisecondClockValue.	self outline: [currentOrigin corner: currentCorner]		while: [[(overtime _ Time millisecondClockValue - nextTime) < 0] whileTrue:					[(Delay untilMilliseconds: nextTime) wait].				samples _ (overtime // period) + 1.				currentOrigin _ currentOrigin + (originDelta * samples).				currentCorner _ currentCorner + (cornerDelta * samples).				nextTime _ nextTime + (period * samples).				(step _ step + samples) <= nSteps]		width: 2		halftone: Form gray	"Display zoom: (100@100 extent: 300@100) to: (600@600 extent: 10@10) speed: 500."! !MapForm comment:'Copyright (c) 1983, 1984 Xerox Corporation.  All Rights Reserved.'!!MapForm methodsFor: 'accessing'!latLonBox	^latLonBox copy!latLonBox: aRectangle	latLonBox _ aRectangle copy.	self changed: #latLonBox! !!ClassOrganizer methodsFor: 'comment'!moveChangedCommentToFile: aFileStream numbered: sourceIndex 	"This is part of source code compression.  Move the comment about the	class classified by the receiver from the file referenced by	sourceIndex and to the stream, aFileStream."	(globalComment ~~ nil and: [globalComment sourceFileNumber = 2])		ifTrue: 			[aFileStream cr; cr.			globalComment _ 				RemoteString					newString: globalComment string					onFileNumber: sourceIndex					toFile: aFileStream]!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource 	"Store the comment about the class onto file, aFileStream."	| newRemoteString saveEmphasis |	saveEmphasis _ aFileStream emphasis.	aFileStream emphasis: 3.		"meant to be 10 point italic font"	globalComment ~~ nil		ifTrue: 			[aFileStream cr.			newRemoteString _ 				RemoteString						newString: globalComment string						onFileNumber: sourceIndex						toFile: aFileStream.			moveSource ifTrue: [globalComment _ newRemoteString]].	aFileStream emphasis: saveEmphasis.! !!ClassOrganizer methodsFor: 'private'!setDefaultList	globalComment _ nil.	categoryArray _ categoryStops _ elementArray _ #().! !!ClassOrganizer methodsFor: 'system compression'!collapsedForClass: aClass fromFileNumber: aSymbolOrInteger1 toFileNumber: aSymbolOrInteger2 toFile: aFileStream	"Collapsed ClassOrganizers are stored on the .changes file (or, more generally SourceFiles at: n) rather than in main memory.	Store is an OrderedCollection in which the file locations of the printStrings and globalComments of the ClassOrganizers of client Classes are stored. This saves oops when compared with the alternative of creating one Array or OrderedCollection per Class. I assign each client Class a serial number for my own internal record-keeping. Serial numbers are stored in an IdentityDictionary called CachedClassNames; the Store is subsequently indexed by serial number. Each Class has the same serial number as its Metaclass."	| b1 b2 fN i0 i1 i2 i3 ky pn rS s0 s1 s2 s3 sN |	(b1 _ aSymbolOrInteger1 == #none) ifTrue:		[globalComment == nil ifTrue:			[self categories size = 0 ifTrue: [^self].].		].	b2 _ aClass isKindOf: Metaclass.	ky _ (b2 ifTrue: [aClass soleInstance.] ifFalse: [aClass.]) name.	sN _ CachedClassNames at: ky ifAbsent:		[b1 ifFalse:			[^self "No entry exists for aClass."].		(sN _ Store at: 1) > (Smalltalk size * 2) ifTrue:			[self class rehash.			^self				collapsedForClass: aClass				fromFileNumber: aSymbolOrInteger1				toFileNumber: aSymbolOrInteger2				toFile: aFileStream			].		Store addAll: (Array new: 8).		CachedClassNames at: ky put: (Store at: 1 put: sN + 1).		].	i0 _ (sN bitShift: 3) - (b2 ifTrue: [6.] ifFalse: [2.]).	i3 _ (i2 _ (i1 _ i0 + 1) + 1) + 1.	b1 ifTrue:		[globalComment == nil			ifTrue: [Store at: i0 put: nil.]			ifFalse:				[(pn _ globalComment position) == nil ifFalse:					[Store at: i0 put: (pn bitShift: -11).					Store at: i1 put: (pn bitAnd: 16r7FF) * 4						+ globalComment sourceFileNumber - 1.					].				"These 2 fields in Store now hold the file location of my globalComment. The first contains the high order bits (i.e., all but the 11 least significant bits) of the file position, and the second contains the least significant 11 bits, additionally the two bits of the second specify the SourceFiles index minus one. Hence the second of these 2 fields of Store is ALWAYS a SmallInteger (<=13 bits), even with Stretch, and the first is a SmallInteger unless the file is HUGE (>16Mbytes for Stretch; >32Mbytes non-Stretch)."				].		self categories size = 0			ifTrue: [Store at: i2 put: nil.]			ifFalse:				["aFileStream setToEnd; readWriteShorten; cr."				rS _ RemoteString					newString: self printString					onFileNumber: aSymbolOrInteger2					"toFile: aFileStream".				"aFileStream readOnly."				pn  _ rS position.				pn == nil ifFalse:					[Store at: i2 put: (pn bitShift: -11).					Store at: i3 put:						(pn bitAnd: 16r7FF) * 4 + aSymbolOrInteger2 - 1.					].				"These 2 fields in Store now hold the file location of my printString. (See the comment for globalComment above for a description of the format of the 2 fields)."				].		^self		].	(s0 _ Store at: i0) == nil ifFalse:	"Find the file position information for my globalComment. This information should have previously been put in Store by a previous call on #collapsedForClass:fromFileNumber:toFileNumber:toFile:, with the 'fromFileNumber:' argument equal to nil, and the 'toFileNumber:' argument not equal to nil."		[pn _ (s0 bitShift: 11) + ((s1 _ Store at: i1) bitShift: - 2).		fN _ (s1 bitAnd: 3) + 1.		globalComment _ RemoteString newFileNumber: fN position: pn.		(aSymbolOrInteger2 == #none)			ifTrue:				["Deliberately tag the pointers to the Stored information as having been read, because this information must only be read once, until it is Stored again; the user may change the globalComment when it is NOT in the Store, but cannot do so while it is in the Store."				Store at: i0 put: nil.				]			ifFalse:				["If the file position information for my globalComment is in the Store, and if aSymbolOrInteger1 == #any, or if the file position information indicates that the globalComment itself is on (SourceFiles at: aSymbolOrInteger1), then move the globalComment to file number aSymbolOrInteger2, and update the Store accordingly. Otherwise, do nothing."				(aSymbolOrInteger2 isInteger and:					[aSymbolOrInteger1 = fN or:						[aSymbolOrInteger1 == #any.].					]				) ifTrue:					[rS _ globalComment string.					aFileStream cr.					rS _ RemoteString						newString: rS						onFileNumber: aSymbolOrInteger2						toFile: aFileStream.					pn _ rS position.					Store at: i0 put: (pn bitShift: -11).					Store						at: i1 put: (pn bitAnd: 16r7FF) * 4 + aSymbolOrInteger2 - 1.					].				].		].	(s2 _ Store at: i2) == nil ifFalse:	"Find the file position information for my printString, then parse the printString. This information should have previously been put in Store by a previous call on #collapsedForClass:fromFileNumber:toFileNumber:toFile:, with the 'fromFileNumber:' argument equal to nil, and the 'toFileNumber:' argument not equal to nil."		[pn _ (s2 bitShift: 11) + ((s3 _ Store at: i3) bitShift: - 2).		fN _ (s3 bitAnd: 3) + 1.		self changeFromString: (RemoteString newFileNumber: fN position: pn) string.		(aSymbolOrInteger2 == #none)			ifTrue:				["Deliberately tag the pointers to the Stored information as having been read, because this information must only be read once, until it is Stored again; the user may change the class category information when it is NOT in the Store, but cannot do so while it is in the Store."				Store at: i2 put: nil.				]			ifFalse:				["If the file position information for my printString is in the Store, and if aSymbolOrInteger1 == #any, or if the file position information indicates that the printString itself is on (SourceFiles at: aSymbolOrInteger1), then move the printString to file number aSymbolOrInteger2, and update the Store accordingly. Otherwise, do nothing."				(aSymbolOrInteger2 isInteger and:					[aSymbolOrInteger1 = fN or:						[aSymbolOrInteger1 == #any.].					]				) ifTrue:					[aFileStream cr.					rS _ RemoteString						newString: self printString						onFileNumber: aSymbolOrInteger2						toFile: aFileStream.					pn _ rS position.					Store at: i2 put: (pn bitShift: -11).					Store						at: i3 put: (pn bitAnd: 16r7FF) * 4 + aSymbolOrInteger2 - 1.					].				].		].!moveChangedCommentFromFileNumber: anInteger1 toFileNumber: anInteger2 toFileStream: aFileStream 	"This is part of source code compression.  Move the comment about the	class classified by the receiver from the file referenced by	sourceIndex and to the stream, aFileStream."	globalComment == nil ifTrue: [^self].	globalComment sourceFileNumber = anInteger1 ifFalse: [^self].	aFileStream cr; cr.	globalComment _ RemoteString		newString: globalComment string		onFileNumber: anInteger2		toFile: aFileStream.! !!SystemOrganizer methodsFor: 'fileIn/Out'!fileOutCategory: category 	| aFileStream |	aFileStream _ Disk file: (category, '.st') asFileName.	self fileOutCategory: category on: aFileStream.	aFileStream shorten; close! !FormsElement comment:'Copyright (c) 1987 Xerox Corporation. All rights reserved.FormsElement is an abstract superclass. A FormsElement is an intelligent region of aForms window, which can respond to messages to display itself or to red/yellow button activity.FormsElements have the following instance variables:	box - 		The rectangle in which this element should display itself. This is specified				relative to the window corner or super-element corner.	value - 		The actual contents of the element.	bordered - 	Boolean indicating whether hether this element should have a border drawn				around it. Display messages should notice this and draw a one pixel box				around the box.	enabled -	Boolean indicating whether this element is enabled for interaction at present.				Display messages should note this state and grey the box if the element				is disabled. Red/yellow button messages should note this state and make fast				returns if the element is disabled.'!!FormsElement methodsFor: 'initialize-release'!release	initialValue release.	value release.	name _ initialValue _ value _ enabled _ bordered _ box _ controller _ nil.	super release!setValuesFromAnswers: answers	self		bordered: (answers at: 1) == #true;		enabled: (answers at: 2) == #true! !!FormsElement methodsFor: 'accessing'!alignment	"a default"	^#Center!bordered	^bordered!bordered: aBoolean	bordered _ aBoolean!box	^box!box: aRectangle	box _ aRectangle!changed	self hasChanged: true.	super changed!controller	^controller!controller: aFormsController	controller _ aFormsController!elementNamed: aName	| model | 	^model controller elementNamed: aName!enabled	^enabled!enabled: aBoolean	enabled _ aBoolean!hasChanged	^hasChanged!hasChanged: aBoolean	hasChanged _ aBoolean!initialValue	^initialValue!initialValue: anObject	initialValue _ anObject.	self value: anObject copy.	hasChanged _ false!label	"a default"	^value printString!name	^name!name: aString	name _ aString asString!value	^value!value: anObject	value _ anObject.	hasChanged _ true! !!FormsElement methodsFor: 'testing'!canUpdate	"this is default behavior for most elements, indicating that they have no 	programmatic behavior, and so need not be updated"	^false!hasController	^false!hasStringData	^false! !!FormsElement methodsFor: 'copying'!copy	"Answer a new instance of my class with copies of my name, initialValue, enabled, bordered, and box.	The value will be set to initialValue."	^(self class named: name)		initialValue: initialValue copy;		value: value copy;		enabled: enabled copy;		bordered: bordered copy;		box: box deepCopy;		controller: controller! !!FormsElement methodsFor: 'displaying'!border: aRectangle on: aDisplayObject 	aDisplayObject		fill: aRectangle		rule: Form reverse		mask: Form black.	aDisplayObject		fill: ((aRectangle origin + 1 corner: aRectangle corner - 1) intersect: controller view insetDisplayBox)		rule: Form reverse		mask: Form black!clear: aRectangle on: aDisplayObject 	aDisplayObject		fill: (aRectangle intersect: controller view insetDisplayBox)		rule: Form over		mask: Form white!displayOn: aDisplayObject at: aPoint clippingBox: aRectangle rule: combinationRule mask: mask 	| form width displayedLabel |	self clear: (aRectangle intersect: (box translateBy: aPoint)) on: aDisplayObject.	self		displayText: self label		alignment: self alignment		on: aDisplayObject		at: aPoint + box origin - (0@3)		clippingBox: (aRectangle intersect: (box translateBy: aPoint))		rule: combinationRule		mask: mask.	enabled ifFalse: [self gray: (aRectangle intersect: (box translateBy: aPoint)) on: aDisplayObject].	bordered ifTrue: [self border: (box translateBy: aPoint) on: aDisplayObject]!displaySelection	"Displays your selection. Since not all types of elements have selections defined,	this message provides default behavior when elements are asked to display their selection."	^self!displayText: aText alignment: aSymbol on: aDisplayObject at: aPoint clippingBox: aRectangle rule: combinationRule mask: mask 	| align |	align _ aSymbol == #rightFlush				ifTrue: [1]				ifFalse: [aSymbol == #leftFlush						ifTrue: [0]						ifFalse: [2]].	LocalTextStyle alignment: align.	LocalFastScanner		displayText: aText		textStyle: LocalTextStyle		destForm: aDisplayObject		leftMargin: aPoint x		rightMargin: aRectangle right		destY: aPoint y		halftoneForm: mask		combinationRule: combinationRule		clipX: aRectangle left		clipY: aRectangle top		clipWidth: aRectangle width		clipHeight: aRectangle height!gray: aRectangle on: aDisplayObject	| r | 	(Quadrangle new) region: (r _ aRectangle intersect: controller view insetDisplayBox);		borderWidthLeft: 1 right: 1 top: 1 bottom: 1;		borderColor: Form black;		insideColor: nil;		displayOn: aDisplayObject.		aDisplayObject		fill: (r insetBy: 1)		rule: Form under		mask:  (Form extent: 16@16 fromArray: #(		16r1010 16r2020 16r4040 16r8080		16r0101 16r0202 16r0404 16r0808		16r1010 16r2020 16r4040 16r8080		16r0101 16r0202 16r0404 16r0808) offset: 0@0)!reverse: aRectangle on: aDisplayObject 	aDisplayObject		fill: (aRectangle intersect: controller view insetDisplayBox)		rule: Form reverse		mask: Form black! !!FormsElement methodsFor: 'selecting'!redButtonAt: aPoint	self subclassResponsibility!yellowButtonAt: aPoint	self subclassResponsibility! !!FormsElement methodsFor: 'store - retrieve'!codeOn: aStream 	aStream cr.	aStream nextPutAll: '	"Add the ', name, ' element"'; cr.	aStream nextPutAll: ' 	model add:'; cr.	aStream nextPutAll: '		((', self class name,' named: ', name printString; nextPut: $); cr.	enabled ifFalse: [aStream nextPutAll: '			enabled: ', enabled printString; nextPut: $;; cr].	bordered ifFalse: [aStream nextPutAll: '			bordered: ', bordered printString; nextPut: $;; cr].	aStream nextPutAll: '			box: (', box printString; nextPut: $); nextPut: $;; cr.!readFrom: aStream 	| comma |	name _ aStream next: aStream nextWord.	enabled _ (aStream next) = $t.	bordered _ (aStream next) = $t.	box _ aStream nextWord @ aStream nextWord corner: (aStream nextWord @ aStream nextWord).!storeOn: aStream 	| comma |	hasChanged _ false.	aStream nextWordPut: name size.	aStream nextPutAll: name.	aStream nextPut: enabled printString first.	aStream nextPut: bordered printString first.	aStream nextWordPut: box origin x.	aStream nextWordPut: box origin y.	aStream nextWordPut: box corner x.	aStream nextWordPut: box corner y! !!FormsElement methodsFor: 'private'!from: anElement with: aSymbol	"a LinkLabelElement sends this message to an element to inform it that the label was selected.  anElement is the instance of LinkLabelElement.  aSymbol may be any symbol, and subclasses may use it any way they wish"	self perform: aSymbol!toggle 	enabled _ enabled not.	controller view fastDisplay: self.	[Sensor redButtonPressed] whileTrue: []! !ImageElement comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ImageElement methodsFor: 'displaying'!displayOn: aDisplayObject at: aPoint clippingBox: aRectangle rule: combinationRule mask: mask	| offset | 	aDisplayObject fill: (aRectangle intersect: (box translateBy: aPoint)) rule: Form over mask: Form white.	bordered ifTrue: [self border: (box translateBy: aPoint) on: aDisplayObject].	value== nil ifFalse: [offset _ (box width - value width) // 2 @ ((box height - value height) // 2).	value		displayOn: aDisplayObject		at: box origin + aPoint + offset		clippingBox: ((aRectangle intersect: (box translateBy: aPoint)) insetBy: 1@1)		rule: combinationRule		mask: mask].	enabled ifFalse: [self gray: (aRectangle intersect: (box translateBy: aPoint)) on: aDisplayObject].! !!ImageElement methodsFor: 'menu messages'!copySelection	Clipboard clip: value.	(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: controller view topView suitcase classification]!cut	Clipboard clip: value.	value _ (Form extent: 5@5) black.	controller view display: self.	(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: controller view topView suitcase classification].	self changed.!paste	| type entry acted picture classif stuff |	(entry _ Clipboard next) == nil ifTrue: [^Clipboard booboo].	acted _ false.	type _ entry contents class.	classif _ entry propertyAt: #classification.	(type == Form or: [(type inheritsFrom: Form)]) ifTrue: 		[value _ entry contents.		acted _ true].	(type == Text or: [type == OrderedCollection]) ifTrue: 		[stuff _ type == Text			ifTrue: [entry contents]			ifFalse: [classif == nil						ifTrue: [classif _ self maxClassification]						ifFalse: [classif _ classif + self maxClassification].					self convertDocumentText].		value _ stuff asDisplayText.		acted _ true].	type == DataItem ifTrue: 		[picture _ DataMaster formFromItem: entry contents.		picture == nil ifFalse: 			[value _ picture.			acted _ true.			classif _ entry contents]].	acted		ifTrue: 			[Clipboard retrieve. "get it out of the buffer"			(Smalltalk includesKey: #Suitcase)				ifTrue: [ controller view topView changeClassification: classif].			controller view display: self]		ifFalse: [Clipboard booboo].	self changed! !!ImageElement methodsFor: 'selecting'!redButtonAt: aPoint	^self!yellowButtonAt: aPoint	| selection | 	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	selection _ ImageElementYellowButtonMenu startUp: #anyButton.	selection = 0 ifFalse:[^self perform: (ImageElementYellowButtonMessages at: selection)]! !!ImageElement methodsFor: 'store - retrieve'!readFrom: aStream	super readFrom: aStream.	value _ Form readFromStream: aStream!setValuesFromAnswers: answers	self		bordered: (answers at: 1) == #true;		enabled: (answers at: 2) == #true.	value == nil ifTrue:		[self initialValue: (Form extent: 5@5) black]!storeOn: aStream	super storeOn: aStream.	value writeOnStream: aStream! !FillElement comment:'Copyright (c) Xerox Corporation, 1987. All rights reserved.'!!FillElement methodsFor: 'displaying'!displayOn: aDisplayObject at: aPoint clippingBox: clipRect rule: combinationRule mask: mask 	| oldGrid oldBase |	aDisplayObject		fill: ((box translateBy: aPoint) intersect: clipRect)		rule: Form over		mask: Form white.	linegrid == nil		ifFalse: 			[oldGrid _ LocalTextStyle lineGrid.			LocalTextStyle lineGrid: linegrid].	baseline == nil		ifFalse: 			[oldBase _ LocalTextStyle baseline.			LocalTextStyle baseline: baseline].	self		displayText: value asText		alignment: #leftFlush		on: aDisplayObject		at: aPoint + box origin + (5 @ 1)		clippingBox: (((box translateBy: aPoint) insetBy: 5 @ 0) intersect: clipRect)		rule: combinationRule		mask: mask.	enabled ifFalse: [self gray: (clipRect intersect: (box translateBy: aPoint)) on: aDisplayObject].	bordered ifTrue: [self border: (box translateBy: aPoint) on: aDisplayObject].	oldGrid == nil ifFalse: [LocalTextStyle lineGrid: oldGrid].	oldBase == nil ifFalse: [LocalTextStyle baseline: oldBase]! !!FillElement methodsFor: 'testing'!hasStringData	^true! !!FillElement methodsFor: 'selecting'!redButtonAt: aPoint	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	self startFillControllerIn: controller view insetDisplayBox.	self hasChanged: (value ~= initialValue)!yellowButtonAt: aPoint	enabled ifTrue: [^self redButtonAt: aPoint]! !!FillElement methodsFor: 'private'!baseline	^baseline!lineGrid	^linegrid!linegrid: lineHeight baseline: baselineHeight	linegrid _ lineHeight.	baseline _ baselineHeight!setValuesFromAnswers: answers	self		bordered: (answers at: 1) == #true;		enabled: (answers at: 2) == #true;		initialValue: (answers at: 3) asText; 		linegrid: ((answers at: 4) isNumeric ifTrue: [(answers at: 4) asNumber asInteger] ifFalse: [nil])			baseline: ((answers at: 5) isNumeric ifTrue: [(answers at: 5) asNumber asInteger] ifFalse: [nil])!startFillControllerIn: aRectangle	| aBlank aModel fillView fillController aBox | 	FillIn action: [:answer | self value: answer].	aBox _ box translateBy: aRectangle origin.	FillInView		window: (0@0 extent: aBox extent)		viewport: aBox.	FillInController element: self.	FillInView editString: value asText linegrid: linegrid baseline: baseline.	FillInController processRedButton.	FillInController startUp! !!FillElement methodsFor: 'store - retrieve'!codeOn: aStream	super codeOn: aStream.	aStream nextPutAll: '			initialValue: '.	initialValue storeOn: aStream.	aStream nextPut: $;; cr.	aStream nextPutAll: '			linegrid: ', linegrid printString, ' baseline: ', baseline printString.	aStream nextPut: $;; cr!readFrom: aStream 	super readFrom: aStream.	initialValue _ aStream next: aStream nextWord.	initialValue _ Text string: initialValue runs: (RunArray readFrom: aStream).	value _ aStream next: aStream nextWord.	value _ Text string: value runs: (RunArray readFrom: aStream).	"for forms last saved prior to 12/22/86, take next four lines out"	aStream binary.	(linegrid _ aStream next) = 0 ifTrue: [linegrid _ nil].	(baseline _ aStream next) = 0 ifTrue: [baseline _ nil].	aStream text!storeOn: aStream	super storeOn: aStream.	initialValue _ value copy.	aStream nextWordPut: initialValue size.	aStream nextPutAll: initialValue.	initialValue runs writeOn: aStream.	aStream nextWordPut: value size.	aStream nextPutAll: value.	value runs writeOn: aStream.	aStream binary.	aStream nextPut: (linegrid == nil ifTrue: [0] ifFalse: [linegrid]); nextPut: (baseline == nil ifTrue: [0] ifFalse: [baseline]).	aStream text! !!FillElement methodsFor: 'copying'!copy	^(super copy) linegrid: linegrid baseline: baseline; yourself! !LabelElement comment:'Copyright (c) Xerox Corporation, 1987. All rights reserved.'!!LabelElement methodsFor: 'initialize-release'!release	label _ alignment  _ nil.	linksAndMsgs _ nil.	super release!setValuesFromAnswers: answers	| theValue | 	theValue _ (answers at: 2) asText.	self		bordered: (answers at: 1) == #true;		initialValue: theValue;		label: theValue; 		alignment: (answers at: 3) asSymbol! !!LabelElement methodsFor: 'accessing'!addLink: anElement with: aSymbol	"link this label element to anElement (where anElement is the actual element object).  When this label is selected, this label element will be sent along with aSymbol to anElement to take whatever action it wishes.  The default is to simply perform aSymbol"	linksAndMsgs == nil		ifTrue: 			[linksAndMsgs _ Array with: OrderedCollection new with: OrderedCollection new].	(linksAndMsgs at: 1) add: anElement.	(linksAndMsgs at: 2) add: aSymbol!alignment	^alignment!alignment: aSymbol	alignment _ aSymbol!hasController	^false!label	^label!label: aText	label _ aText! !!LabelElement methodsFor: 'selecting'!redButtonAt: aPoint 	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	[Sensor redButtonPressed] whileTrue: [].	linksAndMsgs == nil ifFalse:		[1 to: (linksAndMsgs at: 1) size do:			[:i | ((linksAndMsgs at: 1) at: i) from: self with: ((linksAndMsgs at: 2) at: i)]]!yellowButtonAt: aPoint	^self! !!LabelElement methodsFor: 'store - retrieve'!codeOn: aStream	super codeOn: aStream.	aStream nextPutAll: '			label: '.	label storeOn: aStream.	aStream nextPut: $;; cr.	aStream nextPutAll: '			alignment: '.	alignment storeOn: aStream.	aStream nextPut: $;; cr.!readFrom: aStream	| alignMark labelString |  	super readFrom: aStream.	labelString _ aStream next: aStream nextWord.	label _ Text string: labelString runs: (RunArray readFrom: aStream).	alignMark _ aStream next.	alignMark == $L ifTrue:[alignment _ #leftFlush].	alignMark == $R ifTrue:[alignment _ #rightFlush].	alignMark == $C ifTrue:[alignment _ #Center].	initialValue _ aStream next: aStream nextWord.	value _ initialValue.!storeOn: aStream 	super storeOn: aStream.	label class == Paragraph		ifTrue: 			[aStream nextWordPut: label text string size.			aStream nextPutAll: label text string.			label text runs writeOn: aStream]		ifFalse: 			[aStream nextWordPut: label string size.			aStream nextPutAll: label string.			label runs writeOn: aStream].	alignment == #leftFlush		ifTrue: [aStream nextPut: $L]		ifFalse: [alignment == #rightFlush				ifTrue: [aStream nextPut: $R]				ifFalse: [aStream nextPut: $C]].	aStream nextWordPut: initialValue size.	aStream nextPutAll: initialValue! !!LabelElement methodsFor: 'copying'!copy	"Answer a new instance of my class with copies of my superclass's variables and my	form, label, and alignment. The targetController must be updated later."	^(super copy)		label: label deepCopy;		alignment: alignment copy! !OneOfElement comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!OneOfElement methodsFor: 'initialize-release'!release	choices _ nil.	super release!setValuesFromAnswers: answers	self		bordered: (answers at: 1) == #true;		enabled: (answers at: 2) == #true;		initialValue: (answers at: 3); 		choices: (Scanner new scanTokens: (answers at: 4))! !!OneOfElement methodsFor: 'accessing'!choices	^choices!choices: aCollection	choices _ aCollection! !!OneOfElement methodsFor: 'testing'!hasStringData	^true! !!OneOfElement methodsFor: 'copying'!copy	"Answer a new instance of my class with copies of my superclass's variables and my choices."	^(super copy)		choices: choices copy! !!OneOfElement methodsFor: 'displaying'!displayOn: aDisplayObject at: aPoint clippingBox: aRectangle rule: combinationRule mask: mask	| text | 	self clear: (aRectangle intersect: (box translateBy: aPoint)) on: aDisplayObject.	text _ ('{',value printString, '}') asText.	self		displayText: text 		alignment: #center 		on: aDisplayObject		at: aPoint + box origin - (0@3)		clippingBox: (aRectangle intersect: (box translateBy: aPoint))		rule: combinationRule		mask: mask.	enabled ifFalse: [self gray: (aRectangle intersect: (box translateBy: aPoint)) on: aDisplayObject].	bordered ifTrue: [self border: (aRectangle intersect: (box translateBy: aPoint)) on: aDisplayObject]! !!OneOfElement methodsFor: 'selecting'!redButtonAt: aPoint	| answer aRectangle |	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	answer _ PopUpMenu on: choices.	(answer == nil) ifFalse: 		[self value: answer.		self			displayOn: Display			at: (aRectangle _controller view insetDisplayBox)  origin			clippingBox: aRectangle			rule: Form over			mask: Form black].	self changed!yellowButtonAt: aPoint	self redButtonAt: aPoint! !!OneOfElement methodsFor: 'store - retrieve'!codeOn: aStream	super codeOn: aStream.	aStream nextPutAll: '			initialValue: '.	initialValue storeOn: aStream.	aStream nextPut: $;; cr.	aStream nextPutAll: '			choices: #', choices asArray printString; nextPut: $;; cr.!readFrom: aStream	| numberOfChoices | 	super readFrom: aStream.	initialValue _ aStream next: aStream nextWord.	value _initialValue.	choices _ OrderedCollection new.	numberOfChoices _ aStream nextWord.	numberOfChoices timesRepeat: [choices add: (aStream next: aStream nextWord)].!storeOn: aStream 	super storeOn: aStream.	aStream nextWordPut: value size.	aStream nextPutAll: value.	aStream nextWordPut: choices size.	choices do: 		[:each | 		aStream nextWordPut: each size.		aStream nextPutAll: each]! !ExecuteElement comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ExecuteElement methodsFor: 'initialize-release'!release	label _ alignment _ targetController _ nil.	super release!setValuesFromAnswers: answers	self		bordered: (answers at: 1) == #true;		enabled: (answers at: 2) == #true;		initialValue: (answers at: 5) asSymbol; 		label: (answers at: 3) asText;		alignment: (answers at: 4) asSymbol.	(targetController == nil and: [controller ~~ nil]) ifTrue: [targetController _ controller]! !!ExecuteElement methodsFor: 'accessing'!alignment	^alignment!alignment: aSymbol	alignment _ aSymbol!controller: aController	controller _ aController.	targetController == nil ifTrue:[targetController _ aController]!hasController	^true!label	^label!label: aStringorText	label _ aStringorText == nil			ifTrue: [Text new]			ifFalse: [aStringorText asText]!message	^initialValue!message: message	self initialValue: message!targetController	^targetController!targetController: aController	targetController _ aController.! !!ExecuteElement methodsFor: 'copying'!copy	"Answer a new instance of my class with copies of my superclass's variables and my	form, label, and alignment. The targetController must be updated later."	^(super copy)		label: label copy;		alignment: alignment copy! !!ExecuteElement methodsFor: 'selecting'!redButtonAt: aPoint	| last displayBox blackFlag |	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	displayBox _ (box translateBy: controller view insetDisplayBox origin) insetBy: 1.	Display		fill: displayBox		rule: Form reverse		mask: Form black.	blackFlag _ true.	last _ Sensor cursorPoint.	[Sensor redButtonPressed]		whileTrue: 			[last _ Sensor cursorPoint.			(displayBox containsPoint: last)				ifTrue:					[blackFlag						ifFalse: 							[Display								fill: displayBox								rule: Form reverse								mask: Form black.							blackFlag _ true]]				ifFalse:					[blackFlag						ifTrue: 							[Display								fill: displayBox								rule: Form reverse								mask: Form black.							blackFlag _ false].					^nil]].	blackFlag		ifTrue: 			[Display				fill: displayBox				rule: Form reverse				mask: Form black.			SmalltalkSignal do: [targetController perform: value]				handle: [self booboo: 'Something is wrong with ',value asString. SmalltalkSignal handleReturn]]!yellowButtonAt: aPoint	self redButtonAt: aPoint! !!ExecuteElement methodsFor: 'store - retrieve'!codeOn: aStream	super codeOn: aStream.	aStream nextPutAll: '			label: '.	label text storeOn: aStream.	aStream nextPut: $;; cr.	aStream nextPutAll: '			initialValue: '.	initialValue storeOn: aStream.	aStream nextPut: $;; cr.	aStream nextPutAll: '			alignment: '.	alignment storeOn: aStream.	aStream nextPut: $;; cr.!readFrom: aStream	| alignMark labelString |  	super readFrom: aStream.	labelString _ aStream next: aStream nextWord.	label _ Text string: labelString runs: (RunArray readFrom: aStream).	initialValue _ (aStream next: aStream nextWord) asSymbol.	value _ initialValue.	alignMark _aStream next.	alignMark == $L ifTrue:[alignment _ #leftFlush].	alignMark == $R ifTrue:[alignment _ #rightFlush].	alignMark == $C ifTrue:[alignment _ #Center].!storeOn: aStream	super storeOn: aStream.	label class == Paragraph		ifTrue: 			[aStream nextWordPut: label text string size.			aStream nextPutAll: label text string.			label text runs writeOn: aStream]		ifFalse: 			[aStream nextWordPut: label string size.			aStream nextPutAll: label string.			label runs writeOn: aStream].	aStream nextWordPut: initialValue size.	aStream nextPutAll: initialValue.	alignment = #leftFlush		ifTrue: [aStream nextPut: $L]		ifFalse: [alignment = #rightFlush				ifTrue: [aStream nextPut: $R]				ifFalse: [aStream nextPut: $C]]! !InfoCenterElement comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!InfoCenterElement methodsFor: 'selecting'!redButtonAt: aPoint	| last displayBox blackFlag |	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	displayBox _ (box translateBy: controller view insetDisplayBox origin) insetBy: 1.	Display		fill: displayBox		rule: Form reverse		mask: Form black.	blackFlag _ true.	last _ Sensor cursorPoint.	[Sensor redButtonPressed]		whileTrue: 			[last _ Sensor cursorPoint.			(displayBox containsPoint: last)				ifTrue:					[blackFlag						ifFalse: 							[Display								fill: displayBox								rule: Form reverse								mask: Form black.							blackFlag _ true]]				ifFalse:					[blackFlag						ifTrue: 							[Display								fill: displayBox								rule: Form reverse								mask: Form black.							blackFlag _ false].					^nil]].	blackFlag		ifTrue: 			[Display				fill: displayBox				rule: Form reverse				mask: Form black.			value asLowercase = 'make new center'				ifTrue: [InformationCenter makeNewCenter]				ifFalse: [InformationCenter open: value]]! !!ImmediateExecuteElement methodsFor: 'selecting'!redButtonAt: aPoint	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	SmalltalkSignal do: [targetController perform: value]			handle: [self booboo: 'Something is wrong with ',value asString. SmalltalkSignal handleReturn]! !SwitchElement comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!SwitchElement methodsFor: 'initialize-release'!release	label _ nil.	super release!setValuesFromAnswers: answers	self		bordered: (answers at: 1) == #true;		enabled: (answers at: 2) == #true;		initialValue: (answers at: 4) == #true;		label: (answers at: 3)! !!SwitchElement methodsFor: 'accessing'!label	^label!label: aString	label _ aString! !!SwitchElement methodsFor: 'testing'!hasStringData	^true! !!SwitchElement methodsFor: 'copying'!copy	"Answer a new instance of my class with copies of my superclass's variables and my label."	^(super copy)		label: label copy! !!SwitchElement methodsFor: 'displaying'!displayOn: aDisplayObject at: aPoint clippingBox: aRectangle rule: combinationRule mask: mask	super displayOn: aDisplayObject at: aPoint clippingBox: aRectangle rule: combinationRule mask: mask.	value ifTrue: [self reverse: (aRectangle intersect: (box translateBy: aPoint)) on: aDisplayObject]! !!SwitchElement methodsFor: 'selecting'!redButtonAt: aPoint	| displayBox |  	enabled ifFalse:		[SmalltalkSignal do: [controller defaultDisabledAction: self] handle: []. ^self].	[Sensor redButtonPressed] whileTrue: [].	displayBox _ box translateBy: controller view insetDisplayBox origin.	self value: value not.	Display		fill: displayBox		rule: Form reverse		mask: Form black.	self changed!yellowButtonAt: aPoint	[Sensor yellowButtonPressed] whileTrue: [].	self redButtonAt: aPoint! !!SwitchElement methodsFor: 'store - retrieve'!codeOn: aStream	super codeOn: aStream.	aStream nextPutAll: '			label: '.	label storeOn: aStream.	aStream nextPut: $;; cr.	aStream nextPutAll: '			initialValue: ', initialValue printString; nextPut: $;; cr.!readFrom: aStream	| labelString | 	super readFrom: aStream.	labelString _ aStream next: aStream nextWord.	label _ Text string: labelString runs: (RunArray readFrom: aStream).	initialValue _ (aStream next = $t).	value _(aStream next = $t)!storeOn: aStream 	super storeOn: aStream.	aStream nextWordPut: label string size.	aStream nextPutAll: label string.	label runs writeOn: aStream.	initialValue ifTrue: [aStream nextPut: $t] ifFalse: [aStream nextPut: $f].	value ifTrue: [aStream nextPut: $t] ifFalse: [aStream nextPut: $f]! !RS232Memory comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.This is used to remember the text that has been displayed on the RS232 display, but is no longer currently displayed.firstBuffer	this is the first buffer (an RS232MemoryBuffer) in the chain of buffers that hold the text strings.currentBuffer	this is the current buffer - the buffer being written intopageQueue		an OrderedCollection of pages where each page is an Array containing:		1:  the buffer the page starts in		2:  the location in that buffer of the starting character of the page		3:  the length (number of characters) of the page		4:  the highlight collection for the page, where each highlight  is an array #(s, e, t) where:				s is starting index of the highlight from the beginning of the page				e is ending index from the beginning of the page				t is the type of highlight (currently only $H for reverse video, $U for underline).currentPage		the last page in pageQueue - only separate for faster accesspreBrowseState	used to remember the state of memory before the current display page was loaded in for browsing, so that it can be cleared out on termination of browse.pagesReadIndices	an Array containing the first and last pages, respectively, that are being browsed.'!!RS232Memory methodsFor: 'access'!addLine: anRS232DisplayLine	| relativeLineStart lineLength pend | 	relativeLineStart _ currentPage at: 3.	lineLength _ anRS232DisplayLine lastLoc.	currentBuffer _ currentBuffer addString: anRS232DisplayLine string startingAt: 1 endingAt: lineLength.	currentPage at: 3 put: (relativeLineStart + lineLength).	self addHighlights: anRS232DisplayLine highlightColl to: (pageQueue last at: 4) relativeTo: relativeLineStart.	pend _ anRS232DisplayLine pendingHighlightUpto: lineLength.	pend == nil ifFalse: [self addHighlights: (Array with: pend) to: (pageQueue last at: 4) relativeTo: relativeLineStart]!clearMemory	self release.	self initialize!resetToPreBrowseState	"set the memory back to where it was when preBrowseState was set"	preBrowseState == nil ifFalse:		[pageQueue removeLast; addLast: (currentPage _ preBrowseState).		currentBuffer _ (currentPage at: 1) resetTo: (currentPage at: 3) startingAt: (currentPage at: 2).		preBrowseState _ nil]!setPreBrowseState	preBrowseState _ Array with: (currentPage at: 1) with: (currentPage at: 2) with: (currentPage at: 3) with: (currentPage at: 4) copy! !!RS232Memory methodsFor: 'page access'!getPageByCode: aChar	"to allow easier requesting through intermediaries,		this will get the page requested according to aChar,		where: aChar =			$l gives lastPage, $f gives firstPage, $n gives nextPage,			$p gives previous page, $r gives current page again"	| page | 	page _		(aChar < $n)			ifTrue:				[(aChar = $l)					ifTrue: [pageQueue size "lastPage"]					ifFalse: [1 "firstPage"]]			ifFalse:				[(aChar = $n)					ifTrue: [(pagesReadIndices at: 2) + 1 "nextPage"]					ifFalse:						[(aChar = $p)							ifTrue: [(pagesReadIndices at: 1) - 1 "prevPage"]							ifFalse: [pagesReadIndices at: 2]]].	(page < 1 or: [page > pageQueue size]) ifTrue: [^nil].	^self copyPage: page!getPages: firstPage to: lastPage	"return the contents of the pages firstPage through lastPage, return nil if there are none"	(firstPage > lastPage or: [firstPage > pageQueue size]) ifTrue: [^ nil].	^ self copyPages: firstPage to: lastPage!newPage	"a page consists of an array containing:		1:  the buffer the page starts in		2:  the location in that buffer of the starting character of the page		3:  the length (number of characters) of the page		4:  the highlight collection for the page"	(currentPage ~= nil and: [(currentPage at: 3) = 0])	"avoid empty pages (happens when new page immediately follows a reset)"		ifFalse:			[pageQueue addLast: (currentPage _ Array with: currentBuffer with: currentBuffer lastUsed + 1 with: 0 with: OrderedCollection new)]!nextPagesForAppend: numToAppend	| pages savedFirstPageIndex |	savedFirstPageIndex _ pagesReadIndices at: 1.	pages _ self getPages: (pagesReadIndices at: 2) + 1 to: (pagesReadIndices at: 2) + numToAppend.	pagesReadIndices at: 1 put: savedFirstPageIndex.	^pages!pageStatus	"Answer with a string containing the last read page number of the total number of pages"	^ ((pagesReadIndices at: 1) printString, ' thru ', (pagesReadIndices at: 2) printString, ' of ', pageQueue size printString)!prevPagesForAdd: numPages	| pages savedLastPageIndex | 	savedLastPageIndex _ pagesReadIndices at: 2.	pages _ self getPages: (1 max: (pagesReadIndices at: 1) - numPages) to: (pagesReadIndices at: 1) - 1.	pagesReadIndices at: 2 put: savedLastPageIndex.	^pages!totalPages	^pageQueue size! !!RS232Memory methodsFor: 'private'!addHighlights: lineHighlights to: pageHighlights relativeTo: relativeLineStart	lineHighlights do:		[:h |		pageHighlights addLast:			(Array				with: (h at: 1) + relativeLineStart				with: (h at: 2) + relativeLineStart				with: ((h at: 3) = $H ifTrue: [HighlightEmphasis] ifFalse: [UnderlineEmphasis]))].!copyPage: index	"Answer with a copy of the index(th) page from the buffer."	^ self copyPages: index to: index!copyPages: firstPage to: lastPage	"Answer with a text copy of the firstPage through lastPage pages from the buffer."	| startPage endIndex string runs values pos highlights pastEndBuffer |	pagesReadIndices at: 1 put: firstPage.	pagesReadIndices at: 2 put: (lastPage min: pageQueue size).	startPage _ pageQueue at: firstPage.	(pageQueue size > lastPage)		ifTrue:			[pastEndBuffer _ (pageQueue at: (lastPage + 1)) at: 1.			 endIndex _ ((pageQueue at: (lastPage + 1)) at: 2) - 1]		ifFalse:			[pastEndBuffer _ currentBuffer.			 endIndex _ nil].	string _ (startPage at: 1) getStringStartingAt: (startPage at: 2) endingIn: pastEndBuffer at: endIndex.	runs _ OrderedCollection new.	values _ OrderedCollection new.	firstPage to: (pagesReadIndices at: 2) do:		[ :pageNum |		 pos _ 1.		 highlights _ (pageQueue at: pageNum) at: 4.		 highlights isEmpty			ifFalse:				[highlights do: [:h |					runs addLast: (h at: 1) - pos.					values addLast: DefaultEmphasis.					runs addLast: (h at: 2) - (h at: 1) + 1.					values addLast: (h at: 3).					pos _ (h at: 2) + 1]].		 runs addLast: ((pageQueue at: pageNum) at: 3) - pos + 1.		 values addLast: DefaultEmphasis].	^Text string: string runs: (RunArray runs: runs asArray values: values asArray)! !!RS232Memory methodsFor: 'initialize/release'!initialize	firstBuffer _ RS232MemoryBuffer ofSize: BufferSize.	pageQueue _ OrderedCollection new.	currentBuffer _ firstBuffer.	pagesReadIndices _ Array with: 0 with: 1.	self newPage!release	pageQueue do: [:p | p at: 1 put: nil; at: 4 put: nil]. "release the starting buffer and highlight collection from each page"	currentPage _ nil. "this IS important"	currentBuffer _ nil.	firstBuffer releaseAll! !!PositionableStream methodsFor: 'accessing'!peekForMore: anObject	"Return false and don't move position in self if self next ~= anObject or self atEnd.		If self next = anObject, return true and increment position until self next will not return anObject"	(self peekFor: anObject)		ifTrue: [[self peekFor: anObject] whileTrue: []. ^true].	^false! !!PositionableStream methodsFor: 'private'!release	collection _ nil.	super release! !!FileStream methodsFor: 'printing'!asPressPrinter	self readWrite.	^PressOrInterpress == #Press		ifTrue: [PressPrinter new init of: self]		ifFalse: [Interpress of: self]!sendEFTP: hostName 	"Send the receiver over the ethernet using EFTP protocol.  Answer whether transfer was successful."	^self sendEFTPtoPrinter: hostName numOfCopies: 1 numTries: 5 sendMsgsTo: Transcript!sendEFTPtoPrinter: hostName numOfCopies: numCopies numTries: numTries sendMsgsTo: anObject	"Dummy"	Transcript cr; show: 'Press file made - but cannot send it'.	self close.	^false!toPrinter: hostName numOfCopies: numCopies numTries: numTries sendMsgsTo: anObject	"Send the receiver to hostName using either EFTP or XNS protocol.  This version is for the 1108.  Answer the final status if transfer completed. Answer the printPacket if transfer is not complete.	anObject could be Transcript or something else that will understand the message show:"	| printPacket | 	PressOrInterpress == #Press ifTrue:		[self isPressFile ifFalse: [anObject show: 'Error: Not press file'. self close. ^#abort]].	self close.	anObject show: 'Sending ', self name, ' to ', hostName.	printPacket _ PrintFrom1108 sendPrintFile: self name printer: hostName copies: numCopies.	(Delay forSeconds: 10) wait. 	^printPacket checkProgressAndShowOn: anObject! !PilotFileStream comment:'Copyright (c) 1986 Xerox Corporation.  All Rights Reserved.I provide Stream-level interfaces to the underlying Pilot File Sytem.Instance variables:		PositionableStream	collection			<String> or <ByteArray>. buffer. (see also binary)	position				<SmallInteger> position in collection (buffer)	readLimit			<SmallInteger> maximum position before buffer fill		WriteStream	writeLimit			<SmallInteger> maximum position before buffer flush		PilotFileStream	directory			<FileDirectory> containing the file, if known, else nil	name				<String> file name within directory	rwMode			<Symbol: nil, #readOnly, #readWrite, #readWriteShorten, #writeOnly> access as specified by client	fileHandle			<SmallInteger> file Id for underlying file system	filePosition			<Integer> position in file where next action - fill, flush - will occur	fileMode			<Symbol: #readOnly, #readWrite, #writeOnly> current access wrt fileHandle (file system)	The other instance variables inherited from FileStream are not used; removing them would be hard.'!PilotFileDirectory comment:'Copyright (c) 1986 Xerox Corporation.  All Rights Reserved.	I provide general functions for local files. I acquire, add, remove	and rename files. When I acquire or add a file, I make the connection	between the instances of PilotFileStream and the actual Mesa files	with Mesa handles. The client can get the informations of the	file and create the file stream through the interfaces of PilotFileStream.	I also support the hierarchical directory. So, the instances of	PilotFile have the local directory name in its name.'!!PilotFileDirectory methodsFor: 'file copying'!copy: oldFileName to: newFileName	"Copy the file named oldFileName to the file named newFileName."	| oldFile newFile |	oldFile _ self oldFile: oldFileName.	oldFile readOnly.	newFile _ self file: newFileName.	oldFile copyTo: newFile. "newFile nextPutAll: oldFile."	newFile close.	oldFile close! !!PilotFileDirectory methodsFor: 'As yet unclassified'!findFiles: checkFiles inList: mainList inclusive: inclusive addTo: returnList	"look for the filenames in the collection checkFiles in the collection of filenames mainList. If inclusive is true, add the filenames which are in both lists to returnList, otherwise add the filenames which are in only one list.	This is put here to attempt to handle the problems that arise between file systems which have case sensitive filenames and those which are not case sensitive - this particular implementation is for non-case sensitive filenames"	| lowercasedName lowerMainList |	lowerMainList _ Set new.	mainList do: [:i | lowerMainList add: i asLowercase].	inclusive		ifTrue:			[checkFiles do:				[:fileName |				lowercasedName _ fileName asLowercase.				(lowerMainList includes: lowercasedName) ifTrue: [returnList add: fileName]]]		ifFalse:			[checkFiles do:				[:fileName |				lowercasedName _ fileName asLowercase.				(lowerMainList includes: lowercasedName) ifFalse: [returnList add: fileName]]].	^returnList!makeNewFileName: fname withSuffix: suffix	"Convert input label into a unique file name of correct length and characters.  It is assumed that if the user puts a $> in the name, there is a valid subdirectory in front of it"	| special slen maxLen newName len i char baseName tryName counter |	fname isEmpty		ifTrue: [^'empty-file-name-+1'].	special _ '.-+$!!>'.	slen _ suffix size.	maxLen _ (28 - slen) min: fname size.	newName _ WriteStream on: (String new: 36).	len _ 0.	i _ 1.	[len > maxLen or: [i > fname size]] whileFalse:		[char _ fname at: i.		(char isLetter or: [(special includes: char) or: [char isDigit]]) ifTrue:			[newName nextPut: char.			len _ (char = $> ifTrue: [0] ifFalse: [len + 1])].		i _ i + 1].	suffix do: [:i | newName nextPut: i].	newName nextPut: $-.	newName nextPut: $+.	baseName _ newName contents.	newName nextPut: $1.	tryName _ newName contents.	counter _ 1.	[self includesKey: tryName]		whileTrue:[counter _ counter + 1.			tryName _ baseName,counter printString.].	^tryName! !!Magnitude methodsFor: 'printing'!printFormat: formatArray 	"Answer a string description of the receiver.  The argument	formatArray is the print format, where	1-3	positions to print day,month,year respectively 	4	character separator 	5	month format (1 month #, 2 first 3 chars, 3 entire name) 	6	year format (1 year #, 2 year # \\ 100)"	| aStream |	aStream _ WriteStream on: (String new: 16).	self printOn: aStream format: formatArray.	^aStream contents!printOn: aStream format: formatArray 	"Print a description of the receiver on aStream.  The argument formatArray is the print format."	| aCharacter anInteger aString |	aCharacter _ Character space.	anInteger _ 0.	formatArray do: 		[:each |		(each isKindOf: Integer)		ifTrue: [anInteger _ each]		ifFalse:			[			(each isKindOf: Symbol)			ifTrue:				[				aString _ self perform: each.				(aString isKindOf: Integer) ifTrue:					[					anInteger = 0 ifFalse: [aString _ aString \\ (10 raisedTo: anInteger)].					aString _ aString printStringRadix: 10 minimumDigits: anInteger fillWith: aCharacter					].				anInteger = 0					ifTrue: [aStream nextPutAll: aString]					ifFalse: [1 to: anInteger do: [:i | aStream nextPut: (aString at: i)]]				]			ifFalse:				[				(each isKindOf: String)					ifTrue: [aStream nextPutAll: each]					ifFalse:						[						(each isKindOf: Character)						ifTrue: [aCharacter _ each. anInteger timesRepeat: [aStream nextPut: aCharacter]]						]				].			anInteger _ 0			]		]! !UnknownDate comment:'Copyright (c) 1985 Xerox Corporation. All rights reserved.'!!UnknownDate methodsFor: 'comparing'!< aDate	"aDate species = self species ifFalse:[^true]."	^false!= aDate	aDate species = self species ifFalse:[^false].	^true! !!UnknownDate methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'unknown date'! !UnknownTime comment:'Copyright (c) 1985 Xerox Corporation. All rights reserved.'!!UnknownTime methodsFor: 'comparing'!< aTime	"aTime species = self species ifFalse:[^true]."	^false! !!UnknownTime methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'unknown time'! !!Date methodsFor: 'comparing'!< aDate 	"return true if the object is not a date, as a default behavior to handle unknown dates and times"	self species = aDate species ifFalse: [^true].	year = aDate year ifTrue: [^day < aDate day].	^year < aDate year! !!Date methodsFor: 'printing'!printOn: aStream 	self printOn: aStream format: #(dayOfMonth ' ' monthName ' ' year)! !!Time methodsFor: 'comparing'!< aTime 	self species = aTime species ifFalse: [^true].	hours ~= aTime hours ifTrue: [^hours < aTime hours].	minutes ~= aTime minutes ifTrue: [^minutes < aTime minutes].	^seconds < aTime seconds!= aTime 	self species = aTime species ifFalse: [^true].	self species = aTime species ifTrue: [^hours = aTime hours & (minutes = aTime minutes) & (seconds = aTime seconds)].	^false! !!Time methodsFor: 'printing'!printOn: aStream 	"Format is h:mm:ss am/pm"	hours > 12		ifTrue: [hours - 12 printOn: aStream]		ifFalse: [hours < 1					ifTrue: [12 printOn: aStream]					ifFalse: [hours printOn: aStream]].	self printOn: aStream format: #($0 ':' 2 minutes ':' 2 seconds).	aStream nextPutAll: (hours < 12							ifTrue: [' am']							ifFalse: [' pm'])! !ZonedTime comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!Integer methodsFor: 'printing'!printOn: aStream base: base minimumDigits: minimumDigits	self printOn: aStream base: base minimumDigits: minimumDigits fillWith: Character space!printOn: aStream base: base minimumDigits: minimumDigits fillWith: aCharacter	self < 0 ifTrue: [aStream nextPut: $-].	minimumDigits - 1 - (self = 0 ifTrue: [0] ifFalse: [self abs floorLog: base])		timesRepeat: [aStream nextPut: aCharacter].	self abs printOn: aStream base: base!printStringRadix: radix minimumDigits: minimumDigits fillWith: aCharacter	"Answer a String representing the receiver as a base radix integer."	| aStream |	aStream _ WriteStream on: (String new: 16).	self printOn: aStream base: radix minimumDigits: minimumDigits fillWith: aCharacter.	^aStream contents"253 printStringRadix: 16 minimumDigits: 4 fillWith: $0. '00FD'"! !Helper comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation.  All Rights Reserved.'!!Helper methodsFor: 'instance creation'!openWithLabel: myLabel	| topView |	view _ CodeView on: self		aspect: #myHelp		change: nil		menu: #menu		initialSelection: nil.	view borderWidth: 1.	(topView _ StandardSystemView new)		borderWidth: 1;		model: self;		helpIndex: #Help;		addSubView: view;		label: myLabel;		minimumSize: 400@500.	Cursor normal show.	topView controller open! !!Helper methodsFor: 'get help message'!search	"Search the User Guide for matches to the selected text."	| searchString | 	(Smalltalk includesKey: #OutlineView) ifTrue:		[searchString _ view controller selection string.		(searchString == nil or: [searchString isEmpty]) ifTrue: [^view flash].		^OutlineView openUserGuideWithKey: searchString].	self booboo: 'The necessary tool is not installed'!showHelpForIndex: index	"Pop-up a help window with the text from <index>."	| indexFileStream key array dummy giveMe |	HelpIndex == nil		ifTrue:[HelpFileStream _ (FileStream fileNamed: 'Help.data') readOnly.		indexFileStream _ (FileStream fileNamed: 'Help.index') readOnly.		HelpIndex _ OopConservingDictionary new.		[indexFileStream atEnd] whileFalse:			[key _  indexFileStream upTo: $\.			array _ Array new: 2.			array at: 1 put:  (Number readNumberFrom: indexFileStream).			array at: 2 put:  (Number readNumberFrom: indexFileStream).			dummy _  indexFileStream upTo: Character cr.			HelpIndex at: key put: array].	indexFileStream close].	giveMe _ HelpIndex at: (index asString) ifAbsent:[ ^ self booboo: 'Sorry, there is no help for this window.' ].	HelpFileStream position: (giveMe at: 1).	myHelp _ (HelpFileStream next: (giveMe at: 2)) asText.	self openWithLabel: 'Help for ', (index asString)! !!Helper methodsFor: 'private'!changeRequest	"I don't care whether the view has been changed."	^true!menu	^ HelpYellowButtonMenu!myHelp	^ myHelp! !OutlineList comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!OutlineList methodsFor: 'structure manipulations'!addEntry: anArray	"anArray has four elements: position, entry name, classification and modifiers."	| newDataItem selectedDataItem index selectedBPtrs nextIndex prevIndex op | 	newDataItem _ DataItem type: 4 label: (anArray at: 2) atIndex: 0.	newDataItem class: (anArray at: 3) modifiers: (anArray at: 4).	index _ listIndex = 0 ifTrue: [1] ifFalse: [collection at: listIndex].	selectedDataItem _  dataItems at: index.	op _ anArray first.	nextIndex _ dataItems size + 1.	op == #under		ifTrue: [	selectedDataItem addFirstFPointer: nextIndex ofType: LinkPtr. 				newDataItem addBPointer: index type: LinkPtr]		ifFalse: [selectedBPtrs _ selectedDataItem bpIndicesOfType: LinkPtr. "it shouldn't be empty"				prevIndex _ listIndex = 0 ifTrue: [1] ifFalse: [selectedBPtrs first].				op == #after					ifTrue: [(dataItems at: prevIndex) insertFPointer: nextIndex ofType: LinkPtr after: index.							newDataItem addBPointer: prevIndex type: LinkPtr]					ifFalse: [(dataItems at: prevIndex) insertFPointer: nextIndex ofType: LinkPtr before: index.							newDataItem addBPointer: prevIndex type: LinkPtr]].	dataItems add: newDataItem.	self changed: (Array with: #addEntry:at: with: (Array with: op with: dataItems size)).	self updateRootCnM.	Auditor add: 'Outline ', dataItems first label, ' addEntry: ', (anArray at: 2), (String with: $ ), op printString, (String with: $: with: $ ), selectedDataItem label!changeSelection: answer	"answer is an Array of 4. The first, new name; the second is nil, the third is new classification and the fourth, new modifier words."	| aDataItem newName class | 	aDataItem _ dataItems at: (collection at: listIndex).	aDataItem changeSelfWith: answer.	self updateRootCnM.	newName _ String new.	(answer at: 1) == nil ifFalse: [newName _ answer at: 1].	class _ aDataItem classAndWords.	(class == nil or: [class isEmpty])		ifFalse: [newName _ newName, (String with: ${), class, (String with: $})].	self changed: (Array with: #rename: with: (Array with: newName)).	hasChanged _ true!classAndModOf: anIndex classTo: maxClass modTo: allModifiers	| thisItem | 	thisItem _ dataItems at: anIndex.	thisItem classificationIndex > (maxClass at: 1) ifTrue: [maxClass at: 1 put: thisItem classificationIndex].	allModifiers addAll: thisItem numericModifiers.	(thisItem fpIndicesOfType: LinkPtr) do: [:each |		self classAndModOf: each classTo: maxClass modTo: allModifiers].!concat: anotherOL at: startIndex	| prevIndex thisIndex newRoot tempTextFS fs oldRoot nextDataItems originTextFS classificationScheme | 	fs _ self class getOldFileName: anotherOL.	fs == nil ifTrue: [^self].	fs _ HeaderFileStream fileNamed: fs.	classificationScheme _ ClassificationScheme new setupFrom: fs.	nextDataItems _ self readStructureFrom: fs.	fs close.	classificationScheme id = DCM id ifFalse:		[1 to: nextDataItems size do:			[:i | nextDataItems at: i put: ((nextDataItems at: i) convertFrom: classificationScheme)]].	oldRoot _ dataItems first.	newRoot _ nextDataItems at: startIndex.	prevIndex _ 1.	originTextFS _ self openOldFile: anotherOL, (DataMaster giveMe: #specialSuffixString for: #outline asString).	startIndex > 1		ifTrue: [	thisIndex _ dataItems size + 1.				self copyDataItem: nextDataItems at: startIndex to: dataItems under: prevIndex textFrom: originTextFS to: textFS.				oldRoot addFPointer: thisIndex type: LinkPtr]		ifFalse: [(newRoot fpIndicesOfType: LinkPtr) do: [:aPtr |				thisIndex _ dataItems size + 1.				self copyDataItem: nextDataItems at: aPtr to: dataItems under: prevIndex textFrom: originTextFS to: textFS.				oldRoot addFPointer: thisIndex type: LinkPtr]].	originTextFS close.	textFS flush.	self updateRootCnM.	hasChanged _ true.	listIndex _ 0.	self changed: (Array with: #list: with: (Array with: self treeList)).	Auditor add: 'Outline ', oldRoot label, ' concat with: ', newRoot label!concat: heading text: filename	| oldRoot fs newDataItem contents theClass | 	oldRoot _ dataItems first.	newDataItem _ DataItem type: 4 label: heading atIndex: 0.	self addTextPtr: textFS size to: newDataItem.	newDataItem addBPointer: (DataItemPointer type: LinkPtr index: 1).	dataItems add: newDataItem.	textFS setToEnd.	fs _ HeaderFileStream fileNamed: filename.	theClass _ fs classAndModsFromHeader.	theClass == nil ifFalse: [newDataItem class: (theClass at: 1) modifiers: (theClass at: 2)].	contents _ fs contentsOfEntireFile.	textFS nextPut: $T.	textFS nextPutAll: contents size printString;		nextPut: Character space;		nextPutAll: contents.	fs close.	oldRoot addFPointer: dataItems size type: LinkPtr.	Disk removeKey: filename.	self updateRootCnM.	hasChanged _ true.	listIndex _ 0.	self changed: (Array with: #list: with: (Array with: self treeList)).	Auditor add: 'Outline ', oldRoot label, ' concat with text file: ', filename!copy	theCutBuffer _ 0 - (collection at: listIndex).	Auditor add: 'Outline ', dataItems first label, ' copyEntry: ', (dataItems at: theCutBuffer abs) label!cut	| selectedDataItem selectedBPtrs prevIndex | 	theCutBuffer _ collection at: listIndex.	selectedDataItem _ dataItems at: theCutBuffer.	selectedBPtrs _ selectedDataItem bpIndicesOfType: LinkPtr. "it shouldn't be empty !!!!"	prevIndex _ selectedBPtrs first.	(dataItems at: prevIndex) removeFPointer: theCutBuffer type: LinkPtr.	self updateRootCnM.	(displaySubs includes: theCutBuffer)		ifTrue: [displaySubs remove: theCutBuffer].	self changed: #cut.	Auditor add: 'Outline ', dataItems first label, ' cutEntry: ', selectedDataItem label!hideSubs	| thisIndex |	thisIndex _ collection at: listIndex.	(displaySubs includes: thisIndex)		ifTrue: [^0]		ifFalse: [((dataItems at: thisIndex) fpIndicesOfType: LinkPtr) isEmpty					ifTrue: [^0]					ifFalse: [displaySubs add: thisIndex.							self changed: #hideSubs]]!pasteEntry: op	| newDataItem selectedDataItem index prevIndex thisIndex | 	"To paste a copy, all dataItems involved need to be duplicated. To paste an original, no need to duplicate dataItems."	theCutBuffer = 0 ifTrue: [^0].		index _ listIndex = 0 ifTrue: [1] ifFalse: [collection at: listIndex].	selectedDataItem _ dataItems at: index.	newDataItem _ dataItems at: theCutBuffer abs.	prevIndex _ listIndex = 0 ifTrue: [1] ifFalse: [(selectedDataItem bpIndicesOfType: LinkPtr) first]. "it shouldn't be empty !!!!"	theCutBuffer > 0		ifTrue: [thisIndex _ theCutBuffer.				newDataItem removeAllBPointers.				op == #under					ifTrue: [selectedDataItem addFirstFPointer: thisIndex ofType: LinkPtr.							newDataItem addBPointer: index type: LinkPtr]					ifFalse: [op == #after								ifTrue: [(dataItems at: prevIndex) insertFPointer: thisIndex ofType: LinkPtr after: index]								ifFalse: [(dataItems at: prevIndex) insertFPointer: thisIndex ofType: LinkPtr before: index].							newDataItem addBPointer: prevIndex type: LinkPtr]]		ifFalse: [thisIndex _ dataItems size + 1.				op == #under					ifTrue: [self copyDataItem: newDataItem under: index.							selectedDataItem addFirstFPointer: thisIndex ofType: LinkPtr]					ifFalse: [self copyDataItem: newDataItem under: prevIndex.							op == #after								ifTrue: [(dataItems at: prevIndex) insertFPointer: thisIndex ofType: LinkPtr after: index]								ifFalse: [(dataItems at: prevIndex) insertFPointer: thisIndex ofType: LinkPtr before: index]]].	self updateRootCnM.	(displaySubs includes: theCutBuffer abs) ifTrue: [displaySubs add: thisIndex].	(op ~= #under or: [(displaySubs includes: index) not])		ifTrue: [self changed: (Array with: #addEntry:at: with: (Array with: op with: thisIndex))].	theCutBuffer _ 0 - thisIndex.		Auditor add: 'Outline ', dataItems first label, ' pasteEntry: ', newDataItem label, (String with: Character space), op printString, (String with: $: with: $ ), selectedDataItem label!reClassify: newClassAndModifier	(dataItems at: (collection at: listIndex)) changeClassAndModifier: newClassAndModifier.	self updateRootCnM.	hasChanged _ true!repairText	| ws t | 	"Unfortunately, the text file needs to be repaired. Two conditions are forseeable: either the text file is truncated or it is out of sync with the index file. In both cases, the index file will be repaired so that it has a zero text pointer"	Cursor wait showWhile: [	ws _ WriteStream on: String new.	(dataItems first fpIndicesOfType: LinkPtr) do: 		[:i | self repairTextFor: (dataItems at: i) logOn: ws].	textFS setToEnd].	t _ ws contents.	t size > 0		ifTrue: [hasChanged _ true.				t _ (ws contents, (String new: 30 withAll: $-), (String with: Character cr)) asText].	^t!repairTextFor: aDataItem logOn: aStream	"Unfortunately, the text file needs to be repaired. Two conditions are forseeable: either the text file is truncated or it is out of sync with the index file. In both cases, the index file will be repaired so that it has a zero text pointer"	| txtPos sz txtPtrs | 	sz _ textFS size.	(txtPtrs _ aDataItem fpIndicesOfType: TextPtr) size > 0		ifTrue: [txtPos _ self textPtrOf: aDataItem.				(txtPos > sz				or: [textFS position: txtPos.					textFS peek ~= $T])					ifTrue: [txtPtrs do: [:each | aDataItem removeFPointer: each type: TextPtr].							aStream cr; nextPutAll: '---- ', aDataItem label, ' ----'; cr.							txtPos <= sz ifTrue: [aStream nextPutAll: (textFS upTo: (Character value: 255)); cr]]].	(aDataItem fpIndicesOfType: LinkPtr) do: 		[:i | self repairTextFor: (dataItems at: i) logOn: aStream]!showSubs	| thisIndex |	self isUserGuide		ifFalse: [thisIndex _ collection at: listIndex.				(displaySubs includes: thisIndex)					ifTrue: [displaySubs remove: thisIndex]					ifFalse: [^0]].	self changed: #showSubs!updateRootCnM	| allModifiers first maxClass | 	maxClass _ Array with: 1.	allModifiers _ Set new.	(dataItems first fpIndicesOfType: LinkPtr) do: [:each |		self classAndModOf: each classTo: maxClass modTo: allModifiers].	allModifiers _ allModifiers asSortedCollection.	DCM modifierLinks do: [:individualSausage |		first _ individualSausage at: 1.		(allModifiers includes: first abs)			ifTrue: [2 to: individualSausage size do: [:i | (individualSausage at: i) < 0 ifTrue: [allModifiers remove: (individualSausage at: i) abs ifAbsent: []]]]].	dataItems first class: maxClass first modifiers: allModifiers! !!OutlineList methodsFor: 'producing'!add: aDataItem atLevel: anInteger initString: aString maxDataItem: maxDataItem	| index s newS hasInitString |  	"generate the structure for this outline"	hasInitString _ aString size > 0.	(maxDataItem contains: aDataItem)		ifFalse: [s _ Text new]		ifTrue: 			[s _ hasInitString					ifTrue: [aString, (String with: $  with: $ ), aDataItem label, (String with: Character cr)]					ifFalse: [aDataItem label, (String with: Character cr)].			s _ Text string: s emphasis: (anInteger = 0 ifTrue: [26] ifFalse: [5]).			aDataItem classAndWords ~= String new				ifTrue: [s _ s, (Text string: (String with: $  with: $(), aDataItem classAndWords, (String with: $)) emphasis: 1)].			index _ 1.			(aDataItem fpIndicesOfType: LinkPtr)				do: [:aPtr | newS _ (self add: (dataItems at: aPtr)									atLevel: 1									initString: (hasInitString ifTrue: [(String with: Character tab) ,aString, index printString, (String with: $.)] ifFalse: [String new]) 									maxDataItem: maxDataItem).							newS isEmpty								ifFalse: [index _ index + 1.										s size + newS size > 64512											ifTrue: [SmalltalkSignal signal: #textTooLong]											ifFalse: [s _ s, newS]]]].	^s!add: aDataItem atLevel: anInteger initString: aString maxDataItem: maxDataItem withNumbers: ok	| index s newS |  	"generate the structure for this outline"	(maxDataItem contains: aDataItem)		ifFalse: [s _ Text new]		ifTrue: 			[s _ ok					ifTrue: [aString, (String with: $  with: $ ), aDataItem label]					ifFalse: [aString, aDataItem label].			s _ Text string: s emphasis: (anInteger = 0 ifTrue: [26] ifFalse: [5]).			aDataItem classAndWords ~= String new				ifTrue: [s _ s, (Text string: (String with: $  with: $(), aDataItem classAndWords, (String with: $)) emphasis: 1)].			s _ s, (Text with: Character cr).			index _ 1.			(aDataItem fpIndicesOfType: LinkPtr)				do: [:aPtr | newS _ (self add: (dataItems at: aPtr)									atLevel: 1									initString: (ok ifTrue: [(String with: Character tab) ,aString, index printString, (String with: $.)]												ifFalse: [(String with: Character tab) ,aString]) 									maxDataItem: maxDataItem									withNumbers: ok).							newS isEmpty								ifFalse: [index _ index + 1.										s size + newS size > 64512											ifTrue: [SmalltalkSignal signal: #textTooLong]											ifFalse: [s _ s, newS]]]].	^s!add: aDataItem atLevel: anInteger withText: aBoolean initString: aString maxDataItem: maxDataItem	| index s newS spacing hasInitString |  	"add text for myself and my subheadings to aString"	hasInitString _ aString size > 0.	(maxDataItem contains: aDataItem)		ifFalse: [s _ Text new]		ifTrue: 			[spacing _ aBoolean ifTrue: [String with: Character cr with: Character cr] ifFalse: [String with: Character cr with: Character tab].			s _ hasInitString					ifTrue: [aString, (String with: $  with: $ ), aDataItem label, spacing]					ifFalse: [aDataItem label, spacing].			s _ Text string: s emphasis: (anInteger = 0 ifTrue: [26] ifFalse: [5]).			(aBoolean and: [(aDataItem fpIndicesOfType: TextPtr) size > 0])				ifTrue: [s _ s, (self textOf: aDataItem), (Text string: (String with: Character space) emphasis: 1)].			aDataItem classAndWords ~= String new				ifTrue: [s _ s, (Text string: (String with: $  with: $(), aDataItem classAndWords, (String with: $)) emphasis: 1)].			s _ s, (Text string: (String with: Character cr with: Character cr) emphasis: 8).			index _ 1.			(aDataItem fpIndicesOfType: LinkPtr)				do: [:aPtr | newS _ (self add: (dataItems at: aPtr)									atLevel: 1									withText: aBoolean									initString: (hasInitString ifTrue: [aString, index printString, (String with: $.)] ifFalse: [String new]) 									maxDataItem: maxDataItem).							newS isEmpty								ifFalse: [index _ index + 1.										s size + newS size > 64512											ifTrue: [SmalltalkSignal signal: #textTooLong]											ifFalse: [s _ s, newS]]]].	^s!add: aDataItem atLevel: anInteger withText: aBoolean initString: aString maxDataItem: maxDataItem textTo: textStream runsTo: runs	| index t spacing hasInitString |  	"add text for myself and my subheadings to aString"	hasInitString _ aString size > 0.	^(maxDataItem contains: aDataItem)		ifFalse: [false]		ifTrue: 			[(anInteger > 0 or: [runs size > 1])				ifTrue: [t _ Text string: (String with: Character cr with: Character cr) emphasis: 1.						textStream nextPutAll: t string.						runs add: t runs].			spacing _ aBoolean						ifTrue: [String with: Character cr with: Character cr]						ifFalse: [String with: Character cr].			t _ hasInitString				ifTrue: [aString, (String with: $  with: $ ), aDataItem label, spacing]				ifFalse: [aDataItem label, spacing].			textStream nextPutAll: t.			runs add: (RunArray new: t size withAll: (anInteger = 0 ifTrue: [26] ifFalse: [5])).			(aBoolean and: [(aDataItem fpIndicesOfType: TextPtr) size > 0])				ifTrue: [t _ (self textOf: aDataItem), (Text string: (String with: Character space) emphasis: 1).						textStream nextPutAll: t string.						runs add: t runs].			aDataItem classAndWords ~= String new				ifTrue: [t _ Text string: (String with: $  with: $(), aDataItem classAndWords, (String with: $)) emphasis: 1.						textStream nextPutAll: t string.						runs add: t runs].			index _ 1.			(aDataItem fpIndicesOfType: LinkPtr)				do: [:aPtr | (self add: (dataItems at: aPtr)								atLevel: 1								withText: aBoolean								initString: (hasInitString ifTrue: [aString, index printString, (String with: $.)] ifFalse: [String new]) 								maxDataItem: maxDataItem								textTo: textStream								runsTo: runs) ifTrue: [index _ index + 1]].			true]!addOnlyText: aDataItem maxDataItem: maxDataItem textTo: textStream runsTo: runs	| t |  	"add text for myself and my subheadings to aString"	(maxDataItem contains: aDataItem)		ifTrue: 			[(aDataItem fpIndicesOfType: TextPtr) size > 0				ifTrue: [t _ (self textOf: aDataItem), (Text string: (String with: Character space) emphasis: 1).						textStream nextPutAll: t string.						runs add: t runs.].			aDataItem classAndWords ~= String new				ifTrue: [t _ Text string: (String with: $  with: $(), aDataItem classAndWords, (String with: $)) emphasis: 1.						textStream nextPutAll: t string.						runs add: t runs].			t == nil				ifFalse: [t _ Text string: (String with: Character cr with: Character cr) emphasis: 1.						textStream nextPutAll: t string.						runs add: t runs].			(aDataItem fpIndicesOfType: LinkPtr)				do: [:aPtr | self addOnlyText: (dataItems at: aPtr)								maxDataItem: maxDataItem								textTo: textStream								runsTo: runs]].!composeDocument: aSuitcase	| text theNewFileName maxDataItem fs clue suitcase |	SmalltalkSignal		do: [(maxDataItem _ self getMaxDataItemForDisplay) == nil ifTrue: [^self].			text _ self produceText: true max: maxDataItem.			suitcase _ Suitcase new packTheSuitcaseFrom: aSuitcase centerName forItem: (DataItem locked: aSuitcase dataItem isLocked classification: maxDataItem classification modifiers: maxDataItem modifiers type: (DataItem typeIndexFor: #Item) label: self thisLabel filename: #Temp asString, UserName bPointers: nil fPointers: nil atIndex: 0).			AnnotationModel openOnText: text suitcaseToUpdate: suitcase]		handle: [clue _ SmalltalkSignal clue.				clue == #textTooLong					ifTrue: [self booboo: '   Text exceeds 63K !!!!   ']					ifFalse: [SmalltalkSignal noHandler].				SmalltalkSignal handleReturn: nil]!composeStructure: aSuitcase	| maxDataItem clue text theNewFileName suitcase fs return | 	(return _ self getStructureQBoxOptions: 'Outline Structure')== nil ifTrue: [^self].	maxDataItem _ return at: 2.	SmalltalkSignal	do: [text _ self produceStructure: return.		suitcase _ Suitcase new packTheSuitcaseFrom: aSuitcase centerName forItem: (DataItem locked: aSuitcase dataItem isLocked classification: maxDataItem classification modifiers: maxDataItem modifiers type: (DataItem typeIndexFor: #Item) label: self thisLabel filename: #Temp asString, UserName bPointers: nil fPointers: nil atIndex: 0).		AnnotationModel openOnText: text suitcaseToUpdate: suitcase]	handle: [clue _ SmalltalkSignal clue.			clue == #textTooLong				ifTrue: [self booboo: '   Text exceeds 63K !!!!   ']				ifFalse: [SmalltalkSignal noHandler].			SmalltalkSignal handleReturn: nil]!makeSimpleTextFile	| answers maxItem newStreamName | 	(answers _ self getQBoxOptions: 'Text Options' printing: false) == nil ifTrue: [^nil].	maxItem _ self isUserGuide		ifTrue: [DataItem type: 4 label: 'ReferenceManual' atIndex: 0]		ifFalse: [(DataItem type: 4 label: 'max' atIndex: 0) changeClassAndModifier: (Array with: (answers at: (answers size - 1)) with: (answers at: answers size))].		Cursor wait showWhile: [		newStreamName _ Disk makeNewFileName: 'TMPVZZZZ' withSuffix: (DataMaster giveMe: #suffixString for: #text asString).		(self produceText: true heading: (answers at: 1) max: maxItem output: newStreamName) = 0			ifTrue: [Disk removeKey: newStreamName ifAbsent: [].					^nil]].	^newStreamName!produceStructure: return	| col index newText textWs maxDataItem |	maxDataItem _ return at: 2.	col _ listIndex = 0			ifTrue: [dataItems first fpIndicesOfType: LinkPtr]			ifFalse: [Array with: (collection at: listIndex)].	Cursor execute showWhile:[ 	textWs _ Text new.	index _ 1.	col do: [:aPtr | newText _ (self add: (dataItems at: aPtr)						atLevel: 0						initString: (return first = #yes ifTrue: [index printString, (String with: $.)] ifFalse: [String new])						maxDataItem: maxDataItem						withNumbers: (return first = #yes)).		newText isEmpty			ifFalse: [index _ index + 1.					textWs _ textWs, newText]]].	^textWs!produceText: aBoolean max: maxDataItem	| col index newText textWs |	col _ listIndex = 0			ifTrue: [dataItems first fpIndicesOfType: LinkPtr]			ifFalse: [Array with: (collection at: listIndex)].	Cursor execute show. 	textWs _ Text new.	index _ 1.	col do: [:aPtr |		newText _ (self add: (dataItems at: aPtr)						atLevel: 0						withText: aBoolean						initString: index printString, (String with: $.)						maxDataItem: maxDataItem).		newText isEmpty			ifFalse: [index _ index + 1.					textWs _ textWs, newText]].	Cursor normal show. 	^textWs! !!OutlineList methodsFor: 'initialize-release'!changeRequest	^(hasChanged not	or: [(self confirm: 'This has not been saved.  Do you want to discard changes?')			ifTrue: [self dependents						do: [:i | i class == OutlineView								ifTrue: [i topView suitcase cancel]]. true]			ifFalse: [false]])!fileName: aString	fileName _ aString.	dataItems == nil ifTrue: [self setup].!release	textFS position: textFileSize; readWriteShorten; close.!resetTextFileSize	textFS == nil		ifTrue: [textFS _ self openOldFile: fileName, (DataMaster giveMe: #specialSuffixString for: #outline asString).				textFS == nil					ifTrue: [textFS _ FileStream fileNamed: fileName, (DataMaster giveMe: #specialSuffixString for: #outline asString)].				textFS readWrite"Shorten".				textFileSize _ textFS size].!setup	| fs nextEntry newRoot label classificationScheme | 	fs _ self class getOldFileName: fileName.	fs == nil ifFalse: [fileName _ fs].	fs _ HeaderFileStream fileNamed: fileName.	label _ fs labelFromHeader.	fs size = 0		ifTrue: [dataItems _ OrderedCollection new.				label == nil ifTrue: [label _ fileName copyUpTo: $.].				newRoot _ DataItem type: 4 label: label atIndex: 0.				dataItems add: newRoot.				newRoot addFPointer: (dataItems size + 1) type: LinkPtr.				nextEntry _ DataItem type: 4 label: 'Empty Outline' atIndex: 0.				nextEntry addBPointer: 1 type: LinkPtr.				dataItems add: nextEntry]		ifFalse: [classificationScheme _ ClassificationScheme new setupFrom: fs.				dataItems _ self readStructureFrom: fs.				self isUserGuide				ifFalse: [classificationScheme id = DCM id ifFalse:							[self booboo:	'This outline is classified according to an old scheme, and will be converted.'.						1 to: dataItems size do:							[:i | dataItems at: i put: ((dataItems at: i) convertFrom: classificationScheme)]].						label == nil ifFalse: [self root label: label]]].	fs close.	self resetTextFileSize! !!OutlineList methodsFor: 'accessing'!collection	^collection!collection: aCollection	collection _ aCollection!displaySubs	^displaySubs!fileName	^fileName!hasChanged	^hasChanged!hasChanged: aBoolean	hasChanged _ aBoolean!itemAt:anIndex	^dataItems at: (collection at: anIndex)!key	^key!key: aString	aString = nil		ifTrue: [key _ nil]		ifFalse: [key _ aString asLowercase]!listIndex	^listIndex!listIndex: anInteger	listIndex _ anInteger.!root	^dataItems first!theCutBuffer: anInteger	theCutBuffer _ anInteger!thisDataItem	^(listIndex = 0 ifFalse: [dataItems at: (collection at: listIndex)] ifTrue: [nil])! !!OutlineList methodsFor: 'hardcopy'!directHardcopyUnder: maxDataItem heading: aSymbol class: classString withSuitcase: aSuitcase	| questionArray theBP newStreamName theAnswers heading | 	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].	(questionArray _ Array new: 5)		at: 1 put: (Array with: String new with: String new);		at: 2 put: #(fill fill);		at: 3 put: #(('Major Heading') ('Minor Heading'));		at: 4 put: (Classification array: (Array with: classString));		at: 5 put: aSuitcase centerName.	(theBP _ BackgroundPrinter askQuestions: questionArray) == nil ifTrue: [^nil].	Cursor wait showWhile: [		newStreamName _ Disk makeNewFileName: 'TMPVXXXX' withSuffix: (DataMaster giveMe: #suffixString for: #text asString).		(self produceText: true heading: aSymbol max: maxDataItem output: newStreamName) = 0			ifTrue: [Disk removeKey: newStreamName ifAbsent: []]			ifFalse: [theAnswers _ theBP applicAnswers.					1 to: 2 do: [:i | (theAnswers at: i) == nil ifFalse: [theAnswers at: i put: (theAnswers at: i) asText]].					heading _ Array with: classString asText with: (theAnswers at: 1) with: (theAnswers at: 2).					theBP queueData: (Array with: newStreamName with: heading) callOnTurn: self class]]!getQBoxOptions: title printing: printIfTrue	| classArray labelArray defaultArray typeArray linkArray | 	labelArray _ OrderedCollection new.	labelArray add: #('Section Heads' numbered name none).	defaultArray _ OrderedCollection new.	linkArray _ OrderedCollection new.	defaultArray add: #name.	(typeArray _ OrderedCollection new) addAll: #(select). 	(printIfTrue and: [Smalltalk includesKey: #PreviewPageView])		ifTrue: [labelArray add: #('Choose either' Direct Preview); add: #('  if preview:' Portrait Landscape ). 				defaultArray add: #Direct; add: #Portrait.				typeArray add: #select; add: #select.				linkArray add: (Array with: 2@2 with: 3@1 with: 3@2)].	^self isUserGuide		ifTrue: [DCM getNewClassification: nil title: title appendLabel: labelArray types: typeArray defaults: defaultArray links: linkArray]		ifFalse: [DCM getNewClassification: (Array with: dataItems first classification with: dataItems first modifiers"DCM abbrevModifiers") title: title appendLabel: labelArray types: typeArray defaults: defaultArray links: linkArray]!getStructureQBoxOptions: title	| classArray labelArray defaultArray typeArray linkArray answer | 	labelArray _ OrderedCollection new.	labelArray add: #('Numbered Section Heads' yes no).	defaultArray _ OrderedCollection new.	linkArray _ OrderedCollection new.	defaultArray add: #yes.	(typeArray _ OrderedCollection new) addAll: #(select).	answer _ self isUserGuide		ifTrue: [DCM getNewClassification: nil title: title appendLabel: labelArray types: typeArray defaults: defaultArray links: linkArray]		ifFalse: [DCM getNewClassification: (Array with: dataItems first classification with: dataItems first modifiers) title: title appendLabel: labelArray types: typeArray defaults: defaultArray links: linkArray].	answer == nil ifTrue:[^nil].	self isUserGuide		ifTrue: [answer at: 2 put: (DataItem type: 4 label: 'min' atIndex: 0)]		ifFalse:			[answer at: 2 put:				(((answer at: 2) = String new)					ifTrue: [(DataItem type: 4 label: 'min' atIndex: 0)]					ifFalse: [((DataItem type: 4 label: 'max' atIndex: 0) changeClassAndModifier: (Array with: (answer at: (answer size - 1)) with: (answer at: answer size)))])].	 ^answer!hardcopyDocument: aSuitcase	| answers maxItem newSuitcase pvFileName | 	(answers _ self getQBoxOptions: 'Print Options' printing: true) == nil ifTrue: [^nil].	maxItem _ self isUserGuide		ifTrue: [aSuitcase dataItem copy]		ifFalse: [aSuitcase dataItem copy changeClassAndModifier: (Array with: (answers at: (answers size - 1)) with: (answers at: answers size))].	(answers size > 1 and: [(answers at: 2) == #Preview])		ifTrue: [maxItem _ (DataItem locked: maxItem isLocked classification: maxItem classification modifiers: maxItem modifiers type: (DataItem typeIndexFor: #Item) label: self thisLabel filename: nil bPointers: nil fPointers: nil atIndex: 0).				pvFileName _ self previewTextUnder: maxItem heading: (answers at: 1) landscape: ((answers at: 3) == #Landscape).				pvFileName == nil					ifFalse: [maxItem filename: pvFileName.							newSuitcase _ Suitcase new packTheSuitcaseFrom: aSuitcase centerName forItem: maxItem.							PreviewPageView openWithSuitcase: newSuitcase]]		ifFalse: [newSuitcase _ Suitcase new packTheSuitcaseFrom: aSuitcase centerName forItem: maxItem.				self directHardcopyUnder: maxItem heading: (answers at: 1) class: maxItem hardcopyString withSuitcase: newSuitcase]!previewTextUnder: maxDataItem heading: aSymbol landscape: aBoolean	| pvFileName | 	pvFileName _ Disk makeNewFileName: #TMPV asString, UserName withSuffix: (DataMaster previewSuffixFor: (aBoolean ifTrue: [#landscape] ifFalse: [#portrait])).	^(self produceText: true heading: aSymbol max: maxDataItem output: pvFileName, (DataMaster giveMe: #specialSuffixString for: #preview asString)) = 0		ifTrue: [Disk removeKey: pvFileName, (DataMaster giveMe: #specialSuffixString for: #preview asString) ifAbsent: []. nil]		ifFalse: [(HeaderFileStream fileNamed: pvFileName) readWrite; writeHeaderFor: maxDataItem; close.				pvFileName]!produceText: aBoolean heading: aSymbol max: maxDataItem output: filename	| col index runsCol sz runs someStream |	someStream _ (HeaderFileStream fileNamed: filename) readWrite.	col _ listIndex = 0			ifTrue: [dataItems first fpIndicesOfType: LinkPtr]			ifFalse: [Array with: (collection at: listIndex)].	Cursor execute show. 	runsCol _ OrderedCollection new.	aSymbol == #numbered		ifTrue: [index _ 1.				col do: [:aPtr |					(self add: (dataItems at: aPtr)						atLevel: 0						withText: aBoolean						initString: index printString, (String with: $.)						maxDataItem: maxDataItem						textTo: someStream						runsTo: runsCol)						ifTrue: [index _ index + 1]]].	aSymbol == #name		ifTrue: [col do: [:aPtr |					self add: (dataItems at: aPtr)						atLevel: 0						withText: aBoolean						initString: String new						maxDataItem: maxDataItem						textTo: someStream						runsTo: runsCol]].	aSymbol == #none		ifTrue: [col do: [:aPtr |					self addOnlyText: (dataItems at: aPtr)						maxDataItem: maxDataItem						textTo: someStream						runsTo: runsCol]].	sz _ someStream size.	sz > 0		ifTrue: [someStream nextPut: (Character value: 255); cr.				runs _ RunArray new.				runsCol do: [:aRun | runs _ runs, aRun].				runs storeOn: someStream]		ifFalse: [self booboo: 'Text empty - no action taken!!'].	someStream close.	Cursor normal show. 	^sz! !!OutlineList methodsFor: 'utilities'!addTextPtr: aTextPtr to: aDataItem	| maxOne newPtr |  	newPtr _ aTextPtr.	maxOne _ (1 bitShift: 16) - 1.	aDataItem addFPointer: (newPtr bitAnd: maxOne) type: TextPtr.	[newPtr > maxOne]		whileTrue: [aDataItem addFirstFPointer: (newPtr _ newPtr bitShift: -16) ofType: TextPtr].!does: aString contains: anotherString	| aCharacter index |	anotherString isEmpty ifTrue: [^false].	aCharacter _ anotherString first.	1 to: aString size - anotherString size + 1 do:		[:startIndex |		(aString at: startIndex) asLowercase == aCharacter ifTrue:			[index _ 1.			[(aString at: startIndex+index-1) asLowercase == (anotherString at: index)] whileTrue:				[index = anotherString size ifTrue: [^true].				index _ index+1]]]. 	^false!getMaxDataItemForDisplay	"put up a Control box to ask what level to print at"	| answer |	answer _ self isUserGuide				ifTrue: [^DataItem type: 4 label: 'min' atIndex: 0]				ifFalse: [DCM getNewClassification: (Array with: dataItems first classification with: dataItems first modifiers) title: 'Maximum Classification Level to Print?'].	answer == nil ifFalse: [^(DataItem type: 4 label: 'max' atIndex: 0) changeClassAndModifier: answer].	^nil!isUserGuide	^fileName = OutlineView userGuideName!readStructureFrom: aStream	"get the current data structure."	| count aCollection | 	count _ Integer readFrom: aStream.	aStream skip: 1.	aCollection _ OrderedCollection new: count.	count timesRepeat: [aCollection add: (DataItem readMeFrom: aStream)].	^aCollection!treeList	| recordList newCol showTopsOnly | 	newCol _ OrderedCollection new.	recordList _ OrderedCollection new.	showTopsOnly _ self showTopsOnly.	(displaySubs == nil or: [showTopsOnly not]) ifTrue: [displaySubs _ OrderedCollection new]."	MessageTally spyOn: 	["(dataItems first fpIndicesOfType: LinkPtr) do: [:start |		(showTopsOnly		and: [(displaySubs includes: start) not			and: [((dataItems at: start) fpIndicesOfType: LinkPtr) size > 0]]) ifTrue: [displaySubs add: start].		self treeListStartAt: start			addTo: recordList			recCol: newCol			initString: (String new: 4 withAll: $ )			showHides: false]."] to: 'treeList'."	collection _ newCol.	^recordList!treeListStartAt: start addTo: recordList recCol: aCol initString: initString showHides: aBoolean	"fPointers: 0 - next, 1 - under, 2 - text. bPointers: 0 - previous, 1 - above ???"	| aDataItem fPointers s class hideSub isUG | 	aDataItem _ dataItems at: start.	s _ initString,		((aDataItem fpIndicesOfType: TextPtr) isEmpty ifTrue: [String with: $:] ifFalse: [String with: $ ]),		aDataItem label.	class _ aDataItem classAndWords.	(class == nil or: [class isEmpty])		ifFalse: [s _ s, (String with: ${), class, (String with: $})].	(hideSub _ displaySubs includes: start)		ifTrue: [aBoolean ifTrue: [displaySubs remove: start. hideSub _ false] ifFalse: [s at: 1 put: $-]].	aCol add: start.	recordList add: s.	hideSub		ifFalse: [(fPointers _ aDataItem fpIndicesOfType: LinkPtr)				do: [:startPtr | self treeListStartAt: startPtr								addTo: recordList								recCol: aCol								initString: initString, (String new: 5 withAll: $ )								showHides: aBoolean]]! !!OutlineList methodsFor: 'UG specials'!nextReferenceFrom: startIndex	| index found size | 	index _ startIndex.	found _ false.	size _ collection size.	[index >= size or: [found]]		whileFalse: [index _ index + 1.					found _ self does: (dataItems at: (collection at: index)) label contains: key].	^found		ifTrue: [self toggleListIndex: index.				index]		ifFalse: [0]!reset	collection _ OrderedCollection new.	displaySubs _ OrderedCollection new.	theCutBuffer _ 0.	listIndex _ 0.	key _ nil.	self changed: (Array with: #list: with: (Array with: self treeList)).	hasChanged _ false!showTopSubs	| thisIndex needToShow |	thisIndex _ collection at: listIndex.	(displaySubs includes: thisIndex)		ifTrue: [displaySubs remove: thisIndex.				needToShow _ true]		ifFalse: [needToShow _ false.				((dataItems at: thisIndex) fpIndicesOfType: LinkPtr)				do: [:ptr | (displaySubs includes: ptr)							ifFalse: [((dataItems at: ptr) fpIndicesOfType: LinkPtr) size > 0 ifTrue: [needToShow _ true]]]].	^needToShow ifTrue: [self changed: #showTopSubs] ifFalse: [0]!treeTopListStartAt: start addTo: recordList recCol: aCol initString: initString	"fPointers: 0 - next, 1 - under, 2 - text. bPointers: 0 - previous, 1 - above ???"	| aDataItem fPointers s class hideSub isUG | 	aDataItem _ dataItems at: start.	s _ initString,		((aDataItem fpIndicesOfType: TextPtr) isEmpty ifTrue: [String with: $:] ifFalse: [String with: $ ]),		aDataItem label.	class _ aDataItem classAndWords.	(class == nil or: [class isEmpty])		ifFalse: [s _ s, (String with: ${), class, (String with: $})].	isUG _ self isUserGuide.	(hideSub _ displaySubs includes: start) ifTrue: [s at: 1 put: $-].	aCol add: start.	recordList add: s.	hideSub		ifFalse: [(fPointers _ aDataItem fpIndicesOfType: LinkPtr)				do: [:startPtr | (isUG								and: [(displaySubs includes: startPtr) not									and: [((dataItems at: startPtr) fpIndicesOfType: LinkPtr) size > 0]]) ifTrue: [displaySubs add: startPtr].								self treeTopListStartAt: startPtr								addTo: recordList								recCol: aCol								initString: initString, (String new: 5 withAll: $ )]]! !!OutlineList methodsFor: 'current item'!currentText	^listIndex > 0		ifTrue: [self textOf: (dataItems at: (collection at: listIndex))]		ifFalse: [Text new]!fullNameOf: anItem	| fullName class | 	fullName _ anItem label.	class _ anItem classAndWords.	(class == nil or: [class isEmpty]) ifFalse: [fullName _ fullName, (String with: ${), class, (String with: $})].	^fullName!thisClassDefaults	^listIndex = 0		ifTrue: [Array with: dataItems first classification with: DCM abbrevModifiers]		ifFalse: [(dataItems at: (collection at: listIndex)) qboxArray]!thisLabel	^listIndex = 0		ifTrue: [(dataItems at: 1) label]		ifFalse: [(dataItems at: (collection at: listIndex)) label]! !!OutlineList methodsFor: 'text related'!textContentsOf: aDataItem	"Ideally, text at textPosition can be the actual text or a pointer. If the pointer points to an image file then an image editor would be in place rather than a text editor. At each textPosition, the first letter indicates type of the following info. T - text follows, I - image file and F - text pointer."	| cont type theContents theIndex txtPos | 	^(aDataItem fpIndicesOfType: TextPtr) size > 0		ifTrue: [textFS position: (txtPos _ self textPtrOf: aDataItem).				type _ textFS next.				cont _ Integer readFrom: textFS.				type = $T				ifTrue: [textFS next.						theContents _ textFS next: cont.						theIndex _ theContents indexOf: (Character value: 255).						theContents _ theContents copyFrom: 1 to: theIndex - 1.						textFS setToEnd. theContents] ifFalse: [self halt]]		ifFalse: [String new]!textOf: aDataItem	"Ideally, text at textPosition can be the actual text or a pointer. If the pointer points to an image file then an image editor would be in place rather than a text editor. At each textPosition, the first letter indicates type of the following info. T - text follows, I - image file and F - text pointer."	| cont type theContents theIndex theText txtPos clue runs | 	SmalltalkSignal do: 	[^(aDataItem fpIndicesOfType: TextPtr) size > 0		ifTrue: [textFS position: (txtPos _ self textPtrOf: aDataItem).				type _ textFS next.				cont _ Integer readFrom: textFS.				type = $T				ifTrue: [textFS next.						theContents _ textFS next: cont.						theIndex _ theContents indexOf: (Character value: 255).						runs _ (theContents last = $) and: [(theContents at: (theContents size - 1)) = $)])							ifTrue: [Compiler evaluate: (theContents copyFrom: theIndex + 1 to: theContents size)]							ifFalse: [SmalltalkSignal signal: #runError].						theText _ Text string: (theContents copyFrom: 1 to: theIndex - 1)									runs: runs.						textFS setToEnd. theText]				ifFalse: [SmalltalkSignal signal: #outSync]]		ifFalse: [Text new]]	handle: [clue _ SmalltalkSignal clue.			(self confirm: 'Something''s wrong with the text file.Do you want me to repair it ?')				ifTrue: [clue == #runError							ifTrue: [runs _ RunArray new: theIndex - 1 withAll: 1.									SmalltalkSignal signalReturn: runs]							ifFalse: [SmalltalkSignal handleReturnDoing: [^self repairText". ^Text new"]]]				ifFalse: [SmalltalkSignal handleReturnDoing: [^Text new]]]!textPtrOf: aDataItem	| textPtrs index thePtr | 	textPtrs _ aDataItem fpIndicesOfType: TextPtr.	index _ 0.	thePtr _ 0.	textPtrs reverseDo: [:aPtr |		thePtr _ thePtr + (aPtr bitShift: 16* index).		index _ index + 1].	^thePtr!updateText: aText	| ws theItem maxOne | 	ws _ WriteStream on: String new.	ws nextPutAll: aText string.	ws nextPut: (Character value: 255).	aText runs storeOn: ws.	theItem _ dataItems at: (collection at: listIndex).	(theItem fpIndicesOfType: TextPtr) do: [:txtPtr | theItem removeFPointer: txtPtr type: TextPtr]. 	self addTextPtr: textFS size to: theItem.	textFS setToEnd.	textFS nextPut: $T.	textFS nextPutAll: ws size printString.	textFS nextPut: Character space.	textFS nextPutAll: ws contents.	textFS flush.	hasChanged _ true.	self changed: #hasText! !!OutlineList methodsFor: 'updating'!accept	| fs | 	"Text file needs to be updated as well"	fs _ (HeaderFileStream fileNamed: 'CMPRSXXX.OL') writeShorten.	fs writeHeaderFor: self root.	DCM writeClassification: fs.	fs nextPutAll: dataItems size printString.	fs nextPut: $ .	dataItems do: [:aDataItem | aDataItem storeOn: fs].	fs close.	Disk removeKey: fileName.	Disk renameKey: fs name newName: fileName.	textFS flush.	textFileSize _ textFS size.	hasChanged _ false.	Auditor add: 'Outline ', dataItems first label, ' saved'!cancel	Auditor add: 'Outline ', dataItems first label, ' restored'.	^hasChanged		ifTrue: [self setup.				self reset]		ifFalse: [0]!compress	| newDataItems prevIndex thisIndex newRoot tempTextFS fs oldRoot | 	tempTextFS _ (FileStream fileNamed: 'CMPRSXXX.OLT') writeShorten.	newDataItems _ OrderedCollection new.	oldRoot _ dataItems first.	newRoot _ DataItem locked: oldRoot isLocked					classification: oldRoot classification					modifiers: oldRoot modifiers					type: oldRoot type					label: oldRoot label					filename: oldRoot filename					bPointers: nil					fPointers: nil					atIndex: 0.	newDataItems add: newRoot.	prevIndex _ newDataItems size.	(oldRoot fpIndicesOfType: LinkPtr) do: [:aPtr |		thisIndex _ newDataItems size + 1.		self copyDataItem: dataItems at: aPtr to: newDataItems under: prevIndex textFrom: textFS to: tempTextFS.		newRoot addFPointer: thisIndex type: LinkPtr].	tempTextFS close.	fs _ (HeaderFileStream fileNamed: 'CMPRSXXX.OL') writeShorten.	fs writeHeaderFor: newRoot. 	DCM writeClassification: fs.	fs nextPutAll: newDataItems size printString.	fs nextPut: $ .	newDataItems do: [:aDataItem | aDataItem storeOn: fs].	fs close.	Disk removeKey: fileName.	Disk renameKey: fs name newName: fileName.	textFS close.	Disk removeKey: fileName, (DataMaster giveMe: #specialSuffixString for: #outline asString).	Disk renameKey: tempTextFS name newName: fileName, (DataMaster giveMe: #specialSuffixString for: #outline asString).	textFS _ nil.	Auditor add: 'Outline ', dataItems first label, ' compressed'.	self setup; resetLists!resetLists	collection _ OrderedCollection new.	2 to: dataItems size do: [:i | collection add: i].	displaySubs _ OrderedCollection new.	theCutBuffer _ 0.	listIndex _ 0."	self changed: (Array with: #list: with: (Array with: self treeList))."	hasChanged _ false!selectKey	(self showTopsOnly or: [displaySubs isEmpty])		ifTrue: [(key ~~ nil and: [listIndex = 0 or: [((dataItems at: (collection at: listIndex)) label includes: key) not]])					ifTrue: [self changed: #selectKey]]		ifFalse: [self changed: (Array with: #setupList: with: (Array with: self treeList))]!showTopsOnly	^self isUserGuide and: [key == nil]!toggleListIndex: anInteger	listIndex _ anInteger.	self changed: (Array with: #listIndex: with: (Array with: listIndex)).! !!OutlineList methodsFor: 'copying'!copyDataItem: aDataItemCollection at: start to: dataItemCollection under: bPtr textFrom: originTextFS to: aTextFS	"To paste a copy, all dataItems involved need to be duplicated. To paste an original, no need to duplicate dataItems."	| newDataItem thisIndex nextIndex aDataItem | 	aDataItem _ aDataItemCollection at: start.	newDataItem _ DataItem locked: aDataItem isLocked						classification: aDataItem classification						modifiers: aDataItem modifiers						type: aDataItem type						label: aDataItem label						filename: aDataItem filename						bPointers: (Array with: (DataItemPointer type: LinkPtr index: bPtr))						fPointers: nil						atIndex: 0.	dataItemCollection add: newDataItem.	thisIndex _ dataItemCollection size.	(aDataItem fpIndicesOfType: LinkPtr) do: [:ptr |		nextIndex _ dataItemCollection size + 1.		self copyDataItem: aDataItemCollection at: ptr to: dataItemCollection under: thisIndex textFrom: originTextFS to: aTextFS.		newDataItem addFPointer: nextIndex type: LinkPtr].	(aDataItem fpIndicesOfType: TextPtr) size > 0		ifTrue: [ptr _ self textPtrOf: aDataItem.			 	self addTextPtr: aTextFS size to: newDataItem.				aTextFS setToEnd.				self copyTextFrom: ptr of: originTextFS to: aTextFS]!copyDataItem: aDataItem under: bPtr	"To paste a copy, all dataItems involved need to be duplicated. To paste an original, no need to duplicate dataItems."	| newDataItem thisIndex nextIndex | 	newDataItem _ DataItem locked: aDataItem isLocked						classification: aDataItem classification						modifiers: aDataItem modifiers						type: aDataItem type						label: aDataItem label						filename: aDataItem filename						bPointers: (Array with: (DataItemPointer type: LinkPtr index: bPtr))						fPointers: nil						atIndex: 0.	dataItems add: newDataItem.	thisIndex _ dataItems size.	(aDataItem fpIndicesOfType: LinkPtr) do: [:ptr |		nextIndex _ dataItems size + 1.		self copyDataItem: (dataItems at: ptr) under: thisIndex.		newDataItem addFPointer: nextIndex type: LinkPtr].	(aDataItem fpIndicesOfType: TextPtr) do: [:ptr | newDataItem addFPointer: ptr type: TextPtr]!copyTextFrom: start of: originTextFS to: aTextFS	| ws count | 	originTextFS position: start.	aTextFS nextPut: originTextFS next.	count _ Integer readFrom: originTextFS.	aTextFS nextPutAll: count printString.	aTextFS nextPutAll: (originTextFS next: (count + 1)).	originTextFS setToEnd."	ws _ WriteStream on: String new.	ws nextPut: originTextFS next.	count _ Integer readFrom: originTextFS.	ws nextPutAll: count printString.	ws nextPutAll: (originTextFS next: (count + 1)).	originTextFS setToEnd.	aTextFS nextPutAll: ws contents."! !!Inspector methodsFor: 'text'!textMenu	"Inspector flushMenus"	TextMenu == nil ifTrue:		[TextMenu _ ActionMenu			labels: 'again\undo\copy\cut\paste\do it\print itaccept{Accept and store the new value of the variable.}cancel' withCRs			lines: #(2 5 7)			selectors: #(again undo copySelection cut paste doIt printIt accept cancel)].	^ TextMenu! !!DictionaryInspector methodsFor: 'field list'!fieldMenu	"DictionaryInspector flushMenus" 	field == nil ifTrue:		[^ActionMenu labels: 'add field' withCRs			selectors: #(addField)].	DictListMenu == nil ifTrue:		[DictListMenu _ ActionMenu			labels:'inspect{Inspect the selected field.}references{Browse references to this key (if it is a pool-variable).}add fieldremove{Remove the selected field.}'			lines: #(2)			selectors: #(inspectField browseReferences						addField removeField)].	^DictListMenu! !Suitcase comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Suitcase methodsFor: 'initialize/release'!checkClassification	"see if this classification has been accepted"	| fs |	(accepted = working or: [dataItem numberOfBPointers = 0]) ifFalse: 			[(self confirm: 'Change classification from ', accepted classAndWords, 'to ' , working classAndWords) ifTrue:				[self accept.				(DataMaster headerOKon: dataItem filename) ifTrue:					[(fs _ HeaderFileStream fileNamed: dataItem filename) readWrite.					fs writeHeaderFor: dataItem.					fs close]]]!packTheSuitcaseFrom: aCenterName forItem: theItem	| setUp | 	centerName _ aCenterName.	dataItem  _ theItem.	setUp _ theItem modifiers asOrderedCollection.	setUp addFirst: theItem classification.	accepted _ Classification array: setUp.	working _ accepted deepCopy!release	"tell the information center about changes in classification to this data item"	centerName ==nil ifTrue: [^nil].	self checkClassification!updateFromHeaderIn: headerFileStream	headerFileStream hasHeader ifTrue:		[self classification: headerFileStream classFromHeader.		self dataItem label: headerFileStream labelFromHeader.		self accept.		^true].	^false! !!Suitcase methodsFor: 'access'!accept	"saves the working classification as the accepted classification and tells the information center about the newly accepted classification"	accepted _ working.	(accepted classAndWords = dataItem classAndWords)		ifFalse:			[dataItem class: accepted classification modifiers: accepted modifiers.			centerName == nil ifFalse: [self center updateClassFor: dataItem]]!addKeyWord: newWord	"add the newWord to the list of keywords for this item"	| keywordsNow theCenter |	(theCenter _ self center) == nil ifTrue: [^self booboo: 'Cannot make keyword because this item is not filed'].	keywordsNow _ theCenter  keywordsFor: dataItem.	keywordsNow add: newWord asString stripLeadingAndTrailingSpaces asLowercase.	theCenter setKeywordsForItemAt: dataItem centerIndex to: keywordsNow!cancel	"resets the working classification from the accepted classification"	working _ accepted.	^accepted!center	^(InformationCenter centerFor: centerName)!centerName	^centerName!changeClassification: theNewClassification	| setUp | 	"set workingClass to the new classification"	(theNewClassification isKindOf: Classification)		ifFalse: [setUp _ (theNewClassification at: 2) asOrderedCollection.			setUp addFirst:  (theNewClassification at: 1).			working _ Classification array: setUp]		ifTrue: [working _ theNewClassification]!classification	^working!classification: newClassification	working _ newClassification!dataItem	^dataItem!fcUser	^centerName!searchString 	^searchString!searchString: theString	searchString _ theString!spare	^spare!spare: whatEver	spare _ whatEver! !!Browser methodsFor: 'category list'!categoryMenu	"Browser flushMenus"	category == nil ifTrue:		[^ ActionMenu labels:'add category{Create a new system category.}update{Update list to include new categories.}edit all{Display all categories and their classes.}'					lines: #(1)					selectors: #(addCategory updateCategories editCategories )].	CategoryMenu == nil ifTrue:		[CategoryMenu _ ActionMenu			labels:'file out{File out the selected category.}print out{Print out the selected category.}spawn{Open a browser on the classes in this category.}add category{Add a new category above the selected one.}renameremoveupdate{Update list to include new categories.}edit all{Display all categories and their classes.}'			lines: #(3 6)			selectors: #(fileOutCategory printOutCategory spawnCategory addCategory renameCategory removeCategory updateCategories editCategories)].	^ CategoryMenu! !!Browser methodsFor: 'class list'!classMenu	"Browser flushMenus"	className == nil ifTrue: [^nil].	ClassMenu == nil ifTrue:		[ClassMenu _ ActionMenu			labels:'file out{File out selected class.}print out{Print out selected class.}spawn{Open a class browser on selected class.}spawn hierarchy{Open a browser on the selected class, its superclasses and subclasses.}hierarchy{Show the selected class''s class hierarchy.}definition{Show the selected class''s definition.}comment{Show the selected class''s comment.}protocols{Show all messages understood by the selected class, and their categories.}inst var refs{Open a message-set browser on methods referring to a given instance variable of the selected class.}class var refs{Open a message-set browser on methods referring to a given class variable of the selected class.}class refs{Open a message-set browser on methods referring to the selected class.}renameremove'			lines: #(4 8 11)			selectors: #(fileOutClass printOutClass spawnClass spawnHierarchy  showHierarchy editClass editComment editProtocolsbrowseFieldReferences browseClassVariables browseClassReferences renameClass removeClass)].	^ ClassMenu! !!Browser methodsFor: 'protocol list'!protocolMenu	"Browser flushMenus"	protocol == nil ifTrue:		[^ ActionMenu labels:'add protocol{Add a new message category.}'		selectors: #(addProtocol)].	ProtocolMenu == nil ifTrue:		[ProtocolMenu _ ActionMenu			labels:'file out{File out messages in this category.}print out{Print out messages in this category.}spawn{Open a message-set browser on messages in this category.}add protocol{Add a new message category above the selected one.}renameremove'			lines: #(3)			selectors: #(fileOutProtocol printOutProtocol spawnProtocol addProtocol renameProtocol removeProtocol)].	^ ProtocolMenu! !!Browser methodsFor: 'selector list'!selectorMenu	"Browser flushMenus"	selector == nil ifTrue: [^ nil].	MessageMenu == nil ifTrue:		[MessageMenu _ ActionMenu			labels:'file out{File out this method.}print out{Print out this method.}spawn{Open a browser on this method only.}senders{Open a message-set browser on all senders of this message.}implementors{Open a message-set browser on all methods which implement this message.}messages{Open a brower on all methods implementing some message called in this method.}moveremove'			lines: #(3 6)			selectors: #(fileOutMessage printOutMessage spawnMethod browseSenders browseImplementors browseMessages moveMethod removeMethod)].	^ MessageMenu! !!Browser methodsFor: 'text'!textMenu	"Browser flushMenus"	TextMenu == nil ifTrue:		[TextMenu _ ActionMenu			labels:'again\undo\copy\cut\paste\do it\print itaccept{Accept and compile this method.}cancelformat{Pretty-printthis method.\(Accept it first)}spawn{Open a browser on the changed version of this method.}explain{Try to explain what the currently selected text means.}'withCRs			lines: #(2 5 7 9)			selectors: #(again undo copySelection cut paste doIt printIt accept cancel format spawnEdits:from: explain)].	^ TextMenu! !!Debugger methodsFor: 'context list'!contextMenu	"Debugger flushMenus"	context == nil ifTrue:		[^ ActionMenu labels:'full stack{Show the full execution stack.}proceed{Continue with execution.}'		selectors: #(fullStack proceed)].	ContextMenu == nil ifTrue:		[ContextMenu _ ActionMenu			labels:'full stack{Show the full execution stack.}proceed{Continue with execution.}restart{Restart from the beginning of the selected method.}senders{Browse all senders of the selected message.}implementors{Browse all implementors of the selected message.}messages{Browse  all implementors of some message sent in the selected method.}step{Evaluate the next message to be sent in the selected method.}send{Enter the next message at the top of the execution stack.}'			lines: #(3 6)			selectors: #(fullStack proceed restart browseSenders browseImplementors browseMessages step send)].	^ ContextMenu! !!FileModel methodsFor: 'text'!textMenu 	"FileModel flushMenus"	fileName == nil ifTrue: [^ nil].	TextMenu == nil ifTrue:		[TextMenu _ ActionMenu			labels:'again\undo\copy\cut\paste\do it\print itfile it in{File in the contents of the file.}put{Save the contents of the window to the file.}get{Read the contents of the file into the window.}'withCRs			lines: #(2 5 8 10)			selectors: #(again undo copySelection cut paste doIt printIt fileItIn:from: accept getNew:from:)].	^ TextMenu! !!FileModel methodsFor: 'accessing'!put: aString 	"Update the contents of the file stream with the receiver's contents.  If the file name does not include an explicit version number, create a new version."	"((fileName includes: $!!)		ifTrue: [FileStream fileNamed: fileName]		ifFalse: [FileStream newFileNamed: fileName]) nextPutAll: aString; close."	(FileStream fileNamed: fileName) nextPutAll: aString; close.	^true! !!FileList methodsFor: 'pattern'!acceptPattern: aText from: aController	"The text consists of file names and file name patterns separated by carriage returns.	Patterns can include the characters * (any chars) and # (any single char).	Make my new list be those file names on my directory which match the patterns."	| testPattern readStream newList |	Cursor execute showWhile:		[myPattern _ aText string.		readStream _ ReadStream on: myPattern.		newList _ SortedCollection new.		[readStream atEnd] whileFalse:			[testPattern _ readStream upTo: Character cr. "get next name/pattern"			testPattern last = $.				ifTrue: [testPattern _ testPattern copyFrom: 1 to: testPattern size-1].			(testPattern includes: $*) | (testPattern includes: $#)				ifTrue: [(self filesMatching: testPattern)							do: [:s | (newList includes: s) ifFalse: [newList add: s]].						"newList addAll: (self filesMatching: testPattern)"]				ifFalse: [(self isLegalFileName: testPattern)							ifTrue: [newList add: testPattern]]].		list _ newList.		list isEmpty			ifTrue: [aController deselect; replaceSelectionWith: 'No matching files' asText; select].		self changed: #fileName].	^true!patternMenu 	"FileList flushMenus"	PatternMenu == nil ifTrue:		[PatternMenu _ ActionMenu			labels: 'again\undo\copy\cut\pasteaccept{Accept the pattern, and display matching files.}cancel' withCRs			lines: #(2 5)			selectors: #(again undo copySelection cut paste accept cancel)].	^ PatternMenu! !!FileList methodsFor: 'file name list'!fileListMenu 	fileName == nil ifTrue: [^nil].	FileMenu == nil ifTrue:		[FileMenu _			ActionMenu				labels:'get contents{Display the file''s contents in the bottom subview.}file in{File in the contents of the file.}copy name{Copy the file-name into the copy buffer, for later pasting.}rename{Rename the file.}remove{Remove the file.}'				lines: #(2 4)				selectors: #(getFile fileInFile copyName renameFile deleteFile)].	^ FileMenu	"Evaluate this when you change this method:		FileList flushMenus"! !Stats comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Stats methodsFor: 'access'!collection: aCollection	collection _ aCollection!mean	"find the mean of the elements of a matrix"	| sum |	sum _ 0.	collection do: [:each | sum _ sum + each].	^sum / collection size!median	"find the median of the elements of a matrix"	| arrayOfScores median spot |	arrayOfScores _ SortedCollection new.	collection do: [:each |			arrayOfScores add: each].	arrayOfScores size even 		ifTrue:[spot _ arrayOfScores size // 2.			^(arrayOfScores at: spot) + (arrayOfScores at: spot + 1) / 2]		ifFalse:[^(arrayOfScores at: arrayOfScores size // 2 + 1)].!mode	"find the mode of the elements of a matrix"	| dictOfScores mode topKeySize topKey |	dictOfScores _ OopConservingDictionary new.	collection do: [:each | 			dictOfScores at: each				put: (dictOfScores at: each ifAbsent: [0]) + 1].	topKeySize _ 0.	dictOfScores keys do: [:eachKey | (dictOfScores at: eachKey)			> topKeySize			ifTrue: 				[topKeySize _ dictOfScores at: eachKey].	mode _ OrderedCollection new.	dictOfScores keys do: [:eachKey |(dictOfScores at: eachKey)					= topKeySize ifTrue: [mode add: eachKey]]].	mode size = 1 ifTrue:[^mode at: 1].	^mode!range	"find the range of the elements of a matrix"	| min max |	min _ max _ collection first.	collection do: [:each |			each < min ifTrue:[min _ each].			each > max ifTrue:[max _ each]].	^max - min!standardDeviation	"find the standardDeviation of the elements of a matrix"	| sum standardDeviation thisMean |	sum _ 0.	thisMean _ self mean.	collection do: [:each | sum _ sum + (each - thisMean raisedTo: 2)].	standardDeviation _ (sum / collection size) sqrt.	^standardDeviation!sum	"find the sum of the elements of a matrix"	| sum |	sum _ 0.	collection do: [:each | sum _ sum + each].	^sum! !SpreadsheetRule comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!SpreadsheetRule methodsFor: 'initialize-release'!initialize	"Set em up, boys"	string _ ''.	code _ nil.	references _ nil!release	self nilFields.	super release! !!SpreadsheetRule methodsFor: 'accessing'!code	code == nil ifFalse: [^code].	code _ self codeFromString.	^code!code: aBlockContext	code _ aBlockContext!references	^references!references: aSet	references _ aSet!string	^string!string: aString	string _ aString! !!SpreadsheetRule methodsFor: 'rule compilation'!codeNotifying: aController	code == nil ifFalse: [^code].	code _ self codeFromStringNotifying: aController.	^code!compileCodeFrom: aString with: frameArray	"Create a BlockContext as my code, and compile aString for the Block's method.  This routine is used to read the special filed out form of rules in the spreadsheet file."	| readStream block home method frame |	aString = '' ifTrue: [^nil].	readStream _ ReadStream on: aString from: 1 to: aString size.	method _		CompiledMethod			newMethod: (readStream upTo: $\) asNumber			header: ((readStream upTo: $\) asNumber).	1 to: method numLiterals do: [:thisLiteral |		method literalAt: thisLiteral put: (frameArray at: (readStream upTo: $/) asNumber)].	method initialPC to: method size do: [:byte |		method at: byte put: (readStream upTo: Character space) asNumber].	home _		MethodContext			sender: nil			receiver: nil			method: method			arguments: (Array with: nil with: nil with: nil).	block _		(BlockContext new: method frameSize)			home: home			startpc: method initialPC +5			nargs: 3.	code _ block!referencesForCellAt: cellPoint in: aHolder 	| refStream refSet refPoint refPoint2 cipher xRef yRef x2Ref y2Ref |	refSet _ OrderedCollection new.	references do: [:ref | (ref at: 1) class == String			ifTrue: [refSet add: ref]			ifFalse: 				[refPoint _ Point new.				cipher _ ref at: 1.				xRef _ ref at: 2.				yRef _ ref at: 3.				ref size = 5					ifTrue: 						[refPoint2 _ Point new.						x2Ref _ ref at: 4.						y2Ref _ ref at: 5.						(cipher at: 1)							= $r							ifTrue: [refPoint x: cellPoint x + xRef]							ifFalse: [refPoint x: xRef].						(cipher at: 2)							= $r							ifTrue: [refPoint2 x: cellPoint x + x2Ref]							ifFalse: [refPoint2 x: x2Ref].						(cipher at: 3)							= $r							ifTrue: [refPoint y: cellPoint y + yRef]							ifFalse: [refPoint y: yRef].						(cipher at: 4)							= $r							ifTrue: [refPoint2 y: cellPoint y + y2Ref]							ifFalse: [refPoint2 y: y2Ref].						refPoint x to: refPoint2 x do: [:i | refPoint y to: refPoint2 y do: [:j |  i @ j = cellPoint ifFalse:[refSet add: i @ j]]]]					ifFalse: 						[(cipher at: 1)							= $r							ifTrue: [refPoint x: cellPoint x + xRef]							ifFalse: [refPoint x: xRef].						(cipher at: 2)							= $r							ifTrue: [refPoint y: cellPoint y + yRef]							ifFalse: [refPoint y: yRef].						refPoint = cellPoint ifFalse:[refSet add: refPoint]]]].	^refSet! !!SpreadsheetRule methodsFor: 'private'!addressX: xString Y: yString	"parse and answer the address of the strings and log in references collection"	| address firstChar refSymbol thisRef |	address _ Point new.	thisRef _ Array new: 3.	firstChar _ xString first.	(firstChar = $0) | (firstChar = $+) | (firstChar = $-)		ifTrue: [firstChar = $0					ifTrue: [address x: 'xcell']					ifFalse: [address x: 'xcell', xString].				refSymbol _ 'r']		ifFalse: [address x: xString.				refSymbol _ 'a'].	firstChar _ yString first.	(firstChar = $0) | (firstChar = $+) | (firstChar = $-)		ifTrue: [firstChar = $0					ifTrue: [address y: 'ycell']					ifFalse: [address y: 'ycell', yString].				refSymbol _ refSymbol,'r']		ifFalse: [address y: yString.				refSymbol _ refSymbol,'a'].	thisRef at: 1 put: refSymbol asSymbol.	thisRef at: 2 put: (xString first = $+ 						ifTrue: [xString copyFrom: 2 to: xString size]						ifFalse: [xString]) asNumber.	thisRef at: 3 put: (yString first = $+ 						ifTrue: [yString copyFrom: 2 to: yString size]						ifFalse: [yString]) asNumber.	references add: thisRef.	^address!codeFromString	"This method takes a character string and prodces a piece of Smalltalk code 	suitable for evaluation as a block."	| acceptSignal realRule charactersSoFar refIndex refEnd rowStart rowEnd colStart colEnd reference address yCell xCell colonIndex |	references _ OrderedCollection new.	acceptSignal _ CellStringHolderController AcceptSignal.	"to signal when known that rule is bad"	string = '' ifTrue: [^nil].	realRule _ '[:model :xcell :ycell | '.	charactersSoFar _ 1.	(string findString: '{' startingAt: charactersSoFar)		= 0		ifTrue: 			[self booboo: 'Rule must have reference(s) to other cell(s).'.			acceptSignal signal].	"find all {r,c} references"	[(refIndex _ string findString: '{' startingAt: charactersSoFar) ~= 0]		whileTrue: 			[realRule _ realRule , (string copyFrom: charactersSoFar to: refIndex - 1).			"obtain the contents of the {r,c} reference"			refEnd _ string findString: '}' startingAt: refIndex.			reference _ (string copyFrom: refIndex + 1 to: refEnd - 1) asUppercase.			charactersSoFar _ refEnd + 1.			"now, look for each part of the reference"			(reference indexOf: $;)				= 0				ifTrue: 					[colonIndex _ reference indexOf: $:.					colonIndex = 0						ifTrue: [address _ self producePointFrom: reference signalling: acceptSignal]						ifFalse: [address _ self										produceRectFrom: (reference copyFrom: 1 to: colonIndex - 1)										to: (reference copyFrom: colonIndex + 1 to: reference size)										signalling: acceptSignal]]				ifFalse: [address _ self produceLinkFrom: reference signalling: acceptSignal].			realRule _ realRule , address].	charactersSoFar < string size ifTrue: [realRule _ realRule , (string copyFrom: charactersSoFar to: string size)].	^Compiler evaluate: realRule , ']'!codeFromStringNotifying: aController 	"This method takes a character string and prodces a piece of Smalltalk code   	suitable for evaluation as a block."	"to signal when known that rule is bad"	| acceptSignal inStream realRule reference colonIndex address space tab cr next allTemps tempStream |	"set up a signal to handle bad rule code"	acceptSignal _ CellStringHolderController AcceptSignal.	"initialize and check for bad rule"	string = '' ifTrue: [^nil].	references _ OrderedCollection new.	space _ Character space.	tab _ Character tab.	cr _ Character cr.	inStream _ ReadStream on: string.	realRule _ WriteStream on: (String new: 200).	(string indexOf: ${)		= 0		ifTrue: 			[self booboo: 'Rule must have reference(s) to other cell(s).'.			acceptSignal signal].	"look for temporary variable definitions, ignoring comments"	[next _ inStream peek.	next = $"		ifTrue: 			[inStream upTo: $".			next _ inStream peek].	next = space | (next = tab) | (next = cr)]		whileTrue: [inStream next].	next = $|		ifTrue: 			[inStream next.			realRule nextPut: $|; nextPutAll: (allTemps _ inStream upTo: $|); nextPut: $|].	realRule nextPutAll: ' [:model :xcell :ycell | '.	"add code to nil out all temporary variables"	allTemps == nil		ifFalse: 			[tempStream _ ReadStream on: allTemps stripLeadingSpaces.			[tempStream atEnd]				whileFalse: [realRule nextPutAll: (tempStream upTo: space)							, ' _ '].			realRule nextPutAll: 'nil. '].		"find all {r,c} references"	[realRule nextPutAll: (inStream upTo: ${).	inStream atEnd]		whileFalse: 			["obtain the contents of the {r,c} reference"			reference _ (inStream upTo: $}) asUppercase.			"now, look for each part of the reference"			(reference indexOf: $;)				= 0				ifTrue: 					[colonIndex _ reference indexOf: $:.					colonIndex = 0						ifTrue: ["single point"							address _ self producePointFrom: reference signalling: acceptSignal]						ifFalse: ["rectangle of cells"							address _ self										produceRectFrom: (reference copyFrom: 1 to: colonIndex - 1)										to: (reference copyFrom: colonIndex + 1 to: reference size)										signalling: acceptSignal]]				ifFalse: ["link to alternate sheet"					address _ self produceLinkFrom: reference signalling: acceptSignal].			realRule nextPutAll: address].	realRule nextPut: $].	^Compiler new		evaluate: realRule contents		in: nil		to: nil		notifying: aController		ifFail: []!linkX: xString Y: yString at: theReference	"parse and answer the address of the strings and log in references collection"	| address thisRef |	address _ Point new.	address x: xString asNumber.	address y: yString asNumber.	thisRef _ Array new: 3.	thisRef at: 1 put: (theReference copyUpTo: $;).	thisRef at: 2 put: address x.	thisRef at: 3 put: address y.	references add: thisRef.	^address!linkX: xString Y: yString toX: x2String Y: y2String at: theReference	"parse and answer the address of the strings and log in references collection"	| address firstChar refSymbol thisRef |	address _ 0@0 extent: 0@0.	address  origin x: xString asNumber.	address origin y: yString asNumber.	address corner x: x2String asNumber.	address corner y: y2String asNumber.	thisRef _ Array new: 5.	thisRef at: 1 put: (theReference copyUpTo: $;).	thisRef at: 2 put: address origin x.	thisRef at: 3 put: address origin y.	thisRef at: 4 put: address corner x.	thisRef at: 5 put: address corner y.	references add: thisRef.	^address!produceLinkFrom: theReference signalling: acceptSignal 	"produce a point from reference"	| row1Start col1Start row1End col1End row2Start col2Start row2End col2End address1 address2 address reference reference2 semicolonIndex colonIndex |	colonIndex _ theReference indexOf: $:.	semicolonIndex _ theReference indexOf: $;.	colonIndex = 0		ifTrue: [reference _ theReference copyFrom: semicolonIndex + 1 to: theReference size]		ifFalse: 			[reference _ theReference copyFrom: semicolonIndex + 1 to: colonIndex - 1.			reference2 _ theReference copyFrom: colonIndex + 1 to: theReference size].	row1End _ row2End _ 0.	col1End _ col2End _ 0.	row1Start _ reference indexOf: $R.	col1Start _ reference indexOf: $C.	row1Start = 1		ifTrue: 			[row1End _ col1Start - 1.			col1End _ reference size].	col1Start = 1		ifTrue: 			[row1End _ reference size.			col1End _ row1Start - 1].	colonIndex = 0		ifFalse: 			[row2Start _ reference2 indexOf: $R.			col2Start _ reference2 indexOf: $C.			row2Start = 1				ifTrue: 					[row2End _ col2Start - 1.					col2End _ reference2 size].			col2Start = 1				ifTrue: 					[row2End _ reference2 size.					col2End _ row2Start - 1]].	row1Start = 0 | (col1Start = 0) | (row1Start = row1End) | (col1Start = col1End) | (colonIndex = 0			ifTrue: [false]			ifFalse: [row2Start = 0 | (col2Start = 0) | (row2Start = row2End) | (col2Start = col2End)])		ifTrue: 			[self booboo: 'Cell References must have TWO dimensions'.			acceptSignal signal]		ifFalse: [colonIndex = 0				ifFalse: 					[address _ self								linkX: (reference copyFrom: col1Start + 1 to: col1End)								Y: (reference copyFrom: row1Start + 1 to: row1End)								toX: (reference2 copyFrom: col2Start + 1 to: col2End)								Y: (reference2 copyFrom: row2Start + 1 to: row2End)								at: theReference.					address origin x = String new | (address origin y = String new) | (address corner x = String new) | (address corner y = String new)						ifTrue: 							[self booboo: 'Cell References must have non-nil dimensions'.							acceptSignal signal]]				ifTrue:[address _ self								linkX: (reference copyFrom: col1Start + 1 to: col1End)								Y: (reference copyFrom: row1Start + 1 to: row1End)								at: theReference.					address  x = String new | (address  y = String new)						ifTrue: 							[self booboo: 'Cell References must have non-nil dimensions'.							acceptSignal signal]]].	 (address isKindOf: Rectangle)		ifTrue:[^' (model allHolders atSheet: ''', (theReference copyUpTo: $;), ''' rectangle:  (Rectangle new origin: ', address origin printString,' corner: ',address corner printString,') for: model)'] 		ifFalse:[	^' (model allHolders atSheet: ''', (theReference copyUpTo: $;), ''' point: ', address printString,' for: model)']!producePointFrom: reference signalling: acceptSignal 	"produce a point from reference"	| rowStart colStart rowEnd colEnd address |	rowStart _ reference indexOf: $R.	colStart _ reference indexOf: $C.	rowEnd _ 0.	colEnd _ 0.	rowStart = 1		ifTrue: 			[rowEnd _ colStart - 1.			colEnd _ reference size].	colStart = 1		ifTrue: 			[rowEnd _ reference size.			colEnd _ rowStart - 1].	rowStart = 0 | (colStart = 0) | (rowStart = rowEnd) | (colStart = colEnd)		ifTrue: 			[self booboo: 'Cell References must have TWO dimensions'.			acceptSignal signal]		ifFalse: 			[address _ self addressX: (reference copyFrom: colStart + 1 to: colEnd)						Y: (reference copyFrom: rowStart + 1 to: rowEnd).			address x = '' | (address y = '')				ifTrue: 					[self booboo: 'Cell References must have non-nil dimensions'.					acceptSignal signal]].	^ ' ((model atRow: ',address y,' column: ',address x,') contents ) '!produceRectFrom: reference to: reference2 signalling: acceptSignal 	"produce a point from reference"	| row1Start col1Start row1End col1End row2Start col2Start row2End col2End address1 address2 address |	row1Start _ reference indexOf: $R.	row2Start _ reference2 indexOf: $R.	col1Start _ reference indexOf: $C.	col2Start _ reference2 indexOf: $C.	row1End _ row2End _ 0.	col1End _ col2End _ 0.	row1Start = 1		ifTrue: 			[row1End _ col1Start - 1.			col1End _ reference size].	row2Start = 1		ifTrue: 			[row2End _ col2Start - 1.			col2End _ reference2 size].	col1Start = 1		ifTrue: 			[row1End _ reference size.			col1End _ row1Start - 1].	col2Start = 1		ifTrue: 			[row2End _ reference2 size.			col2End _ row2Start - 1].	row1Start = 0 | (col1Start = 0) | (row1Start = row1End) | (col1Start = col1End) | (row2Start = 0) | (col2Start = 0) | (row2Start = row2End) | (col2Start = col2End)		ifTrue: 			[self booboo: 'Cell References must have TWO dimensions'.			acceptSignal signal]		ifFalse: 			[address _ self						rectangleX: (reference copyFrom: col1Start + 1 to: col1End)						Y: (reference copyFrom: row1Start + 1 to: row1End)						toX: (reference2 copyFrom: col2Start + 1 to: col2End)						Y: (reference2 copyFrom: row2Start + 1 to: row2End).			address origin x = '' | (address origin y = '') | (address corner x = '') | (address corner y = '')				ifTrue: 					[self booboo: 'Cell References must have non-nil dimensions'.					acceptSignal signal]].	^' (model contentsFromPoint: (' , address origin x , ')@(' , address origin y , ') toPoint: (' , address corner x , ')@(' , address corner y , ')) '!rectangleX: xString Y: yString toX: x2String Y: y2String	"parse and answer the address of the strings and log in references collection"	| address firstChar refSymbol thisRef |	address _ 0@0 extent: 0@0.	thisRef _ Array new: 5.	firstChar _ xString first.	(firstChar = $0) | (firstChar = $+) | (firstChar = $-)		ifTrue: [firstChar = $0					ifTrue: [address  origin x: 'xcell']					ifFalse: [address  origin x: 'xcell', xString].				refSymbol _ 'r']		ifFalse: [address  origin x: xString.				refSymbol _ 'a'].	firstChar _ yString first.	(firstChar = $0) | (firstChar = $+) | (firstChar = $-)		ifTrue: [firstChar = $0					ifTrue: [address origin y: 'ycell']					ifFalse: [address origin y: 'ycell', yString].				refSymbol _ refSymbol,'r']		ifFalse: [address origin y: yString.				refSymbol _ refSymbol,'a'].	firstChar _ x2String first.	(firstChar = $0) | (firstChar = $+) | (firstChar = $-)		ifTrue: [firstChar = $0					ifTrue: [address corner x: 'xcell']					ifFalse: [address corner x: 'xcell', x2String].				refSymbol _ refSymbol,'r']		ifFalse: [address corner x: x2String.				refSymbol _ refSymbol,'a'].	firstChar _ y2String first.	(firstChar = $0) | (firstChar = $+) | (firstChar = $-)		ifTrue: [firstChar = $0					ifTrue: [address corner y: 'ycell']					ifFalse: [address corner y: 'ycell', y2String].				refSymbol _ refSymbol,'r']		ifFalse: [address corner y: y2String.				refSymbol _ refSymbol,'a'].	thisRef at: 1 put: refSymbol asSymbol.	thisRef at: 2 put: (xString first = $+ 						ifTrue: [xString copyFrom: 2 to: xString size]						ifFalse: [xString]) asNumber.	thisRef at: 3 put: (yString first = $+ 						ifTrue: [yString copyFrom: 2 to: yString size]						ifFalse: [yString]) asNumber.	thisRef at: 4 put: (x2String first = $+ 						ifTrue: [x2String copyFrom: 2 to: x2String size]						ifFalse: [x2String]) asNumber.	thisRef at: 5 put: (y2String first = $+ 						ifTrue: [y2String copyFrom: 2 to: y2String size]						ifFalse: [y2String]) asNumber.	references add: thisRef.	^address! !!ControlManager methodsFor: 'initialize-release'!initialize	"Initialize the receiver to refer to only the background controller."	| screenView |	screenController _ ScreenController new.	screenView _ FormView new.	screenView model: (InfiniteForm with: Form screen)		controller: screenController.	screenView window: Display boundingBox.	scheduledControllers _ OrderedCollection with: screenController! !!ControlManager methodsFor: 'accessing'!backgroundColor: aForm	screenController model form: aForm! !!ControlManager methodsFor: 'scheduling'!bailOut	"Create a Notifier on the active scheduling process whose label is title	Make the Notifier the active controller."	| suspendingList |	[suspendingList _ activeControllerProcess suspendingList.	suspendingList isNil		ifTrue:	[activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess terminate]]		ifFalse:	[suspendingList remove: activeControllerProcess.				activeControllerProcess offList].	activeController == nil ifFalse: [activeController controlTerminate].	self "searchForActiveController" activeController: screenController] forkAt: Processor userInterruptPriority!searchForActiveController	"Find a scheduled controller that wants control and give control to it.  If none	wants control, then see if the System Menu has been requested."	| aController |	activeController _ nil.	activeControllerProcess _ Processor activeProcess.	[Processor yield.	 aController _ scheduledControllers 		detect:			[:aController |			aController isControlWanted and:				[aController ~~ screenController]]		ifNone:			[screenController isControlWanted				ifTrue: [screenController]				ifFalse: [nil]].	aController isNil]		whileTrue: [BackgroundDelay == 0 ifFalse: [(Delay forMilliseconds: BackgroundDelay) wait "allow background to run"]].	self activeController: aController.	Processor terminateActive!suicideLeapInto: aBlock	| suspendingList |	[suspendingList _ activeControllerProcess suspendingList.	suspendingList isNil		ifTrue:	[activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess terminate]]		ifFalse:	[suspendingList remove: activeControllerProcess.				activeControllerProcess offList].	activeController == nil ifFalse: [activeController controlTerminate].	aBlock value.	self activeController: screenController] forkAt: Processor userInterruptPriority! !!ControlManager methodsFor: 'displaying'!collapse	"Clear the screen to gray and then display all the scheduled views in collapsed form."	| x y margin verticalSeparation columnWidth aView |	self unschedule: screenController.	self scheduleOnBottom: screenController.	screenController view window: Display boundingBox.	verticalSeparation _ 10.	x _ y _ margin _ verticalSeparation + verticalSeparation.	columnWidth _ 175.	scheduledControllers reverseDo: 		[:aController |		aView _ aController view.		aController == screenController			ifTrue: [aView display; deEmphasize]			ifFalse:				[				aView collapse.				(y + aView labelDisplayBox extent y + margin) > (Display boundingBox extent y)					ifTrue: "Start another column."						[						x _ x + columnWidth.						y _ margin.						].				aView lastLabelLocation: x @ y;					align: aView displayBox topLeft					with: aView lastLabelLocation.				aView display; deEmphasize.				y _ (aView viewport bottomLeft y) + verticalSeparation.				].		].	Cursor normal show! !!Set methodsFor: 'testing'!includes: anObject 	^(self basicAt: (self findElementOrNil: anObject)) == nil == false! !!SystemDictionary methodsFor: 'system backup/out'!getImagePrefix	"Prompt the user for a snapshot file name.  Persist until a legal name is supplied."	| default newPrefix prompt prefixSize |	prompt _ 'Enter name for image file:'.	SourceFiles == nil ifTrue: [^(FillInTheBlank request: prompt default: 'snapshot') asFileName].	prefixSize _ ((SourceFiles at: 2) name) findLast: [:char| char = $.].	default _ ((SourceFiles at: 2) name) copyFrom: 1 to: prefixSize - 1.	(self versionName match: default) ifTrue: [default _ 'snapshot'].	newPrefix _ String new.	FillInTheBlank		request: prompt		displayAt: Sensor cursorPoint		centered: true		action: [:newPrefix | ] 		initialAnswer: default.	[newPrefix isEmpty or:			[(Disk isLegalFileName: newPrefix, '.changes') not]] whileTrue:		[newPrefix isEmpty ifTrue: [^newPrefix].		FillInTheBlank			request: prompt			displayAt: Sensor cursorPoint			centered: true			action: [:newPrefix | ] 			initialAnswer: default.		(newPrefix size > 2 and:			[(newPrefix copyFrom: newPrefix size-2 to: newPrefix size) sameAs: '.im'])				ifTrue: [newPrefix _ newPrefix copyFrom: 1 to: newPrefix size-3].		prompt _'Illegal file name: ', newPrefix, 'Enter name for image file:'.		default _ Disk checkName: newPrefix, '.changes' fixErrors: true.		default _ default copyFrom: 1 to: default size - 8].	^newPrefix! !!SystemDictionary methodsFor: 'time/versions'!addToAnalystVersion: aString	SystemDictionary		compile:'analystVersionInfo	^', (self analystVersionInfo, aString) printString	classified: 'time/versions' asSymbol.	Smalltalk changes removeSelectorChanges: #analystVersionInfo class: SystemDictionary!analystVersionInfo	^'The Analyst(tm).Copyright (c) 1985, 1986, 1987 Xerox Corporation.  All rights reserved.Copyright protection claimed includes all forms and matters of copyrightable material and information now allowed by statutory or judicial law or hereinafter granted, including without limitation, material generated from the software programs which are displayed on the screen such as icons, screen display looks, etc.This Analyst was built on top of:Smalltalk-80 of August 28, 1986 (Dandelion/Daybreak Version 6)Copyright (c) 1983 Xerox Corp.  All rights reserved.Analyst base version 1.2Interpress printing support(30 April 1987 6:45:42 pm ) saved by ConfigMeister'!version	^'The Analyst(tm) on Smalltalk-80 of August 28, 1986 (Dandelion/Daybreak Version 6)'!versionName	"Answer the version identification, e.g. ST80-DV6."	| version index |	version _ self version.	index _ version findString: 'Version' startingAt: 1.	^'ST80-DV', (String with: (version at: (version size >= (index + 8) ifTrue: [index + 8] ifFalse: [$u])))! !!SystemDictionary methodsFor: 'system compression'!moveChangesFromFileNumber: anInteger1 toFileNumber: anInteger2 toFileStream: anExternalStream	"Move all the changes onto a compacted sources file."	"Condense changes.	""	Smalltalk		moveChangesFromFileNumber: 2		toFileNumber: 2		toFileStream: (SourceFiles at: 2).	"	"Move changes to base.""	SourceFiles size < 3 ifTrue:		[SourceFiles _ (Array new: 3)			at: 1 put: (SourceFiles at: 1);			at: 2 put: (SourceFiles at: 2);			yourself.		].	(SourceFiles at: 3) == nil ifTrue:		[SourceFiles at: 3 put:			(FileStream fileNamed: {Base File Name}, '.base')		].	Smalltalk		moveChangesFromFileNumber: 2		toFileNumber: 3		toFileStream: (SourceFiles at: 3).	(SourceFiles at: 2) close.	SourceFiles at: 2 put:		(FileStream fileNamed: (SourceFiles at: 2) file fullName).	"	| bn cl dr f1 f2 i1 i2 sF sg |	bn _ anInteger1 ~= anInteger2.	bn ifFalse: [bn _ SourceFiles == nil.].	bn ifFalse:		[bn _			(	((anInteger1 >= 1) and: [anInteger1 <= SourceFiles size])				and: [(SourceFiles at: anInteger1) == anExternalStream.]			) not.		].	f2 _ bn		ifTrue:			[anExternalStream close.			(FileStream fileNamed: anExternalStream file fullName) readWrite setToEnd.			]		ifFalse: [anExternalStream directory file: 'ST80.temp'.].	sg _ f2 file fullName.	f2 timeStamp.	Smalltalk allBehaviorsDo:		[:cl |		cl			moveChangesFromFileNumber: anInteger1			toFileNumber: anInteger2			toFileStream: f2.		].	f2 close; readOnly.	sF _ SourceFiles.	f1 _ sF at: anInteger1.	SourceFiles at: anInteger1 put: nil.	SourceFiles _ nil.	dr _ f1 directory.	sg _ f1 name.	f1 close.	dr removeKey: sg.	f1 _ dr file: sg.	bn		ifTrue:			 ["f1 _ dr file: sg."			 f1 timeStamp.			 ]		ifFalse:			["f2 close.			dr rename: f2 file newName: sg.			f2 _ f1 _ dr file: sg."			i1 _ f2 size.			f2 close; reset.			[i1 > 0.] whileTrue:				[i2 _ 4096 min: i1.				f1 nextPutAll: (f2 next: i2).				i1 _ i1 - i2.				].			f2 directory removeKey: 'ST80.temp'.			f2 _ f1.			].	f2 close; readOnly.	sF at: anInteger1 put: f1.	sF at: anInteger2 put: f2.	SourceFiles _ sF.!nilOrganizationsForClasses: classNames	"Nil out all organizations for the set of classNames given. To recover as many oops and words of core as possible, 'doIt' the following:""	ClassOrganizer rehash.	Smalltalk nilOrganizationsForClasses: Smalltalk classNames.	Symbol rehash.	"	| aClass classSet count factor saveCursorPoint |	count _ 0.	classSet _ Set new: classNames size.	classNames do: [:each | classSet add: (each copyUpTo: Character space).].	factor _ Display boundingBox height - 16 asFloat / classSet size / 2.	saveCursorPoint _ Sensor cursorPoint.	classSet do:		[:className |		Sensor cursorPoint: saveCursorPoint x @ (count * factor) rounded.		aClass _ Smalltalk at: className.		aClass collapse.		aClass class collapse.		count _ count + 2.		].	Sensor cursorPoint: saveCursorPoint.	^count! !!SystemDictionary methodsFor: 'private'!lowSpaceNotificationLoop	| core oops aString aForm aRectangle |	[true] whileTrue: 		[LowSpaceSemaphore wait.		 Cursor garbage showWhile: [			core _ Smalltalk coreLeft.			oops _ Smalltalk oopsLeft.			Smalltalk garbageCollect.			aString _ ' core recovered: ' , (Smalltalk coreLeft - core) printString, ' words    oops recovered: ' , (Smalltalk oopsLeft - oops) printString.			aForm _  aString asParagraph asForm.			aRectangle _ aForm boundingBox.			aRectangle _  aRectangle align: aRectangle  topCenter with: (Display boundingBox topCenter + (0@4)).			aForm displayOn: Display at: aRectangle topLeft].		(self coreLeft - core < (30 * 1000) and: [self oopsLeft - oops < 200]) ifTrue:		"If garbage collection didn't find much garbage, then bring up a notifier (so that we don't get into an infinite garbage collection loop). I chose 30000 words or 200 oops as an arbitrary garbage quota just by making a wild guess as to what I thought was reasonable. 30 * 1000 was used instead of 30000 in order to save one precious oop. --Kerry LaPrade, Xerox Special Information Systems."			[self resetSpaceLimits.			ScheduledControllers interruptName: 'Space is Low']]! !!SystemDictionary methodsFor: 'not for release-static checks'!rehashBadSets	"Smalltalk rehashBadSets"	| badSets checkSet |	badSets _ Set new.	checkSet _ [:set |		(set isKindOf: Dictionary)			ifTrue: [set keysDo:				[:x | (set includesKey: x) ifFalse: [badSets add: set]]]			ifFalse: [set do:				[:x | (set includes: x) ifFalse: [badSets add: set]]]].	Set allInstances do: checkSet.	Set allSubInstancesDo: checkSet.	badSets do: [:bad | bad rehash].	Transcript cr; print: badSets size; show: ' bad sets/dictionaries rehashed'.	^badSets! !AssociationlessDictionary comment:'Copyright (c) 1984, 1985 Xerox Corporation.  All rights reserved.I implement a Dictionary without using Associations, thus saving one object pointer per dictionary entry.I was first created on February 22, 1984 by Kerry LaPrade.'!!AssociationlessDictionary methodsFor: 'accessing'!associationAt: key ifAbsent: aBlock	key == nil ifTrue: [self errorNilKey ifTrue: [^nil]].	^Association key: key value: (self at: key ifAbsent: [^aBlock value])!at: key ifAbsent: aBlock	self subclassResponsibility.!at: key put: anObject	self subclassResponsibility.!dataSize	self subclassResponsibility.! !!AssociationlessDictionary methodsFor: 'adding'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^anAssociation!grow	| newSelf |	newSelf _ self species new: self dataSize + self growSize.	self associationsDo: [:each | newSelf noCheckAdd: each].	self become: newSelf.! !!AssociationlessDictionary methodsFor: 'enumerating'!do: aBlock	self keysDo: [:each | aBlock value: (self at: each)].! !!AssociationlessDictionary methodsFor: 'dictionary testing'!includesAssociation: anAssociation	^(self at: anAssociation key ifAbsent: [^false]) == anAssociation value! !!AssociationlessDictionary methodsFor: 'dictionary removing'!removeAssociation: anAssociation ifAbsent: anExceptionBlock	(self includesAssociation: anAssociation)		ifTrue:			[self removeKey: anAssociation key.			^anAssociation			]		ifFalse: [^anExceptionBlock value].!removeKey: key ifAbsent: aBlock 	"Remove key from the receiver.  If key is not in the receiver,	answer the result of evaluating aBlock.  Otherwise, answer the value associated	with key."	| index element |	index _ self findKey: key ifAbsent: [^aBlock value].	element _ self basicAt: index.	self basicAt: index put: nil.	self basicAt: index + 1 put: nil.	tally _ tally - 1.	self fixCollisionsFrom: index.	^element! !!AssociationlessDictionary methodsFor: 'dictionary enumerating'!associationsDo: aBlock	self keysDo: [:each | aBlock value: (Association key: each value: (self at: each))].!keysDo: aBlock	self subclassResponsibility.! !!AssociationlessDictionary methodsFor: 'private'!errorNilKey	self error: 'I cannot use nil as a key.'.	^true!findKeyOrNil: key	self subclassResponsibility.!fixCollisionsFrom: index	self subclassResponsibility.!fullCheck	self dataSize - self size <= (self dataSize // 4) ifTrue: [self grow].!growSize	"Answer an amount by which the receiver should grow to make room for more elements (in response to the message 'grow')."	^self dataSize min: 2!noCheckAdd: anAssociation	self at: anAssociation key put: anAssociation value.! !OopConservingDictionary comment:'Copyright (c) 1984, 1985 Xerox Corporation.  All rights reserved.I implement a Dictionary without using Associations, thus saving one object pointer per dictionary entry.I was first created on February 22, 1984 by Kerry LaPrade.'!!OopConservingDictionary methodsFor: 'accessing'!at: key ifAbsent: aBlock	| index |	key == nil ifTrue: [^self errorNilKey].	index _ self findKey: key ifAbsent: [^aBlock value].	^self basicAt: index + 1!at: key put: anObject	| index |	key == nil ifTrue: [^self errorNilKey].	index _ self findKeyOrNil: key.	self basicAt: index + 1 put: anObject.	(self basicAt: index) == nil ifTrue: 		[self atNewIndex: index put: key]. 	^anObject!dataSize	^self basicSize // 2! !!OopConservingDictionary methodsFor: 'enumerating'!do: aBlock"The code for this method in my superclass would work OK, but overriding it here is faster."	| index |	index _ 1.	[index < self basicSize] whileTrue: 		[(self basicAt: index) == nil ifFalse:			[aBlock value: (self basicAt: index + 1)].		index _ index + 2.		].! !!OopConservingDictionary methodsFor: 'dictionary enumerating'!associationsDo: aBlock"The code for this method in my superclass would work OK, but overriding it here is faster."	| index |	index _ 1.	[index < self basicSize] whileTrue: 		[(self basicAt: index) == nil ifFalse:			[aBlock value:				(Association					key: (self basicAt: index)					value: (self basicAt: index + 1)				)			].		index _ index + 2.		].!keysDo: aBlock	| index |	index _ 1.	[index < self basicSize] whileTrue: 		[(self basicAt: index) == nil ifFalse:			[aBlock value: (self basicAt: index).].		index _ index + 2.		].! !!OopConservingDictionary methodsFor: 'private'!findKeyOrNil: key	| index length probe pass |	length _ self basicSize.	pass _ 1.	index _ (key hash \\ (length / 2)) * 2 + 1.	[(probe _ self basicAt: index) == nil or: [probe = key]] whileFalse:		[(index _ index + 2) > length ifTrue: 			[index _ 1.			pass _ pass + 1.			pass > 2 ifTrue: [^self grow findKeyOrNil: key].			].		].	^index!fixCollisionsFrom: index	| myLength oldIndex nextIndex nextObject |	oldIndex _ index.	myLength _ self basicSize.	[oldIndex _ oldIndex + 1 \\ myLength + 1.	nextObject _ self basicAt: oldIndex.	nextObject == nil.	] whileFalse:		[nextIndex _ self findKeyOrNil: nextObject.		nextIndex = oldIndex ifFalse:			[self basicAt: nextIndex put: nextObject.			self basicAt: (nextIndex + 1) put: (self basicAt: (oldIndex + 1)).			self basicAt: oldIndex put: nil.].		].! !LRUCacheDictionary comment:'Copyright (c) 1983, 1984, 1985, 1986 Xerox Corporation.  All rights reserved.I maintain a 1..N Array with protocol to manage myself as an LRU cache; i.e, my elements are ordered so that the most frequently referenced element is 1, the Least Recently Used, N. I can be very handy for speeding up algorithms which tend to have repetitious input.My protocol is very much like that of a Dictionary. A Dictionary is a Set of keys and values. I am an Array of keys and values. I never grow. If my size is N, and an N+1st element is added to me, I will completely forget about my least recently used element.To use me, first declare my size, e.g.,	"cache _ LRUCacheDictionary new: N."Next, access me with "find:ifAbsentUseResultOf:" whenever you like.Keep in mind that I behave much like a Dictionary, and also be aware that	"	cache find: key ifAbsentUseResultOf: aBlock	"is functionally equivalent to	"	cache at: key ifAbsent: [cache at: key put: aBlock value].		^cache at: key	"(See also LRUCacheDictionary example.).I was first created on October 20, 1983 by Kerry LaPrade.'!!LRUCacheDictionary methodsFor: 'accessing'!at: key ifAbsent: aBlock	^(self includesKey: key)		ifTrue:			[self				find: key				ifAbsentUseResultOf: [self error: 'Cache item just disappeared!!']			]		ifFalse: [aBlock value]!at: key put: value	^self		ripple: key ifAbsentUseResultOf: [nil];		basicAt: 1 put: key;		basicAt: 2 put: value!find: key ifAbsentUseResultOf: aBlock	"Return the value associated with 'key', either by finding an item equal to 'key' in the cache (a fixed-capacity stack), or failing that, by evaluating 'aBlock'. Leave that key and value as the new top of the stack."	| value |"	tally < 1 ifTrue: [^aBlock value]."	key = (self basicAt: 1) ifFalse:		[value _ self ripple: key ifAbsentUseResultOf: aBlock.		self basicSize < 2 ifFalse:			[self basicAt: 1 put: key.			self basicAt: 2 put: value.			].		^value		].	^self basicAt: 2! !!LRUCacheDictionary methodsFor: 'adding'!grow	self shouldNotImplement.! !!LRUCacheDictionary methodsFor: 'enumerating'!do: aBlock	2 to: tally * 2 by: 2 do: [:i | aBlock value: (self basicAt: i)].! !!LRUCacheDictionary methodsFor: 'dictionary testing'!includesKey: key	^self keys includes: key! !!LRUCacheDictionary methodsFor: 'dictionary removing'!removeKey: key ifAbsent: aBlock	self shouldNotImplement.! !!LRUCacheDictionary methodsFor: 'dictionary enumerating'!keysDo: aBlock	1 to: tally * 2 by: 2 do: [:i | aBlock value: (self basicAt: i)].! !!LRUCacheDictionary methodsFor: 'private'!errorNilKey	^false!findKeyOrNil: key	self shouldNotImplement.!rehash!ripple: key ifAbsentUseResultOf: aBlock	"Return the value associated with 'key', either by finding an item equal to 'key' in the cache (a fixed-capacity stack), or failing that, by evaluating 'aBlock'. Leave that key and value as the new top of the stack."	| basicTally key1 key2 value1 value2 |	basicTally _ tally * 2.	1 to: self basicSize by: 2 do:		[:i|		key2 _ self basicAt: i.		value2 _ self basicAt: i + 1.		self basicAt: i put: key1.		self basicAt: i + 1 put: value1.		key1 _ key2.		value1 _ value2.		key = key1 ifTrue: [^value1].		i > basicTally ifTrue:			[tally _ tally + 1.			^aBlock value			].		].	^aBlock value! !SpreadsheetDictionary comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SpreadsheetDictionary methodsFor: 'spreadsheet file reading'!readCell: aPoint inHolder: aHolder from: aString 	"Create a new SpreadsheetHolder from aStream."	| code contents theContents thePoint someJunk aStream |	theContents _ nil.	thePoint _ 0@0.	(Disk includesKey: aString) ifTrue:[aStream _ (FileStream oldFileNamed: aString) readOnly] ifFalse:[^nil].	Cursor read		showWhile: 			[[aStream peek = Character newPage] whileFalse:					[aStream next].			aStream next. "Gobble newPage (signifies beginning of new cell)"			[aStream atEnd | ((thePoint x > aPoint x) & (thePoint y > aPoint y))  ] whileFalse:				[thePoint _  (aStream upTo: $@) asNumber @ (aStream upTo: Character cr) asNumber.				thePoint = aPoint 					ifTrue:[						code _ aStream next. aStream next. "Gobble space"						contents _ aStream upTo: Character cr.						contents _ aStream upTo: $>.						[aStream peek == $R] whileFalse: [contents _ contents, (aStream upTo: $>)].						(code = $*) ifTrue: [theContents _ (Compiler evaluate: contents)].						(code = $B) ifTrue: [theContents _ aHolder badRef].						(code = $N) ifTrue: [theContents _ contents asNumber].						(code = $S) ifTrue: [theContents _ (String readFromString: contents)].						(code = $L) ifTrue: [theContents _ contents asSymbol].						(code = $t) ifTrue: [theContents _ true].						(code = $f) ifTrue: [theContents _ false].						(code = $n) ifTrue: [theContents _ nil]].				someJunk _ aStream upTo: Character newPage]].	aStream setToEnd; close.	^theContents!readGroup: aRectangle inHolder: aHolder from: aString 	"Create a new SpreadsheetHolder from aStream."	| code contents theContents thePoint theMatrix someJunk aStream |	theMatrix _ Matrix new: aRectangle height + 1 by: aRectangle width + 1.	thePoint _ 0@0.	(Disk includesKey: aString) ifTrue:[aStream _ (FileStream oldFileNamed: aString) readOnly] ifFalse:[^nil].	Cursor read		showWhile: 			[[aStream peek = Character newPage] whileFalse:					[aStream next].			aStream next. "Gobble newPage (signifies beginning of new cell)"			[aStream atEnd | ((thePoint x > aRectangle corner x) & (thePoint y > aRectangle corner y))] whileFalse:				[thePoint _  ((aStream upTo: $@) asNumber) @ (aStream upTo: Character cr) asNumber.				(aRectangle origin <= thePoint and: [thePoint <= aRectangle corner])					ifTrue:[						code _ aStream next. aStream next. "Gobble space"						contents _ aStream upTo: $>.						[aStream peek == $R] whileFalse: [contents _ contents, (aStream upTo: $>)].						(code = $*) ifTrue: [theContents _ (Compiler evaluate: contents)].						(code = $B) ifTrue: [theContents _ aHolder badRef].						(code = $N) ifTrue: [theContents _ contents asNumber].						(code = $S) ifTrue: [theContents _ (String readFromString: contents)].						(code = $L) ifTrue: [theContents _ contents asSymbol].						(code = $t) ifTrue: [theContents _ true].						(code = $f) ifTrue: [theContents _ false].						(code = $n) ifTrue: [theContents _ nil].						theMatrix atPoint: (thePoint x - aRectangle origin x + 1) @ (thePoint y - aRectangle origin y + 1) put: theContents].				someJunk _ aStream upTo: Character newPage]].	aStream setToEnd; close.	^theMatrix! !!SpreadsheetDictionary methodsFor: 'accessing'!at: aString put: aHolder 	| eachRef |	(self at: aString ifAbsent: [nil])		= nil		ifTrue: [super at: aString put: aHolder]		ifFalse: 			[((self at: aString)				isKindOf: Dictionary)				ifTrue: [(self at: aString) keys do: 					[:each | 						((self at: aString) at: each) dependents do: 							[:dep | 							(each class ==  Rectangle)								ifTrue: [aHolder fromPoint: each origin toPoint: each corner do: 										[:eachCell |											eachCell addDependent: dep]]								ifFalse: [(aHolder atPoint: each) addDependent: dep]]]].			super at: aString put: aHolder]!atSheet: aString point: aPoint for: aHolder 	| theHolder theRectangle |	theHolder _ self at: aString				ifAbsent: 					[self at: aString put: Dictionary new.					(self at: aString) at: aPoint put: (self							readCell: aPoint							inHolder: aHolder							from:  aString, '.ss').					^(self at: aString) at: aPoint].	(theHolder isKindOf: Dictionary)		ifTrue: [^theHolder at: aPoint				ifAbsent: 					[(self at: aString) at: aPoint put: (self							readCell: aPoint							inHolder: aHolder							from:  aString, '.ss').					^(self at: aString) at: aPoint]]		ifFalse: [^(theHolder atPoint: aPoint) contents]!atSheet: aString point: aPoint for: aHolder addDependent: anObject	| theHolder theRectangle |	theHolder _ self at: aString				ifAbsent: 					[self at: aString put: Dictionary new.					(self at: aString) at: aPoint put: (self							readCell: aPoint							inHolder: aHolder							from:  aString, '.ss').					^((self at: aString) at: aPoint) = nil ifFalse: [((self at: aString) at: aPoint) addDependent: anObject]].	(theHolder class == Dictionary)		ifTrue: [^theHolder at: aPoint				ifAbsent: 					[(self at: aString) at: aPoint put: (self							readCell: aPoint							inHolder: aHolder							from:  aString, '.ss').					^((self at: aString) at: aPoint) = nil ifFalse: [((self at: aString) at: aPoint) addDependent: anObject]]]		ifFalse: [^(theHolder atPoint: aPoint) addDependent: anObject]!atSheet: aString point: aPoint for: aHolder removeDependent: anObject	| theHolder theRectangle |	theHolder _ self at: aString ifAbsent: [^nil].	(theHolder isKindOf: Dictionary)		ifTrue: [^(theHolder at: aPoint ifAbsent: [^nil]) removeDependent: anObject]		ifFalse: [^(theHolder atPoint: aPoint) removeDependent: anObject]!atSheet: aString rectangle: aRectangle for: aHolder 	| theHolder theRectangle |	theHolder _ self at: aString				ifAbsent: 					[self at: aString put: Dictionary new.					self at: aRectangle put: (self							readGroup: aRectangle							inHolder: aHolder							from:  aString, '.ss').					^self at: aRectangle].	(theHolder isKindOf: Dictionary)		ifTrue: [^theHolder at: aRectangle				ifAbsent: 					[self at: aRectangle put: (self							readGroup: aRectangle							inHolder: aHolder							from:  aString, '.ss').					^self at: aRectangle]]		ifFalse: [^theHolder contentsFromPoint: aRectangle origin toPoint: aRectangle corner]!atSheet: aString rectangle: aRectangle for: aHolder addDependent: anObject	| theHolder theRectangle |	theHolder _ self at: aString				ifAbsent: 					[self at: aString put: Dictionary new.					(self at: aString) at: aRectangle put: (self							readGroup: aRectangle							inHolder: aHolder							from:  aString, '.ss').					^((self at: aString) at: aRectangle) = nil ifFalse: [((self at: aString) at: aRectangle) addDependent: anObject]].	(theHolder isKindOf: Dictionary)		ifTrue: [^theHolder at: aRectangle				ifAbsent: 					[(self at: aString) at: aRectangle put: (self							readGroup: aRectangle							inHolder: aHolder							from:  aString, '.ss').					^((self at: aString) at: aRectangle) = nil ifFalse: [((self at: aString) at: aRectangle) addDependent: anObject]]]		ifFalse: [^(theHolder fromPoint: aRectangle origin toPoint: aRectangle corner) do: [:each | each addDependent: anObject]]!atSheet: aString rectangle: aRectangle for: aHolder removeDependent: anObject	| theHolder theRectangle |	theHolder _ self at: aString ifAbsent: [^nil].	(theHolder isKindOf: Dictionary)		ifTrue: [^(theHolder at: aRectangle ifAbsent: [^nil]) removeDependent: anObject]		ifFalse: [^(theHolder fromPoint: aRectangle origin toPoint: aRectangle corner) do: [:each | each removeDependent: anObject]]!removeKey: aKey ifAbsent: aBlock 	| test |	super removeKey: aKey ifAbsent: aBlock.	test _ true.	self keys do: [:key | (self at: key) class == SpreadsheetHolder ifTrue: [test _ false]].	test ifTrue: [self keys do: [:key | super removeKey: key ifAbsent: []]]! !!DirectoryHierarchy methodsFor: 'initialize-release'!initialize"	DirectoryHierarchy initialize	"	(self class organization listAtCategoryNamed: 'lists' asSymbol)		do: [:each | self at: each put: (self perform: each)]! !!DirectoryHierarchy methodsFor: 'lists'!AnnotationModel"	DirectoryHierarchy initialize	"	^#(		''   "local disk""		'[]<AnalystData>Text>'		'[]<AnalystData>User>'"	)!ContainerModel"	DirectoryHierarchy initialize	"	^#(		''   "local disk"		"'[]<AnalystData>ntfc>'		'[]<AnalystData>text>'"	)!ImageEditor"	DirectoryHierarchy initialize	"	^#(		 ''  "local disk""		'[]<AnalystData>Images>'"	)!KeyFileList"	DirectoryHierarchy initialize	"	^#(		''   "local disk"		"'[]<AnalystData>Text>'		'[]<AnalystData>Images>'"	)!MapEditor"	DirectoryHierarchy initialize	"	^#(		''   "local disk""		'[]<AnalystData>Text>'		'[]<AnalystData>Maps>'		'[]<WDBII>Extractions>'"	)!Object"	DirectoryHierarchy initialize	"	^#(		''   "local disk"	)!OutlineView"	DirectoryHierarchy initialize	"	^#(		''   "local disk"	"	'[]<AnalystSupport>usersguide>'"	"	'[]<AnalystData>text>'"	)! !Pool comment:'Copyright (c) 1987 Xerox Corporation.  All rights reserved.This class is intended to be used for every SharedPool in the system (instead of Dictionary).It should be filed in in conjunction with a few changes to ClassDescription fileOuts and the addition of a method to Metaclass.  Look for a file called Pools-System-Changes.st.  These changes make sure that when any method is filed out (except from a change browser?), it is preceded by messages to Pool to insure that any referenced pool and pool variables will exist in the system when it is filed in.  This is important, for one of the severe drawbacks of using SharedPools has been making sure all Pool definitions were in before any code referencing them.Use of this class also prevents users from changing the value of SharedPool variables from outside of classes referencing the Pool.Pool variables already existing that are in the image as a Dictionary need to be converted in the following manner:#(TextConstants FilePool) do: [:poolName |	p _ Pool named: PoolName	Pool replace: (Smalltalk at: poolName) with: p]'!!Pool methodsFor: 'accessing'!name	^name!name: aString	name _ aString! !!Pool methodsFor: 'adding'!addVariable: aSymbol 	| index element anAssociation |	aSymbol class == Symbol 		ifFalse: [^self error: 'Variable names in pools must be specified as Symbols'].	anAssociation _ Association key: aSymbol value: nil.	index _ self findKeyOrNil: anAssociation key.	element _ self basicAt: index.	element == nil ifTrue: [self atNewIndex: index put: anAssociation].	"Do nothing if the variable already exists"	^anAssociation!grow	| newSelf |	newSelf _ self species new: self basicSize + self growSize.	newSelf name: name.	self associationsDo: [:each | newSelf noCheckAdd: each].	self become: newSelf! !!Pool methodsFor: 'warning behavior'!at: aKey put: aValue 	(self confirm: 'Pools should not be set in this fashion,are you sure you want to do this?')		ifTrue: [super at: aKey put: aValue]! !!SequenceableCollection methodsFor: 'comparing'!= otherCollection 	"Answer whether the species of the receiver is the same as otherCollection's species,	and the receiver's size is the same as otherCollection's size, and each of the receiver's	elements equal the corresponding element of otherCollection."	| size index |	self == otherCollection ifTrue: [^ true].	(size _ self size) = otherCollection size ifFalse: [^false].	self species == otherCollection species ifFalse: [^false].	index _ 0.	[size >= (index _ index + 1)]		whileTrue: [(self at: index) = (otherCollection at: index) ifFalse: [^false]].	^true! !!SequenceableCollection methodsFor: 'accessing'!indexOf: anElement ifAbsent: exceptionBlock 	"Answer the index of anElement within the receiver.  If the receiver does	not contain anElement, answer the result of evaluating the exceptionBlock."	| i n |	i _ 1.	n _ self size.	[i <= n] whileTrue:		[(self at: i) = anElement ifTrue: [^i].		 i _ i + 1].	^exceptionBlock value! !!ByteArray methodsFor: 'special-accessing'!specialReplaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. Destructively replace elements in the receiver (a ByteArray	or String) starting at start (a byte index) with replacement (a WordArray)	starting at repStart (a word index). Answer the receiver. Note: Complete	range checks are performed by the primitive. Furthermore, the primitive	requires that:	   self is a byte-type object (such as a ByteArray or String),	   replacement is a non-pointer word-type object (such as a WordArray),	   start is a positive integer <64K,	   stop is a positive integer <64K,	   repStart is an odd positive integer <64K.	Xerox specific. See Object documentation whatIsAPrimitive."	| j useLeftHandByte |	<primitive: 176>	j _ repStart.	useLeftHandByte _ false.	start to: stop do:		[:i | (useLeftHandByte _ useLeftHandByte not)			ifTrue:	[self at: i put: ((replacement at: j) bitShift: -8)]			ifFalse:	[self at: i put: ((replacement at: j) bitAnd: 255). j _ j + 1]]! !Classification comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!Classification methodsFor: 'initialize - release'!initialize	self atAllPut: 0.	self at: ClassByte put: 1! !!Classification methodsFor: 'accessing - classification '!classAndWords	"return the classAndWords string for this item"	| displayStream modifiers theClassification | 	displayStream _ ExternalStream on: String new.	theClassification _ self classification.	modifiers _ self modifiers.	theClassification isEmpty		ifTrue:			[modifiers isEmpty				ifFalse:[modifiers do: [:each | displayStream space; nextPutAll: each]]]		ifFalse:			[displayStream nextPutAll: theClassification.			modifiers do: [:each | displayStream space; nextPutAll: each]].	^displayStream contents!classification	"return the classification string for this item"	^DCM convert: (self at: ClassByte) to: #abbrevClass!classification: classification 	"set the classification for this info label"	self at: ClassByte put: (DCM convert: classification to: #classIndex)!classificationIndex	"return the classification index for this item"	^self at: ClassByte!hardcopyString	"return the string to use in printing top and bottom headings"	| displayStream modifiers theClassification | 	displayStream _ ExternalStream on: String new.	theClassification _ (DCM convert: (self at: ClassByte) to: #fullClass).	modifiers _ self fullModifiers.	theClassification isEmpty		ifTrue:			[modifiers isEmpty				ifFalse: [modifiers do: [:each | displayStream space; nextPutAll: each]]]		ifFalse:			[displayStream nextPutAll: theClassification.			modifiers do: [:each | displayStream space; nextPutAll: each]].	^displayStream contents! !!Classification methodsFor: 'accessing - modifiers'!addModifier: anIndexOrModifier 	"add a modifier to this classification"	| theIndex theNewCountByte |	(anIndexOrModifier isKindOf: String)		ifTrue: [theIndex _ DCM convert: anIndexOrModifier to: #modIndex]		ifFalse: [theIndex _ anIndexOrModifier].	theNewCountByte _ (self at: ModifierCountByte) + 1.	self at: ModifierCountByte put: theNewCountByte.	self at: theNewCountByte + ControlSize put: theIndex!fullModifiers	"return the modifiers for this item as an Array"	| count  theArray |	(count _ self at: ModifierCountByte) = 0 ifTrue:[^Array new].	theArray _ Array new: count.	1 to: count do: [:each | theArray at: each put: (DCM convert: (self at: each + ControlSize) to: #fullMod)].	^theArray!modifierCount	^self at: ModifierCountByte!modifiers	"return the modifiers for this item as an Array"	| count  theArray |	(count _ self at: ModifierCountByte) = 0 ifTrue:[^Array new].	theArray _ Array new: count.	1 to: count do: [:each | theArray at: each put: (DCM convert: (self at: each + ControlSize) to: #abbrevMod)].	^theArray!modifierString	"return the modifiers for this item as an string"	| count string space |	(count _ self at: ModifierCountByte) = 0 ifTrue: [^String new].	space _ String with: Character space.	string _ String new.	1 to: count do: [:each | string _ string , (DCM convert: (self at: each + ControlSize) to: #abbrevMod) , 				(count = each						ifTrue: [String new]						ifFalse: [space])].	^string!numericModifiers	"return the modifiers for this item as an Array"	| count theArray |	(count _ self at: ModifierCountByte) = 0 ifTrue: [^Array new].	theArray _ Array new: count.	1 to: count do: [:each | theArray at: each put: (self at: each + ControlSize)].	^theArray! !!Classification methodsFor: 'comparing'!+ aClassification 	"combine the two classifications together"	| newClass allModifiers first maxClass | 	newClass _ self species new.	newClass classification: (maxClass _ (self at: ClassByte) max: (aClassification at: ClassByte)).	allModifiers _ Set new.	allModifiers addAll: self numericModifiers.	allModifiers addAll: aClassification numericModifiers.	DCM classModLinks do: [:individualSausage |		first _ individualSausage at: 1.	"classification"		maxClass = first abs			ifTrue: [2 to: individualSausage size do: [:i | (individualSausage at: i) sign ~= first sign ifTrue: [allModifiers remove: (individualSausage at: i) abs ifAbsent: []]]]].	DCM classModLinkBys do: [:individualSausage |		first _ individualSausage at: 1.	"modifier"		(allModifiers includes: first abs)			ifTrue: [2 to: individualSausage size do: [:i | ((individualSausage at: i) sign = first sign and: [maxClass ~= (individualSausage at: i) abs]) ifTrue: [allModifiers remove: first ifAbsent: []]]]].	DCM modifierLinkBys do: [:individualSausage |		first _ individualSausage at: 1.	"modifier"		(allModifiers includes: first abs)			ifTrue: [(((individualSausage select: [:i | i > 0]) inject: true into: [:flag :j | flag and: [allModifiers includes: j]]) and: [(individualSausage select: [:i | i < 0]) inject: true into: [:flag :j | flag and: [(allModifiers includes: j negated) not]]]) ifFalse: [allModifiers remove: first abs ifAbsent: []]]].	DCM modifierLinks do: [:individualSausage |		first _ individualSausage at: 1.	"modifier"		(allModifiers includes: first abs)			ifTrue: [2 to: individualSausage size do: [:i | (individualSausage at: i) sign ~= first sign ifTrue: [allModifiers remove: (individualSausage at: i) abs ifAbsent: []]]]].	allModifiers _ allModifiers asSortedCollection.	allModifiers do: [:each | newClass addModifier: each].	^newClass!< anotherClassification	| max | 	^"(anotherClassification isKindOf: self class)		and: ["(self at: ClassByte) < (anotherClassification at: ClassByte)				or: [(self at: ClassByte) = (anotherClassification at: ClassByte)						and: [max _ DCM maxModifiersFor: anotherClassification numericModifiers.							self numericModifiers inject: true into: [:less :next | less and: [max includes: next]]]]"]"!= anotherClassification	(anotherClassification isKindOf: Classification) ifFalse: [	^ false].^((anotherClassification classification = self classification) and: [anotherClassification modifiers = self modifiers])!> anotherClassification	| max | 	^"(anotherClassification isKindOf: self class)		and: ["(self at: ClassByte) > (anotherClassification at: ClassByte)				or: [(self at: ClassByte) = (anotherClassification at: ClassByte)						and: [max _ DCM maxModifiersFor: anotherClassification numericModifiers.							self numericModifiers inject: false into: [:less :next | less or: [(max includes: next) not]]]]"]"!contains: aClassification	"given that self is truly an internally consistent and valid maximum classification, answer whether something of aClassification fits within it.  It is unclear what < and > are doing, except it isn't this"	| max | 	(aClassification at: ClassByte) > (self at: ClassByte) ifTrue: [^false].	max _ self numericModifiers.	aClassification numericModifiers do: [:m | (max includes: m) ifFalse: [^false]].	^true! !!Classification methodsFor: 'converting'!convertFrom: aClassificationScheme 	"interpret this classification according to aClassificationScheme, and produce 	a new Classification with the same modifiers under this scheme"	| newClass count |	newClass _ self species new.	newClass classification: (aClassificationScheme convert: self classification to: #fullClass).	count _ self at: ModifierCountByte.	1 to: count do: [:each | 		newClass addModifier: (aClassificationScheme convert: (self at: each + ControlSize)													to: #fullMod)].	^newClass!qboxArray	^Array with: self classification with: self modifiers!setFromArray: theArray	"set the classification from the array returned by a standard classification qbox"	self initialize.	self classification: (DCM convert: (theArray at: 1) to: #classIndex).	theArray size = 2		ifTrue: [(theArray at: 2) == nil ifFalse:			[(theArray at: 2) do: [:each | self addModifier: each]]]! !!Classification methodsFor: 'displaying'!displayString	"print this compressed classification on a stream"	| aStream position modifierByte |	aStream _ WriteStream on: String new.	aStream nextPutAll: '(' , (DCM convert: self classificationIndex to: #abbrevClass).	modifierByte _ self at: ModifierCountByte.	1 to: modifierByte do: 		[:each | 		position _ each + ControlSize.		aStream space.		aStream nextPutAll: (DCM convert: (self at: position)				to: #abbrevMod)].	aStream nextPutAll: ')'.	^aStream contents!headerString	"print this compressed classification on a stream"	| aStream position modifierByte |	aStream _ WriteStream on: String new.	aStream nextPut: $(.	aStream nextPutAll: (DCM convert: self classificationIndex to: #abbrevClass).	modifierByte _ self at: ModifierCountByte.	1 to: modifierByte do: 		[:each | 		position _ each + ControlSize.		aStream nextPut: $,.		aStream nextPutAll: (DCM convert: (self at: position) to: #abbrevMod)].	aStream nextPut: $).	^aStream contents!printOn: aStream	"print this compressed classification on a stream"	aStream nextPutAll: ' (Classification array: #(', self classification.	self modifiers do: [:each | aStream space; nextPutAll: each].	aStream nextPutAll: ')) '! !!Classification methodsFor: 'save/restore'!dumpTo: aStream	"save myself on aStream"	aStream nextPutAll: self asString!readFrom: theStream	| aString | 	"read me from this stream or else"	aString _ theStream next: self size.	self replaceFrom: 1 to: self size withString: aString startingAt: 1.!storeOn: aStream	"save myself on aStream"	aStream nextPutAll: self asString! !DataItem comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.pointer is array of 3 where 1 is the certainty, 2 is the link type, and 3 is its index in some collection'!!DataItem methodsFor: 'access flag'!clearFlag	self at: FlagByte put: 0!isFlagSet	^(self at: FlagByte) == 1!setFlag	self at: FlagByte put: 1! !!DataItem methodsFor: 'access locked'!isLocked	"is the item locked"	^(self at: LockedByte) = $L asciiValue!isUnlocked	"is the item unlocked"	^(self at: LockedByte) = $U asciiValue!lock	"lock this item"	self at: LockedByte put: $L asciiValue!unlock	"lock this item"	self at: LockedByte put: $U asciiValue! !!DataItem methodsFor: 'testing'!includes: theString	"this will check an folder label to see if it contains theString"	(self label asLowercase findString: theString startingAt: 1)  = 0 ifFalse: [^true].	^false!isFolder	^(self at: TypeByte) = 1 "folder"!isItem	^(self at: TypeByte) = 2 "Item"!isKeyword	^(self at: TypeByte) = 3 "Keyword"! !!DataItem methodsFor: 'changing'!changeClassAndModifier: return	self class: (return at: 1) modifiers: (return at: 2)!changeSelfWith: return	| newDataItem | 	return size == 4		ifTrue:[newDataItem _ DataItem locked: self isLocked classification: (return at: 3) modifiers: (return at: 4) type: self type dataType: self dataType label: (return at: 1) filename: self filename bPointers: self bPointers fPointers: self fPointers atIndex: self centerIndex]			ifFalse:[newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: (return at: 1) filename: self filename bPointers: self bPointers fPointers: self fPointers atIndex: self centerIndex].	self become: newDataItem.	newDataItem _ nil!convertFrom: theOldClassScheme	| newDataItem theClass theModifiers count currentModifers theMod | 	theClass _ theOldClassScheme convert: (self at: ClassByte) to: #fullClass.	theModifiers _ OrderedCollection new.	count _ self at: ModifierCountByte.	currentModifers _ DCM fullModifiers.	1 to: count do: [:each |(currentModifers includes: (theMod _ (theOldClassScheme convert: (self at: each + ControlSize) to: #fullMod))) ifTrue: [theModifiers add: theMod ]].	newDataItem _ DataItem locked: self isLocked classification: theClass modifiers: theModifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil! !!DataItem methodsFor: 'access label'!dataType	"return the data type for this item as a Integer.	See the DataControl fileTypeString for the current icon numbers in use"	^self at: DataTypeByte!dataType: aDataType	"return the data type for this item as a Integer.	See the DataControl fileTypeString for the current icon numbers in use"	^self at: DataTypeByte put: aDataType!dataTypeUpdated	"return the updated dataType for this item"	| s | 	self dataType = 0		ifTrue: [self filename == nil					ifTrue:						[self isFolder							ifTrue: [self dataType: (DataMaster giveMe: #iconIndex for: #folder)]							ifFalse:								[self isKeyword									ifTrue: [self dataType: (DataMaster giveMe: #iconIndex for: #keyword)]]]					ifFalse: [self dataType: (DataMaster giveMe: #iconIndex for: self filename)]].	^self dataType!label	"return the label for this item as a String"	|  position return size |	size _ self at: LabelSizeByte.	(size = 0) ifTrue:[^String new].	position _ ControlSize + 1+( self at: ModifierCountByte).	return _ String new: size.	return		replaceFrom: 1		to: size		withByteArray: self		startingAt: position.	^return!label: newLabel	| newDataItem | 	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: newLabel filename: self filename bPointers: self bPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!type	"return the type for this item as a Integer.	1 = folder	2 = data item	3 = Keyword"	^self at: TypeByte!type: type	self at: TypeByte put: type!typeSymbol	"return the type for this item as a Integer.	1 = Folder	2 = Item	3 = Keyword"	^DataTypes at: (self at: TypeByte)! !!DataItem methodsFor: 'access filename'!filename	"return the keywords for this item as a String"	|  position return size |	size _ self at: FileNameSizeByte.	(size = 0) ifTrue:[^nil].	position _ ControlSize + 1+( self at: ModifierCountByte)+( self at: LabelSizeByte).	return _ String new: size.	return		replaceFrom: 1		to: size		withByteArray: self		startingAt: position.	^return!filename: newfilename	| newDataItem | 	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: newfilename bPointers: self bPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil! !!DataItem methodsFor: 'access pointers'!addBPointer: thePointer	| oldPointers newDataItem | 	oldPointers _ self bPointers. 	oldPointers == nil		ifTrue:[oldPointers _ Array with: thePointer]		ifFalse:[oldPointers _ oldPointers copyWith: thePointer].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: oldPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!addBPointer: theIndex type: type	self addBPointer: theIndex type: type certainty: DefaultCert!addBPointer: theIndex type: type certainty: cert	| oldPointers newDataItem | 	oldPointers _ self bPointers. 	oldPointers == nil		ifTrue:[oldPointers _ Array with: (DataItemPointer certainty: cert type: type index: theIndex)]		ifFalse:[oldPointers _ oldPointers copyWith: (DataItemPointer certainty: cert type: type index: theIndex)].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: oldPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!addFirstFPointer: theIndex ofType: type	self addFirstFPointer: theIndex ofType: type certainty: DefaultCert!addFirstFPointer: theIndex ofType: type certainty: cert	| oldPointers newDataItem newPointers | 	oldPointers _ self fPointers. 	newPointers _ OrderedCollection new.	oldPointers == nil		ifTrue: [newPointers _ Array with: (DataItemPointer certainty: cert type: type index: theIndex)]		ifFalse: [newPointers add: (DataItemPointer certainty: cert type: type index: theIndex).				oldPointers do: [:ptr | newPointers add: ptr]].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: newPointers asArray atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!addFPointer: thePointer	| oldPointers newDataItem | 	oldPointers _ self fPointers. 	oldPointers == nil		ifTrue:[oldPointers _ Array with: thePointer]		ifFalse:[oldPointers _ oldPointers copyWith: thePointer].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: oldPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!addFPointer: theIndex type: type	self addFPointer: theIndex type: type certainty: DefaultCert!addFPointer: theIndex type: type certainty: cert	| oldPointers newDataItem |	oldPointers _ self fPointers. 	oldPointers == nil		ifTrue:[oldPointers _ Array with: (DataItemPointer certainty: cert type: type index: theIndex)]		ifFalse:[oldPointers _ oldPointers copyWith: (DataItemPointer certainty: cert type: type index: theIndex)].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: oldPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!bpIndicesOfType: type	| ptrs rightTypedPtrs | 	ptrs _ self bPointers.	type == nil ifTrue: [^ptrs].	rightTypedPtrs _ OrderedCollection new.	ptrs == nil		ifFalse: [ptrs do: [:each | (each at: 2) = type ifTrue: [rightTypedPtrs add: (each at: 3)]]].	^rightTypedPtrs!bPointers	"Return the backward pointers for this item as an Array of pointers each pointer has 4 bytes and is translated into an array with three elements. The first element is the link type.  The second element if the certainty of the link.  The third element in the pointer is the integer index to the indicated element in the information center array"	| count tempArray position item |	(count _ self numberOfBPointers) = 0 ifTrue: [^nil].	tempArray _ Array new: count.	position _ ControlSize + 1+( self at: ModifierCountByte)+( self at: LabelSizeByte)+( self at: FileNameSizeByte).	item _ 0.	count timesRepeat:[item _ item + 1.		tempArray at: item put: (DataItemPointer with: (self at: position) with: (self at: position+1) with: (((self at: position+2)*256) +(self at: position+3))).		position _ position+4].	^tempArray!bPointersIncludes: theIndex type: type	| bPointers | 	(bPointers _ self bPointers) == nil		ifFalse:			[bPointers do: [:each | ((each at: 2) = type and: [(each at: 3) = theIndex]) ifTrue: [^true]]].	^false!bPointersOfType: type	| ptrs rightTypedPtrs | 	ptrs _ self bPointers.	type == nil ifTrue: [^ptrs].	rightTypedPtrs _ OrderedCollection new.	ptrs == nil		ifFalse: [ptrs do: [:each | (each at: 2) = type ifTrue: [rightTypedPtrs add: each]]].	^rightTypedPtrs!centerIndex	"Return the center index for this item"^(((self at: IndexByte) *256) +(self at: IndexByte+1))!centerIndex: theIndex	"Set the center index for this item"	(theIndex < 256)		ifTrue:[self at: IndexByte put: 0; at: (IndexByte+1) put: theIndex]		ifFalse:[self at: IndexByte put: (theIndex digitAt:2); at: (IndexByte+1) put: (theIndex digitAt:1)].!fpIndicesOfType: type	"return only the pointers of the desired type."	| ptrs rightTypedPtrs | 	ptrs _ self fPointers.	type == nil ifTrue: [^ptrs].	rightTypedPtrs _ OrderedCollection new.	ptrs == nil		ifFalse: [ptrs do: [:each | (each at: 2) = type ifTrue: [rightTypedPtrs add: (each at: 3)]]].	^rightTypedPtrs!fPointers	"Return the forward pointers for this item as an Array of pointers each pointer has 4 bytes and is translated into an array with three elements. The first element is the link type.  The second element if the certainty of the link.  The third element in the pointer is the integer index to the indicated element in the information center array"	| count position item tempArray |	(count _ self numberOfFPointers) = 0 ifTrue:[^nil].	tempArray _ Array new: count.	position _ ControlSize + 1 +( self at: ModifierCountByte)+( self at: LabelSizeByte)+( self at: FileNameSizeByte)+( self numberOfBPointers * 4).	item _ 0.	count timesRepeat:[item _ item + 1.		tempArray at: item put: (DataItemPointer with: (self at: position) with: (self at: position+1) with: (((self at: position+2)*256) +(self at: position+3))).		position _ position+4].	^tempArray!fPointersIncludes: theIndex type: type	| fPointers | 	(fPointers _ self fPointers) == nil		ifFalse:[fPointers do: [:each | ((each at: 2) = type and: [(each at: 3) = theIndex]) ifTrue: [^true]]].	^false!fPointersOfType: type	| ptrs rightTypedPtrs | 	ptrs _ self fPointers.	type == nil ifTrue: [^ptrs].	rightTypedPtrs _ OrderedCollection new.	ptrs == nil		ifFalse: [ptrs do: [:each | (each at: 2) = type ifTrue: [rightTypedPtrs add: each]]].	^rightTypedPtrs!insertFPointer: newPointer before: oldPointer 	| oldPointers newDataItem | 	oldPointers _ self fPointers asOrderedCollection. 	oldPointers == nil		ifTrue: [oldPointers _ Array with: newPointer]		ifFalse: [oldPointers add: newPointer before: oldPointer].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: oldPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!insertFPointer: theIndex ofType: type after: anIndex 	self insertFPointer: theIndex ofType: type certainty: DefaultCert after: anIndex!insertFPointer: theIndex ofType: type before: anIndex 	self insertFPointer: theIndex ofType: type certainty: DefaultCert before: anIndex!insertFPointer: theIndex ofType: type certainty: cert after: anIndex 	| oldPointers newDataItem newPointers | 	oldPointers _ self fPointers. 	newPointers _ OrderedCollection new.	oldPointers == nil		ifTrue: [newPointers _ Array with: (DataItemPointer certainty: cert type: type index: theIndex)]		ifFalse: [oldPointers do: [:ptr |					newPointers add: ptr.					(ptr at: 3) = anIndex ifTrue: [newPointers add: (DataItemPointer certainty: cert type: type index: theIndex)]]].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: newPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!insertFPointer: theIndex ofType: type certainty: cert before: anIndex 	| oldPointers newDataItem newPointers | 	oldPointers _ self fPointers. 	newPointers _ OrderedCollection new.	oldPointers == nil		ifTrue: [newPointers _ Array with: (DataItemPointer certainty: cert type: type index: theIndex)]		ifFalse: [oldPointers do: [:ptr |					(ptr at: 3) = anIndex ifTrue: [newPointers add: (DataItemPointer certainty: cert type: type index: theIndex)].					newPointers add: ptr]].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: newPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!numberOfBPointers	"Return the number of forward pointers for this item"^(((self at: BPointerCountByte) *256) +(self at: BPointerCountByte+1))!numberOfFPointers	"Return the number of forward pointers for this item"^(((self at: FPointerCountByte) *256) +(self at: FPointerCountByte+1))!pointersTo: anItem	| ptrs rightIndexedPtrs | 	ptrs _ self fPointers.	rightIndexedPtrs _ OrderedCollection new.	ptrs == nil		ifFalse: [ptrs do: [:each | (each index) = anItem centerIndex ifTrue: [rightIndexedPtrs add: each]]].	^rightIndexedPtrs!removeAllBPointers	| newDataItem | 	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: nil fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!removeAllFPointers	| newDataItem | 	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: nil atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!removeBPointer: thePointer	| oldPointers newDataItem | 	oldPointers _ self bPointers. 	oldPointers == nil		ifTrue:[^nil]		ifFalse:[oldPointers _ oldPointers copyWithout: thePointer].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: oldPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!removeBPointer: theIndex type: type	| oldPointers newDataItem | 	oldPointers _ self bPointers. 	oldPointers == nil		ifTrue:[^nil]		ifFalse:[oldPointers _ oldPointers copyWithout: (DataItemPointer type: type index: theIndex)].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: oldPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!removeFPointer: thePointer	| oldPointers newDataItem | 	oldPointers _ self fPointers. 	oldPointers == nil		ifTrue:[^nil]		ifFalse:[oldPointers _ oldPointers copyWithout: thePointer].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: oldPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!removeFPointer: theIndex type: type	| oldPointers newDataItem | 	oldPointers _ self fPointers. 	oldPointers == nil		ifTrue:[^nil]		ifFalse:[oldPointers _ oldPointers copyWithout: (DataItemPointer type: type index: theIndex)].	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: oldPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil!replaceFPointersWith: pointerList	| newDataItem | 	newDataItem _ DataItem locked: self isLocked classification: self classification modifiers: self modifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: pointerList atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil! !!DataItem methodsFor: 'access modifiers'!class: theClass modifiers: theModifiers	| newDataItem | 	newDataItem _ DataItem locked: self isLocked classification: theClass modifiers: theModifiers type: self type dataType: self dataType label: self label filename: self filename bPointers: self bPointers fPointers: self fPointers atIndex: self centerIndex.	self become: newDataItem.	newDataItem _ nil! !!DataItem methodsFor: 'save'!storeOn: aStream	"save myself on aStream"	| size |	size _ self size.	aStream nextPutAll: size printString.	aStream nextPut: $ .	aStream nextPutAll: self asString! !!DataItem methodsFor: 'displaying'!displayString	"return the display string for this item"	| displayStream modifiers theClassification | 	displayStream _ ExternalStream on: String new.	self isLocked ifTrue: [displayStream nextPutAll: '[locked] '].	displayStream nextPutAll: self label.	theClassification _ self classification.	modifiers _ self modifierString.	theClassification isEmpty		ifTrue:[modifiers isEmpty			ifFalse:[displayStream space; nextPut: $(;nextPutAll: modifiers ;nextPut: $)].]		ifFalse:[displayStream space;			nextPut: $(;			nextPutAll: theClassification.			modifiers isEmpty ifFalse:[displayStream space; nextPutAll: modifiers].			displayStream nextPut: $).].	^displayStream contents!hardcopyWithTypeString	"return the display and type english string for this item"	| s englishString | 	s _ self displayString. 	self filename == nil		ifTrue:			[self isFolder				ifTrue: [englishString _ #folder asString]				ifFalse:					[self isKeyword						ifTrue: [englishString _ #keyword asString]						ifFalse: [^s]]]		ifFalse: [englishString _ DataMaster giveMe: #englishString for: self filename].	^s, (String with: $  with: $~ with: $ ), englishString!iconDisplayString	"return the icon and display string for this item"	| s | 	s _ self displayString. 	self dataType = 0		ifTrue: [self filename == nil					ifTrue:						[self isFolder							ifTrue: [self dataType: (DataMaster giveMe: #iconIndex for: #folder)]							ifFalse:								[self isKeyword									ifTrue: [self dataType: (DataMaster giveMe: #iconIndex for: #keyword)]									ifFalse: [^s]]]					ifFalse: [self dataType: (DataMaster giveMe: #iconIndex for: self filename)]].	^self dataType > 0		ifTrue: [(String with: self dataType asCharacter), s]		ifFalse: [s]!printOn: aStream 	| tooMany |	tooMany _ aStream position + self maxPrint.	aStream nextPutAll: self class name, ' ('.	self do: 		[:element | 		aStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].		element printOn: aStream.		aStream space].	aStream nextPut: $)!printString	"return the icon and display string for this item"	| s | 	s _ self displayString. 	self dataType = 0		ifTrue: [self filename == nil					ifTrue:						[self isFolder							ifTrue: [self dataType: (DataMaster giveMe: #iconIndex for: #folder)]							ifFalse:								[self isKeyword									ifTrue: [self dataType: (DataMaster giveMe: #iconIndex for: #keyword)]									ifFalse: [^s]]]					ifFalse: [self dataType: (DataMaster giveMe: #iconIndex for: self filename)]].	^self dataType > 0		ifTrue: [(String with: self dataType asCharacter), s]		ifFalse: [s]! !!WordArray methodsFor: 'initialize-release'!fromFileStream: aFileStream 	"Initialize the array of bits by reading integers from the FileStream, aStream."	| sizeInBytes howManyBytesRead start increment nextStart |	Cursor read showWhile:		[		sizeInBytes _ self size bitShift: 1.		howManyBytesRead _ 0.		start _ 1.		[howManyBytesRead < sizeInBytes] whileTrue:			[			increment _ 8192 min: (sizeInBytes - howManyBytesRead).			nextStart _ start + (increment bitShift: -1).			self specialReplaceFrom: start to: (nextStart -1) with: (aFileStream next: increment) startingAt: 1.			start _ nextStart.			howManyBytesRead _ howManyBytesRead + increment.			].		].! !!WordArray methodsFor: 'filing'!toFileStream: aFileStream 	"Store the array of bits onto the FileStream, aFileStream."	 | sizeInBytes aByteArray increment howManyBytesWritten start |	Cursor write showWhile:		[		sizeInBytes _ self size bitShift: 1.		(sizeInBytes >= 8192) ifTrue: [aByteArray _ ByteArray new: (increment _ 8192)].		howManyBytesWritten _ 0.		start _ 1.		[howManyBytesWritten < sizeInBytes] whileTrue:			[			(sizeInBytes - howManyBytesWritten) < 8192 ifTrue:				[aByteArray _ ByteArray new: (increment _ sizeInBytes - howManyBytesWritten)].			aByteArray specialReplaceFrom: 1 to: increment with: self startingAt: start.			start _ start + (increment bitShift: -1).			aFileStream nextPutAll: aByteArray.			howManyBytesWritten _ howManyBytesWritten + increment.			].		].! !!WordArray methodsFor: 'special-accessing'!specialReplaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. Destructively replace elements in the receiver (a WordArray)	starting at start (a word index) with replacement (a String or ByteArray)	starting at repStart (a byte index). Answer the receiver. Note: Complete	range checks are performed by the primitive. Furthermore, the primitive	requires that:	   self is a non-pointer word-type object (such as a WordArray),	   replacement is a byte-type object (such as a String or ByteArray),	   start is a positive integer <64K,	   stop is a positive integer <64K,	   repStart is an odd positive integer <64K.	Xerox specific. See Object documentation whatIsAPrimitive."	| j |	<primitive: 177>	j _ repStart - 1.	start to: stop do:		[:i | self at: i put:			(((replacement at: (j _ j +1)) asInteger bitShift: 8) +				((replacement at: (j _ j + 1)) asInteger bitAnd: 255))]! !!String methodsFor: 'comparing'!= otherCollection 	"Answer whether the species of the receiver is the same as otherCollection's species,	and the receiver's size is the same as otherCollection's size, and each of the receiver's	elements equal the corresponding element of otherCollection."	| size index |	self == otherCollection ifTrue: [^ true].	(size _ self size) = otherCollection size ifFalse: [^false].	self species == otherCollection species ifFalse: [^false].	index _ 0.	[size >= (index _ index + 1)]		whileTrue: [(self at: index) = (otherCollection at: index) ifFalse: [^false]].	^true!isNumeric	"A rough check to determine whether I look like a number. "	self do:		[ :char |		char isDigit | char isSeparator |			(char==$.) | (char==$-) | (char==$r) | (char==$R)			| (char==$e) ifFalse:  [^false] ].	^true! !!String methodsFor: 'accessing'!findBackwardString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start and working backwards. If the receiver does not contain subString, answer 0."	| aCharacter index |	subString isEmpty ifTrue: [^0].	aCharacter _ subString first.	(start - subString size + 1) to: 1 by: -1 do:		[:startIndex |		(self at: startIndex) = aCharacter ifTrue:			[index _ 1.			[(self at: startIndex+index-1) = (subString at: index)] whileTrue:				[index = subString size ifTrue: [^startIndex].				index _ index+1]]].	^0!specialReplaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. Destructively replace elements in the receiver (a String or	ByteArray) starting at start (a byte index) with replacement (a WordArray)	starting at repStart (a word index). Answer the receiver. Note: Complete	range checks are performed by the primitive. Furthermore, the primitive	requires that:	   self is a byte-type object (such as a String or ByteArray),	   replacement is a non-pointer word-type object (such as a WordArray),	   start is a positive integer <64K,	   stop is a positive integer <64K,	   repStart is an odd positive integer <64K.	Xerox specific. See Object documentation whatIsAPrimitive."	| j useLeftHandByte characterTable |	<primitive: 176>	j _ repStart.	useLeftHandByte _ false.	characterTable _ Character characterTable.	start to: stop do:		[:i | (useLeftHandByte _ useLeftHandByte not)			ifTrue:	[self at: i put: (characterTable at: ((replacement at: j) bitShift: -8))]			ifFalse:	[self at: i put: (characterTable at: ((replacement at: j) bitAnd: 255)).					j _ j + 1]]! !!String methodsFor: 'converting'!acronym	| tokenList acronym | 	tokenList _ Scanner new scanTokens: self.	acronym _ WriteStream on: String new.	tokenList do: [:each | each class == Symbol ifTrue:[(each at: 1) isUppercase ifTrue:[acronym nextPut: (each at: 1)]]].	^acronym contents	"'Office of Management and Budget (a Federal Agency)' acronym"!asForm	^FastTextDisplayScanner new formFromString: self emphasis: 1!openFile	^FileStream fileNamed: self!openNewFile	^FileStream newFileNamed: self!openOldFile	^FileStream oldFileNamed: self!paddedToWidth: width inStyle: style font: font	"Return a copy of me which to which tabs have been appended to	make it at least <width> pixels wide in the given font.	(Peter Alfke 9/84)"	"'Hello there' paddedToWidth: 75 inStyle: TextStyle default font: 1."	| numberOfTabs tabString |	numberOfTabs _ (width negated // style tabWidth) negated -      "round upward"		(((style fontAt: font) widthOfString: self) // style tabWidth)		max: 0.	^ self, (self species new: numberOfTabs withAll: Character tab)!stripLeadingAndTrailingSpaces	"trim the leading and trailing spaces from this string "	| last i start |	last _ self size.	i _ 1.	[i <= last and: [(self at: i) = $ ]] whileTrue: [i _ i + 1].	start _ i.	start > last ifTrue: [^String new].	[last > 0 and: [(self at: last) = $ ]] whileTrue: [last _ last - 1].	^self copyFrom: start to: last!stripLeadingSpaces	"trim the leading spaces from this string "	| last i |	last _ self size.	i _ 1.	[i <= last and: [(self at: i) = $ ]] whileTrue: [i _ i + 1].	^self copyFrom: i to: last! !!String methodsFor: 'displaying'!displayAt: aPoint 	"Show a representation of the receiver as a DisplayText at location aPoint on the display screen."	self displayOn: Display at: aPoint.!displayOn: aDisplayMedium at: aPoint	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium."	FastTextDisplayScanner new		displayString: self emphasis: 1		on: aDisplayMedium at: aPoint		clippingBox: aDisplayMedium boundingBox		rule: Form over mask: nil.! !!Symbol methodsFor: 'converting'!asString	| newString len index |	newString _ String new: (len _ self size).	index _ 0.	[(index _ index + 1) <= len] whileTrue: [newString at: index put: (self at: index)].	^newString! !Label comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Label methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self!storeOn: aStream	aStream nextPutAll: '(Label fromString: '''.	aStream nextPutAll: self.	aStream nextPutAll: ''')'.! !MapTransformationTable comment:'Copyright (c) 1983, 1984 Xerox Corporation.  All Rights Reserved.'!!MapTransformationTable methodsFor: 'initialize-release'!destinationStart: yStart destinationStop: yStop	"This is the Bresenham plotting algorithm (IBM Systems Journal Vol 	4 No. 1, 1965). It chooses a principal direction, and maintains  	a potential, P.  When P's sign changes, it is time to move in the 	minor direction as well."	| x y dx dy py px P i |	self at: (x _ 1) put: (y _ yStart).	dx _ 1.	dy _ (yStop - yStart) sign.	px _ (yStop - yStart) abs.	py _ self size - 1.	py > px		ifTrue:	"more horizontal"			[P _ py // 2.			i _ 0.			[(i _ i + 1) <= py] whileTrue:				[				x _ x + dx.				(P _ P - px) < 0 ifTrue:					[y _ y + dy.					P _ P + py].				self at: x put: y				]			]		ifFalse:	"more vertical"			[P _ px // 2.			i _ 0.			[(i _ i + 1) <= px] whileTrue: 				[				y _ y + dy.				(P _ P - py) < 0 ifTrue:					[x _ x + dx.					P _ P + px].				self at: x put: y				]			]!offset: anInteger1 shiftAmount: anInteger2 scale: aNumber1 translation: aNumber2	offset _ anInteger1.	shiftAmount _ anInteger2.	scale _ aNumber1 * (1.0 timesTwoPower: 0 - shiftAmount).	translation _ (aNumber2 + (scale * offset)) truncated! !!MapTransformationTable methodsFor: 'accessing'!at: index	<primitive: 60>	index < 1 ifTrue: [^self at: 1].	^self at: self size"	^(index * scale) truncated+ translation"!offset	^offset!shiftAmount	^shiftAmount! !DataItemPointer comment:'Copyright (c)  1985, 1986 Xerox Corporation. All rights reserved.This object is an array of three elements.The first is the certainty of the link 100 is the default and means totaly certain.The  second is the link type .The third is the index of the item in its center.'!!DataItemPointer methodsFor: 'access'!certainty	^self at: 1!certainty: aCertainty	self at: 1 put: aCertainty!index	^self at: 3!index: aIndex	self at: 3 put: aIndex!linkType	^(self at: 2) max:1! !!Text methodsFor: 'comparing'!sameAs: aString	^string sameAs: aString! !!Text methodsFor: 'accessing'!findBackwardString: aString startingAt: start 	"Answer the index of subString within the receiver, starting at position start and working backwards. If the receiver does not contain subString, answer 0."	^string findBackwardString: aString asString startingAt: start! !!Text methodsFor: 'emphasis'!emphasisAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	self size = 0 ifTrue: [^(UserFont == nil ifTrue: [1] ifFalse: [UserFont])].	"null text tolerates access"	^runs at: characterIndex! !!TextLineInterval methodsFor: 'comparing'!= line 	self == line ifTrue: [^ true].	self species = line species		ifTrue: [^((start = line first and: [stop = line last])				and: [internalSpaces = line internalSpaces])				and: [paddingWidth = line paddingWidth]]		ifFalse: [^false]! !PreviewTextLineInterval comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.PreviewTextLineInterval is used to keep track of the complicated text interval for press printing and interpress printing.	instanceVariableNames: ''margins delimitorCount delimitorParameters alignment ''Instance Variable========[margins] 			this keeps the right and left margins as a point.  Furthermore it is used to display and print text.[delimitorCount] 		this accumulates the total number of delimitors in a particular line(cr, tab, run, etc).[delimitorParameters]		this is an array which takes care of the following variables.	{delimitorIndices} 	this shows the character index to where each of the delimitor is.	{delimitorPositions} 	this shows the absolute printer space from the left margin where each of the delimitor is at.	{countsBetweenDelimitors} 		this is a character count between two delimitors.	{delimitorTypes}		this gives the types of the various delimitors such as cr, run, tab, etc.	{delimitorSpaceCounts}	this is an array of integers that indicate how many spaces are in the text since the last tab or the beginning of the line.[alignment]			this is the justification information for each line.  0 = left, 1 = center, 2 = right, 3 = full'!!PreviewTextLineInterval methodsFor: 'accessing'!alignment	^alignment!alignment: anInteger	"0=left, 1=centered, 2=right,3=justified"	alignment _ anInteger \\ 4!internalSpaces: spacesInteger paddingWidth: padWidthInteger margins: lrMarginPoint alignment: alignmentInt	internalSpaces _ spacesInteger.	paddingWidth _ padWidthInteger.	margins _ lrMarginPoint.	alignment _ alignmentInt.	self initInterpressVariables!lMargin	^margins x!lMargin: anInteger	margins x: anInteger!margins	^margins!rMargin	^margins y!rMargin: anInteger	margins y: anInteger! !!PreviewTextLineInterval methodsFor: 'interpress variables manipulations'!adjustBy: offset	| index old | 	"return a line just like self except for the character index."	start _ start + offset.	stop _ stop + offset.	index _ 1.	1 to: delimitorCount do: [:i |		old _ delimitorParameters at: ((i - 1)*5 + index).		delimitorParameters at: ((i - 1)*5 + index) put: old + offset].!collectDelimitorParameter: index	| arr |	delimitorCount = 0 ifTrue: [^Array new: 5 withAll: 0].	arr _ Array new: delimitorCount.	1 to: delimitorCount do: [:i |		arr at: i put: (delimitorParameters at: ((i - 1)*5 + index))].	^arr!countsBetweenDelimitors	^self collectDelimitorParameter: 4!delimitorCount	^delimitorCount!delimitorIndices	^self collectDelimitorParameter: 1!delimitorPositions	^self collectDelimitorParameter: 2!delimitorSpaceCounts	^self collectDelimitorParameter: 5!delimitorSpaceCounts: anInteger	self setDelimitorParameters: anInteger elementIndex: 5!delimitorType: aSymbol	self setDelimitorParameters: aSymbol elementIndex: 3!delimitorTypes	^self collectDelimitorParameter: 3!growDelimitors	"Increase by half the original size."	| newSize newDelimitorParameters |	newSize _ delimitorParameters size + 20.	newDelimitorParameters _ Array new: newSize withAll: 0.	1 to: delimitorParameters size do: [:i | 		newDelimitorParameters at: i put: (delimitorParameters at: i)].	delimitorParameters _ newDelimitorParameters.!hasDelimitors	^delimitorCount > 0!initInterpressVariables	"delimitorParameters is an array of parameters. Its elements are organized so that the ith set consists of delimitorIndex, delimitorPosition, delimitorType, countsBetweenDelimitor and delimitorSpaceCount in the order specified."	delimitorCount _ 0.	delimitorParameters _ Array new: 40 withAll: 0!lastDelimitorIndex	^self delimitorIndices at: delimitorCount!remainingSpaces: lastIndex	| total spaceCounts | 	total _ 0.	spaceCounts _ self delimitorSpaceCounts.	(self delimitorIndices indexOf: lastIndex) + 1 to: delimitorCount		do: [:i | total _ total + (spaceCounts at: i)].	^total!rememberSpaceCount: spaceCount	self delimitorSpaceCounts: spaceCount"	| total counts | 	total _ 0.	counts _ self delimitorSpaceCounts.	1 to: delimitorCount - 1		do: [:i | total _ total + (counts at: i)].	self delimitorSpaceCounts: (spaceCount - total)"!reverseAdjustBy: offset untilTypeIs: anArray	| index oldType types i old | 	"add offset to positions until the type aSymbol is found or changes exhausted."	types _ self delimitorTypes.	i _ delimitorCount.	[i >= 1] whileTrue: 	[old _ delimitorParameters at: ((i - 1)*5 + 2).	delimitorParameters at: ((i - 1)*5 + 2) put: old + offset.	("delimitorParameters at: ((i - 1)*5 + 3)"anArray includes: (types at: i))		ifTrue: [i _ 0]		ifFalse: [i _ i - 1]].	paddingWidth _ paddingWidth > offset ifTrue: [paddingWidth - offset] ifFalse: [0]!setDelimitorParameters: someValue at: ith elementIndex: index	delimitorParameters at: ((ith - 1)*5 + index) put: someValue!setDelimitorParameters: someValue elementIndex: index	delimitorParameters at: ((delimitorCount - 1)*5 + index) put: someValue!spaceCountsUpToNextDelimitor: lastIndex	| spaceCounts index | 	delimitorCount = 0		ifTrue: [^0].	spaceCounts _ self delimitorSpaceCounts.	index _ self delimitorIndices indexOf: lastIndex.	index = 0 ifTrue: [^0].	^index < delimitorCount		ifTrue: [(spaceCounts at: (index + 1)) - (spaceCounts at: index)]		ifFalse: [internalSpaces - (spaceCounts at: index)]!stop: stopInteger	| old next newCount indices types | 	"Set the stopping point in the string of the line to be stopInteger."	super stop: stopInteger.	indices _ self delimitorIndices.	types _ self delimitorTypes.	[delimitorCount > 0 and: [(indices at: delimitorCount) > stopInteger]]		whileTrue: ["indices at: delimitorCount put: 0.					positions at: delimitorCount put: 0.					types at: delimitorCount put: nil".					delimitorCount _ delimitorCount - 1].	old _ start - 1.	1 to: delimitorCount do: [:i |		self setDelimitorParameters: (newCount _ (next _ indices at: i) - old max: 0) at: i elementIndex: 4.		((types at: i) == #tab or: [(types at: i)  == #runTab])			ifTrue: [self setDelimitorParameters: (newCount - 1 max: 0) at: i elementIndex: 4].		old _ next ]!updateInterpressVarCharIndex: anInteger	"Update Interpress delimitorIndices."	self setDelimitorParameters: anInteger elementIndex: 1!updateInterpressVarPos: newPos type: newType	"Various Interpress variables are updated."	delimitorCount _ delimitorCount + 1.	delimitorParameters size < (delimitorCount*5)		ifTrue: [self growDelimitors].	self setDelimitorParameters: newPos elementIndex: 2.	self setDelimitorParameters: newType elementIndex: 3! !!PreviewTextLineInterval methodsFor: 'justification related'!ignoredSpaceCounts	"return space counts before all tabs."	| lastTab | 	^(lastTab _ self lastTab) = 0		ifTrue: [0]		ifFalse: [self delimitorSpaceCounts at: lastTab]!justifiedPad	"justification starts after the last tab, so ignor the spaces come prior to all tabs."	| count | 	count _ internalSpaces - self ignoredSpaceCounts.	^count > 0		ifTrue: [paddingWidth //count]		ifFalse: [0]!lastTab	"return the index to the last tab."	| types lastTab continue | 	types _ self delimitorTypes.	lastTab _ delimitorCount +1.	continue _ true.	[continue and: [lastTab > 1]]	whileTrue: [lastTab _ lastTab - 1.				continue _ (types at: lastTab) == #run].	^continue		ifTrue: [0]		ifFalse: [lastTab]!nextTabIndexFrom: startIndex	"return the index of the next tab starting at startIndex. If none found, startIndex is returned."	 | type types | 	types _ self delimitorTypes.	startIndex + 1 to: delimitorCount do: [:i |		type _ types at: i.		(type == #tab or: [type == #runTab])			ifTrue: [^i]].	^startIndex!positionAt: lastIndex	"return the absolute position of lastIndex from the left margin. This should only be called when a change is recorded at lastIndex."	^self delimitorPositions at: (self delimitorIndices indexOf: lastIndex)!startJustify: anIndex	"check if anIndex is after all tabs. return true if no more tabs follows anIndex, false otherwise."	| lastTabIndex | 	lastTabIndex _ self lastTab.	^lastTabIndex = 0		or: [anIndex > (self delimitorIndices at: lastTabIndex)]! !!Semaphore methodsFor: 'mutual exclusion'!critical: mutuallyExcludedBlock 	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in the 	process of running the critical: message.  If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue |	self wait.	blockValue _ Signal do: mutuallyExcludedBlock		onUnwindDo: [self signal]. "release lock if not continuing"	self signal.	^blockValue! !!OrderedCollection methodsFor: 'adding'!add: newObject atIndex: apparentIndex	"insert newObject at apparentIndex (the index as seen from the outside world);		this means what is at that index now, and everything after, is moved down one place"	| realIndex |	realIndex _ self realIndexFrom: apparentIndex.	(apparentIndex < 1 or: [realIndex > (lastIndex + 1)])		ifTrue: [self errorNoSuchElement].	self insert: newObject before: realIndex! !!OrderedCollection methodsFor: 'removing'!removeObjectAt: apparentIndex	"remove object at apparentIndex (the index as seen from the outside world)"	| realIndex theObject |	realIndex _ self realIndexFrom: apparentIndex.	(apparentIndex < 1 or: [realIndex > lastIndex])		ifTrue: [self errorNoSuchElement].	theObject _ self basicAt: realIndex.	self removeIndex: realIndex.	^ theObject! !!OrderedCollection methodsFor: 'private'!realIndexFrom: apparentIndex	"returns the internal index corresponding to		the apparentIndex'th object in the collection" 	^(apparentIndex + firstIndex - 1)! !FixedFileFilter comment:'FixedFileFilter (Copyright (c) Xerox Corporation, 1984, 1985, 1986. All rights reserved.) produces a special object for use by FixedFileStream when filtering records.  It is produced by parsing a string containing a query (see comments in class method - on: ).  Numerous querying methods of the FixedFileStream expect one of theese filters as an argument.'!!FixedFileFilter methodsFor: 'private'!constructFilterFrom: aString 	"this allows a filter to be constructed to check a 	FixedFileStream's records against.  The parser functions as a state machine which determines the type of a new token based upon its previous state."	| startCharacter nextEnd nextToken state thisFilter quote|	startCharacter _ 1.	quote _ '''' at: 1.	thisFilter _ #($* $* $* $*).	state _ 4.	[startCharacter <= aString size]		whileTrue: 			[(aString at: startCharacter) = quote				ifTrue:[nextEnd _ (aString findString: '''' startingAt: startCharacter + 1) + 1.						nextEnd = 0 ifTrue:[nextEnd _ aString size + 1].						[nextEnd <= aString size							ifTrue:[(aString at: nextEnd) = quote]							ifFalse:[false]]							whileTrue:[nextEnd _ (aString findString: '''' startingAt: startCharacter + 1) + 1.								nextEnd = 0 ifTrue:[nextEnd _ aString size + 1]].						nextToken _ aString copyFrom: startCharacter to: nextEnd - 1]				ifFalse:[[(aString at: startCharacter) = Character space] 							whileTrue: [startCharacter _ startCharacter + 1].						nextEnd _ aString findString: ' ' startingAt: startCharacter.						nextEnd = 0 ifTrue:[nextEnd _ aString size + 1].						nextToken _ aString copyFrom: startCharacter to: nextEnd - 1].			state = 2				ifTrue: 					[state _ 3.					thisFilter at: state put: (Compiler evaluate: nextToken).					self add: thisFilter.					thisFilter _ OopConservingDictionary new]				ifFalse: [state = 1						ifTrue: 							[state _ 2.							thisFilter at: state put: (nextToken asSymbol)]						ifFalse: [state = 4								ifTrue: 									[state _ 1.									thisFilter at: state put: (nextToken asSymbol)]								ifFalse: [state = 3										ifTrue: 											[state _ 4.											thisFilter at: state put: (nextToken asSymbol)]]]].			startCharacter _ nextEnd + 1].	^self! !!SortedCollection methodsFor: 'comparing'!= aSortedCollection 	"Answer true if my and aSortedCollection's species are the same,	and if our blocks are the same, and if our elements are the same."	self == aSortedCollection ifTrue: [^ true].	self species = aSortedCollection species ifFalse: [^false].	sortBlock = aSortedCollection sortBlock		ifTrue: [^super = aSortedCollection]		ifFalse: [^false]! !!SortedCollection methodsFor: 'private'!sort: i to: j 	"Sort elements i through j of self to be nondescending according to sortBlock."	"Use heapsort algorithm from 'Numerical Recipies' (Press, Flannery, Teukolsky, Vetterling) p. 231."	| n l r a b t |	(n _ j + 1 - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	n = 2		ifTrue:  "Just two elements - at most one swap."			[(sortBlock value: (self basicAt: i) value: (self basicAt: j)) "i.e., should i precede j?"				ifFalse: 					[self swap: i with: j].			^self].	l _ n // 2 + i.	r _ j.	[true] whileTrue:		[		l > i			ifTrue:				[l _ l - 1.				t _ self basicAt: l]			ifFalse:				[t _ self basicAt: r.				self basicAt: r put: (self basicAt: i).				r _ r - 1.				r = i					ifTrue:						[self basicAt: i put: t.						^self]].		a _ l.		b _ l + l - i + 1.		[b <= r] whileTrue:			[			(b < r and: [(sortBlock value: (self basicAt: b) value: (self basicAt: b+1))]) ifTrue: [b _ b + 1].			(sortBlock value: t value: (self basicAt: b))				ifTrue:					[self basicAt: a put: (self basicAt: b).					a _ b.					b _ b + b - i + 1]				ifFalse:					[b _ r + 1].			].		self basicAt: a put: t.		].! !SerialPort comment:'This class provides the asynchronous communication with the external device by using RS232C port. The client can send or receive the data frame(block) of the arbitrary size.The usual sequence of using this interface is as follow.1. Create a instance of this class.2. Open the port.3. Set the parameters.4. Reset the port.5. Start communicating by setting the appropriate control line on.6. Send or receive data7. End communicating by setting the appropriate control line off.8. Close the port.The default parameter values are as follows.line speed => 1200 bpscharacter length => 7 bitsthe number of stop bits => 1parity => oddframe timeout => 0 millisecondsthe internal buffer size => 512 bytesthe number of input buffers => 12the number of output buffers => 4Note that, on input,  the frame timeout occur when the next data byte does not arrive within the specified milliseconds since the last data byte arrives. However, the statsu of the input frame(block) is set the success. The value zero of the frame timeout means the infinite timeout.The client must take care about the following things.1. The client must close the port when you finish using it. Otherwise, the port can not be open any more.2. Keep the inernal buffer space smaller. The client should set the parameters, the buffer size, the number of input/output buffer, with the amount just necessary for your communication. Using the large amount of the internal buffer space may cause the system down.'!!SerialPort methodsFor: 'public channel management'!close	"Delete the channel and set 0 into the instance variable."	self delete.	portNumber _ 0!open: number	"Create the channel and set the port number into the instance variable"	portNumber _ 0.	self create: number.	portNumber _ number!port	"Answer the port number currently used."	(portNumber = nil) ifTrue: [portNumber _ 0].	^portNumber!reset	"Initialize the channel status and the internal buffers and validate parameters.	DTR(Data Terminal Ready) and RTS(Request To Send) is reset to off"	<primitive: 203>		^self primitiveFailed! !!SerialPort methodsFor: 'channel management'!create: number	"Create the channel on the given port number. the port number starts at 1."	<primitive: 201>		^self primitiveFailed!delete	"Delete the channel."	<primitive: 202>		^self primitiveFailed! !!SerialPort methodsFor: 'public sending/receiving'!receive: aByteArray startingAt: startIndex signal: semaphore	"Receive the data frame(block) from serial line into aByteArray.	The received data is stored into bytes starting from startIndex + 4.	The status of the receiving is stored into a byte at startIndex + 1.	The data count is stored into bytes at startIndex + 2 and startIndex + 3.	The startIndex must be a even number.	The data space in aByteArray must be larger than the intenal buffer size.	However, you can not receive the data more than the internal buffer size at one time.	The semaphore will be signaled after the receiving is completed"	<primitive: 206>	^self primitiveFailed!receivingDataCount: aByteArray startingAt: index	"Answer the number of receiving data."	^(aByteArray at: (index + 2)) * 256 + (aByteArray at: (index + 3))!receivingStatus: aByteArray startingAt: index	"Answer aSymbol representing the receiving status."	| status |	status _ aByteArray at: index + 1.	^(self inputStatusList) at: status!sendAndStatus: aByteArray startingAt: startIndex size: dataSize signal: semaphore	"Send the data frame(block) in aByteArray onto the serial line and return the aSymbol representing the output status.	The dataSize must be less than the internal buffer size.	The semaphore will be signaled after sending is completed."	^self sendingStatus: 		(self send: aByteArray startingAt: startIndex size: dataSize signal: semaphore)!sendBreak	"Transmit a break on the serial line."	^self writeStatus: (ParameterIndices at: #sendBreak) with: 0! !!SerialPort methodsFor: 'sending/receiving'!inputStatusList	"Answer the list of the input ststus."	^#(success aborted dataLost deviceError frameTimeout parityError invalidChar others requestTimeout)!outputStatusList	"Answer the list of the output ststus."	^#(success others)!send: aByteArray startingAt: startIndex size: dataSize signal: semaphore	"Send the data frame(block) in aByteArray onto the serial line and return aSmallInteger representing the output status.	The dataSize must be less than the internal buffer size.	The semaphore will be signaled after sending is completed."	<primitive: 207>	^self primitiveFailed!sendingStatus: number	"Answer aString representing the sending status."	^(self outputStatusList) at: number! !!SerialPort methodsFor: 'public line state'!breakDetected	"Answer whether the break is detected."	((self readStatus: (ParameterIndices at: #breakDetected)) = 1)		ifTrue: [^true]		ifFalse: [^false]!resetBreakDetected	"Clear the latched break detection."	self writeStatus: (ParameterIndices at: #breakDetected) with: 0!setDTROff	"Set DTR(Data Terminal Ready) off."	self writeStatus: (ParameterIndices at: #dataTerminalReady) with: 2!setDTROn	"Set DTR(Data Terminal Ready) on."	self writeStatus: (ParameterIndices at: #dataTerminalReady) with: 1!setRTSOff	"Set RTS(Request To Send) off."	self writeStatus: (ParameterIndices at: #requestToSend) with: 2!setRTSOn	"Set RTS(Request To Send) on."	self writeStatus: (ParameterIndices at: #requestToSend) with: 1!stateOfCTS	"Answer the state of CTS(Clear To Send)."	((self readStatus: (ParameterIndices at: #clearToSend)) = 1)		ifTrue: [^true]		ifFalse: [^false]!stateOfDCD	"Answer the state of DCD(Data Carrier Detect)."	((self readStatus: (ParameterIndices at: #dataCarrierDetect)) = 1)		ifTrue: [^true]		ifFalse: [^false]!stateOfDSR	"Answer the state of DSR(Data Set Ready)."	((self readStatus: (ParameterIndices at: #dataSetReady)) = 1)		ifTrue: [^true]		ifFalse: [^false]! !!SerialPort methodsFor: 'public internal buffers'!bufferSize	"Answer the maximum data size in a frame(block) in bytes. Default is 512"	^self readStatus: (ParameterIndices at: #bufferSize)!bufferSize: size	"Set the maximum data size in a frame(block) in byte.	 The client should set a reasonable size. Default is 512"	^self writeStatus: (ParameterIndices at: #bufferSize) with: size!inputBuffers	"Answer the number of internal input buffers. Default is 12"	^self readStatus: (ParameterIndices at: #numOfInputBuffers)!inputBuffers: number	"Set the number of internal input buffers. The client should set a reasonable number. Default is 12"	^self writeStatus: (ParameterIndices at: #numOfInputBuffers) with: number!outputBuffers	"Answer the number of internal output buffers. Default is 4"	^self readStatus: (ParameterIndices at: #numOfOutputBuffers)!outputBuffers: number	"Set the number of internal output buffer. The client should set a reasonable number. Default is 4"	^self writeStatus: (ParameterIndices at: #numOfOutputBuffers) with: number! !!SerialPort methodsFor: 'public parameters'!charLength	"Answer the character length."	^self readStatus: (ParameterIndices at: #characterLength)!charLength: length	"Set the character length. The length should be one of followings.	 5, 6, 7, 8. The default length is 8."	((length >= 5) and: [length <= 8])		ifTrue: [^self writeStatus: (ParameterIndices at: #characterLength) with: length]		ifFalse: [^self error: 'Invalid parameter value']!frameTimeout	"Answer the frame timeout in millisecond."	^self readStatus: (ParameterIndices at: #frameTimeout)!frameTimeout: time	"Set the frame timeout in millisecond. The time should be positive aSmallInteger.	 The default frame timeout is 0 that means an infinite frame timeout."	^self writeStatus: (ParameterIndices at: #frameTimeout) with: time!lineSpeed	"Answer the current line speed in bps"	| value |	value _ self readStatus: (ParameterIndices at: #lineSpeed).	^(self lineSpeedList) at: value!lineSpeed: bps	"Set the line speed. The line speed should be one of the followings.	 50, 75, 110, 134(134.5), 150, 300, 600, 1200, 2400, 3600, 4800, 7200, 9600.	 The default line speed is 1200 bps."	| value |	value _ 0.	(self lineSpeedList) do: [ :element | value _ value + 1.		bps = element ifTrue: [^self writeStatus: (ParameterIndices at: #lineSpeed) with: value]].	^self error: 'Invalid parameter value'!lineSpeedList	"Answer the list of the available line speed in bps"	^#(50 75 10 134 150 300 600 1200 2400 3600 4800 7200 9600 19200 28800 38400 48000 56000 57600)!numOfSyncCharacter	"Answer the number of the synchronization characters."	^self readStatus: (ParameterIndices at: #syncCount)!numOfSyncCharacter: value	"Set the number of the synchronization characters."	((value >= 0) and: [value <= 7])		ifTrue: [self writeStatus: (ParameterIndices at: #syncCount) with: value]		ifFalse: [^self error: 'invalid parameter value']!parity	"Answer aSymbol representing the parity."	| value |	value _ self readStatus: (ParameterIndices at: #parity).	^(self parityList) at: value!parity: aSymbol	"Set the parity specified by aSymbol."	| value |	value _ 0.	(self parityList) do: [ :element | value _ value + 1.		aSymbol = element ifTrue: [^self writeStatus: (ParameterIndices at: #parity) with: value]].	^self error: 'Invalid parameter value'!parityList	"Answer the list of the parities."	^#(none odd even)!stopBits	"Answer the number of the stop bits."	^self readStatus: (ParameterIndices at: #stopBits)!stopBits: number	"Set the number of the stop bits. The number should be one of two, 1 or 2.	 The default stop bits is 1."	(number = 1 or: [number = 2]) ifTrue: [^self writeStatus: (ParameterIndices at: #stopBits) with: number].	^self error: 'Invalid parameter value'!syncCharacter	"Answer the synchronization character."	^self readStatus: (ParameterIndices at: #syncCharacter)!syncCharacter: value	"Set the synchronization character."	((value >= 0) and: [value <= 255])		ifTrue: [self writeStatus: (ParameterIndices at: #syncCharacter) with: value]		ifFalse: [^self error: 'invalid parameter value']! !!SerialPort methodsFor: 'private'!readStatus: index	"Answer the value of the parameter specified by index."	<primitive: 204>	^self primitiveFailed!writeStatus: index with: value	"Set value as the value of the parameter specified by index."	<primitive: 205>	^self primitiveFailed! !!SerialPort methodsFor: 'Tiger private'!inputRequestTimeout	"Answer the timeout of the input request in millisecond."	^self readStatus: (ParameterIndices at: #inputRequestTimeout)!inputRequestTimeout: time	"Set the timeout of the input request in millisecond. The time should be positive aSmallInteger.	 The default frame timeout is 0 that means an infinite timeout."	^self writeStatus: (ParameterIndices at: #inputRequestTimeout) with: time!lineSpeed: speed charLength: length stopBits: number parity: aSymbol frameTimeout: time1 inputRequestTimeout: time2	"Set parameters. Note that this method does't initialize the communication."	self lineSpeed: speed.	self charLength: length.	self stopBits: number.	self parity: aSymbol.	self frameTimeout: time1.	self inputRequestTimeout: time2!threshold	"Answer the threshold number of internal input buffers."	^self readStatus: (ParameterIndices at: #thresholdNumOfInput)!threshold: number	"Set the threshold number of internal input buffers.	When the number of the empty input buffers get less than the threshold number,	some efforts will be done to avoid losing data. The default number is 0."	^self writeStatus: (ParameterIndices at: #thresholdNumOfInput) with: number! !AsyncSerialPort comment:'Copyright (c) Xerox Corporation, 1985, 1986.'!!AsyncSerialPort methodsFor: 'initialize/release'!initByteInputArray	byteInputArray _ ByteArray new: 6148. "happen to use this size to be able to get full 1100 buffer load 6K + 4"	currentPos _ lastPos _ 6148	"when currentPos = lastPos, need to refill array"!initialize	"dummy - to allow use of a Test*AsyncSerialPort"!open: number	self initialize.	super open: number.	self standardSettings.	aSemaphore _ Semaphore new.	self reset.	self setDTROn!release	self close.	super release!reset	super reset.	self initByteInputArray!standardSettings	self lineSpeed: 9600 charLength: 8 stopBits: 1 parity: #none frameTimeout: 25 inputRequestTimeout: 1.	self threshold: 4.	self bufferSize: 512! !!AsyncSerialPort methodsFor: 'external in/out'!inputBufferEmpty	"return true if the input buffer is empty, otherwise return false"	(currentPos >= lastPos) ifTrue:		["try to refill byteInputArray"		self receive: byteInputArray startingAt: 1 signal: aSemaphore.		"((status _ self receivingStatus: byteInputArray startingAt: 1) = #success or: [status = #requestTimeout]) ifFalse: [Transcript cr; show: status asString]."		aSemaphore wait.	"the port should be set up so that it will come back right away even if 0 bytes have been received"		lastPos _ ((byteInputArray at: 3) bitShift: 8) + (byteInputArray at: 4) + 5.	"num bytes received + the initial overhead"		currentPos _ 5.		(currentPos = lastPos) ifTrue: [^true]		].	^ false!nextByte	"return the next byte"	| theByte status |	(currentPos >= lastPos) ifTrue:		["refill byteInputArray"		self receive: byteInputArray startingAt: 1 signal: aSemaphore.		"((status _ self receivingStatus: byteInputArray startingAt: 1) = #success or: [status = #requestTimeout]) ifFalse: [Transcript cr; show: status asString]."		aSemaphore wait.	"the port should be set up so that it will come back right away even if 0 bytes have been received"		lastPos _ ((byteInputArray at: 3) bitShift: 8) + (byteInputArray at: 4) + 5.	"num bytes received + the initial overhead"		currentPos _ 5.		(currentPos = lastPos) ifTrue: [^NoData]  "buffer empty"		].	theByte _ (byteInputArray at: currentPos) bitAnd: 127.	currentPos _ currentPos + 1.	^ theByte!sendByteCollection: aByteCollection	"send aByteCollection to RS232"	| byteArray start end |	(aByteCollection isKindOf: ByteArray)		ifFalse:			[byteArray _ ByteArray new: aByteCollection size.			byteArray replaceFrom: 1 to: byteArray size with: aByteCollection startingAt: 1]		ifTrue: [byteArray _ aByteCollection].	start _ 1.	end _ byteArray size min: 512.	[[(self sendAndStatus: byteArray startingAt: start size: end - start + 1 signal: aSemaphore) == #success] whileFalse.	aSemaphore wait.	end < byteArray size]		whileTrue:			[start _ end + 1.			end _ byteArray size.			(end - start + 1) > 512 ifTrue: [end _ start + 511]]!sendTextString: aString	"send aString to RS232. Probably should check for stDEL to asciiDEL conversion. Only check last character for CR to Xoff conversion"	| byteArray start end |	byteArray _ ByteArray new: aString size.	byteArray replaceFrom: 1 to: byteArray size withString: aString startingAt: 1.	(byteArray at: byteArray size) = 16rD "CR"		ifTrue: [byteArray at: byteArray size put: 16r13 "Xoff"].	start _ 1.	end _ byteArray size min: 512.	[[(self sendAndStatus: byteArray startingAt: start size: end - start + 1 signal: aSemaphore) == #success] whileFalse.	aSemaphore wait.	end < byteArray size]		whileTrue:			[start _ end + 1.			end _ byteArray size.			(end - start + 1) > 512 ifTrue: [end _ start + 511]]! !Test1108AsyncSerialPort comment:'Copyright (c) Xerox Corporation, 1985, 1986.'!!Test1108AsyncSerialPort methodsFor: 'avoid primitive calls for file input'!create: number		fileInput ifFalse: [super create: number]!delete	fileInput ifFalse: [super delete]!readStatus: index	fileInput		ifFalse:			[^super readStatus: index]		ifTrue:			[^0]!receive: aByteArray startingAt: startIndex signal: theSemaphore	| numChars | 	fileInput		ifFalse:			[super receive: aByteArray startingAt: startIndex signal: theSemaphore]		ifTrue:			[numChars _ aByteArray size - startIndex - 3.			 aByteArray				at: startIndex + 2 put: ((numChars bitShift: -8) bitAnd: 8r377);				at: startIndex + 3 put: (numChars bitAnd: 8r377).			 startIndex +4 to: startIndex + numChars + 3 do:				[:i | testFileStream atEnd ifTrue: [testFileStream reset].				aByteArray at: i put: testFileStream next].			 theSemaphore signal]!send: aByteArray startingAt: startIndex size: dataSize signal: theSemaphore	fileInput		ifFalse:			[^super send: aByteArray startingAt: startIndex size: dataSize signal: theSemaphore]		ifTrue:			[theSemaphore signal. ^1]!writeStatus: index with: value	fileInput		ifFalse:			[^super writeStatus: index with: value]		ifTrue:			[^0]! !!Test1108AsyncSerialPort methodsFor: 'external in/out'!inputBufferEmpty	"this hack assumes anyone who is asking plans to continue trying to receive if this returns true. It will never be empty if input is coming from a file, however, so in that case return true"	fileInput		ifTrue: [^true]		ifFalse: [^super inputBufferEmpty]!nextByte	"return the next byte"	| theByte |	theByte _ super nextByte.	(saveInput and: [theByte ~= NoData]) ifTrue: [saveFileStream nextPut: theByte asCharacter].	^ theByte! !!Test1108AsyncSerialPort methodsFor: 'initialize/release'!initialize	(fileInput _ self confirm: 'Get input from file?') ifTrue:		[testFileStream _ (FileStream fileNamed: 'safe-capture.data') binary readOnly].	(saveInput _ self confirm: 'Save input in a file?') ifTrue:		[FillInTheBlank			request: 'name file to put all input to'			displayAt: Sensor mousePoint			centered: true			action: [:answer | saveFileStream _ (FileStream fileNamed: answer asFileName)] 			initialAnswer: 'allInput-keep-file'].	super initialize"form1-fixedNoData-capture.data""Nomad-noDatafixed-capture.data""NomadScreen.capture""safe-capture.data""Nomad-underlines-capture.data""OCRServ-captured.data""SlidingLineOnForm-capture.data""OCRServ-more-capture.data" "ezprint-capture.data""SafeT-capture1.data""Safe2-createProfile-capture.data""Safe2-captureSplits.data""IBM-Jun29-83.data""IBM-Aug31-1.data""IBM-Aug31-funcKey-1.data""IBM-Aug31-funcKey-2.data""IBM-OCT5-1.data""IBM-OCT5-2.data""IBM-OCT5-3.data""IBM-Jan7-83-1.data""IBM-Jan7-83-2.data""IBM-Jan7-83-3.data""LE-Aug-83-funcKeyTest.data""LE-Jan-84-highlightTest.data""RS232-CAM-test.data""RS232-timetest.data""LE-Jun-84-underlineTest.data""Safe.data""safe2.data""Aim-functionKeys.data""under""fullScreen-testfileftpUserSendResponsesftpUserReceiveResponsesftpServerStoreResponsesftpServerRetrieveResponses""uncl-Tek1-data""uncl-Tek2-data""tek-timing.data""tack""Tek-capture1.data" "Tek-grid-capture.data""Smoking-noDataFixed-capture.data""US-capture.data""World-noDataFixed-capture.data"!makeFakeInputBuffer	"For time testing from file only"	| numChars |	testFileStream reset.	self initByteInputArray.	numChars _ testFileStream size min: byteInputArray size - 1.	5 to: numChars + 4 do:		[:i | byteInputArray at: i put: testFileStream next].	testFileStream reset.	lastPos _ numChars + 5.	currentPos _ 5.!release	fileInput ifTrue: [testFileStream close].	saveInput ifTrue: [saveFileStream close].	super release!reset	fileInput		ifTrue: [self initByteInputArray]		ifFalse: [super reset]! !ClassificationScheme comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!ClassificationScheme methodsFor: 'accessing'!abbrevClassifs	^abbrevClassifs!abbrevModifiers	^abbrevModifiers!classModLinkBys	^classModLinkBys!classModLinks	^classModLinks!convert: anObject to: aSymbol 	"convert anObject (which is either a string or a number) to the appropriate 	return "	| stringWasInput index returnArray searchArray |	stringWasInput _ anObject isKindOf: String.	"return the index for either a classification or modifier, either in abbreviated or full form"	aSymbol == #classIndex ifTrue: 		[stringWasInput			ifTrue: 				[(index _ abbrevClassifs findFirst: [:each | each = anObject]) = 0 					ifTrue: [(index _ fullClassifs findFirst: [:each | each = anObject]) = 0 ifTrue: [^1]].				^index]			ifFalse: [^anObject]].	aSymbol == #modIndex ifTrue: 		[stringWasInput			ifTrue: 				[(index _ abbrevModifiers findFirst: [:each | each = anObject]) = 0 					ifTrue: [(index _ modifiers findFirst: [:each | each = anObject]) = 0 ifTrue: [^1]].				^index]			ifFalse: [^anObject]].	"now search the appropriate list for the indicated element, and return the element from the list specified"	aSymbol == #fullClass ifTrue: [returnArray _ fullClassifs].	aSymbol == #abbrevClass ifTrue: [returnArray _ abbrevClassifs].	aSymbol == #fullMod ifTrue: [returnArray _ modifiers].	aSymbol == #abbrevMod ifTrue: [returnArray _ abbrevModifiers].	stringWasInput		ifTrue: 			[aSymbol == #fullClass ifTrue: [searchArray _  abbrevClassifs].			aSymbol == #abbrevClass ifTrue: [searchArray _fullClassifs].			aSymbol == #fullMod ifTrue: [searchArray _ abbrevModifiers].			aSymbol == #abbrevMod ifTrue: [searchArray _ modifiers].			(index _ searchArray findFirst: [:each | each = anObject]) = 0					ifTrue: [^returnArray at: 1].			^returnArray at: index]		ifFalse: [anObject == nil ifTrue:[^returnArray at: 1].				anObject = 0 ifTrue:[^returnArray at: 1].				^returnArray at: anObject]!fullClassifs	^fullClassifs!fullModifiers	^modifiers!id	^id!linkBys	| linkBys eachLink clinks mlinks | 	linkBys _ OrderedCollection new.	1 to: modifiers size do: [:i |		eachLink _ OrderedCollection new.		clinks _ classModLinkBys select: [:each | each first = i].		mlinks _ modifierLinkBys select: [:each | each first = i].		clinks isEmpty			ifFalse: [clinks do: [:arr | 2 to: arr size do: [:j | eachLink add: (Point x: 1 y: (arr at: j))]]].		mlinks isEmpty			ifFalse: [mlinks do: [:arr | 2 to: arr size do: [:j | eachLink add: (Point x: 2 y: (arr at: j))]]].		eachLink isEmpty			ifFalse: [eachLink addFirst: (Point x: 2 y: i).					linkBys add: eachLink]].	^linkBys!maxModifiersFor: arrOfModifiers	| maxLinks | 	maxLinks _ Set new.	modifierLinks do: [:aLink |		(arrOfModifiers includes: aLink first abs)			ifTrue: [2 to: aLink size do: [:j | (aLink at: j) < 0 ifTrue: [maxLinks add: (aLink at: j)]]]			ifFalse: [2 to: aLink size do: [:j | ((aLink at: j) < 0 and: [arrOfModifiers includes: (aLink at: j) abs]) ifTrue: [maxLinks add: aLink first abs]]]].	^arrOfModifiers, maxLinks asOrderedCollection asArray!maxSize	^(modifiers size + Classification controlSize)!modifierLinkBys	^modifierLinkBys!modifierLinks	^modifierLinks!modifiers	^abbrevModifiers!totalLinks	| links eachLink | 	links _ OrderedCollection new.	classModLinks do: [:individualSusage |		eachLink _ OrderedCollection new.		eachLink add: (Point x: 1 y: individualSusage first).		2 to: individualSusage size do: [:i | eachLink add: (Point x: 2 y: (individualSusage at: i))].		links add: eachLink].	modifierLinks do: [:individualSusage |		eachLink _ OrderedCollection new.		eachLink add: (Point x: 2 y: individualSusage first).		2 to: individualSusage size do: [:i | eachLink add: (Point x: 2 y: (individualSusage at: i))].		links add: eachLink].	^links! !!ClassificationScheme methodsFor: 'qbox accessing'!getNewClassification: defaults	"generate a Q-box to display the current classification of the data item and allow the user to change it."	^self getNewClassification: defaults title: 'Change Classification'!getNewClassification: defaults title: titleString	"generate a Q-box to display the current classification of the data item and allow the user to change it."	^self getNewClassification: defaults			title: titleString			appendLabel: OrderedCollection new			types: OrderedCollection new			defaults: OrderedCollection new!getNewClassification: defaults title: titleString appendLabel: labelArray types: selectArray defaults: defaultArray	^self getNewClassification: defaults title: titleString appendLabel: labelArray types: selectArray defaults: defaultArray links: OrderedCollection new!getNewClassification: defaults title: titleString appendLabel: labelArray types: selectArray defaults: defaultArray links: linkArray	"generate a Q-box to display the current classification of the data item and allow the user to change it."	| answer returnArray size ans |	size _ labelArray size.	defaults == nil		ifFalse: [returnArray _ self setUpDBoxStartingAt: size + 1.				1 to: ((returnArray at:1) size)  do: [:each|					labelArray add: ((returnArray at: 1) at: each).					selectArray add: ((returnArray at: 2) at: each)].				defaultArray add: (defaults at: 1); add: (defaults at: 2).				linkArray addAll: (returnArray at: 3)].	answer _DBoxView		openFor: selectArray		title: titleString		labels: labelArray		defaults: defaultArray		commands: #( accept cancel bailOut)		autoAccept: false		links: linkArray		linksBy: (defaults == nil ifTrue: [Array new] ifFalse: [returnArray at: 4]).	answer == nil ifTrue:[^nil].	^defaults == nil		ifTrue: [answer]		ifFalse: [ans _ self returnDBoxAnswer: answer startingAt: size + 1.				(answer copyFrom: 1 to: size), ans]!returnDBoxAnswer: answer startingAt: start 	self modifiers isEmpty		ifTrue:[^Array with: (answer at: start) with: nil]		ifFalse:[^Array with: (answer at: start) with: (answer at: start + 1)]!setUpDBoxStartingAt: start	"(DCM inspectsetUpDBoxStartingAt: 0) inspect"	"return a new key for this selection from the user"	| labelArray classArray linkArray begin modArray linkByArray |	start = 0 ifTrue:[begin _ 0] ifFalse:[begin _ start - 1].	(classArray _ OrderedCollection new) add: #Classification; addAll: self abbrevClassifs.	(modArray _ OrderedCollection new) add: #Controls; addAll: self modifiers.	(labelArray _ OrderedCollection new) add: classArray.	modArray size > 1 ifTrue: [labelArray add: modArray].	linkArray _ OrderedCollection new.	self totalLinks do: [:each| linkArray add: (each collect:[:aPoint| (aPoint x + begin) @ aPoint y])].	linkByArray _ OrderedCollection new.	self linkBys do: [:each| linkByArray add: (each collect: [:aPoint | (aPoint x + begin) @ aPoint y])].	^Array with: labelArray with: (Array with: #select with:#multipleSelect) with: linkArray with: linkByArray! !!ClassificationScheme methodsFor: 'read/write'!setup	"ClassificationScheme initialize"	| theStream | 	(self getOldFileName: self class classificationFileName) == nil		ifTrue: [self class writeDefaultClassification].	theStream _ self openOldFile: self class classificationFileName.	theStream readOnly.	self setupFrom: theStream.	theStream close.!setup: theStream	"read in the classification sceme from the stream and return the results in an 6 element array.1	scheme ID.2	abbrieviated classifications.3	full classifications.4	full access words.5	abbreviated access words.6	access word links.7	access word link bys."	| count theArray modLinksArray | 	theArray _ Array new: 7.	theArray at: 1 put: (theStream upTo: Character cr). "schema ID"	count _ Integer readFrom: theStream. "number of classification levels"	theStream skip: 1.	theArray at: 2 put:  (OrderedCollection new: count).	theArray at: 3 put:  (OrderedCollection new: count).	count timesRepeat:[(theArray at: 2) add: (theStream upTo: Character cr)]. "abbrev classifs"	count timesRepeat:[(theArray at: 3) add: (theStream upTo: Character cr)]. "full classifs"	count _ Integer readFrom: theStream. "number of modifiers"	theStream skip: 1.	theArray at: 4 put:  (OrderedCollection new: count).	theArray at: 5 put:  (OrderedCollection new: count).	count timesRepeat:[(theArray at: 4) add: (theStream upTo: Character cr)]. "full mods"	count timesRepeat:[(theArray at: 5) add: (theStream upTo: Character cr)]. "abbrev mods"	modLinksArray _ self setupModLinksFrom: theStream.	theArray at: 6 put: modLinksArray first.	theArray at: 7 put: modLinksArray last.	^ theArray!setupFrom: theStream	| theArray sign each eachM eachC | 	theArray _ self setup: theStream.	id _ theArray at: 1.	abbrevClassifs _ (theArray at: 2) asArray.	fullClassifs _ (theArray at: 3) asArray.	modifiers _ (theArray at: 4) asArray. 	abbrevModifiers _ (theArray at: 5) asArray. 	modifierLinks _ OrderedCollection new.	classModLinks _ OrderedCollection new.	classModLinkBys _ OrderedCollection new.	modifierLinkBys _ OrderedCollection new.	(theArray at: 6) do: [:col |		each _ OrderedCollection new.		each add: col first y abs.		sign _ col first y sign.		2 to: col size do: [:i | each add: ((col at: i) y * sign)].		col first x = 1 ifTrue: [classModLinks add: each asArray] ifFalse: [modifierLinks add: each asArray]].	(theArray at: 7) do: [:col |		eachM _ OrderedCollection new.		eachC _ OrderedCollection new.		sign _ col first y sign.		2 to: col size do: [:i |			(col at: i) x = 1 ifTrue: [eachC add: ((col at: i) y * sign)] ifFalse: [eachM add: ((col at: i) y * sign)]].		eachC isEmpty			ifFalse: [eachC addFirst: col first y abs.					classModLinkBys add: eachC asArray].		eachM isEmpty			ifFalse: [eachM addFirst: col first y abs.					modifierLinkBys add: eachM asArray]].!setupModLinksFrom: theStream	| tempCollection firstThing whatIs aCollection x count byCollection firstX | 	tempCollection _ OrderedCollection new.	byCollection _ OrderedCollection new.	count _ Integer readFrom: theStream. "number of lines following this to define modifier schema"	theStream skip: 1.	count > 0 ifTrue: "there are some modifier words"		[firstThing _ Integer readFrom: theStream.		whatIs _ theStream next.		whatIs = $@			ifTrue: "new stuff"				[theStream skip: -2.				count timesRepeat:					[aCollection _ OrderedCollection new.					 firstX _ Integer readFrom: theStream. "read section number"					 x _ firstX abs.					[theStream skip: 1. "skip @"					aCollection add: x @ (Integer readFrom: theStream). "add section@box"					theStream next = Character cr] whileFalse: [x _ Integer readFrom: theStream].					firstX > 0 ifTrue: [tempCollection add: aCollection] ifFalse: [byCollection add: aCollection]]]			ifFalse: "old stuff"				["firstThing is number of independent modifier words"				count _ count - 1.				count timesRepeat:					[aCollection _ OrderedCollection new.					 [aCollection add: 2 @ (Integer readFrom: theStream). "modifier dependancy"					  theStream next = $ "space"] whileTrue.					tempCollection add: aCollection asArray]]].	^Array with: tempCollection asArray with: byCollection asArray!writeClassification: theStream	| totalLinks linkBys | 	theStream nextPutAll: id; cr.	theStream nextPutAll: abbrevClassifs size printString ; cr.	abbrevClassifs do: [:each| theStream nextPutAll: each; cr].	fullClassifs do: [:each| theStream nextPutAll: each; cr].	theStream nextPutAll: modifiers size printString ; cr.	modifiers do: [:each| theStream nextPutAll: each; cr].	abbrevModifiers do: [:each| theStream nextPutAll: each; cr].	totalLinks _ self totalLinks.	linkBys _ self linkBys.	theStream nextPutAll: (totalLinks size + linkBys size) printString ; cr.	totalLinks do: [:each| each do: [:aPoint|  theStream nextPutAll: aPoint printString; space].	theStream skip: -1 ; cr.].	linkBys do: [:each| theStream nextPutAll: (Point x: each first x negated y: each first y) printString; space.					2 to: each size do: [:i |  theStream nextPutAll: (each at: i) printString; space].	theStream skip: -1 ; cr.]! !!PopUpMenu methodsFor: 'marker adjustment'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked item.		Otherwise no item is to be marked."	| aPoint |	aPoint _ Sensor cursorPoint.	(frame inside containsPoint: aPoint)		ifTrue:			[self markerOn: aPoint.			^true]		ifFalse:			[self markerOff.			^false]!markerOn: aPoint	| noSelection | 	noSelection _ selection == 0 | (selection == nil).	noSelection | (marker containsPoint: aPoint) not 		ifTrue: [noSelection & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[noSelection ifFalse: [Display reverse: marker].						marker _ 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection _ marker top - frame inside top // marker height + 1!selectionIndex: anInteger 	"Set the selection index and move but do not display the marker."	selection _ anInteger.	selection isNil ifFalse:		[marker _ marker 			align: marker topLeft 			with: marker left@((selection-1)*font height + frame inside top)].! !!PopUpMenu methodsFor: 'controlling'!startUp: aSymbol 	"Display and make a selection from the receiver as long as the button	denoted by the symbol, aSymbol, is pressed.  Answer the current selection."	| helpMarkerBckgndAndTimer |	helpMarkerBckgndAndTimer _ Array new: 3.	self displayAt: Sensor cursorPoint 		during: [Sensor cursorPoint: marker center.				[self buttonPressed: aSymbol] whileFalse: [].				[self buttonPressed: aSymbol]					whileTrue: [self doHelp: self manageMarker with: helpMarkerBckgndAndTimer]].	self unDisplayHelp: helpMarkerBckgndAndTimer.	^selection!startUp: aSymbol withHeading: aText	"Display and make a selection from the receiver as long as the button	denoted by the symbol, aSymbol, is pressed.  Answer the current selection."	| helpMarkerBckgndAndTimer |	helpMarkerBckgndAndTimer _ Array new: 3.	self displayAt: Sensor cursorPoint withHeading: aText		during: [Sensor cursorPoint: marker center.				[(self buttonPressed: aSymbol) and: [frame inside containsPoint: Sensor cursorPoint]]					whileFalse: [(frame containsPoint: Sensor cursorPoint) ifFalse: [Display flash: frame]].				[(self buttonPressed: aSymbol) and: [frame inside containsPoint: Sensor cursorPoint]]					whileTrue: [self doHelp: self manageMarker with: helpMarkerBckgndAndTimer]].	self unDisplayHelp: helpMarkerBckgndAndTimer.	^selection!startUpAndWaitForSelectionAt: aPoint	"Display and make a selection from the receiver as long as the button denoted	by the symbol, aSymbol, is pressed.  Answer the current selection."	| helpMarkerBckgndAndTimer |	helpMarkerBckgndAndTimer _ Array new: 3.	self displayAt: aPoint 		during: [[(Sensor anyButtonPressed and: [frame inside containsPoint: Sensor cursorPoint])]					whileFalse: [].				[self buttonPressed: #anyButton]					whileTrue: [self doHelp: self manageMarker with: helpMarkerBckgndAndTimer]].	self unDisplayHelp: helpMarkerBckgndAndTimer.	^selection! !!PopUpMenu methodsFor: 'private'!child	"in case a TreeMenu has a PopUpMenu as a child"	^nil!font: newFont	"Cause me to be recreated with a new font."	labelString == nil 		ifFalse: [self labels: labelString font: newFont lines: lineArray]	"PopUpMenu allInstancesDo:		[:each | each font: (TextStyle default fontAt: 7)].	PopUpMenu allSubInstancesDo:		[:each | each font: (TextStyle default fontAt: 7)]"!labels: aStringWithHelp font: aFont lines: anArray	| ts st b | 	st _ self pullOutHelps:		(labelString _ self removeTrailingCR: aStringWithHelp).	(ts _ TextStyle fontArray: (Array with: (font _ aFont)))		alignment: 2;  "TextConstants at: #Centered"		lineGrid: font height;		baseline: font ascent.	form _ FastTextDisplayScanner new		formFromText: (Text string: st emphasis: 1)		textStyle: ts		maxWidth: 8000.	lineArray _ anArray.	lineArray == nil ifFalse:		[lineArray do: [ :line |			form fill: (0@(line * font height) - form offset extent: form width @ 1)				mask: Form black]].	b _ 1@1 corner: 2@3.	b origin: b origin - form offset.	frame _ Quadrangle new.	frame region: ((0@0 extent: form extent + form offset) expandBy: b);		borderWidth: b.	marker _ frame inside origin extent: frame inside width@font height..	selection _ 0!removeTrailingCR: aString	"If the last character is a carriage return, remove it."	| sz |	((sz _ aString size) > 0 and: [(aString at: sz) = (Character value: 13)])		ifTrue:			[^(String new: (sz _ sz - 1))				primReplaceFrom: 1				to: sz				with: aString				startingAt: 1].	^aString!rescan	"cause me to be recreated for system changes like fonts"	labelString == nil ifTrue: [^ self].	self labels: labelString font: font lines: lineArray.	"PopUpMenu allInstancesDo: [:x | x rescan]."!storeOn: aStream	aStream nextPut: $(.	aStream nextPutAll: self class name, ' new labels: ', labelString printString, ' font: '.	font storeOn: aStream.	aStream nextPutAll: ' lines: #', (lineArray == nil ifTrue: [String with: $( with: $)] ifFalse: [lineArray printString]).	aStream nextPut: $)! !!PopUpMenu methodsFor: 'help'!doHelp: checkOn with: markerBckgndAndTimer	"markerBckgndAndTimer is an Array containing the lastMarker, the helpBackground, and the helpTimer"	checkOn		ifTrue:			[marker = (markerBckgndAndTimer at: 1) "check for displaying help"				ifTrue:					[(markerBckgndAndTimer at: 3) == nil ifFalse:						[(Time millisecondClockValue - (markerBckgndAndTimer at: 3) >= 3000 "3 seconds" or: [Sensor leftShiftDown])							ifTrue:								[markerBckgndAndTimer at: 2 put: self showHelp.								markerBckgndAndTimer at: 3 put: nil]]]				ifFalse:					[(markerBckgndAndTimer at: 2) == nil ifFalse: "remove help"						[(markerBckgndAndTimer at: 2) display.						markerBckgndAndTimer at: 2 put: nil].					markerBckgndAndTimer at: 1 put: marker.					markerBckgndAndTimer at: 3 put: Time millisecondClockValue]]		ifFalse:			[markerBckgndAndTimer at: 1 put: nil.			(markerBckgndAndTimer at: 2) == nil ifFalse: "remove help"				[(markerBckgndAndTimer at: 2) display.				markerBckgndAndTimer at: 2 put: nil]]!helpFor: anIndex on: aString	"Return the help string stored for the label at anIndex.	If no help is found in aString, look in MenuHelpConstants"	| inStream char label cr labelPos |	cr _ Character cr.	(aString isKindOf: String) ifFalse: [^ nil].	inStream _ ReadStream on: aString, (String with: cr).	"skip previous lines:"	(anIndex - 1) timesRepeat:		[[(char _ inStream next) = cr] whileFalse:			[char = ${ ifTrue: "skip help which may have crs"				[[inStream next = $}] whileFalse: []]]].	"skip to end, or beginning of help:"	labelPos _ inStream position.	[char _ inStream next. (char = cr) | (char = ${)] whileFalse: [].	char = ${		ifTrue:			[^ inStream upTo: $}]		ifFalse:			[inStream position: labelPos.			label _ (inStream upTo: Character cr).			((Smalltalk at: #MenuHelpConstants ifAbsent: [Dictionary new]) includesKey: label asSymbol)				ifFalse: [^nil]				ifTrue: [^(Smalltalk at: #MenuHelpConstants) at: label asSymbol]]!pullOutHelps: aString	"Return the contents of aString minus the help, if any."	| ch hp i sg sm sz temp |	sm _ WriteStream on:		(sg _ String new: (sz _ aString size)).	hp _ temp _ false.	i _ 0.	[(i _ i + 1) <= sz] whileTrue:		[ch _ aString at: i.		temp			ifTrue: [ch = $} ifTrue: [temp _ false]]			ifFalse:				[ch = ${					ifTrue: [hp _ temp _ true]					ifFalse: [sm nextPut: ch].				].		].	hp ifFalse: [^aString].	temp ifTrue: [self error: 'Missing "}" in menu help'].	^(String new: (temp _ sm position))		primReplaceFrom: 1 to: temp with: sg startingAt: 1!showHelp	"Show help information (if any) for the current selection."	| helpString helpForm helpBackground ts width para |	Cursor execute showWhile:		[helpString _ self helpFor: selection on: labelString.		(helpString == nil or: [helpString= String new])			ifTrue: [helpString _ 'No Help'. width _ 75 max: frame width]			ifFalse: [width _ 250]. "max width of a help"		(helpString ~= 'No Help' and: [Smalltalk includesKey: #FastTextDisplayScanner])			ifFalse:				[para _ (Paragraph withText: (Text string: helpString emphasis: 4)) centered.				para compositionRectangle: (0@0 extent: width@1).				helpForm _ para asForm]			ifTrue:				[ts _ TextStyle default alignment: 2; rightIndent: 4; firstIndent: 2; restIndent: 2.				ts baseline: (ts fontAt: 4) ascent + 2; lineGrid: (ts fontAt: 4) height + 4.				helpForm _ FastTextDisplayScanner new formFromText: (Text string: helpString emphasis: 4) textStyle: ts maxWidth: width].		helpForm borderWidth: 2.		helpForm align: helpForm boundingBox bottomCenter with: frame topCenter.		helpForm offset y < 0 ifTrue:      "off top of screen"			[helpForm offset: 0@0;				align: helpForm boundingBox topCenter with: frame bottomCenter].		helpBackground _ helpForm backgroundAt: helpForm offset.		helpForm display].	^helpBackground!unDisplayHelp: helpMarkerBckgndAndTimer	(helpMarkerBckgndAndTimer at: 2) == nil		ifFalse:			[(helpMarkerBckgndAndTimer at: 2) display]! !TreeMenu comment:'Copyright (c) 1983, 1984, 1985, 1986, 1987 Xerox Corporation.  All rights reserved.A TreeMenu is a PopUpMenu that is a node of a tree, where the descendants are TreeMenu. Descendants are activated by moving to the right out of a selection while keeping the mouse button pressed; the corresponding descendant then shows and takes over control. If the cursor moves to the right again, the next generation will show itself. If the cursor moves out of the active menu without activating a descendant, then a loop checks to see if the cursor enters any of the currently active menus; if so, that one is given control and all its descendants are neatly disposed of. Each menu has its own array of answers corresponding to the possible selections, and a similar array of children to pass control to in the circumstances described above. When the user finally lets up on the button, then if the active menu has a selection, the root menu and the last menu are passed to a block for a general evaluation of the result; the default behavior is to return the answer provided by the last menu.How help works:	Help strings are (generally) stored in labelString; they appear after the label on each line, delimited by { }.During the control loop, (markerBckgndAndTimer at: 1) contains the last value that marker had (nil if not in a menu item).If marker remains the same as (markerBckgndAndTimer at: 1) for a certain time (3 seconds), showHelp starts up.  It looks for the label''s help string; if none is found it looks for the label as a key into MenuHelpConstants; if there is still nothing, ''No Help'' is used.  The resulting string is displayed above (below if there''s no room) the pop-up until marker becomes unequal to lastmarker or a selection is made.answers	<Array> of answers for each selection index	if nil then use the selection index itselfchildren	<Array> of sub-menus for each selection index	if nil or if the entry is nil then do not pass controlparent	<TreeMenu> higher in the tree, who passed control to me	nil if I am the root of the treeresultBlock	<BlockContext> taking the first and last menus as arguments	if nil then use [:first :last | last answer]background	<Form> or nil; copy of the screen area covered by the displayed menumarkerBckgndAndTimer	<Array> of 3.(markerBckgndAndTimer at: 1)	<Rectangle> or nil; what marker was last time around; used for help features.(markerBckgndAndTimer at: 2)	<Integer> or nil; telling what millisecondClockValue was when lastMarker last changed; used for help(markerBckgndAndTimer at: 3)	<Form> or nil; copy of the screen area covered by the displayed help messageselectBlock	<BlockContext> to be evaluated repeatedly with the menu as an argument until the selection changes.  By default, this is helpBlock, causing help to display.popUpChildren	<Boolean> or nil; tells whether the descendant of a selection is displayed immediately, rather than waiting for movement to the right of the selection.  If nil before entering display loop, it is set to the value of PopUpChildren.Class variables:AccelerateCursorPlace	<Boolean> if true, the cursor will be pushed away from the middle of the menu, thus it appears to "accelerate" across the menus, allowing faster accessing.PopUpChildren	<Boolean> if true, the descendant of a selection is displayed immediately, rather than waiting for movement to the right of the selection.Global variable:MenuHelpConstants	<OopConservingDictionary or Dictionary> associates symbols of labels with help strings for common labels.  Made a global so that PopUpMenu can also access it when it has help facilities filed in."TreeMenu example"'!!TreeMenu methodsFor: 'initialize-release'!addChildMarks	| mark newForm |	(children isKindOf: SequenceableCollection) ifTrue: [		mark _ self childMark.		newForm _ Form extent: form width+mark width@form height.		form displayOn: newForm at: 0@0 clippingBox: (0@0 corner: form width@form height).		1 to: children size do: [:i |			(children at: i) == nil ifFalse: [				mark displayOn: newForm					at: form width@((i - 1)*marker height + (marker height - mark height//2))						 - form offset ]. ].		form _ newForm. ].!answers: anArray	"My answers are arbitrary values corresponding to the selections.	Thus answers size must be the same as the number of selection lines."	answers _ anArray!childMark	| a |	a _ # (16 24 28 30 31 30 28 24 16 ) collect: [:n | n * 512].	^ Form extent: 8@9 fromArray: a offset: 0@0!children: anArray	"My children are TreeMenu (or nil) corresponding to the selections.	Thus children size must be the same as the number of selection lines."	children _ anArray.	self addChildMarks addLines reframe.!form: aForm height: aHeight	font _ (StrikeFont new) ascent: aHeight; descent: 0.	form _ labelString _ aForm.	self addLines reframe.	selection _ 0.	self addChildMarks reframe.!labels: aStringWithHelp font: aFont lines: anArray	| st ts | 	st _ self pullOutHelps:		(labelString _ self removeTrailingCR: aStringWithHelp).	(Smalltalk includesKey: #FastTextDisplayScanner)		ifTrue:			[(ts _ TextStyle fontArray: (Array with: (font _ aFont)))				alignment: 2;  "TextConstants at: #Centered"				lineGrid: font height;				baseline: font ascent.			form _ FastTextDisplayScanner new				formFromText: (Text string: st emphasis: 1)				textStyle: ts				maxWidth: 8000.			lineArray _ anArray.			self addLines reframe.			selection _ 0]		ifFalse: [super labels: st font: aFont lines: anArray].	selectBlock _ self helpBlock.	self addChildMarks addLines reframe.!letGo	"Break possible double-links between self and: parent, children, etc."	(children isKindOf: TreeMenu) ifTrue: [children letGo].	(children isKindOf: SequenceableCollection) ifTrue: [		children do: [:eachChild |			(eachChild isKindOf: TreeMenu) ifTrue: [eachChild letGo]]].	parent _ nil.	resultBlock release!popUpChildren: aBooleanOrNil	"use this to override the default PopUpChildren for particular menus.	If popUpChildren is nil, the default PopUpChildren will be used"	popUpChildren _ aBooleanOrNil!reframe	| b |	b _ self border.	b origin: b origin - form offset.	frame _ Quadrangle new.	frame region: ((0@0 extent: form extent + form offset) expandBy: b);		borderWidth: b.	marker _ frame inside origin extent: frame inside width@font height.!release	"super release."	parent release.	parent _ nil.!replaceChildAt: anIndex with: newChild	"Use this carefully"	| oldChild mark | 	(children == nil or: [children isKindOf: SequenceableCollection]) ifFalse: [^nil].	children == nil ifTrue: [children _ Array new: answers size].	oldChild _ children at: anIndex.	children at: anIndex put: newChild.	oldChild == nil		ifTrue: "add child mark here"			[(children select: [:i | i ~~ nil]) size = 1				ifTrue: [self addChildMarks addLines reframe]				ifFalse:					[mark _ self childMark.					mark displayOn: form						at: (form width - mark width) @ ((anIndex - 1) * marker height + (marker height - mark height // 2)) - form offset]]		ifFalse:			[newChild == nil ifTrue: "erase child mark"				[mark _ self childMark.				(children select: [:i | i ~~ nil]) size = 0					ifTrue: [self rescan]					ifFalse:						[mark displayOn: form							at: (form width - mark width) @ ((anIndex - 1) * marker height + (marker height - mark height // 2)) - form offset							rule: Form reverse]]].	^oldChild!resultBlock: aBlock	"aBlock is passed the first and last menus in a selection trace.	The menus are doubly linked (forward by 'menu child', back by 'menu parent').	Default is essentially [:first :last | last answer]"	resultBlock _ aBlock fixTemps!selectBlock: aBlock	"provide a Block to be evaluated with this menu during the time the marker is on a selection"	selectBlock _ aBlock!size	| n |	labelString isEmpty ifTrue: [^ 0].	n _ 1.	labelString do: [:c | c = Character cr ifTrue: [n _ n+1] ].	^ n!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' answers: #', answers printString.	children == nil ifFalse: [aStream nextPutAll: '; children: '. children storeOn: aStream].	resultBlock == nil ifFalse: ["aStream nextPutAll: '; resultBlock: '. resultBlock storeOn: aStream" "nothing but trouble"].	aStream nextPut: $).!style: aTextStyle font: fontIndex	| labelPara rect style bw |	font _ aTextStyle fontAt: fontIndex.	style _ aTextStyle copy newFontArray: (Array with: font).	style gridForFont: 1 withLead: 0;		alignment: aTextStyle alignment.	labelPara _ Paragraph withText: labelString asText style: style.	form _ labelPara asForm.	self addChildMarks addLines reframe.! !!TreeMenu methodsFor: 'controlling'!controlAt: aPoint	"see if I can pass the buck to an ancestor"	| it |	self manageMarkerAt: aPoint.	it _ self whoWantsControlAt: aPoint.	it == nil ifTrue: [^self].	^ it!manageMarkerAt: aPoint	"Things could get confused if a new cursorpoint is used"	(frame inside containsPoint: aPoint)		ifTrue:			[self markerOn: aPoint.			self doSelectBlock]		ifFalse:			[self markerOff.			self noHelp]!multipleStartUp	^self multipleStartUp: nil!multipleStartUp: aSymbol 	"Display and make selections from the receiver until the button selected is clicked outside the menu.  Answer all the selections.	Note that this ignores children and resultBlocks"	| aCollect newmarker answerCollect |	selection _ nil.	aCollect _ Set new.	self displayAt: Sensor cursorPoint during:		[Sensor cursorPoint: marker center.		[self buttonPressed: aSymbol] whileFalse: [].		[selection = 0] whileFalse: [[self buttonPressed: aSymbol] whileTrue: [self manageMarkerAt: self cursorPoint].		(selection = 0 or: [selection == nil]) ifFalse:		[newmarker _ marker 						align: marker topLeft 						with: marker left @ (frame inside top + ((selection - 1) * marker height)).		Display fill: newmarker rule: Form reverse mask: Form white.		(aCollect includes: selection) ifTrue:[aCollect remove: selection] ifFalse:[aCollect add: selection].		selection _ nil]]].	answerCollect _ (answers == nil ifTrue: [aCollect] ifFalse: [aCollect collect: [:i | answers at: i]]).	^answerCollect!resetAllSelections	selection _ 0.	(children isKindOf: Array) ifTrue:		[children do:			[:eachChild | eachChild == nil ifFalse:				[(eachChild isKindOf: TreeMenu)					ifTrue: [eachChild resetAllSelections]]]]!selectionIndex: anInteger 	"Set the selection index and move but do not display the marker."	selection _ anInteger.	selection isNil ifFalse:		[marker _ marker 			align: marker topLeft 			with: marker left@((selection-1)*font height + frame inside top)].!startUp: aSymbol	"Display me as the root of a menu tree. If a selection is made (in me or  offspring), pass me and the selected menu as arguments to resultBlock to compute a response; otherwise return nil."	| last result |	last _ self startUp: aSymbol parent: nil.	result _ last selection = 0		ifTrue: [nil]		ifFalse: [resultBlock == nil			ifTrue: [last answer]			ifFalse: [resultBlock value: self value: last] ].	last release.	^ result!startUp: aSymbol for: somebody	"Display me as the root of a menu tree. If a selection is made (in me or  offspring), pass me, the selected menu, and somebody as arguments to resultBlock to compute a response; otherwise return nil."	| last result |	last _ self startUp: aSymbol parent: nil.	result _ last selection = 0		ifTrue: [nil]		ifFalse: [resultBlock == nil			ifTrue: [last answer]			ifFalse: [resultBlock value: self value: last value: somebody] ].	last release.	^ result!startUp: aSymbol parent: aTreeMenu	"Display me as a node of a menu tree. If the cursor goes to the right out of a selection, then pass control to the corresponding child. If the cursor is not in my frame but enters an ancestor, then I disappear returning the ancestor, so it can intercept and take over control. If a selection is made in me, then return me as the result for the root to use in computing the complete answer." 	| last pt child |	self initSelection.	last _ self.	parent _ aTreeMenu.	self displayAt: self startUpPoint during:		[parent == nil ifTrue: [[self buttonPressed: aSymbol] whileFalse: []].		[pt _ self cursorPoint.		 self == last and: [self buttonPressed: aSymbol]]			whileTrue:				[last _ (pt x >= marker right and: [selection ~= 0] )						ifTrue: [self startUpChild: aSymbol]						ifFalse:							[((marker containsPoint: pt) and:									[(child _ self child) == nil == false])								ifTrue:									[child initSelection.									popUpChildren										ifTrue: [child startUp: aSymbol parent: self]										ifFalse: [self controlAt: pt]]								ifFalse: [self controlAt: pt]]]].	(self == last and: 		[parent == nil == false and: 			[parent marker containsPoint: pt]]) ifTrue: [last _ parent].	last == parent ifTrue: [parent _ nil]. "avoid circular garbage"	^ last!startUpChild: aSymbol	"Cursor has moved right out of me. Pass control to selected child if any."	| child |	self noHelp.	child _ self child.	child == nil ifTrue: [^self markerOff].	child == false ifTrue: [^false].	^child startUp: aSymbol parent: self!startUpPoint	^ parent == nil		 ifTrue: [Sensor cursorPoint]		 ifFalse: [marker width // 2 + frame borderWidth left + parent frame right @parent marker center y]!whoWantsControlAt: aPoint	"Do I or an ancestor want control here, if so return who, else nil."	(frame inside containsPoint: aPoint) ifTrue: [^self].	parent == nil ifTrue: [^ nil].	(parent marker containsPoint: aPoint) ifTrue: [^ self].	aPoint x < parent marker right ifTrue: [^ parent].	^ nil! !!TreeMenu methodsFor: 'answering'!answer	"Respond with my currently selected answer, or nil"	(selection = 0 or: [selection == nil]) ifTrue: [^nil].	answers == nil ifTrue: [^selection].	"default answer is selection"	^ answers at: selection!child	"Respond with my currently selected child, or nil"	| child |	selection = 0 ifTrue: [^nil].	child _ children.	(child isKindOf: Array) ifTrue: [child _ child at: selection].	(child isKindOf: BlockContext) ifTrue: [^ child value: self].	^ child!parent	"Respond with my parent if any."	^ parent! !!TreeMenu methodsFor: 'accessing'!answers	^answers!background	^ background!children	^children!form	^form!frame	^frame!marker	^marker!resetSelection	selection _ 0.!resultBlock	^resultBlock! !!TreeMenu methodsFor: 'displaying'!alignWith: aPoint	frame _ frame align: marker center with: aPoint.	marker _ marker align: marker center with: aPoint.!displayAt: aPoint during: aBlock 	"Display the receiver centered at aPoint while aBlock is evaluated.	If necessary, translate so the view is completely on the screen."	| delta savePopUpChildren |	self alignWith: aPoint.	"move onto Display"	delta _ frame amountToTranslateWithin: Display boundingBox.	0@0 = delta ifFalse:		[frame _ frame moveBy: delta.		marker _ marker moveBy: delta.		Sensor cursorPoint: Sensor cursorPoint + delta.  "keep cursor in same relative position"		parent == nil ifFalse: [parent moveBy: delta]].	background _ Form fromDisplay: frame region.	self show.	savePopUpChildren _ popUpChildren.	popUpChildren == nil ifTrue: [popUpChildren _ PopUpChildren].	self initHelp.	Cursor normal showWhile: [aBlock value].      "SHAZAM"	self noHelp.	popUpChildren _ savePopUpChildren.	background == nil ifFalse: [background displayAt: frame origin].	background _ nil!markerOff	(selection == 0 or: [selection == nil]) ifFalse: [Display reverse: marker]. selection _ 0!moveBy: delta	0@0 = delta ifFalse: [		background displayAt: frame origin.		frame _ frame moveBy: delta.		marker _ marker moveBy: delta.		parent == nil ifFalse: [parent moveBy: delta].		background _ Form fromDisplay: frame region.		self show. ].!show	self showFrame showInside showSelection.!showFrame	| pt |	pt _ frame topLeft + self border topLeft.	frame displayOn: Display.	0@0 = form offset ifFalse: [		form displayOn: Display			at: pt - form offset			clippingBox: (pt corner: frame inside topRight).		frame borderWidth left > 1 ifTrue: [			background displayOn: Display at: frame origin				clippingBox: (frame origin corner: (frame inside left - 1)@(frame inside top - 1))]]!showInside	| inside |	inside _ frame inside.	form displayOn: Display		at: inside origin		clippingBox: inside.!showSelection	(selection == 0 or: [selection == nil]) ifFalse: [Display reverse: marker].! !!TreeMenu methodsFor: 'help'!helpBlock	^[:menu |		menu marker = (menu markerBckgndAndTimer at: 1)			ifTrue:				[(menu markerBckgndAndTimer at: 3) == nil ifFalse:					[(Time millisecondClockValue - (menu markerBckgndAndTimer at: 3) >= 3000 "3 seconds" or: [Sensor leftShiftDown])						ifTrue: [menu showHelp]]]			ifFalse:				[(menu markerBckgndAndTimer at: 2) == nil ifFalse: [menu removeHelp].				menu markerBckgndAndTimer at: 1 put: menu marker.				menu markerBckgndAndTimer at: 3 put: Time millisecondClockValue]]!helpFor: anIndex on: aString	"Return the help string stored for the label at anIndex.	If no help is found in aString, look in HelpConstants	(unless this menu has children, in which case the user is told to look for submenus)."	| inStream char label cr labelPos |	cr _ Character cr.	(aString isKindOf: String) ifFalse: [^ nil].	inStream _ ReadStream on: aString, (String with: cr).	"skip previous lines:"	(anIndex - 1) timesRepeat:		[[(char _ inStream next) = cr] whileFalse:			[char = ${ ifTrue: "skip help which may have crs"				[[inStream next = $}] whileFalse: []]]].	"skip to end, or beginning of help:"	labelPos _ inStream position.	[char _ inStream next. (char = cr) | (char = ${)] whileFalse: [].	char = ${		ifTrue:			[^ inStream upTo: $}]		ifFalse:			[self child == nil ifFalse: [^'Move to the right to see submenus.'].			inStream position: labelPos.			label _ (inStream upTo: Character cr).			(MenuHelpConstants includesKey: label asSymbol)				ifFalse: [^nil]				ifTrue: [^MenuHelpConstants at: label asSymbol]]!initHelp	"To be called when the menu starts up."	markerBckgndAndTimer _ Array new: 3. "last marker" "help background" "help timer"!noHelp	"No item is selected, so turn off the counter.	Should be called when turning off the menu."	markerBckgndAndTimer at: 1 put: nil.	(markerBckgndAndTimer at: 2) == nil ifFalse:		[self removeHelp]!pullOutHelps: aString	"Return the contents of aString minus the help, if any."	| ch hp i sg sm sz temp |	sm _ WriteStream on:		(sg _ String new: (sz _ aString size)).	hp _ temp _ false.	i _ 0.	[(i _ i + 1) <= sz] whileTrue:		[ch _ aString at: i.		temp			ifTrue: [ch = $} ifTrue: [temp _ false]]			ifFalse:				[ch = ${					ifTrue: [hp _ temp _ true]					ifFalse: [sm nextPut: ch].				].		].	hp ifFalse: [^aString].	temp ifTrue: [self error: 'Missing "}" in menu help'].	^(String new: (temp _ sm position))		primReplaceFrom: 1 to: temp with: sg startingAt: 1!removeHelp	"Remove the help display, restoring the background."	(markerBckgndAndTimer at: 2) display.	markerBckgndAndTimer at: 2 put: nil!removeTrailingCR: aString	"If the last character is a carriage return, remove it."	| sz |	((sz _ aString size) > 0 and: [(aString at: sz) = (Character value: 13)])		ifTrue:			[^(String new: (sz _ sz - 1))				primReplaceFrom: 1				to: sz				with: aString				startingAt: 1].	^aString!showHelp	"Show help information (if any) for the current selection."	| helpString para width helpForm ts |	Cursor execute showWhile:		[helpString _ self helpFor: selection on: labelString.		(helpString == nil or: [helpString= String new])			ifTrue: [helpString _ 'No Help'. width _ 75 max: frame width]			ifFalse: [width _ 250]. "max width of a help"		(helpString ~= 'No Help' and: [Smalltalk includesKey: #FastTextDisplayScanner])			ifFalse:				[para _ (Paragraph withText: (Text string: helpString emphasis: 4)) centered.				para compositionRectangle: (0@0 extent: width@1).				helpForm _ para asForm]			ifTrue:				[ts _ TextStyle default alignment: 2; rightIndent: 4; firstIndent: 2; restIndent: 2.				ts baseline: (ts fontAt: 4) ascent + 2; lineGrid: (ts fontAt: 4) height + 4.				helpForm _ FastTextDisplayScanner new formFromText: (Text string: helpString emphasis: 4) textStyle: ts maxWidth: width].		helpForm borderWidth: 2.		helpForm align: helpForm boundingBox bottomCenter with: frame topCenter.		helpForm offset y < 0 ifTrue:      "off top of screen"			[helpForm offset: 0@0;				align: helpForm boundingBox topCenter with: frame bottomCenter].		markerBckgndAndTimer at: 2 put: (helpForm backgroundAt: helpForm offset).		helpForm display.		markerBckgndAndTimer at: 3 put: nil]! !!TreeMenu methodsFor: 'private'!addLines	lineArray == nil ifFalse:		[lineArray do: [:line |			form fill: (0@(line * font height) - form offset extent: form width @ 1)				mask: Form black ]].!border	^ 1@1 corner: 2@3!cursorPoint	| pt gutter l r |	pt _ Sensor cursorPoint.	(pt x < frame left and:	[parent == nil == false])		ifTrue: [pt _ parent cursorPoint].	(AccelerateCursorPlace and: [(children == nil and: [parent == nil]) not]) ifTrue:		[gutter _ 32. "about 1 cm"		l _ marker left + gutter.		r _ marker right - gutter.		(l < pt x and: [pt x < r])  ifTrue: [ "jump across middle"			pt x: (pt x < (l + r // 2)				ifTrue: [r]				ifFalse: [l]).			Sensor cursorPoint: pt]].	^ pt!doSelectBlock	selectBlock == nil ifFalse: [selectBlock value: self]!font: newFont	"Cause me to be recreated with a new font."	labelString == nil 		ifFalse: [self labels: labelString font: newFont lines: lineArray]	"TreeMenu allInstancesDo:		[:each | each font: (TextStyle default fontAt: 7)].	TreeMenu allSubInstancesDo:		[:each | each font: (TextStyle default fontAt: 7)]"!initSelection	selection _ 0.!markerBckgndAndTimer	^markerBckgndAndTimer!rescan	"cause me to be recreated for system changes like fonts"	labelString == nil ifTrue: [^ self].	(labelString isKindOf: Form)		ifTrue: [self form: labelString height: font height]		ifFalse: [self labels: labelString font: font lines: lineArray]	"TreeMenu allInstancesDo: [:x | x rescan]."!title: titleForm	| tf bt bf r f |	tf _ (titleForm isKindOf: Form)		ifTrue: [titleForm]		ifFalse: [titleForm asParagraph asForm].	bt _ tf boundingBox.	bf _ form boundingBox.	bt _ bt align: bt bottomCenter with: 0@-1 + bf topCenter.	r _ bt merge: bf.	f _ Form extent: r extent.	tf displayOn: f at: bt origin - r origin.	f fill: (0@bt height extent: f width@1) mask: Form black.	form displayOn: f at: bf origin - r origin.	f offset: 0@(r top - bf top).	self form: f height: font height! !ScrollMenu comment:'Copyright (c) Xerox Corporation, 1983, 1984, 1985, 1986, 1987. All rights reserved.'!!ScrollMenu methodsFor: 'initialization'!border	maxLines == nil ifTrue: [maxLines _ 10].	^ maxLines * font height < (form height + form offset y)		ifTrue: [6@1 corner: 2@3]		ifFalse: [super border]!maxLines: anInteger	"max number that show at once"	maxLines _ anInteger.	self reframe.!reframe	| b |	b _ self border.	b origin: b origin - form offset.	maxLines == nil ifTrue: [maxLines _ form height//font height].	frame _ Quadrangle new.	frame region: ((0@0 extent: form width@			(form height + form offset y min: maxLines*font height)) expandBy: b);		borderWidth: b.	marker _ frame inside origin extent: form width@font height.	topLine _ 1.!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' maxLines: ', maxLines printString.	aStream nextPut: $).!style: aTextStyle font: fontIndex	super style: aTextStyle font: fontIndex.	self maxLines: maxLines.! !!ScrollMenu methodsFor: 'controlling'!initSelection	super initSelection.	topLine == nil ifTrue: [topLine _ 1].	LastScrollTime _ Time millisecondClockValue.!manageMarkerAt: aPoint	| dy lastLine newTopLine t |	(frame inside containsPoint: aPoint)		ifTrue: [			self markerOn: aPoint.			selection _ selection + topLine - 1. "fudge for current markerOn:"			self doSelectBlock]		ifFalse: [			self markerOff.			self noHelp.			lastLine _ (form height + form offset y)//marker height.			lastLine <= maxLines ifTrue: [^self].			dy _ frame inside top - aPoint y.			newTopLine _ dy > 0				ifTrue: [topLine - (dy//marker height + 1)]				ifFalse: [					dy _ aPoint y - frame inside bottom.					dy < 0 ifTrue: [topLine]						 ifFalse: [topLine + (dy//marker height + 1)] ].			newTopLine _ (newTopLine min: lastLine - maxLines + 1) max: 1.			newTopLine = topLine ifFalse: ["scroll"				t _ Time millisecondClockValue.				t - LastScrollTime < ScrollMsec ifFalse: [					LastScrollTime _ t.					topLine _ newTopLine.					self showInside showScroll. ]. ]. ]!show	super show.	self showScroll.!showInside	| dy |	dy _ (topLine - 1) * marker height.	form displayOn: Display		at: frame inside topLeft - (0@dy)		clippingBox: frame inside!showScroll	| h n bar mark |	h _ form height + form offset y.	h > frame inside height ifTrue: [		n _ h // marker height.		n > maxLines ifTrue: [			bar _ frame left + 1 @ frame inside top				corner: frame inside left - 1@frame inside bottom.			mark _ bar left @ (bar top + ((topLine - 1) * bar height // n))				corner: bar right @ ( bar top + ((topLine + maxLines - 1) * bar height // n) ).			Display fill: bar mask: Form white; fill: mark mask: Form gray.			 ]	].! !!ScrollMenu methodsFor: 'accessing'!maxLines	^maxLines! !!ActionMenu methodsFor: 'accessing'!selectors	^selectors! !!ActionMenu methodsFor: 'acccessing'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' setSelectors: #', selectors printString; nextPut: $).! !NonprogrammerMenu comment:'Copyright (c) Xerox Corporation, 1983, 1984, 1985, 1986. All rights reserved.'!!NonprogrammerMenu methodsFor: 'initialize-release'!fullMenu: aPopUpMenu	fullMenu _ aPopUpMenu!letGo	(fullMenu isKindOf: TreeMenu) ifTrue: [fullMenu letGo].	(restrictedMenu isKindOf: TreeMenu) ifTrue: [restrictedMenu letGo]!restrictedMenu: aPopUpMenu	restrictedMenu _ aPopUpMenu! !!NonprogrammerMenu methodsFor: 'controlling'!startUp: aSymbol	^self appropriateMenu startUp: aSymbol!startUpAndWaitForSelection: aSymbol	^self appropriateMenu startUpAndWaitForSelection: aSymbol! !!NonprogrammerMenu methodsFor: 'answering'!answer	^self appropriateMenu answer!child	^self appropriateMenu child! !!NonprogrammerMenu methodsFor: 'private'!appropriateMenu	^InhibitProgramming		ifTrue: [restrictedMenu]		ifFalse: [fullMenu]!storeOn: aStream	aStream nextPut: $(.	aStream nextPutAll: self class name, ' new fullMenu: '.	fullMenu storeOn: aStream.	aStream nextPutAll: '; restrictedMenu: '.	restrictedMenu storeOn: aStream.	aStream nextPut: $).! !Animation comment:'Copyright (c) Xerox Corporation, 1985, 1986.Version 0.6 (3/4/86)Animation is a package for simulation.  It will simulate form icons on the screen over a period of time.  This is being used mainly in Maps along with Database.Instance Variables========window<not in>	this should be the clipping rectangle but it is not being used for now.objects			this is an ordered collection of forms which the package simulates.currentTime		this is the main clock that the simulation goes by.beginTime		the is the begin time for the simulation.endTime		this is the end time for the simulation.interval			this is the interval of the objects being simulated.  It is always in minutes.clock			this should be a point telling where the clock should be.tempTime		this simple keeps track of the earliest time and the latest time of the input in case for defaultinfo'!!Animation methodsFor: 'initialization'!initialize	interval _ Array with: 1 with: #hour with: 60 with: true.	info _ Array new: 8 withAll: false.	window _ Rectangle origin: 0 @ 0 extent: 1024 @ 808.	clock _ 0 @ 0.	objects _ OrderedCollection new.	tempTime _ Array new: 2.	^true! !!Animation methodsFor: 'accessing'!beginTime: aUTime	beginTime _ aUTime!clock: aPoint	clock _ aPoint!endTime: aUTime	endTime _ aUTime!info	^info!window: aRect	window _ aRect! !!Animation methodsFor: 'simulation'!alterParameter	self getParameter		ifTrue: [objects do: 				[:each | 				each interval: interval; 				info: info copy; 				beginTime: beginTime copy; 				endTime: endTime copy; 				currentTime: currentTime copy.				each setPosition].				^true]		ifFalse: [^false]!start	| finished halt index |	self checkTime.	self displayTime.	finished _ false.	halt _ false.	objects do: [:each | each display].	[finished]		whileFalse: 			[[halt | Sensor yellowButtonPressed]				whileFalse: [self step].			Sensor leftShiftDown				ifTrue: 					[index _ ProgrammerMenu startUp.					objects do: [ : each | each cleanUp].					self displayTime.					index = 1 ifTrue: [self inspectAll].					index = 2 ifTrue: [self newClockLocation].					index = 3 ifTrue: [self setDirection].					index = 4 ifTrue: [objects do: [ : each | each getInfo]].					index = 5 ifTrue: [self pasteImage].					objects do: [ : each | each display]]				ifFalse: 					[index _ YellowButtonMenu startUp.					index = 1						ifTrue: 							[halt _ true.							self step].					index = 2 ifTrue: [halt _ false].					index = 3						ifTrue: 							[objects do: [ : each | each cleanUp].							self displayTime.							self alterParameter.							objects do: [ : each | each display].							self displayTime.							halt _ false].					index = 4 ifTrue: [finished _ true]]].	(info at: 2) ifFalse: [objects do: [:each | each cleanUp]].	self displayTime!step	self displayTime.	(interval at: 4)		ifTrue: [currentTime < endTime ifTrue: [currentTime addMinutes: (interval at: 3)]]		ifFalse: [currentTime > beginTime ifTrue: [currentTime subtractMinutes: (interval at: 3)]].	self displayTime.	objects do: [:each | each displayConnect; step]! !!Animation methodsFor: 'private'!addObject: objectForm withEvents: eventList withLocation: locationList 	| a |	(a _ Sprite new) initialize.	beginTime == nil ifTrue: [(tempTime at: 1)			== nil			ifTrue: [tempTime at: 1 put: eventList first]			ifFalse: [eventList first < (tempTime at: 1) ifTrue: [tempTime at: 1 put: eventList first]]].	endTime == nil ifTrue: [(tempTime at: 2)			== nil			ifTrue: [tempTime at: 2 put: eventList last]			ifFalse: [eventList last > (tempTime at: 2) ifTrue: [tempTime at: 2 put: eventList last]]].	a beginTime: beginTime copy; endTime: endTime copy; interval: interval copy; currentTime: currentTime copy; window: window; info: info;		object: objectForm		events: eventList		locations: locationList		labels: nil"; getInfo".	objects add: a!addObject: objectForm withEvents: eventList withLocation: locationList labels: label	| a |	(a _ Sprite new) initialize.	beginTime == nil ifTrue: [(tempTime at: 1)			== nil			ifTrue: [tempTime at: 1 put: eventList first]			ifFalse: [eventList first < (tempTime at: 1) ifTrue: [tempTime at: 1 put: eventList first]]].	endTime == nil ifTrue: [(tempTime at: 2)			== nil			ifTrue: [tempTime at: 2 put: eventList last]			ifFalse: [eventList last > (tempTime at: 2) ifTrue: [tempTime at: 2 put: eventList last]]].	a beginTime: beginTime copy; endTime: endTime copy; interval: interval copy; currentTime: currentTime copy; window: window; info: info;		object: objectForm		events: eventList		locations: locationList		labels: label"; getInfo".	objects add: a!checkTime	beginTime == nil | (endTime == nil)		ifTrue: 			[beginTime == nil ifTrue: [beginTime _ tempTime at: 1].			endTime == nil ifTrue: [endTime _ tempTime at: 2].			currentTime == nil ifTrue: [(interval at: 4) ifTrue: [currentTime _ beginTime copy] ifFalse: [currentTime _ endTime copy]].			objects do: 				[:each | 				each beginTime: beginTime copy; endTime: endTime copy; currentTime: currentTime copy.				each setPosition]]!displayTime	currentTime printString asForm		displayOn: Display		at: clock		clippingBox: Display boundingBox		rule: Form reverse		mask: Form black.!getInfo	| defaultArray ans |	defaultArray _ OrderedCollection new.	info do: [:each | each			ifTrue: [defaultArray add: #yes]			ifFalse: [defaultArray add: #no]].	ans _ DBoxView				openFor: #(multipleSelect )				title: 'Parameter Information'				labels: (Array with:#(SelectOptions Step Trace Label Date Time Connection Open))				defaults: defaultArray.	ans == nil		ifTrue: [info _ Array new: 7 withAll: false]		ifFalse: 			[info _ Array new: 7.			1 to: 7 do: [:i | (ans at: i) asSymbol = #yes					ifTrue: [info at: i put: true]					ifFalse: [info at: i put: false]]]!getParameter	| defaultArray ans temp optionDefaults theLabels time date booboo |	defaultArray _ OrderedCollection new.	theLabels _ OrderedCollection new.	theLabels add: #('Current Time');		add: #('Current Date');		add: #('Begin Time');		add: #('Begin Date');		add: #('End Time');		add: #('End Date');		add: #('Increment');		add: #(Unit: second minute hour day);		add: #(Direction forward reverse);		add: #('Select Options' 'Show Steps' 'Leave Trace' 'Show Label' 'Show Date' 'Show Time' Connection Open).		"add: #('Select Options' 'Show Steps' 'Leave Trace' 'Show Label' 'Show Date' 'Show Time' Connection Open 'Single events')"	currentTime == nil		ifTrue: [defaultArray add: String new; add: String new]		ifFalse: [defaultArray add: currentTime time printString; add: currentTime date printString].	beginTime == nil		ifTrue: [defaultArray add: String new; add: String new]		ifFalse: [defaultArray add: beginTime time printString; add: beginTime date printString].	endTime == nil		ifTrue: [defaultArray add: String new; add: String new]		ifFalse: [defaultArray add: endTime time printString; add: endTime date printString].	interval == nil		ifTrue: [defaultArray add: #1; add: #minute; add: #forward]		ifFalse: 			[defaultArray add: (interval at: 1) printString; add: (interval at: 2).			(interval at: 4)				ifTrue: [defaultArray add: #forward]				ifFalse: [defaultArray add: #reverse]].	optionDefaults _ OrderedCollection new.	1 to: info size do: [:each | (info at: each) ifTrue: [optionDefaults add: ((theLabels at: 10) at: each+1)]].	defaultArray add: optionDefaults.	ans _ DBoxView				openFor: #(fill fill fill fill fill fill fill select select multipleSelect)				title: 'Animation parameters'				labels: theLabels				defaults: defaultArray.	ans == nil		ifTrue: [^false]		ifFalse: 			[booboo _ ' entry is unacceptable. Try again'.			(ans at: 1) = String new				ifFalse: 					[(ans at: 2) = String new ifTrue: [ans at: 2 put: Date today printString].					SmalltalkSignal do: [time _ Time readFrom: (ReadStream on: (ans at: 1))]						handle: [SmalltalkSignal handleReturnDoing: [self booboo: (theLabels at: 1), booboo.  ^self getParameter]].					SmalltalkSignal do: [date _ Date readFrom: (ReadStream on: (ans at: 2))]						handle: [SmalltalkSignal handleReturnDoing: [self booboo: (theLabels at: 2), booboo.  ^self getParameter]].					currentTime _ UTime time: time date: date].			(ans at: 3) = String new				ifFalse: 					[(ans at: 4) = String new ifTrue: [ans at: 4 put: Date today printString].					SmalltalkSignal do: [time _ Time readFrom: (ReadStream on: (ans at: 3))]						handle: [SmalltalkSignal handleReturnDoing: [self booboo: (theLabels at: 3), booboo.  ^self getParameter]].					SmalltalkSignal do: [date _ Date readFrom: (ReadStream on: (ans at: 4))]						handle: [SmalltalkSignal handleReturnDoing: [self booboo: (theLabels at: 4), booboo.  ^self getParameter]].					beginTime _ UTime time: time date: date].			(ans at: 5) = String new				ifFalse: 					[(ans at: 6) = String new ifTrue: [ans at: 6 put: Date today printString].					SmalltalkSignal do: [time _ Time readFrom: (ReadStream on: (ans at: 5))]						handle: [SmalltalkSignal handleReturnDoing: [self booboo: (theLabels at: 5), booboo.  ^self getParameter]].					SmalltalkSignal do: [date _ Date readFrom: (ReadStream on: (ans at: 6))]						handle: [SmalltalkSignal handleReturnDoing: [self booboo: (theLabels at: 6), booboo.  ^self getParameter]].					endTime _ UTime time: time date: date].			interval _ Array new: 4.			(temp _ (ans at: 7) asNumber) = 0 ifTrue: [temp _ 15].			interval at: 1 put: temp; at: 2 put: (ans at: 8) asSymbol.			(ans at: 8) asSymbol = #second ifTrue: [interval at: 3 put: temp / 60].			(ans at: 8) asSymbol = #minute ifTrue: [interval at: 3 put: temp].			(ans at: 8) asSymbol = #hour ifTrue: [interval at: 3 put: temp * 60].			(ans at: 8) asSymbol = #day ifTrue: [interval at: 3 put: temp * 60 * 24].			(ans at: 9) asSymbol = #forward				ifTrue: 					[interval at: 4 put: true.					currentTime == nil ifTrue: [currentTime _ beginTime copy]]				ifFalse: 					[interval at: 4 put: false.					currentTime == nil ifTrue: [currentTime _ endTime copy]]].	info _ Array new: 8 withAll: false.	(ans at: 10) == nil ifTrue: [^true].	(ans at: 10) do: [:each | info at: ((theLabels at: 10) indexOf: each) - 1 put: true].	^true!inspectAll	self inspect!newClockLocation	Cursor crossHair show.	 [Sensor noButtonPressed] whileTrue: [clock _ Sensor cursorPoint].	Cursor normal show!pasteImage	| tempLabels index | 	tempLabels _ OrderedCollection new.	objects do: [ : each | tempLabels add: (each labels first)].	index _ (ScrollMenu new: 5 on: tempLabels) startUp: #redButton.	(objects at: index) objectForm: Form fromUser!setDirection	| old ans |	old _ interval at: 4.	ans _ DBoxView				openFor: #(select )				title: 'Set Time Direction'				labels: #((Direction forward reverse ) )				defaults: (old						ifTrue: [#(forward )]						ifFalse: [#(reverse )]).	ans == nil ifTrue: [^self].	(ans at: 1) asSymbol = #forward		ifTrue: 			[interval at: 4 put: true.			currentTime == nil ifTrue: [currentTime _ beginTime copy]]		ifFalse: 			[interval at: 4 put: false.			currentTime == nil ifTrue: [currentTime _ endTime copy]].	objects do: [ :each | each interval: interval]! !!ClassDescription methodsFor: 'organization'!collapse	organization == #collapsed ifTrue: [^self].	organization == nil ifTrue: [^self].	organization		collapsedForClass: self		fromFileNumber: #none		toFileNumber: 2		toFile: nil.	organization _ #collapsed.!organization"Answer the instance of ClassOrganizer that represents the organization of the messages of the receiver."	| cO |	organization == nil ifTrue: [^organization _ ClassOrganizer new].	organization == #collapsed ifFalse: [^organization].	cO _ ClassOrganizer new.	methodDict size > 0 ifTrue:		[cO classifyAll: self selectors under:			ClassOrganizer defaultProtocol.		]. "Use cO as temporary variable just in case of file error during #collapsedForClass:fromFileNumber:toFileNumber:toFile:."	^organization _ Sensor leftShiftDown ifTrue: [cO.] ifFalse:		[cO			collapsedForClass: self			fromFileNumber: #any			toFileNumber: #none			toFile: nil.		]! !!ClassDescription methodsFor: 'fileIn/Out'!fileOutCategory: aString on: aFileStream moveSource: moveSource toFile: fileIndex	| sels allPoolRefs |  	"File a description of the receiver's category, aString, onto aFileStream.  If	the boolean argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the source code."	sels _ self organization listAtCategoryNamed: aString.	allPoolRefs _ Set new.	sels do: [:sel | allPoolRefs addAll: (self allPoolRefsIn: sel)].	self printPoolChunks: allPoolRefs on: aFileStream.	self printCategoryChunk: aString on: aFileStream.	sels		do: [:sel | self				printMethodChunk: sel				on: aFileStream				moveSource: moveSource				toFile: fileIndex].	aFileStream nextChunkPut: ' '!fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the messages of the receiver that have been changed	(i.e., are entered into the system ChangeSet) onto aFileStream.  If	the boolean argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the source code."	| org sels allPoolRefs |	(org _ self organization) categories do: 		[:cat | 		sels _ (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels size > 0			ifTrue: 				[Transcript cr; show: self name , '>' , cat.				allPoolRefs _ Set new.				sels do: [:sel | allPoolRefs addAll: (self allPoolRefsIn: sel)].				self printPoolChunks: allPoolRefs on: aFileStream.				self printCategoryChunk: cat on: aFileStream.				sels do: [:sel | 						self							printMethodChunk: sel							on: aFileStream							moveSource: moveSource							toFile: fileIndex].				aFileStream nextChunkPut: ' ']]!fileOutMessage: aString on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's message, aString, onto aFileStream.  If	the boolean argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the source code."	| cat |	cat _ self organization categoryOfElement: aString.	cat == nil ifTrue: [^self error: 'no such message'].	self printPoolChunks: (self allPoolRefsIn:aString asSymbol) on: aFileStream.	self printCategoryChunk: cat on: aFileStream.	self		printMethodChunk: aString		on: aFileStream		moveSource: moveSource		toFile: fileIndex.	aFileStream nextChunkPut: ' '!moveChangesFromFileNumber: anInteger1 toFileNumber: anInteger2 toFileStream: aFileStream 	"Used in the process of condensing changes, this message requests that the source code of all methods of the receiver that have been changed should be moved to aFileStream."	| bn changes |	(bn _ organization == #collapsed)		ifTrue:			[organization _ ClassOrganizer new.			methodDict size > 0 ifTrue:				[organization classifyAll: self selectors under:					ClassOrganizer defaultProtocol.				].			organization				collapsedForClass: self				fromFileNumber: anInteger1				toFileNumber: anInteger2				toFile: aFileStream.			]		ifFalse:			[self organization				moveChangedCommentFromFileNumber: anInteger1				toFileNumber: anInteger2				toFileStream: aFileStream.			].	changes _ methodDict keys select:		[:sel | (methodDict at: sel) fileIndex = anInteger1.].	self fileOutChangedMessages: changes		on: aFileStream		moveSource: true		toFile: anInteger2.	bn ifTrue: [organization _ #collapsed.].!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that the source	code of all methods of the receiver that have been changed should be moved to	newFile."	| bn changes |	(bn _ organization == #collapsed)		ifTrue:			[organization _ ClassOrganizer new.			methodDict size > 0 ifTrue:				[organization classifyAll: self selectors under:					ClassOrganizer defaultProtocol.				].			organization				collapsedForClass: self				fromFileNumber: 2				toFileNumber: 2				toFile: newFile.			]		ifFalse:			[self organization moveChangedCommentToFile: newFile numbered: 2.].	changes _ methodDict keys select:		[:sel | (methodDict at: sel) fileIndex = 2].	self		fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2.	bn ifTrue: [organization _ #collapsed.].!printMethodChunk: aSelector on: aFileStream moveSource: moveSource toFile: fileIndex 	"Print the source code for the method associated with the argument 	selector onto 	the fileStream. aFileStream, and, for backup, if the argument 	moveSource (a Boolean) 	is true, also set the file index within the method to be the argument 	fileIndex. "	| pd pn |	moveSource ifFalse:		[Cursor write showWhile:			[aFileStream cr; cr; nextChunkPut:				(self sourceCodeAt: aSelector).			].		^self		].	pd _ 1.	pn _ aFileStream position.	fileIndex == nil ifFalse:		[fileIndex < MinFileIndexQuadWordAligned ifFalse:			[pd _ 8 - (pn - 1 \\ 8).			pn _ pn + pd bitShift: -3.			].		].	Cursor write showWhile:		[aFileStream nextPutAll: (String new: pd withAll: Character cr).		aFileStream nextChunkPut: (self sourceCodeAt: aSelector).		(self compiledMethodAt: aSelector)			setSourcePosition: pn inFile: fileIndex.		].!printPoolChunks: aCollection on: aFileStream 	"print category definition on aFileStream."	aFileStream cr;cr.	aCollection do: [:each | aFileStream cr.			aFileStream nextChunkPut:				'Pool named: #', (each at: 1) , ' includes: #' , (each at: 2)]!printSharedPoolChunk: aPoolName on: aFileStream 	"print a doIt onto the stream which sets up the pool before the class is filed in"	aFileStream cr.	aFileStream nextChunkPut: 'Pool named: #' , aPoolName.	aFileStream cr! !!ClassDescription methodsFor: 'fileIn-Out'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	"file me out on aFileStream"	| bn ix |	aFileStream emphasis: 5.		"Meant to be 12 point bold font."	self sharedPools do: [:pool | (pool isKindOf: Pool) ifTrue: [self printSharedPoolChunk: pool name on: aFileStream]].	aFileStream nextChunkPut: self definition.	bn _ moveSource and: [organization == #collapsed.].	bn		ifTrue:			[ix _ aFileStream emphasis.			aFileStream emphasis: 3.			organization _ ClassOrganizer new.			methodDict size > 0 ifTrue:				[organization classifyAll: self selectors under:					ClassOrganizer defaultProtocol.				].			organization				collapsedForClass: self				fromFileNumber: #any				toFileNumber: #any				toFile: nil.			aFileStream emphasis: ix.			]		ifFalse:			[self organization				putCommentOnFile: aFileStream				numbered: fileIndex				moveSource: moveSource.			].	aFileStream cr.	organization categories do: 		[:heading |		self			fileOutCategory: heading			on: aFileStream			moveSource: moveSource			toFile: fileIndex.		].	bn ifTrue: [organization _ #collapsed.]! !!ClassDescription methodsFor: 'pool variables'!allPoolRefsIn: aMessageSelector	| literals assocs classVarAssociations pools notFound poolRefs | 	literals _ (self compiledMethodAt: aMessageSelector) literals.	assocs _ OrderedCollection new.	literals do: [:lit | lit class == Association ifTrue:[assocs add: lit]].	classVarAssociations _ self classPool.	pools _ self sharedPools.	poolRefs _ OrderedCollection new.	assocs do: [:each | (self classPool includes: each) ifFalse:[		notFound _ true.		pools do: [:pool | (notFound and: [(pool includesKey: each key) and: [pool isKindOf: Pool]]) ifTrue:[poolRefs add: (Array with: pool name with: each key). notFound _ false]]]].	^poolRefs! !!Metaclass methodsFor: 'copying'!copy	"Make a copy of the receiver without a list of subclasses.  Share the 	reference to the sole instance."	| copy t |	organization == #collapsed ifTrue: [self organization.].	t _ thisClass.	thisClass _ nil.	copy _ super copy.	thisClass _ t.	^copy!copyForValidation	"Special copy for ClassDescription validateFrom:in:fields:methods:.  Answer a copy	of the receiver without the subclasses."	organization == #collapsed ifTrue: [self organization.].	^super copy! !!Metaclass methodsFor: 'pool variables'!sharedPools	^thisClass sharedPools! !!Class methodsFor: 'initialize-release'!obsolete	"Change the receiver to an obsolete class by changing its name to have the prefix -AnObsolete-, and nilling the fields of any instances."	self organization.	"Ensure that ClassOrganizer Store entry (if any) gets nilled-out."	self class organization.	"Ensure that ClassOrganizer Store entry (if any) gets nilled-out."	self isPointers ifTrue:		[self allInstancesDo: [:instance | instance nilFields.]]. 	"nil fields of instances"	('AnObsolete*' match: name) ifFalse:		[name _ 'AnObsolete' , name].	classPool _ Dictionary new.	self class obsolete.	super obsolete! !!Class methodsFor: 'copying'!copy	| newClass |	self organization.	newClass _ self class copy new		superclass: superclass		methodDict: methodDict copy		format: format		name: name		organization: organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^newClass!copyForValidation	"Make a copy of the receiver (a class) but do not install the created class	as a new class in the system.  This is used for creating a new version of	the receiver in which the installation is deferred until all changes are	successfully completed."	self organization.	^self class copy new		superclass: superclass		methodDict: methodDict copy		format: format		name: name		organization: organization		instVarNames: instanceVariables copy		classPool: classPool		sharedPools: sharedPools! !!Class methodsFor: 'class name'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	newName _ aString asSymbol.	(Smalltalk includesKey: newName)		ifTrue: [^self error: newName , ' already exists'].	self organization.	"Ensure that ClassOrganizer Store entry (if any) gets nilled-out."	self class organization.	"Ensure that ClassOrganizer Store entry (if any) gets nilled-out."	Smalltalk renameClass: self as: newName.	name _ newName.	self comment: self comment.	self class comment: self class comment! !!Object class methodsFor: 'file accessing'!createAnalystDataItem: tempItem	"Create a new Analyst data item file. This is the default data item creation message for Analyst tools." 	| return filename | 	return _ InformationCenter getNewKeyFor: tempItem withKeywords: String new dBoxTitle: 'Create new ', tempItem label askClass: true.	return == nil ifTrue: [^nil].	Cursor wait showWhile: 		[filename _ Disk makeNewFileName: (return at: 1) withSuffix: (DataMaster giveMe: #suffixString for: tempItem label).		(HeaderFileStream fileNamed: filename) readWrite; writeHeaderLabel: (return at: 1) class: (return at: 3) mods: (return at: 4) dataType: (DataMaster giveMe: #iconIndex for: filename)].	^Array with: return with: filename!getFileName: aFileName	^FileStream getFileName: aFileName list: self listOfFileDirectories!getNewFileName: aFileName	^FileStream getNewFileName: aFileName list: self listOfFileDirectories!getOldFileName: aFileName	^FileStream getOldFileName: aFileName list: self listOfFileDirectories!listOfFileDirectories	self withAllSuperclasses do:		[:each | (FileDirectoryLists includesKey: each name) ifTrue:			[^FileDirectoryLists at: each name]]!openFile: aFileName	^FileStream openFile: aFileName list: self listOfFileDirectories!openNewFile: aFileName	^FileStream openNewFile: aFileName list: self listOfFileDirectories!openOldFile: aFileName	^FileStream openOldFile: aFileName list: self listOfFileDirectories! !!RS232DisplayMem class methodsFor: 'As yet unclassified'!height	^ Height!initialize"RS232DisplayMem initialize"	TTYFont _ (TextConstants at: #DefaultTextStyle) fontAt: (TextStyle getNumForStrikeFont: 'Gacha10').	Height _ TTYFont height + 4.	Width _ TTYFont widthOf: $a.	Stops _ TTYFont stopConditions copy.	CharTable _ Character classPool at: #CharacterTable!new	^super new initialize! !Idle class comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation.  All rights reserved.Idle watches the system and waits for a specified time of no input.  After Idle times out, it blanks the display to save the poor, little phosphors, and displays a user-specified form in a random walk (again, for the phosphors) to let evil terminal stealers know that the machine is in use.  Idle returns control when any key or mouse button is pressed.Be aware, however, that Idle is not stand-alone.  Alterations have been made to InputState|nextEvent:with: to support the timeout monitoring.  Don''t mess with Idle until after disabling these references or the system will probably lock up very nicely.For the user:	<Idle start> lets you start the inuse display without waiting for a timeout.	<Idle idleForm: aForm> allows you to specify the image to be displayed.  The default		is rather boring, so be creative.	<Idle idleForm> answers the displayed form, in case you lose it.	<Idle watchTime: howLong> lets you set the timeout period in minutes.		The default time is 5 minutes.'!!Idle class methodsFor: 'initialize-release'!initialize	"initialize class instance variables, and start the background process""	Idle initialize.	"	previousCursorPoint _ Sensor cursorPoint.	formBorder _ 3 asPoint.	form _ nil.	watchTime _ 1500.	driftDelayTime _ 2000.	secondTimeout _ 2000.	self installWatcher.!installWatcher"	Idle installWatcher.	"	self killWatcher.	watchCount _ 0.	watcher _ [self watch.] newProcess.	watcher priority: Processor userInterruptPriority.	watcher resume.!killWatcher"	Idle killWatcher.	"	watcher == nil ifFalse: [watcher terminate.].!release	self killWatcher.	super release.!removeFromSystem	self release.	^super removeFromSystem! !!Idle class methodsFor: 'accessing'!driftDelayTime: milliseconds	driftDelayTime _ milliseconds.!idleForm	^form!idleForm: aForm"	Idle idleForm: (Form readFrom: 'Balloon.form').	"	form _ aForm.	^aForm!isActive	^activeCount ~~ nil!secondTimeout: minutes"	Idle secondTimeout: 30.	"	secondTimeout _ minutes rounded max: 0.!watchTime: minutes"	Idle watchTime: 5.	"	watchTime _ minutes rounded max: 0.! !!Idle class methodsFor: 'action'!newEvent	"set input event flag"		| temp |	event _ #notNil.	activeCount == nil ifFalse:		[activeCount = 0			ifTrue: [activeCount _ 1.]			ifFalse:				[Time totalSeconds - activeTime > 3 ifTrue:					[activeCount _ activeCount + 1.					(temp _ Delay classPool at: #ActiveDelay ifAbsent: [nil.]) == nil ifFalse: [temp reactivate.].					activeCount > 3 ifTrue:					"Emergency restoration (self drift seems to have died)."						[((Display isKindOf: DisplayScreen) and: [Display bits isKindOf: DisplayBitmap.]) ifFalse:							[idleDisplay == nil ifFalse:								[idleDisplay become: Display; display.								idleDisplay bits size > 16 ifFalse: [ScheduledControllers restore.].								idleDisplay _ Display.								].							].						].					].				].		activeTime _ Time totalSeconds.		^true		].	^false!noIdleDuring: aBlock	| d p v |	d _ Delay forMilliseconds: 10000.	p _ [[true] whileTrue: [d wait. Idle newEvent]] newProcess.	p priority: Processor userInterruptPriority.	p resume.	v _ aBlock value.	p terminate.	^ v!start"	Idle start.	"	"...initialize idle display upon timeout or command"	| enoughCore oldCursorPoint process processes viewToRestore |	loop == nil ifFalse: [^self].	loop _ #notNil.	activeCount _ 0.	event _ nil.		[((Smalltalk includesKey: #Auditor) and: [Auditor audit.]) ifTrue:			[Auditor absoluteAdd: 'Idle start at: ', Time dateAndTimeNow printString.			Auditor save.			].		oldCursorPoint _ Sensor cursorPoint.		(enoughCore _ Smalltalk coreLeft > ((Display boundingBox area // 16) + Smalltalk coreLeftLimit + 8000))			ifTrue: [idleDisplay _ Form extent: Display extent.]			ifFalse:				[processes _ OrderedCollection new.					[process _ Processor suspendFirstAt: Processor userSchedulingPriority ifNone: [nil.].					process == nil.					] whileFalse: [processes add: process.].				(Smalltalk includesKey: #ImageEditor) ifTrue:					[(Smalltalk at: #ImageEditor) withAllSubclasses do:						[:each |						each allInstancesDo:							[:inst |							inst view topView controller = ScheduledControllers activeController ifTrue:								[viewToRestore _ inst view topView.								inst controlTerminate.								].							].						].					].				idleDisplay _ Form extent: 16 @ 16.				].		idleDisplay become: Display; display.		self drift.	"clear screen and display drifting form"		Sensor cursorPoint: (previousCursorPoint _ oldCursorPoint).		idleDisplay become: Display; display.		idleDisplay _ Display.		enoughCore ifFalse:			[processes do: [:each | each resume.].			ScheduledControllers restore.			].		((Smalltalk includesKey: #Auditor) and: [Auditor audit.]) ifTrue:			[Auditor absoluteAdd: 'Idle end at: ', Time dateAndTimeNow printString.].		watchCount _ 0.		event _ #notNil.		loop _ activeCount _ nil.		] forkAt: Processor userInterruptPriority.!watch	"This is the loop that watches the system for periods of no input."	| hiatus |	hiatus _ Delay forSeconds: 60.	[true.] whileTrue:		[hiatus wait.		loop == nil ifTrue:			[watchCount _ watchCount + 1.			previousCursorPoint = Sensor cursorPoint & (event == nil) ifFalse:				[previousCursorPoint _ Sensor cursorPoint.				event _ nil.				watchCount _ 0.				].			watchCount >= watchTime				ifTrue: [self start.]				ifFalse: [previousCursorPoint _ Sensor cursorPoint.].			].		].! !!Idle class methodsFor: 'private'!drift	"update form position and check for input to finish idle"	| startTime hiatus balloon vel maxVel minVel velFactor boundBox milliClock where newWhere suspendedProcess suspendedProcesses times |	startTime _ Time totalSeconds.	previousCursorPoint _ Sensor cursorPoint.	driftDelayTime = 0 ifFalse: [hiatus _ Delay forMilliseconds: driftDelayTime].	balloon _ self driftForm.	vel _ 0 @ 0.	minVel _ (maxVel _ 8 @ 8) * -1.	velFactor _ 3.	boundBox _ idleDisplay boundingBox.	boundBox extent: (boundBox extent - balloon extent).	milliClock _ LargePositiveInteger new: 4.	where _ boundBox center.	(Smalltalk at: #BackgroundDelay ifAbsent: [0]) = 0 ifFalse:		[suspendedProcesses _ OrderedCollection new.			[(suspendedProcesses add:				(Processor suspendFirstAt: Processor userSchedulingPriority ifNone: [nil.])			) == nil.			] whileFalse.		suspendedProcesses removeLast.		].		[Sensor flushKeyboard.		event _ nil.		Sensor cursorPoint: previousCursorPoint.		times _ 0.		idleDisplay black.			[event == nil &				((previousCursorPoint - Sensor cursorPoint) abs < (10 @ 10) or:					[(Time totalSeconds - startTime) // 60 >= secondTimeout]				)			] whileTrue:				[5 timesRepeat:					[times _ times + 1.					activeCount _ 0.					Sensor cursorPoint: previousCursorPoint.					Time millisecondClockInto: milliClock.					vel x: (vel x + ((milliClock at: 1) \\ 3 - 1)).					Time millisecondClockInto: milliClock.					vel y: (vel y + ((milliClock at: 1) \\ 3 - 1)).					vel _ (vel min: maxVel) max: minVel.					newWhere _ where + ((vel x quo: velFactor) @ (vel y quo: velFactor)).					(newWhere x < boundBox left) | (newWhere x > boundBox right)						ifTrue: [vel x: vel x negated.].					(newWhere y < boundBox top) | (newWhere y > boundBox bottom)						ifTrue: [vel y: vel y negated.].					newWhere _ where + ((vel x quo: velFactor) @ (vel y quo: velFactor)).					newWhere = where ifFalse:						[balloon displayOn: idleDisplay at: (where _ newWhere).].					].				(suspendedProcesses ~= nil and: [(Smalltalk at: #BackgroundDelay ifAbsent: [0.]) = 0.]) ifTrue:					[suspendedProcesses do: [:each | each resume.].					suspendedProcesses _ nil.					].				hiatus == nil ifFalse: [times > 24 ifTrue: [hiatus wait. times _ 0.]].				].		Sensor waitNoButton; flushKeyboard.		event _ nil.		Time totalSeconds - startTime // 60 < secondTimeout			ifTrue: [true.] ifFalse: [self forceLogin.].		] whileFalse.	suspendedProcesses == nil ifFalse: [suspendedProcesses do: [:each | each resume]]!driftForm	"answer the form to display while idle"	| aForm driftForm |	aForm _ ((Smalltalk at: #RS232Collector ifAbsent: [nil.]) = nil)		ifTrue: [form.] ifFalse: [RS232Collector idleForm.].	aForm == nil ifTrue:		[aForm _ ((Form dotOfSize: 50) offset: 0 @ 0) reverse].	driftForm _ (Form extent: (aForm extent + (formBorder rounded * 2))) black.	aForm displayOn: driftForm at: formBorder.	^driftForm!forceLogin	"the user spent too much time on the phone, so make him log back in."	| logClass processes process result |	logClass _ Smalltalk at: #LogInOut ifAbsent: [nil].	(logClass class canUnderstand: #reLogIn) ifTrue:		[idleDisplay gray.		processes _ OrderedCollection new.		Processor systemBackgroundPriority - 1 to: Processor userSchedulingPriority do:			[:i |				[(process _ Processor suspendFirstAt: i ifNone: [nil]) == nil.]					whileFalse: [processes add: process]			].		process _ [[true.] whileTrue.] newProcess.		process priority: Processor systemBackgroundPriority - 1.		process resume.		idleDisplay become: Display.		activeCount _ nil.		result _ logClass reLogIn.		idleDisplay become: Display.		activeCount _ 0.		process terminate.		processes do: [:each | each resume].		Sensor waitNoButton; flushKeyboard.		^result		].	^true! !!ClickBuffer class methodsFor: 'class initialization'!initialize	"ClickBuffer initialize."	Smalltalk at: #Clicks put: ClickBuffer new! !SpreadsheetRule class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!ConfigFile class methodsFor: 'access'!clearCurrentUserFile	"ConfigFile clearCurrentUserFile"	CurrentUserConfig == nil ifFalse: [CurrentUserConfig release].	CurrentUserConfig _ nil!currentUserConfig	"ConfigFile currentUserConfig"	CurrentUserConfig == nil		ifFalse: [CurrentUserConfig fileName = (UserName, '-configFile') asFileName ifFalse: [self clearCurrentUserFile]].	CurrentUserConfig == nil		ifTrue: [Cursor execute showWhile: [CurrentUserConfig _ self new initialize: (UserName, '-configFile') asFileName]].	^CurrentUserConfig!userConfigFor: userName	"ConfigFile userConfigFor: 'ellersk'"	| cf fileName |	userName = UserName ifTrue: [^self currentUserConfig].	fileName _ (userName, '-configFile') asFileName.	ConfigFile allInstances do: [:ocf | ocf fileName = fileName ifTrue: [^ocf]].	Cursor execute showWhile: [cf _ self new initialize: fileName].	^cf! !LogInOut class comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation.  All rights reserved.'!!LogInOut class methodsFor: 'initialize'!initialize	"LogInOut initialize"	SystemName _ 'The Analyst(tm)'.	NetLogin _ #NoNetPassword. "other choices are #AutoSetNetPassword and #AskNetPassword"	DefaultELabel _ ByteArray new: 19.	#(4 11 84 104 8 115 9 7 8 115 39 9 68 117 109 98 33 5 4) inject: 1 into: [:i :next | DefaultELabel at: i put: next. i + 1].	DefaultELabel _ DefaultELabel asString!initialize: systemName	"this should be called during the build, perhaps"	"LogInOut initialize: 'Analyst'"	SystemName _ systemName! !!LogInOut class methodsFor: 'net info'!getNetworkInfo	"LogInOut getNetworkInfo"	| netFileStream switch fs | 	switch _ String with: $\ with: $\.	(netFileStream _ self class openOldFile: 'networkinfo') == nil		ifTrue: "file does not exist, build one from the last known choices"			[^self writeNetworkInfo].	"file exists, clear everything have and use it"	UserProfile current clearItAll.	netFileStream readOnly.	fs _ String with: netFileStream next with: netFileStream next.	fs = switch		ifTrue: [NetLogin _ (netFileStream upTo: Character cr) asSymbol]		ifFalse: [NetLogin _ #AutoSetNetPassword.				netFileStream position: 0 "reset to pick up domain"].	UserProfile current domain: (netFileStream upTo: Character cr) organization: (netFileStream upTo: Character cr).	[(fs _ netFileStream upTo: Character cr) isEmpty or: [fs = switch]]		whileFalse: [UserProfile current addFileServer: fs].	((fs _ netFileStream upTo: Character cr) isEmpty not and: [fs = #Press asString or: [fs = #Interpress asString]])		ifTrue: [(Smalltalk includesKey: #BackgroundPrinter) ifTrue: [BackgroundPrinter setToPress: fs = #Press]]		ifFalse: [fs isEmpty ifFalse: [UserProfile current addPrinter: fs]].	netFileStream close!netLogIn: userName password: localPassword	"NetLogin should be used as follows:		#NoNetPassword	don't do anything - there is no net or it is unsettable from ST		#AutoSetNetPassword	try to use the Analyst user name and password		#AskNetPassword	Ask the user to provide a user name and password for logging into the net.	If this image does not contain XDEInterfaceModel, then set NetLogin to NoNetPassword."	(NetLogin == nil or: [NetLogin ~= #NoNetPassword and: [(Smalltalk includesKey: #XDEInterfaceModel) not]])		ifTrue: [NetLogin _ #NoNetPassword. self writeNetworkInfo. ^self].	NetLogin = #NoNetPassword ifTrue: [^self].	NetLogin = #AutoSetNetPassword		ifTrue: [UserProfile current login: userName password: localPassword]		ifFalse: [UserProfile current login == nil ifTrue: [^self]].	(XDEInterfaceModel giveMeOne: false) networkLogin!printErrorLog	"If AnalystError.log and XDEInterfaceModel exist and NetLogin is not #NoNetPassword, then send the log to the currently set printer, and delete it afterwards"	| errorLog printPacket | 	errorLog _ 'AnalystError.log'.	(NetLogin == nil or: [NetLogin = #NoNetPassword or:			[(Smalltalk includesKey: #XDEInterfaceModel) not				or: [(Disk includesKey: errorLog) not]]])		ifTrue: [^self].	printPacket _ PrintFrom1108 new sendPrintFile: errorLog printer: UserProfile current printerName copies: 1 doneSemaphore: nil.	XDEInterfaceModel addToQueue:		[printPacket heresYourChance.		Disk removeKey: errorLog ifAbsent: []].!writeNetworkInfo	"LogInOut writeNetworkInfo"	| netFileStream switch | 	NetLogin == nil ifTrue: [NetLogin _ #AutoSetNetPassword].	switch _ String with: $\ with: $\.	netFileStream _ (FileStream fileNamed: 'networkinfo') writeShorten.	netFileStream		nextPutAll: NetLogin asString;		nextPut: Character cr;		nextPutAll: UserProfile current domain;		nextPut: Character cr;		nextPutAll: UserProfile current organization.	UserProfile current fileServerChoices do: [:fs | netFileStream nextPut: Character cr; nextPutAll: fs].	netFileStream nextPut: Character cr; nextPutAll: switch.	UserProfile current printerChoices do: [:fs | netFileStream nextPut: Character cr; nextPutAll: fs].	netFileStream close! !!LogInOut class methodsFor: 'access'!displayGreeting	"LogInOut displayGreeting"	| aForm aRectangle | 	aForm _  FastTextDisplayScanner new formFromText: ((Text string: 'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.' emphasis: 1), (Text string: 'Welcome to ', SystemName emphasis: 5)) textStyle: (TextStyle default alignment: 2; lineGrid: 16; baseline: 12) maxWidth: 500.	aRectangle _ aForm boundingBox.	aRectangle _  aRectangle align: aRectangle topCenter with: (Display boundingBox topCenter).	aForm displayOn: Display at: aRectangle topLeft.!editUsersFile	"LogInOut editUsersFile"	| userFileStream initContents | 	NonprogrammerMenu inhibitProgramming ifTrue: [^self].	(userFileStream _ self usersFileStream) == nil ifTrue: [^self].	initContents _ userFileStream contentsOfEntireFile.	userFileStream close.	EditStringHolder new		openEditorOn: initContents		blockOnAccept:			[:newList :userStream |			userStream reopen; reset; readWriteShorten.			userStream nextPutAll: newList.			userStream close]		withArgs: userFileStream		withLabel: 'Editing Users List'!getCenters	"get all the .center files on the disk." "LogInOut getCenters"	| newList end i ch |	Disk removeKey: #Scavenge asString, InformationCenter centerSuffix ifAbsent: [].	Cursor execute showWhile:		[newList _ OrderedCollection new.		(Disk filesMatching: (String with: $*), InformationCenter centerSuffix) do:			[:each |				end _ i _ each size.				[i = 1 or: [(ch _ each at: i - 1) = $/ or: [ch = $>]]]					whileFalse: [i _ i - 1. ch = $. ifTrue: [end _ i]].				newList add: (each copyFrom: i to: end - 1)].		InformationCenter possibleCenters: newList.		ClassificationScheme initialize]!initializeCurrentUser	| color font printer clipState config temp | 	UserProfile current userName: UserName.	config _ ConfigFile currentUserConfig.	ScreenController		changeOITMenu;		makeScreenColor: ((color _ config getSection: #ScreenColor) == nil ifTrue: [#gray] ifFalse: [color]) asSymbol logChange: false.	self setIdleFormWithChange: false.	Smalltalk at: #UserFont put: ((font _ config getSection: #SystemUserFont) == nil ifTrue: [1] ifFalse: [font asNumber]).	(printer _ config getSection: (Smalltalk at: #PressOrInterpress) asSymbol) == nil		ifFalse: [UserProfile current printerName: printer].	(Smalltalk includesKey: #ClockView) ifTrue: [ClockView timeZonePopUpFromConfigFile].	Clipboard statusString: ((clipState _ config getSection: #ClipboardState) == nil ifTrue: ['noStack/f'] ifFalse: [clipState]).	(temp _ config getSection: #ScrollMenuScrollMsec) == nil		ifFalse: [ScrollMenu scrollMsec: temp asNumber].	(temp _ config getSection: #TreeMenuPopUpChildren) == nil		ifFalse: [TreeMenu popUpChildren: temp = 'true'].	(temp _ config getSection: #TreeMenuMoveCursor) == nil		ifFalse: [TreeMenu accelerateCursorPlace: temp = 'true']!setIdleFormWithChange: forceChange	"if forceChange is false, just read and set the idle form for the current user; if forceChange is true, get and set the form from the info center copy buffer and set on the disk, too"	| fullName fileName theItem oldFile itemFileName type theForm | 	(Smalltalk includesKey: #Idle) ifFalse: [forceChange ifTrue: [self booboo: 'Idle not installed']. ^self].	fileName _ UserName, '.idleImage'.	forceChange		ifTrue:			[type _ Clipboard nextClass.			type == Form				ifTrue: [theForm _ Clipboard retrieveEntry contents]				ifFalse:					[type == Text						ifTrue: [theForm _ Clipboard retrieveEntry contents asParagraph asForm]						ifFalse:							[(type == DataItem and: [(itemFileName _ Clipboard next contents filename) ~~ nil and: [(fullName _ DataMaster formFileName: itemFileName) ~~ nil]])								ifTrue: [theForm _ Form readFrom: fullName]]].			theForm == nil				ifFalse: [Idle idleForm: theForm. theForm writeOn: fileName]				ifTrue: [Clipboard booboo]]		ifFalse: "just going to read it, unless it isn't there"			[(fullName _ self getOldFileName: fileName) == nil				ifFalse: [Idle idleForm: (Form readFrom: fullName)]]!userList	"return a collection of all the valid user names"	"LogInOut userList"	| userList userFileStream aUser | 	userList _ OrderedCollection new.	(userFileStream _ self usersFileStream) == nil ifTrue: [^userList].	[userFileStream atEnd] whileFalse:		[aUser _ userFileStream upTo: $\.		 aUser isEmpty ifFalse: [userList addLast: aUser].		 userFileStream skipTo: Character cr]. 	userFileStream close.	^userList!usersFileName	^'AnalystUsers'!usersFileStream	| userFileStream | 	(Disk includesKey: self usersFileName) ifFalse: [^nil].	userFileStream _ (HeaderFileStream oldFileNamed: self usersFileName) readOnly.	userFileStream isEncrypted ifTrue: [^(EncryptedFileStream encryptedStreamOn: userFileStream withKey: (self changeKey: userFileStream labelFromHeader)) readOnly].	userFileStream writeHeaderLabel: DefaultELabel class: String new mods: nil dataType: 1.	userFileStream close.	EncryptedFileStream encryptFile: self usersFileName toFile: nil withKey: (self changeKey: DefaultELabel).	^self usersFileStream! !!LogInOut class methodsFor: 'login/out'!changeKey: theKey	"this is just to try to make trouble"	| myKey myKeySize |	myKeySize _ (theKey inject: 0 into: [:i :c | c asciiValue + i]) \\ theKey size.	myKey _ String new: myKeySize.	1 to: myKeySize do: [:i |		myKey at: i put: (((theKey at: i) asciiValue bitShift: 1) bitXor: ((theKey at: i + myKeySize \\ theKey size + 1) asciiValue)) asCharacter].	^myKey!logInDBox	^DBoxView		openFor: #(fill password)		title: (ReLogInUser == nil ifTrue: [SystemName, ' Log In'] ifFalse: ['Away too long - Please log in again'])		labels: #(#(Name:) #(Password: ))		defaults: (Array with: (ReLogInUser == nil ifTrue: [String new] ifFalse: [ReLogInUser]) with: String new)		autoAccept: true!logMeIn	"check out this person. If ReLogInUser is not nil, this is assumed to be a re-login."	| theReturn user password theError userFileStream aUser thePassword wheel |	theError _ 'Invalid Log In. Please try again.'.	theReturn _ self logInDBox.	theReturn == nil ifTrue: [ReLogInUser == nil ifTrue: [^self quit] ifFalse: [^false]].	1 to: 2 do: [:i | (theReturn at: i) == nil ifTrue: [theReturn at: i put: String new]].	user _ (theReturn at: 1) asLowercase.	password _ (theReturn at: 2) asLowercase.	(userFileStream _ self usersFileStream) == nil ifTrue: [self booboo: 'The user list is missing.Consult your system administrator'. ^false].	[userFileStream atEnd] whileFalse:		[aUser _ (userFileStream upTo: $\) asLowercase.		aUser = user			ifTrue: [thePassword _ (userFileStream upTo: $\) asLowercase.					thePassword = password						ifFalse:							[userFileStream close. self booboo: theError. ^false]						ifTrue:							[aUser = ReLogInUser ifTrue:								[userFileStream close.								[Clipboard includes: password] "just in case"									whileTrue: [Clipboard remove: password].								^true].							wheel _ ((userFileStream upTo: $\)=(String with: $t)).							(ReLogInUser ~= nil and: [wheel not])								ifTrue: [userFileStream close. self booboo: theError. ^false].							Auditor turnMeOn: ((userFileStream next: 2) = '66').							userFileStream close.							ReLogInUser == nil ifFalse: [ReLogInUser _ user].							Cursor wait showWhile: [								UserProfile current login: user password: String new.								self netLogIn: user password: password.								self getCenters.								Smalltalk at: #UserName put: user.								Smalltalk at: #Wheel put: wheel.								NonprogrammerMenu makeWheel: Wheel.								Cursor read showWhile: [self initializeCurrentUser].								Auditor add: 'logged in -- ', UserName, Time dateAndTimeNow printString.								self printErrorLog.								self displayGreeting].							^true]]			ifFalse: [userFileStream skipTo: Character cr]]. 	userFileStream close.	self booboo: theError.	^false!logOut "This method will shut down all other windows, save the information center and open the logon window "	(Smalltalk includesKey:#RS232Model) ifTrue: [(RS232Model checkRS232Connections) ifFalse: [^self]].	(self confirm: 'Logging out will close all windows.Are you sure you want to log out?') ifFalse: [^self].	ScheduledControllers scheduledControllers do:		[:each |(each isMemberOf: ScreenController) ifFalse: [each closeAndUnschedule]].	((ScheduledControllers scheduledControllers) size = 1)		ifFalse: [ScheduledControllers restore.				^self booboo: 'the remaining windows require attention'].	((ConfigFile currentUserConfig getSection: #ClipboardState) = Clipboard statusString)		ifFalse: [ConfigFile currentUserConfig writeSection: #ClipboardState with: Clipboard statusString].	ConfigFile currentUserConfig compressFile.	InformationCenter saveAndClearAll.	Smalltalk at: #UserName put: nil.	Clipboard clear.	UserProfile current clearPasswords.	ConfigFile clearCurrentUserFile.	self quit!quit	"this will allow you to get out of Analyst "	| imagePrefix |	(self confirm: 'Do you really want to quit ', SystemName, (String with: $?))		ifTrue:			[Auditor shutDown.			Sensor leftShiftDown				ifTrue:					[(SourceFiles ~= nil or: [self confirm: 'SourceFiles is nil. Still want to save?']) ifTrue:						[(Smalltalk respondsTo: #addToAnalystVersion:) ifTrue:							[Smalltalk addToAnalystVersion: Time dateAndTimeNow printString, ' saved by ', UserProfile current userName, (String with: Character cr)].						(Smalltalk includesKey: #XDEInterfaceModel) ifTrue: [XDEInterfaceModel installQueueProcess "clear out anything in there"].						(Smalltalk includesKey: #Idle) ifTrue: [Idle killWatcher].						imagePrefix _ Smalltalk getImagePrefix.						Smalltalk saveAs: imagePrefix thenQuit: false.						Sensor cursorPoint: Display boundingBox center.						(Smalltalk includesKey: #Idle) ifTrue: [Idle installWatcher].						Cursor execute showWhile: [						self getNetworkInfo.						(SourceFiles ~= nil and: [Disk includesKey: (SourceFiles at: 2) name])							ifFalse: [SourceFiles _ nil "this allows users with no changes to do printIts"]]]]				ifFalse: [Smalltalk quit]].	self startUp!reLogIn	| ans | 	UserName == nil ifTrue: [^true].	ReLogInUser _ UserName.	UserName _ nil.	ans _ self logMeIn.	UserName _ ReLogInUser.	ReLogInUser _ nil.	(ans and: [Smalltalk includesKey: #Idle]) ifTrue: [Idle secondTimeout: 30].	^ans!startUp	(Smalltalk includesKey: #Idle) ifTrue:		[Idle driftDelayTime: 0.		Idle start].	self logMeIn.	(Smalltalk includesKey: #Idle) ifTrue:		[[Idle isActive] whileTrue.		"On all but Sun's, allow user and lower priority processes time to run by pausing during Idle.  The PPS Sun interpreter does something strange with Display that makes this impossible"		(Smalltalk includesKey: #UnixFileDirectory) ifFalse: [Idle driftDelayTime: 2000]]! !SSDataBase class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SSDataBase class methodsFor: 'As yet unclassified'!on: aFileName	| newDB | 	newDB _ super new init: aFileName.	^newDB! !DataBase class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DataBase class methodsFor: 'instance creation'!createAnalystDataItem: tempItem	"Create a new Analyst data item file. This differs from the default in order to not allow setting of class" 	| return filename | 	return _ InformationCenter getNewKeyFor: tempItem withKeywords: String new dBoxTitle: 'Create new ', tempItem label askClass: false.	return == nil ifTrue: [^nil].	Cursor wait showWhile: 		[filename _ Disk makeNewFileName: (return at: 1) withSuffix: (DataMaster giveMe: #suffixString for: tempItem label).		(HeaderFileStream fileNamed: filename) readWrite; writeHeaderLabel: (return at: 1) class: (return at: 3) mods: (return at: 4) dataType: (DataMaster giveMe: #iconIndex for: filename)].	^Array with: return with: filename!new: theDB 	^super new initialize: theDB! !!DataBase class methodsFor: 'new views'!openWithSuitcase: aSuitcase 	"Schedule a DataBase window"	| theRightOne theModel topView firstListView secondListView textView queryView reportView classView theClass |	Cursor wait		showWhile: 			[theModel _ DataBase new: aSuitcase dataItem filename.			topView _ StandardSystemView new model: theModel.			topView controller: DBStandardSystemController new.			theModel topView: topView.			(aSuitcase updateFromHeaderIn: theModel file)				ifFalse: [theModel file writeHeaderFor: aSuitcase dataItem].			topView label: aSuitcase dataItem label.			topView helpIndex: #Database.			topView classifyLabel: aSuitcase classification.			topView addDependent: aSuitcase.			firstListView _ DFieldListView new.			firstListView model: theModel controller: DFieldListController new.			firstListView window: (0 @ 0 extent: 225 @ 500).			firstListView borderWidth: 1.			secondListView _ DHitListView new.			secondListView model: theModel controller: DHitListController new.			secondListView window: (0 @ 0 extent: 225 @ 500).			secondListView borderWidth: 1.			textView _ FieldStringView new.			textView model: theModel controller: DBTextController new.			textView window: (0 @ 0 extent: 600 @ 440).			textView borderWidth: 1.			classView _ StringHolderView new.			classView window: (0 @ 0 extent: 600 @ 60).			classView model: StringHolder new.			classView controller: NoController new.			classView insideColor: Form white.			classView borderWidth: 1.			textView classView: classView.			queryView _ DQueryListView new.			queryView model: theModel controller: DQueryListController new.			queryView window: (0 @ 0 extent: 1050 @ 150).			queryView borderWidth: 1.			reportView _ DReportListView new.			reportView model: theModel controller: DReportListController new.			reportView window: (0 @ 0 extent: 1050 @ 150).			reportView borderWidth: 1.			topView borderWidth: 1; 					addSubView: firstListView;					addSubView: secondListView toRightOf: firstListView;					addSubView: classView toRightOf: secondListView;					addSubView: textView below: classView;					addSubView: queryView below: firstListView;					addSubView: reportView below: queryView;					minimumSize: 600 @ 260;					maximumSize: 1050 @ 750].	topView controller open! !!FormsModel class methodsFor: 'instance creation'!fromFile: aSuitcase	| aFile model | 	aFile _ (MixedFileStream fileNamed: aSuitcase) readOnly.	model _ FormsModel new.	model readFrom: aFile.	^model!fromStream: aStream	| model | 	model _ FormsModel new.	model readFrom: aStream.	^model!fromSuitcase: aSuitcase	| aFile | 	aFile _ (MixedFileStream fileNamed: aSuitcase dataItem filename) readOnly.	aFile atEnd ifTrue:[aFile close. ^FormsView openEditorOn: aSuitcase].	^FormsModel new readFrom: aFile!named: formName 	| elements |	elements _ SortedCollection new.	elements sortBlock: SortBlock.	^(super new) name: formName asString; elements: elements; elemNames: Dictionary new! !!FormsModel class methodsFor: 'examples'!changesPanel	"FormsView		openOn: FormsModel changesPanel		backgroundColor: Form lightGray."	| formsModel formsController |	formsModel _ FormsModel named: 'Smalltalk Changes'.	formsController _ FormsController new.	formsModel		addControlPanel: ExecuteElement		labels: #('inspect changes' 'recover changes' 'reset changes' 'file out changes')		messages: #(inspectChanges browseRecover resetChanges fileOutChanges)		targetController: ScreenController someInstance		boundingBox: (0@0 extent: 500@30).	^formsModel!controlPanel	"FormsView		openOn: FormsModel controlPanel		backgroundColor: Form lightGray."	| formsModel formsController |	formsModel _ FormsModel named: 'Smalltalk Controls'.	formsModel		addControlPanel: ExecuteElement		labels: #('browser' 'file list' 'workspace' 'transcript' 'open file' 'suspend')		messages: #(openBrowser openFileList openWorkspace openTranscript openWorkspaceOnFile defer)		targetController: ScreenController someInstance		boundingBox: (0@0 extent: 500@30).	^formsModel!example	"FormsView openOn: FormsModel example."	| formsModel formsController topView label choices size i |	formsModel _ FormsModel named: 'Sample Form'.	label _ Paragraph withText: (Text string: 'EXECUTE BUTTONS' emphasis: 23).	formsModel add:		((LabelElement named: #L1)			label: label;			bordered: false;			box: (25@10 extent: 100@25)).	i _ 1.	#(flash reverse choose) do:		[:message |		label _ Paragraph withText: (Text string: message asString emphasis: 2).		formsModel add: 			((ExecuteElement named: message)				label: label;				message: message;				bordered: true;				enabled: true;				targetController: formsController;				box: (25@(i*21+10) extent: 100@20)).		i _ i + 1].	i _ 1.	#(Switch1 Switch2) do:		[:switch |		label _ Paragraph withText: (Text string: switch asString emphasis: 2).		formsModel add:			((SwitchElement named: switch)				label: label;				initialValue: true;				bordered: true;				enabled: true;				box: (150@(i*21+31) extent: 75@20)).		i _ i + 1].	choices _ #('Larry' 'Moe' 'Curly').	formsModel add:		((OneOfElement named: #Choices)			initialValue: (choices at: 1);			choices: choices;			bordered: true;			enabled: true;			box: (150@110 extent: 75@25)).	formsModel add:		((FillElement named: #Fill1)			initialValue: 'Me Too';			bordered: true;			enabled: true;			box: (25@110 extent: 100@150)).	formsModel add:		((FillElement named: #Fill2)			initialValue: 'Fill Me In';			bordered: true;			enabled: true;			box: (250@31 extent: 175@229)).	^formsModel! !!FormsModel class methodsFor: 'initialization'!initialize	"FormsModel initialize"	SortBlock _ self positionBlock fixTemps!positionBlock	^[:first :second | first box origin y < second box origin y			ifTrue: [true]			ifFalse: [first box origin y = second box origin y					ifTrue: [first box origin x <= second box origin x]					ifFalse: [false]]]! !!DatabaseFormsModel class methodsFor: 'instance creation'!fromStream: aStream	| model | 	model _ self new.	model readFrom: aStream.	^model!openOn: formsModel label: label suitcase: aSuitcase	"Open an instance of me with the model and controller specified in anArray,	and with the specified label and suitcase."	| formsController formsView topView borderWidth boundingBox size |	formsController _ DatabaseFormsController new.	formsModel resetState.	formsModel updateControllers: formsController.	borderWidth _ 2.	boundingBox _ formsModel boundingBox.	size _ boundingBox extent + (boundingBox origin * 2) + (borderWidth * 2) + 5.	formsView _ FormsView new.	formsView model: formsModel.	formsView controller: formsController.	formsView insideColor: Form white.	formsView borderWidth: borderWidth.	topView _ StandardSystemView new.	topView label: label.	topView controller: ClassifiedStandardSystemController new.	topView model: formsModel.	topView minimumSize: size.	size x > 600 ifTrue:[topView maximumSize: size x @ 750] ifFalse:[	topView maximumSize: 600@750].	topView addSubView: formsView.	aSuitcase == nil ifFalse:		[topView classifyLabel: aSuitcase classification.		topView addDependent: aSuitcase].	topView controller open! !!FormsElement class methodsFor: 'instance creation'!named: elementName	^(self new)		name: elementName;		enabled: true;		bordered: true;		hasChanged: false! !!FormsElement class methodsFor: 'class initialization'!defineNeedsFor: anElement	"returns an Array the symbols and values necessary to create a new element of this type (if anElement is nil) or to edit anElement.	The returnArray contains:		a string		What type of element to call this.  If left nil, the user of this message will get the name from this class name.		label array	The D-Box label array for editing or creating an element of this type.		type array	The D-Box type array for editing or creating an element of this type.		value array 	The D-Box default values for editing anElement, or if it is nil, creation of a new element of this type.	In each D-Box array, the last item must be the name variable.  If the default is left nil it will be generated."	| defaults |	defaults _ OrderedCollection new.	anElement == nil		ifTrue:			[defaults add: #true; add: #true; add: nil]		ifFalse:			[defaults				add: anElement bordered printString asSymbol;				add: anElement enabled printString asSymbol;				add: anElement name].	^Array		with: nil		with: #((Bordered true false ) (Enabled true false ) (Name ))		with: #(select select fill)		with: defaults!initialize	"FormsElement initialize"	LocalTextStyle _ TextStyle default rightIndent: 3; restIndent: 2; firstIndent: 2.	LocalFastScanner _FastTextDisplayScanner new! !!OneOfElement class methodsFor: 'class initialization'!defineNeedsFor: anElement	"returns an Array the symbols and values necessary to create a new element of this type (if anElement is nil) or to edit anElement.	The returnArray contains:		a string		What type of element to call this.  If left nil, the user of this message will get the name from this class name.		label array	The D-Box label array for editing or creating an element of this type.		type array	The D-Box type array for editing or creating an element of this type.		value array 	The D-Box default values for editing anElement, or if it is nil, creation of a new element of this type.	In each D-Box array, the last item must be the name variable.  If the default is left nil it will be generated."	| defaults choiceString |	defaults _ OrderedCollection new.	anElement == nil		ifTrue:			[defaults add: #true; add: #true; add: 'Initial Choice'; add: 'choices separated by spaces'; add: nil]		ifFalse:			[defaults				add: anElement bordered printString asSymbol;				add: anElement enabled printString asSymbol;				add: anElement initialValue;				add: ((choiceString _ anElement choices asArray printString) copyFrom: 2 to: choiceString size - 1 );				add: anElement name].	^Array		with: 'Choice'		with: #((Bordered true false ) (Enabled true false ) ('Initial Choice' ) (Choices ) (Name ))		with: #(select select fill fill fill)		with: defaults! !!SwitchElement class methodsFor: 'class initialization'!defineNeedsFor: anElement	"returns an Array the symbols and values necessary to create a new element of this type (if anElement is nil) or to edit anElement.	The returnArray contains:		a string		What type of element to call this.  If left nil, the user of this message will get the name from this class name.		label array	The D-Box label array for editing or creating an element of this type.		type array	The D-Box type array for editing or creating an element of this type.		value array 	The D-Box default values for editing anElement, or if it is nil, creation of a new element of this type.	In each D-Box array, the last item must be the name variable.  If the default is left nil it will be generated."	| defaults |	defaults _ OrderedCollection new.	anElement == nil		ifTrue:			[defaults add: #true; add: #true; add: 'Switch Label'; add: #true; add: nil]		ifFalse:			[defaults				add: anElement bordered printString asSymbol;				add: anElement enabled printString asSymbol;				add: anElement label;				add: anElement initialValue printString asSymbol;				add: anElement name].	^Array		with: nil		with: #((Bordered true false ) (Enabled true false ) (Label ) ('initial value' true false) (Name ))		with: #(select select paragraph select fill)		with: defaults! !!ImageElement class methodsFor: 'class initialization'!initialize	"ImageElement initialize"	ImageElementYellowButtonMenu _ PopUpMenu labels: 'copycutpaste' lines: #().	ImageElementYellowButtonMessages _ #(copySelection cut paste )! !!FillElement class methodsFor: 'class initialization'!defineNeedsFor: anElement	"returns an Array the symbols and values necessary to create a new element of this type (if anElement is nil) or to edit anElement.	The returnArray contains:		a string		What type of element to call this.  If left nil, the user of this message will get the name from this class name.		label array	The D-Box label array for editing or creating an element of this type.		type array	The D-Box type array for editing or creating an element of this type.		value array 	The D-Box default values for editing anElement, or if it is nil, creation of a new element of this type.	In each D-Box array, the last item must be the name variable.  If the default is left nil it will be generated."	| defaults |	defaults _ OrderedCollection new.	anElement == nil		ifTrue:			[defaults add: #true; add: #true; add: 'default text'; add: 18 printString; add: 15 printString; add: nil]		ifFalse:			[defaults				add: anElement bordered printString asSymbol;				add: anElement enabled printString asSymbol;				add: anElement initialValue;				add: anElement lineGrid printString;				add: anElement baseline printString;				add: anElement name].	^Array		with: 'Fill In'		with: #((Bordered true false ) (Enabled true false ) ('Initial Value') ('Line height') (Baseline) (Name ))		with: #(select select paragraph fill fill fill)		with: defaults!initialize	"FillElement initialize."	FillIn _ FillInTheBlank new.	FillInController _ FormsFillController new.	FillInView _ FillInTheBlankView new.	FillInView model: FillIn controller: FillInController.	FillInView borderWidth: 1! !!FillElement class methodsFor: 'instance creation'!named: elementName	^(super named: elementName)		initialValue: String new asText! !!ExecuteElement class methodsFor: 'instance creation'!defineNeedsFor: anElement	"returns an Array the symbols and values necessary to create a new element of this type (if anElement is nil) or to edit anElement.	The returnArray contains:		a string		What type of element to call this.  If left nil, the user of this message will get the name from this class name.		label array	The D-Box label array for editing or creating an element of this type.		type array	The D-Box type array for editing or creating an element of this type.		value array 	The D-Box default values for editing anElement, or if it is nil, creation of a new element of this type.	In each D-Box array, the last item must be the name variable.  If the default is left nil it will be generated."	| defaults |	defaults _ OrderedCollection new.	anElement == nil		ifTrue:			[defaults add: #true; add: #true; add: 'Executor Label'; add: #Center; add: 'a message name'; add: nil]		ifFalse:			[defaults				add: anElement bordered printString asSymbol;				add: anElement enabled printString asSymbol;				add: anElement label;			 	add: anElement alignment;				add: anElement message;				add: anElement name].	^Array		with: 'Executor'		with: #((Bordered true false ) (Enabled true false ) (Label ) (Alignment rightFlush leftFlush Center) (Message ) (Name ))		with: #(select select paragraph select fill fill)		with: defaults!named: elementName	^(super named: elementName)		alignment: #Centered! !!LabelElement class methodsFor: 'class initialization'!defineNeedsFor: anElement	"returns an Array the symbols and values necessary to create a new element of this type (if anElement is nil) or to edit anElement.	The returnArray contains:		a string		What type of element to call this.  If left nil, the user of this message will get the name from this class name.		label array	The D-Box label array for editing or creating an element of this type.		type array	The D-Box type array for editing or creating an element of this type.		value array 	The D-Box default values for editing anElement, or if it is nil, creation of a new element of this type.	In each D-Box array, the last item must be the name variable.  If the default is left nil it will be generated."	| defaults |	defaults _ OrderedCollection new.	anElement == nil		ifTrue:			[defaults add: #true; add: 'Label Text'; add: #Center; add: nil]		ifFalse:			[defaults				add: anElement bordered printString asSymbol;				add: anElement label asText;				add: anElement alignment;				add: anElement name].	^Array		with: nil		with: #((Bordered true false ) (Label ) (Alignment rightFlush leftFlush Center) (Name ))		with: #(select paragraph select fill)		with: defaults! !!XDEInterfaceModel class methodsFor: 'server access'!retrieveThese: aString fromDirectory: aDirectoryName doAfter: afterBlock withArgs: afterArgs	"This will retrieve the files listed in aString from the directory specified in aDirectoryName.The contents of aString may also be the name of a command file like @backup"	|  aXDE theFileServerName | 	theFileServerName _ UserProfile current selectFileServer.	theFileServerName == nil ifTrue: [^self].	aXDE _self giveMeOne: true.	aXDE ftp: #retrieve asString directory: aDirectoryName source: aString destination: nil switches:  (String with: $c with: $ ) doAfter: afterBlock withArgs: afterArgs.	aXDE changed.	XDEInterfaceModel openWith: aXDE!storeThese: aString inDirectory: aDirectoryName	"This will store the the files listed in aString into the directory specified in aDirectoryName.The contents of aString may also be the name of a command file like @backup"	|  aXDE theFileServerName | 	theFileServerName _ UserProfile current selectFileServer.	theFileServerName == nil ifTrue: [^self].	aXDE _self giveMeOne: true.	aXDE ftp: #store asString directory: aDirectoryName source: aString destination: nil switches: (String with: $u with: $a) doAfter: [:xdeModel :unusedArgs | ] withArgs: nil.	aXDE changed.	XDEInterfaceModel openWith: aXDE! !!XDEInterfaceModel class methodsFor: 'public access'!addToQueue: aBlock	Queue addLast: aBlock!displayCritical	^DisplayCritical! !!XDEInterfaceModel class methodsFor: 'initialization'!initialize	"XDEInterfaceModel initialize"	DisplayCritical	_ (Smalltalk includesKey: #XDEInterfaceController)		ifTrue: [XDEInterfaceController displayCritical]		ifFalse: [Semaphore new].	Smalltalk at: #TheXDE put: nil.	Menu _ self initMenu.	LockedMenu _ self initLockedMenu.	Queue _ SharedDeque new: 10.	self installQueueProcess!initLockedMenu	^ActionMenu		labels: 'status\abort current\copy text\hardcopy' withCRs		lines: (Array with: 2)		selectors: #(showStatus abort copySelection hardcopy)!initMenu	^ActionMenu		labels: 'log in\ftp\send command\status\abort current\flush queue\copy text\hardcopy\get file contents' withCRs		lines: (Array with: 1 with: 4 with: 6)		selectors: #(login ftp sendCommandToXDE showStatus abort flushQueue copySelection hardcopy displayFileContents)!installQueueProcess	"XDEInterfaceModel installQueueProcess"	QueueProcess == nil ifFalse: [self terminateQueueProcess].	QueueProcess _		[[true] whileTrue:			[Queue removeFirst value]] newProcess.	QueueProcess priority: Processor userBackgroundPriority.	QueueProcess resume!terminateQueueProcess	"XDEInterfaceModel terminateQueueProcess"	QueueProcess == nil ifFalse:		[QueueProcess terminate. QueueProcess _ nil. self new quietAbort "self protection"]! !!XDEInterfaceModel class methodsFor: 'instance creation'!giveMeOne: locked	| aXDE | 	TheXDE == nil		ifTrue: [aXDE _ self new]		ifFalse:[aXDE _ TheXDE model].	aXDE locked: locked.	^aXDE!new	^super new initialize!open"	 XDEInterfaceModel open.	"	self openWith: (self giveMeOne: false)!openWith: aXDEInterface	| aView |	TheXDE == nil		ifTrue: [(aView _ TextView on: aXDEInterface aspect: nil change: nil menu: #menu)					insideColor: Form white;					borderWidth: 1.				aView controller: (XDEInterfaceController new).				Smalltalk at: #TheXDE put: (StandardSystemView new					model: aXDEInterface;					label: 'A FileServer Window on ',UserProfile current ifsName;					minimumSize: 500 @ 400;					borderWidth: 1;					addSubView: aView) controller.				TheXDE open]		ifFalse: [ScheduledControllers unschedule: TheXDE.				ScheduledControllers scheduleActive: TheXDE].! !!ClipEntry class methodsFor: 'instance creation'!new	^super new initialize! !RS232Kermit class comment:'Copyright (c) Xerox Corporation, 1986.'!!RS232Kermit class methodsFor: 'class initialization'!initialize	"RS232Kermit initialize"	FtpFilesInfo _ OrderedCollection new.	MarkLoc _ 1.	LenLoc _ 2.	SeqLoc _ 3.	TypeLoc _ 4.	RetryLimit _ 16.	XferCursors _ Array new: 2.	XferCursors		at: 1 put: (Cursor			extent: 16@16			fromArray: #(65280 65280 65280 65280 65280 65280 65280 65280 255 255 255 255 255 255 255 255)			offset: 0@0);		at: 2 put: (Cursor			extent: 16@16			fromArray: #(255 255 255 255 255 255 255 255 65280 65280 65280 65280 65280 65280 65280 65280)			offset: 0@0)	"RS232Kermit initialize"! !!RS232Kermit class methodsFor: 'instance creation'!new	^super new initialize! !!RS232Kermit class methodsFor: 'queue management'!addRequest: request remoteName: remoteName localName: localName textFile: textFile	"request should be $R or $S; remoteName will be truncated to 7 chars; textFile is a boolean"	| requestPacket |	requestPacket _ Array new: 4.	requestPacket		at: 1 put: request;		at: 2 put: (localName == nil ifTrue: [nil] ifFalse: [localName asFileName]);		at: 3 put: (textFile ifTrue: [$A] ifFalse: [$B]);		at: 4 put: remoteName.	FtpFilesInfo addLast: requestPacket!emptyQueue	FtpFilesInfo _ OrderedCollection new!queueFileTransfer	| answers what | 	answers _ DBoxView		openFor: #( select fill fill select)		title: 'File Transfer Request'		labels: #( #( Direction: Retrieve Send) #( 'Remote File Name:') #( 'Local File Name:') #( 'File Type:' Text Binary))		defaults: (Array with: #Retrieve with: String new with: String new with: #Text)		commands: #( accept cancel bailOut)		autoAccept: false		links: Array new.	answers == nil ifTrue: [^self].	what _ (answers at: 1) asString at: 1.	(answers at: 2) = String new ifFalse:		[(what = $R or: [(answers at: 3) ~= String new and: [Disk includesKey: (answers at: 3) asFileName]]) ifTrue:			[^self				addRequest: what				remoteName: (answers at: 2)				localName: (answers at: 3)				textFile: ((answers at: 4) ~= #Binary)]].	^self booboo: 'Sorry, that request is unacceptable'! !!RS232Kermit class methodsFor: 'private'!padCollection: oldColl toLength: length with: pad	"return a new collection which is oldColl padded with pad until it's size is length.		If oldColl size > length, truncate it to length"	| newColl oldLength |	oldLength _ oldColl size min: length.	newColl _ oldColl species new: length.	newColl replaceFrom: 1 to: oldLength with: oldColl startingAt: 1.	oldLength + 1 to: length do: [:i | newColl at: i put: pad].	^ newColl! !!DirectoryHierarchy class methodsFor: 'class initialization'!initialize"	DirectoryHierarchy initialize 	"	(Smalltalk includesKey: #FileDirectoryLists)		ifTrue: [(Smalltalk at: #FileDirectoryLists) become: DirectoryHierarchy new initialize]		ifFalse: [Smalltalk at: #FileDirectoryLists put: DirectoryHierarchy new initialize]! !!AnalystArchitect class methodsFor: 'log'!awolSummaryPart01""!conflictsSummaryPart01"ClassDescription fileOutOn:moveSource:toFile: 	'Pools-System-Changes.st'	'kl-OopConservingOrganizers.st'	'kl-OopConsOrganizers-Pool-patch.st'ClassDescription moveChangesTo: 	'kl-CondenseChanges-nonPS20.st'	'kl-OopConservingOrganizers.st'Cursor 	'CursorChanges.st'	'ScrollBarChanges.st'FileStream toPrinter:numOfCopies:numTries:sendMsgsTo: 	'CV4-FileStream-Printing-changes.st'	'FileStream-NS-Changes.st'FillInTheBlank class request:default: 	'CV4-FillInTheBlankChanges.st'	'FastUserInterface-use.st'Form class initializeMasks 	'CV4-FormChanges.st'	'kl-FormsStrikeFont-nonTek4407.st'ListView findSelection: 	'CV4-ListViewChanges.st'	'ScrollBarChanges.st'ListView list: 	'CV4-ListViewChanges.st'	'FastLists.st'Object booboo: 	'CV4-ObjectChanges.st'	'FastUserInterface-use.st'Object confirm: 	'CV4-ObjectChanges.st'	'FastUserInterface-use.st'Object confirm:yesLabel:noLabel: 	'CV4-ObjectChanges.st'	'FastUserInterface-use.st'Object doesNotUnderstand: 	'Signal-mm.st'	'lc-notifier.st'Object error: 	'Signal-mm.st'	'lc-notifier.st'ScreenController 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController class initializeBlueButtonMenu 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController class initializeYellowButtonMenu 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController isControlWanted 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController quit 	'CV4-ScreenControllerSmalltalk.st'	'WatchforRS232onQuit-changes.st'ScreenController saveThenQuit 	'CV4-ScreenControllerSmalltalk.st'	'WatchforRS232onQuit-changes.st'StandardSystemController collapse 	'CV4-SSControllerChanges.st'	'SysWindows-patches-nonTek.st'StandardSystemController expand 	'CV4-SSControllerChanges.st'	'SysWindows-patches-nonTek.st'"!crossRefSummaryPart01"ABFormController 	'XSIS-AutoBook.st'ActionMenu selectors 	'CV4-ActionMenuChanges.st'ActionMenu storeOn: 	'CV4-ActionMenuChanges.st'AdjacencyMatrix 	'XSIS-Matrices.st'AnalystArchitect 	'Build-AnalystArchitect.st'Animation 	'XSIS-Animation.st'AnnotationController 	'XSIS-FileModel.st'AnnotationModel 	'XSIS-FileModel.st'Architect 	'Build-Architect.st'AssociationlessDictionary 	'AssociationlessDictionary.st'AsyncSerialPort 	'AsyncSerialPort.st'Auditor 	'XSIS-Auditor.st'AutoBook 	'XSIS-AutoBook.st'AutoBookListController 	'XSIS-AutoBook.st'AutoBookListView 	'XSIS-AutoBook.st'AutoBookStandardSystemController 	'XSIS-AutoBook.st'AutoBookTextController 	'XSIS-AutoBook.st'AutoBookTextView 	'XSIS-AutoBook.st'BackgroundController 	'XSIS-Background.st'BackgroundPrinter 	'XSIS-Background.st'BarChart 	'XSIS-Charts.st'Behavior printMethodChunk:on:moveSource:toFile: 	'kl-QuadWordAlignedRemoteStrings.st'Benchmark 	cv4FinalRemovalsBigAlwaysAcceptCodeController 	'XSIS-Big-Paragraphs.st'BigCodeController 	'XSIS-Big-Paragraphs.st'BigOnlyWhenSelectedCodeController 	'XSIS-Big-Paragraphs.st'BigParagraph 	'XSIS-Big-Paragraphs.st'BigParagraphEditor 	'XSIS-Big-Paragraphs.st'BigStringHolderController 	'XSIS-Big-Paragraphs.st'BigTextController 	'XSIS-Big-Paragraphs.st'BinaryChoice class myMessage:displayAt:centered:ifTrue:ifFalse: 	'CV4-BinaryChoiceChanges.st'BinaryChoice class myMessage:displayAt:centered:yesLabel:noLabel:ifTrue:ifFalse: 	'CV4-BinaryChoiceChanges.st'BinaryChoiceController centerCursorInView 	'CV4-BinaryChoiceChanges.st'BinaryChoiceController isControlActive 	'KeepCursorInView.st'BinaryChoiceView class buildSingleSwitchFor:width: 	'CV4-BinaryChoiceViewChanges.st'BinaryChoiceView class buildSwitchesFor:width:yesLabel:noLabel: 	'CV4-BinaryChoiceViewChanges.st'BinaryChoiceView class openBooBooOn:message:displayAt:centered: 	'CV4-BinaryChoiceViewChanges.st'BinaryChoiceView class openBooBooOn:message:displayAt:centered:yesLabel:noLabel: 	'CV4-BinaryChoiceViewChanges.st'BioController 	'XSIS-FileModel.st'BitBlt drawFrom:to:segmentLength: 	'BitBltAndForm-tek-adds.st'BitBlt drawSegLoopX:Y:segLen:spaceLen: 	'BitBltAndForm-tek-adds.st'BitEditor class bitEdit:at:scale:remoteView: 	'CV4-BitEditorChanges.st'BitEditor class buildColorMenu:colorCount: 	'CV4-BitEditorChanges.st'BitEditor class initialize 	'CV4-BitEditorChanges.st'BitEditor controlActivity 	'CV4-BitEditorChanges.st'BitEditor isControlActive 	'CV4-BitEditorChanges.st'BlockContext join: 	'StuffForLaterMerge.st'BoxController 	'XSIS-Boxes.st'BoxView 	'XSIS-Boxes.st'Browser categoryMenu 	'CV4-BrowserChanges.st'Browser classMenu 	'CV4-BrowserChanges.st'Browser protocolMenu 	'CV4-BrowserChanges.st'Browser selectorMenu 	'CV4-BrowserChanges.st'Browser textMenu 	'CV4-BrowserChanges.st'Builder 	'Build-Architect.st'ByteArray specialReplaceFrom:to:with:startingAt: 	'CV4-ByteArrayChanges.st'CellStringHolderController 	'XSIS-Spreadsheets.st'ChangeController 	'Big-Paragraphs-useThem-changes.st'ChangeListController class initialize 	'CV4-CListControllerChanges.st'ChangeSet fileOutClassChanges:on: 	'Pools-System-Changes.st'ChapterController 	'XSIS-NewOutlines.st'CharacterBlockScanner buildCharacterBlockIn: 	'CV4-CharacterBlockScannerChanges.st'CharacterBlockScanner characterBlockAtPoint:in: 	'CV4-CharacterBlockScannerChanges.st'CharacterBlockScanner characterBlockForIndex:in: 	'CV4-CharacterBlockScannerChanges.st'CharacterBlockScanner onePixelBackspace 	'CV4-CharacterBlockScannerChanges.st'CharacterBlockScanner onePixelSpace 	'CV4-CharacterBlockScannerChanges.st'CharacterBlockScanner setStopConditions 	'CV4-CharacterBlockScannerChanges.st'CharacterScanner characterNotInFont 	'CV4-CharacterScannerChanges.st'CharacterScanner scanPrinterCharactersFrom:to:in:rightX:stopConditions: 	'CV4-CharacterScannerChanges.st'CharacterScanner scanPrinterWidthsCharactersFrom:to:in:rightX:stopConditions:displaying: 	'CV4-CharacterScannerChanges.st'Chart 	'XSIS-Charts.st'ChartEditor 	'XSIS-ChartEditor.st'CheapDictionary 	'Build-Architect.st'Checker 	cv4FinalRemovalsClass copy 	'kl-OopConservingOrganizers.st'Class copyForValidation 	'kl-OopConservingOrganizers.st'Class obsolete 	'kl-OopConservingOrganizers.st'Class rename: 	'kl-OopConservingOrganizers.st'ClassDescription allPoolRefsIn: 	'Pools-System-Changes.st'ClassDescription collapse 	'kl-OopConservingOrganizers.st'ClassDescription fileOutCategory:on:moveSource:toFile: 	'Pools-System-Changes.st'ClassDescription fileOutChangedMessages:on:moveSource:toFile: 	'Pools-System-Changes.st'ClassDescription fileOutMessage:on:moveSource:toFile: 	'Pools-System-Changes.st'ClassDescription fileOutOn:moveSource:toFile: 	'Pools-System-Changes.st'	'kl-OopConservingOrganizers.st'	'kl-OopConsOrganizers-Pool-patch.st'ClassDescription moveChangesFromFileNumber:toFileNumber:toFileStream: 	'kl-SourceFilesAt3.st'ClassDescription moveChangesTo: 	'kl-CondenseChanges-nonPS20.st'	'kl-OopConservingOrganizers.st'ClassDescription organization 	'kl-OopConservingOrganizers.st'ClassDescription printMethodChunk:on:moveSource:toFile: 	'kl-QuadWordAlignedRemoteStrings.st'ClassDescription printPoolChunks:on: 	'Pools-System-Changes.st'ClassDescription printSharedPoolChunk:on: 	'Pools-System-Changes.st'Classification 	'XSIS-Classification.st'ClassificationScheme 	'XSIS-Classification.st'ClassifiedFixedFileStream 	'XSIS-FixedFiles.st'ClassifiedStandardSystemController 	'ClassifiedStandardSystemController.st'ClassifiedStringHolderController 	'ClassifiedStringHolderController.st'ClassOrganizer 	'kl-OopConservingOrganizers.st'ClassOrganizer class rehash 	'kl-OopConservingOrganizers.st'ClassOrganizer collapsedForClass:fromFileNumber:toFileNumber:toFile: 	'kl-OopConservingOrganizers.st'ClassOrganizer moveChangedCommentFromFileNumber:toFileNumber:toFileStream: 	'kl-SourceFilesAt3.st'ClassOrganizer putCommentOnFile:numbered:moveSource: 	'CV4-ClassOrganizerChanges.st'ClassOrganizer setDefaultList 	'kl-OopConservingOrganizers.st'ClickBuffer 	'XSIS-Forms.st'ClipBuffer 	'XSIS-DataControl.st'ClipEntry 	'XSIS-DataControl.st'ClockController 	'TimeZone-Clocks.st'ClockView 	'TimeZone-Clocks.st'ClusteredBarChart 	'XSIS-Charts.st'CodeView defaultControllerClass 	'Big-Paragraphs-useThem-changes.st'CodeView update: 	'Big-Paragraphs-useThem-changes.st'ComposeSystemController 	'XSIS-FileModel.st'ComposeTextController 	'XSIS-FileModel.st'CompositionScanner composeLine:fromCharacterIndex:inParagraph: 	'CV4-CompositionScannerChanges.st'CompositionScanner crossedX 	'CV4-CompositionScannerChanges.st'CompositionScanner onePixelBackspace 	'CV4-CompositionScannerChanges.st'CompositionScanner onePixelSpace 	'CV4-CompositionScannerChanges.st'CompositionScanner resetFont 	'CV4-CompositionScannerChanges.st'CompositionScanner rightX 	'CV4-CompositionScannerChanges.st'CompositionScanner setStopConditions 	'CV4-CompositionScannerChanges.st'ConfigFile 	'XSIS-ConfigFiles.st'ConfigFileModel 	'XSIS-ConfigFiles.st'ConnectedBoxView 	'XSIS-Boxes.st'ContainerListController 	'XSIS-InfoCenter.st'ContainerListView 	'XSIS-InfoCenter.st'ContainerModel 	'XSIS-InfoCenter.st'Controller controlLoop 	'Background-DelayAndProtect3Changes.st'Controller keepCursorIn: 	'KeepCursorInView.st'Controller keepCursorInView 	'KeepCursorInView.st'ControlManager backgroundColor: 	'CV4-ControlManagerChanges.st'ControlManager bailOut 	'CV4-ControlManagerChanges.st'ControlManager collapse 	'CV4-ControlManagerChanges.st'ControlManager initialize 	'CV4-ControlManagerChanges.st'ControlManager searchForActiveController 	'Background-DelayAndProtect3Changes.st'ControlManager suicideLeapInto: 	'Background-DelayAndProtect3Changes.st'CreateController 	'XSIS-ChartEditor.st'CRFillInTheBlankController 	'CV4-FITBlankControllerChanges.st'"!crossRefSummaryPart02"CRFillInTheBlankController cr: 	'CV4-FITBlankControllerChanges.st'CRFillInTheBlankController readKeyboard 	'CV4-FITBlankControllerChanges.st'Cursor 	'CursorChanges.st'	'ScrollBarChanges.st'Cursor class bottomLeft 	'CursorChanges.st'Cursor class garbage 	'CursorChanges.st'Cursor class grabBar 	'CursorChanges.st'Cursor class initialize 	'CursorChanges.st'Cursor class mouse 	'CursorChanges.st'Cursor class myInitialize 	'ScrollBarChanges.st'Cursor class topRight 	'CursorChanges.st'Cursor class upDown 	'ScrollBarChanges.st'DataBase 	'XSIS-DataBase.st'DatabaseFormsController 	'XSIS-DataBase.st'DatabaseFormsEditController 	'XSIS-DataBase.st'DatabaseFormsModel 	'XSIS-DataBase.st'DataControl 	'XSIS-DataControl.st'DataItem 	'XSIS-Classification.st'DataItemPointer 	'XSIS-Classification.st'DataListController 	'XSIS-ChartEditor.st'DataListModel 	'XSIS-ChartEditor.st'DataListStandardSystemController 	'XSIS-ChartEditor.st'DataListView 	'XSIS-ChartEditor.st'Date < 	'0711-kp-date-time-changes.st'Date class readFrom: 	'0711-kp-date-time-changes.st'Date printFormat: 	'CV4-DateChanges.st'Date printOn: 	'CV4-DateChanges.st'Date printOn:format: 	'CV4-DateChanges.st'DBox 	'XSIS-ControlBox.st'DBoxController 	'XSIS-ControlBox.st'DBoxFillController 	'XSIS-ControlBox.st'DBoxKeywordFillController 	'XSIS-ControlBox.st'DBoxParaFillController 	'XSIS-ControlBox.st'DBoxQuerier 	'XSIS-ControlBox.st'DBoxQueryController 	'XSIS-ControlBox.st'DBoxView 	'XSIS-ControlBox.st'DBStandardSystemController 	'XSIS-DataBase.st'DBTextController 	'XSIS-DataBase.st'Debugger contextMenu 	'CV4-DebuggerChanges.st'DFieldListController 	'XSIS-DataBase.st'DFieldListView 	'XSIS-DataBase.st'DHitListController 	'XSIS-DataBase.st'DHitListView 	'XSIS-DataBase.st'DictionaryInspector fieldMenu 	'CV4-DictionaryInspectorChanges.st'DigitalClockView 	'TimeZone-Clocks.st'DirectoryHierarchy 	'kl-RemoteFiles.st'DirectoryHierarchy AnnotationModel 	'DirectoryHierarchy-lists.st'DirectoryHierarchy ContainerModel 	'DirectoryHierarchy-lists.st'DirectoryHierarchy ImageEditor 	'DirectoryHierarchy-lists.st'DirectoryHierarchy KeyFileList 	'DirectoryHierarchy-lists.st'DirectoryHierarchy MapEditor 	'DirectoryHierarchy-lists.st'DirectoryHierarchy Object 	'DirectoryHierarchy-lists.st'DirectoryHierarchy OutlineView 	'DirectoryHierarchy-lists.st'DisplayPrintFont 	'Xerox-NSPrinting.st'DisplayScanner 	'CV4-DisplayScannerChanges.st'DisplayScanner checkEmphasis 	'CV4-DisplayScannerChanges.st'DisplayScanner cr 	'CV4-DisplayScannerChanges.st'DisplayScanner crossedX 	'CV4-DisplayScannerChanges.st'DisplayScanner displayLines:in:clippedBy: 	'CV4-DisplayScannerChanges.st'DisplayScanner doesDisplaying 	'CV4-DisplayScannerChanges.st'DisplayScanner endOfRun 	'CV4-DisplayScannerChanges.st'DisplayScanner fontAscentDelta 	'CV4-DisplayScannerChanges.st'DisplayScanner lineY 	'CV4-DisplayScannerChanges.st'DisplayScanner onePixelBackspace 	'CV4-DisplayScannerChanges.st'DisplayScanner onePixelSpace 	'CV4-DisplayScannerChanges.st'DisplayScanner paddedSpace 	'CV4-DisplayScannerChanges.st'DisplayScanner pressTabOrSpace 	'CV4-DisplayScannerChanges.st'DisplayScanner setStopConditions 	'CV4-DisplayScannerChanges.st'DisplayScanner tab 	'CV4-DisplayScannerChanges.st'DisplayScreen outline:while:width:halftone: 	'CV4-DisplayScreenChanges.st'DisplayScreen zoom:to:speed: 	'CV4-DisplayScreenChanges.st'DQueryListController 	'XSIS-DataBase.st'DQueryListView 	'XSIS-DataBase.st'DReportListController 	'XSIS-DataBase.st'DReportListView 	'XSIS-DataBase.st'EditStringHolder 	'XSIS-ConfigFiles.st'EditStringHolderController 	'XSIS-ConfigFiles.st'Encoder undeclared: 	'CV4-EncoderChanges.st'EncryptedFileStream 	'XSIS-SpecialFileStreams.st'ExecuteElement 	'XSIS-Forms-Elements.st'FakeCollection 	'XSIS-SpecialMenus.st'FastTextDisplayScanner 	'FastTextDisplayScanner.st'FastTextList 	'FastLists.st'FieldParagraph 	'XSIS-DataBase.st'FieldStringView 	'XSIS-DataBase.st'FileDirectory copy:to: 	'CV4-FileDirectoryChanges.st'FileDirectory findFiles:inList:inclusive:addTo: 	'CV4-FileDirectoryChanges.st'FileDirectory makeNewFileName:withSuffix: 	'CV4-FileDirectoryChanges.st'FileDirectory renameKey:newName: 	'CV4-FileDirectoryChanges.st'FileList acceptPattern:from: 	'CV4-FileListChanges.st'FileList class open 	'Big-Paragraphs-useThem-changes.st'FileList fileListMenu 	'CV4-FileListChanges.st'FileList patternMenu 	'CV4-FileListChanges.st'FileModel put: 	'CV4-FileModelChanges.st'FileModel textMenu 	'CV4-FileModelChanges.st'FileStream asPressPrinter 	'CV4-FileStream-Printing-changes.st'FileStream class findDirectoryForFileNamed:andEvaluateThisBlock: 	'kl-RemoteFiles.st'FileStream class getFileName:list: 	'kl-RemoteFiles.st'FileStream class getNamesOfDirectoriesContaining:list: 	'kl-RemoteFiles.st'FileStream class getNewFileName:list: 	'kl-RemoteFiles.st'FileStream class getOldFileName:list: 	'kl-RemoteFiles.st'FileStream class isRoot: 	'kl-RemoteFiles.st'FileStream class openFile:list: 	'kl-RemoteFiles.st'FileStream class openNewFile:list: 	'kl-RemoteFiles.st'FileStream class openOldFile:list: 	'kl-RemoteFiles.st'FileStream class trivialFullName:list: 	'kl-RemoteFiles.st'FileStream class tryToGetFileNameFrom:list: 	'kl-RemoteFiles.st'FileStream sendEFTP: 	'CV4-FileStream-Printing-changes.st'FileStream sendEFTPtoPrinter:numOfCopies:numTries:sendMsgsTo: 	'CV4-FileStream-Printing-changes.st'FileStream toPrinter:numOfCopies:numTries:sendMsgsTo: 	'CV4-FileStream-Printing-changes.st'	'FileStream-NS-Changes.st'FileStringHolder 	'XSIS-FileModel.st'FillElement 	'XSIS-Forms-Elements.st'FillInTheBlank class request:default: 	'CV4-FillInTheBlankChanges.st'	'FastUserInterface-use.st'FillInTheBlankController 	'CV4-FITBlankControllerChanges.st'FillInTheBlankController bailOut 	'CV4-FITBlankControllerChanges.st'FillInTheBlankController class 	'CV4-FITBlankControllerChanges.st'FillInTheBlankController class initialize 	'CV4-FITBlankControllerChanges.st'FillInTheBlankController initializeYellowButtonMenu 	'CV4-FITBlankControllerChanges.st'FillInTheBlankView editString:linegrid:baseline: 	'CV4-FillInTheBlankChanges.st'FillInTheBlankView initialize 	'Big-Paragraphs-useThem-changes.st'FirstABListController 	'XSIS-AutoBook.st'FirstABListView 	'XSIS-AutoBook.st'FixedFileFilter 	'XSIS-FixedFiles.st'FixedFileStream 	'XSIS-FixedFiles.st'Form 	'kl-FormsStrikeFont-nonTek4407.st'Form class 	'CV4-FormChanges.st'Form class initializeMasks 	'CV4-FormChanges.st'	'kl-FormsStrikeFont-nonTek4407.st'Form class masks 	'kl-FormsStrikeFont-nonTek4407.st'Form class readAISFile: 	'CV4-FormChanges.st'Form class readFrom: 	'FormChangesForHeaderStreams.st'Form class readFromStream: 	'FormFilingChanges.st'Form class readFromSuitcase: 	'FormChangesForHeaderStreams.st'Form class screen 	'CV4-FormChanges.st'Form class setScreenMask: 	'CV4-FormChanges.st'Form computeBoundingBox 	'CV4-FormChanges.st'Form drawSegLine:from:to:clippingBox:rule:mask:segmentLength: 	'BitBltAndForm-tek-adds.st'Form edit 	'CV4-FormChanges.st'Form editAt: 	'CV4-FormChanges.st'Form fill:rule:mask: 	'CV4-FormChanges.st'Form hardcopy 	'CV4-FormChanges.st'Form hardcopyOnFileNamed: 	'CV4-FormChanges.st'Form hardcopyOnFileNamed:scale:landscape: 	'CV4-FormChanges.st'Form isAllWhite 	'CV4-FormChanges.st'Form valueAt:put: 	'CV4-FormChanges.st'Form writeAsDataItem: 	'FormChangesForHeaderStreams.st'Form writeCAIS: 	'CV4-FormChanges.st'Form writeOnStream: 	'FormFilingChanges.st'FormButtonCache 	'CV4-RemoveFormEditor.st'FormEditor 	'CV4-RemoveFormEditor.st'FormHolderView updateRequest 	'CV4-FormHolderViewChanges.st'FormMenuController 	'CV4-RemoveFormEditor.st'FormMenuView 	'CV4-RemoveFormEditor.st'FormsController 	'XSIS-Forms.st'FormsEditController 	'XSIS-Forms.st'"!crossRefSummaryPart03"FormsElement 	'XSIS-Forms-Elements.st'FormsFillController 	'XSIS-Forms.st'FormsModel 	'XSIS-Forms.st'FormsStrikeFont 	'kl-FormsStrikeFont.st'FormsView 	'XSIS-Forms.st'FormView defaultControllerClass 	'CV4-RemoveFormEditor.st'FunctionKeyEditor 	'XSIS-RS232-Applics.st'FunctionKeyEditorController 	'XSIS-RS232-Applics.st'GrapherController 	'XSIS-Boxes.st'HeaderFileStream 	'XSIS-SpecialFileStreams.st'Helper 	'XSIS-Help.st'ICGStandardSystemController 	'InfoCenter-Graph.st'Idle 	'Idle.st'ImageEditor 	'XSIS-ImageEditor.st'ImageEditorTextCollector 	'XSIS-ImageEditor.st'ImageElement 	'XSIS-Forms-Elements.st'ImmediateExecuteElement 	'XSIS-Forms-Elements.st'InfoCenterElement 	'XSIS-Forms-Elements.st'InfoCenterGraphController 	'InfoCenter-Graph.st'InfoCenterGraphView 	'InfoCenter-Graph.st'InformationCenter 	'XSIS-InfoCenter.st'InputState keyAt:put: 	'Background-DelayAndProtect3Changes.st'InputState nextEvent:with: 	'ConnectIdle.st'Inspector textMenu 	'CV4-InspectorChanges.st'Integer printOn:base:minimumDigits: 	'CV4-IntegerChanges.st'Integer printOn:base:minimumDigits:fillWith: 	'CV4-IntegerChanges.st'Integer printStringRadix:minimumDigits:fillWith: 	'CV4-IntegerChanges.st'Interpress 	'Xerox-NSPrinting.st'KeyFileList 	'XSIS-FileModel.st'KeywordQuerier 	'XSIS-Querying.st'Label 	'XSIS-Spreadsheet-Support.st'LabelElement 	'XSIS-Forms-Elements.st'LabelSwitch 	'XSIS-Spreadsheets.st'LabelSwitchController 	'XSIS-Spreadsheets.st'LabelSwitchView 	'XSIS-Spreadsheets.st'LinearFit hardcopyOn: 	'CV4-LinearFitChanges.st'LinearFit hardcopyOn:roundEnds: 	'CV4-LinearFitChanges.st'LineChart 	'XSIS-Charts.st'ListController computeMarkerRegion 	'ScrollBarChanges.st'ListView 	'CV4-ListView-nonTek.st'ListView deselect 	'CV4-ListViewChanges.st'ListView displaySelectionBox 	'CV4-ListViewChanges.st'ListView findSelection: 	'CV4-ListViewChanges.st'	'ScrollBarChanges.st'ListView insideSelectionBox 	'CV4-ListViewChanges.st'ListView list: 	'CV4-ListViewChanges.st'	'FastLists.st'ListView listTitle: 	'CV4-ListViewChanges.st'ListView minimumSelection 	'CV4-ListViewChanges.st'ListView selectionBox 	'CV4-ListViewChanges.st'ListView topDelimiter: 	'CV4-ListViewChanges.st'LockedFormsController 	'XSIS-Forms.st'LogInOut 	'XSIS-LogInOut.st'LRUCacheDictionary 	'LRUCacheDictionary.st'Magnitude 	'CV4-MagnitudeChanges.st'Magnitude printFormat: 	'CV4-MagnitudeChanges.st'Magnitude printOn:format: 	'CV4-MagnitudeChanges.st'MapEditor 	'XSIS-MapEditor.st'MapFileList 	'XSIS-MapSupport.st'MapForm 	'XSIS-MapSupport.st'MapTransformationTable 	'XSIS-MapSupport.st'MapView 	'XSIS-MapSupport.st'Matrix 	'XSIS-Matrices.st'MessageView 	'XSIS-RS232-Basics.st'Metaclass copy 	'kl-OopConservingOrganizers.st'Metaclass copyForValidation 	'kl-OopConservingOrganizers.st'Metaclass sharedPools 	'Pools-System-Changes.st'MixedFileStream 	'XSIS-SpecialFileStreams.st'MouseMenuController blueButtonActivity 	'CV4-MouseMenuControllerChanges.st'MouseMenuController getLastSelectionIn: 	'CV4-MouseMenuControllerChanges.st'MouseMenuController performBlueSelections 	'CV4-MouseMenuControllerChanges.st'MouseMenuController performTreeBackwards: 	'CV4-MouseMenuControllerChanges.st'MouseMenuController performYellowSelections 	'CV4-MouseMenuControllerChanges.st'MouseMenuController redButtonActivity 	'CV4-MouseMenuControllerChanges.st'MouseMenuController yellowButtonActivity 	'CV4-MouseMenuControllerChanges.st'NewArc 	'XSIS-Paths.st'NewCircle 	'XSIS-Paths.st'NonprogrammerMenu 	'XSIS-SpecialMenus.st'NonprogrammerMessages 	'XSIS-SpecialMenus.st'NotifierController model: 	'CV4-NotifierControllerChanges.st'NotifierView class reportContext: 	'lc-notifier.st'Number class readNumberFrom: 	'CV4-NumberChanges.st'Object booboo: 	'CV4-ObjectChanges.st'	'FastUserInterface-use.st'Object class createAnalystDataItem: 	'CV4-ObjectChanges.st'Object class getFileName: 	'kl-RemoteFiles.st'Object class getNewFileName: 	'kl-RemoteFiles.st'Object class getOldFileName: 	'kl-RemoteFiles.st'Object class listOfFileDirectories 	'kl-RemoteFiles.st'Object class openFile: 	'kl-RemoteFiles.st'Object class openNewFile: 	'kl-RemoteFiles.st'Object class openOldFile: 	'kl-RemoteFiles.st'Object confirm: 	'CV4-ObjectChanges.st'	'FastUserInterface-use.st'Object confirm:yesLabel:noLabel: 	'CV4-ObjectChanges.st'	'FastUserInterface-use.st'Object doesNotUnderstand: 	'Signal-mm.st'	'lc-notifier.st'Object error: 	'Signal-mm.st'	'lc-notifier.st'Object getFileName: 	'kl-RemoteFiles.st'Object getNewFileName: 	'kl-RemoteFiles.st'Object getOldFileName: 	'kl-RemoteFiles.st'Object openFile: 	'kl-RemoteFiles.st'Object openNewFile: 	'kl-RemoteFiles.st'Object openOldFile: 	'kl-RemoteFiles.st'Object ~~ 	'StuffForLaterMerge.st'OneOfElement 	'XSIS-Forms-Elements.st'OnlyWhenSelectedCodeView defaultControllerClass 	'Big-Paragraphs-useThem-changes.st'OopConservingDictionary 	'OopConservingDictionary.st'OrderedCollection add:atIndex: 	'CV4-OrderedCollectionChanges.st'OrderedCollection realIndexFrom: 	'CV4-OrderedCollectionChanges.st'OrderedCollection removeObjectAt: 	'CV4-OrderedCollectionChanges.st'OutlineController 	'XSIS-NewOutlines.st'OutlineEditController 	'XSIS-NewOutlines.st'OutlineList 	'XSIS-NewOutlines.st'OutlineView 	'XSIS-NewOutlines.st'Paragraph asForm 	'CV4-ParagraphChanges.st'Paragraph asPressParagraph 	'CV4-ParagraphChanges.st'Paragraph asPrinterWidthsParagraph 	'CV4-ParagraphChanges.st'Paragraph class examplePrinterWidths 	'CV4-ParagraphChanges.st'Paragraph class forPressWithText:style:compositionRectangle: 	'CV4-ParagraphChanges.st'Paragraph class usingPrinterWidthsText: 	'Background-DelayAndProtect3Changes.st'Paragraph class withText:style: 	'CV4-ParagraphChanges.st'Paragraph class withText:style:compositionRectangle:clippingRectangle: 	'CV4-ParagraphChanges.st'Paragraph extendSelection:to:using: 	'CV4-ParagraphChanges.st'Paragraph leftMarginForCompositionForLine: 	'CV4-ParagraphChanges.st'Paragraph leftMarginForCompositionForStartIndex: 	'CV4-ParagraphChanges.st'Paragraph leftMarginForCompositionIfFirst: 	'CV4-ParagraphChanges.st'Paragraph leftMarginForDisplayForLine: 	'CV4-ParagraphChanges.st'Paragraph mouseSelect:to: 	'CV4-ParagraphChanges.st'Paragraph newPage: 	'CV4-ParagraphChanges.st'Paragraph newPage:in: 	'CV4-ParagraphChanges.st'Paragraph outputMedium 	'CV4-ParagraphChanges.st'Paragraph pressFile 	'CV4-ParagraphChanges.st'Paragraph pressOn: 	'CV4-ParagraphChanges.st'Paragraph recomposeIn:clippingBox: 	'CV4-ParagraphChanges.st'Paragraph rightMarginForComposition 	'CV4-ParagraphChanges.st'Paragraph rightMarginForDisplay 	'CV4-ParagraphChanges.st'Paragraph updateCompositionHeight 	'CV4-ParagraphChanges.st'Paragraph visibleRectangle 	'CV4-ParagraphChanges.st'ParagraphEditor 	'CV4-ParaEditor-NonTek.st'ParagraphEditor again 	'CV4-ParagraphEditorChanges.st'ParagraphEditor class copyText: 	'CV4-ParagraphEditorChanges.st'ParagraphEditor class fontSubMenu 	'CV4-ParagraphEditorChanges.st'ParagraphEditor class initFontMenu 	'CV4-ParagraphEditorChanges.st'ParagraphEditor class initialize 	'CV4-ParaEditor-NonTek.st'ParagraphEditor closeTypeIn 	'CV4-ParagraphEditorChanges.st'ParagraphEditor computeMarkerRegion 	'ScrollBarChanges.st'ParagraphEditor copySelection 	'CV4-ParagraphEditorChanges.st'ParagraphEditor copySelection: 	'CV4-ParagraphEditorChanges.st'ParagraphEditor cr: 	'CV4-ParaEditor-NonTek.st'ParagraphEditor cut 	'CV4-ParagraphEditorChanges.st'ParagraphEditor cut: 	'CV4-ParagraphEditorChanges.st'ParagraphEditor fileIt 	'CV4-ParagraphEditorChanges.st'ParagraphEditor findIt 	'CV4-ParagraphEditorChanges.st'ParagraphEditor findOnceAndReplace:with: 	'CV4-ParagraphEditorChanges.st'ParagraphEditor findOrReplace 	'CV4-ParagraphEditorChanges.st'ParagraphEditor fontIt 	'CV4-ParagraphEditorChanges.st'"!crossRefSummaryPart04"ParagraphEditor hardcopy 	'CV4-ParagraphEditorChanges.st'ParagraphEditor initialText 	'CV4-ParagraphEditorChanges.st'ParagraphEditor maxCanPaste 	'CV4-ParagraphEditorChanges.st'ParagraphEditor paste 	'CV4-ParagraphEditorChanges.st'ParagraphEditor pasteInfoText: 	'CV4-ParagraphEditorChanges.st'ParagraphEditor put 	'CV4-ParagraphEditorChanges.st'ParagraphEditor scrollRectangleHeight 	'CV4-ParagraphEditorChanges.st'ParagraphEditor scrollView: 	'CV4-ParagraphEditorChanges.st'ParagraphEditor selectCurrentTypeIn: 	'CV4-ParagraphEditorChanges.st'ParagraphEditor sometimesCloseTypeIn 	'CV4-ParagraphEditorChanges.st'ParagraphEditor stripCarraigeReturns 	'CV4-ParagraphEditorChanges.st'ParagraphEditor tab: 	'CV4-ParaEditor-NonTek.st'ParagraphEditor timeStamp 	'CV4-ParagraphEditorChanges.st'Parser makeNewSymbol:startingAt: 	'CV4-ParserChanges.st'PieChart 	'XSIS-Charts.st'PilotCalls 	'StuffForLaterDV6Merge.st'PilotFileDirectory 	'StuffForLaterDV6Merge.st'PilotFileDirectory copy:to: 	'PilotFile-Stretch-addns.st'PilotFileDirectory copyFileNamed:to: 	'PilotFile-Stretch-addns.st'PilotFileDirectory findFiles:inList:inclusive:addTo: 	'PilotFile-Stretch-addns.st'PilotFileDirectory makeNewFileName:withSuffix: 	'PilotFile-Stretch-addns.st'PilotFileStream 	'StuffForLaterDV6Merge.st'Point class numbersReverseInit: 	'CV4-PointChanges.st'Point fromPress:value: 	'CV4-PointChanges.st'Point hidePress:complete: 	'CV4-PointChanges.st'Point numbersDo: 	'CV4-PointChanges.st'Point numbersInit: 	'CV4-PointChanges.st'Point numbersReverseDo: 	'CV4-PointChanges.st'Point numbersReverseInit: 	'CV4-PointChanges.st'Point pressCode 	'CV4-PointChanges.st'Pool 	'Pool.st'PopUpMenu child 	'PopUpMenu-usefulStuff.st'PopUpMenu class initialize 	'PopUpMenu-addHelp.st'PopUpMenu class labels:lines: 	'Analyst-changeMenuFont.st'PopUpMenu class on: 	'PopUpMenu-usefulStuff.st'PopUpMenu class on:title: 	'PopUpMenu-usefulStuff.st'PopUpMenu doHelp:with: 	'PopUpMenu-addHelp.st'PopUpMenu font: 	'PopUpMenu-usefulStuff.st'PopUpMenu helpFor:on: 	'PopUpMenu-addHelp.st'PopUpMenu labels:font:lines: 	'PopUpMenu-addHelp.st'PopUpMenu manageMarker 	'PopUpMenu-addHelp.st'PopUpMenu markerOn: 	'PopUpMenu-usefulStuff.st'PopUpMenu pullOutHelps: 	'PopUpMenu-addHelp.st'PopUpMenu removeTrailingCR: 	'PopUpMenu-addHelp.st'PopUpMenu rescan 	'PopUpMenu-usefulStuff.st'PopUpMenu selectionIndex: 	'PopUpMenu-usefulStuff.st'PopUpMenu showHelp 	'PopUpMenu-addHelp.st'PopUpMenu startUp: 	'PopUpMenu-addHelp.st'PopUpMenu startUp:withHeading: 	'PopUpMenu-addHelp.st'PopUpMenu startUpAndWaitForSelectionAt: 	'PopUpMenu-addHelp.st'PopUpMenu storeOn: 	'PopUpMenu-usefulStuff.st'PopUpMenu unDisplayHelp: 	'PopUpMenu-addHelp.st'PositionableStream peekForMore: 	'CV4-ParagraphEditorChanges.st'PositionableStream release 	'PosStream-changesForKermit.st'PreviewCharacterBlockScanner 	'Preview-Support.st'PreviewCompositionScanner 	'Preview-Support.st'PreviewDisplayScanner 	'Preview-Support.st'PreviewPage 	'Preview-Page.st'PreviewPageController 	'Preview-Page.st'PreviewPageView 	'Preview-Page.st'PreviewTabController 	'Preview-Support.st'PreviewTabView 	'Preview-Support.st'PreviewTextLineInterval 	'Preview-Support.st'PrintFont 	'Xerox-NSPrinting.st'PrintFrom1108 	'XSIS-InterfaceXDE.st'PrintScanner 	'Xerox-NSPrinting.st'PrintStyle 	'Xerox-NSPrinting.st'Project 	'CV4-ProjectChanges.st'Project class initialize 	'CV4-ProjectChanges.st'Project class top 	'CV4-ProjectChanges.st'Project projectWindows 	'CV4-ProjectChanges.st'ProjectController class initialize 	'CV4-ProjectControllerChanges.st'Quadrangle displayOn: 	'StuffForLaterMerge.st'Querier 	'XSIS-Querying.st'QuerierController 	'XSIS-Querying.st'QuerierView 	'XSIS-Querying.st'Rectangle class fromUser: 	'CV4-RectangleChanges.st'Rectangle class fromUser:gridOrigin: 	'CV4-RectangleChanges.st'Rectangle class fromUser:gridOrigin:withExtent: 	'CV4-RectangleChanges.st'Rectangle class fromUserAspectRatio: 	'CV4-RectangleChanges.st'Rectangle class fromUserAtVertex:withExtent: 	'CV4-RectangleChanges.st'Rectangle class fromUserMinExtent:maxExtent:outlineColor: 	'CV4-RectangleChanges.st'Rectangle class fromUserWithExtent: 	'CV4-RectangleChanges.st'Rectangle class fromUserWithReduceFromMax: 	'CV4-RectangleChanges.st'Rectangle class numbersReverseInit: 	'CV4-RectangleChanges.st'Rectangle class pointsInit: 	'CV4-RectangleChanges.st'Rectangle numbersDo: 	'CV4-RectangleChanges.st'Rectangle numbersInit: 	'CV4-RectangleChanges.st'Rectangle numbersReverseDo: 	'CV4-RectangleChanges.st'Rectangle numbersReverseInit: 	'CV4-RectangleChanges.st'Rectangle pointsDo: 	'CV4-RectangleChanges.st'Rectangle pointsInit: 	'CV4-RectangleChanges.st'Rectangle userChangeCornerMinExtent:maxExtent:grid:gridOrigin:outlineColor: 	'CV4-RectangleChanges.st'RectForm 	'Preview-Support.st'RemoteMenuController 	'XSIS-SpecialMenus.st'RemoteString string 	'kl-QuadWordAlignedRemoteStrings.st'RemoteString string:onFileNumber:toFile: 	'kl-QuadWordAlignedRemoteStrings.st'RS232Controller 	'XSIS-RS232-Basics.st'RS232DisplayLine 	'XSIS-RS232-Basics.st'RS232DisplayMem 	'XSIS-RS232-Basics.st'RS232FunctionKeys 	'XSIS-RS232-Applics.st'RS232FunctionKeysController 	'XSIS-RS232-Applics.st'RS232FunctionKeysView 	'XSIS-RS232-Applics.st'RS232GraphicsDisplayMem 	'XSIS-RS232-Applics.st'RS232Kermit 	'XSIS-RS232-Kermit.st'RS232Memory 	'XSIS-RS232-Basics.st'RS232MemoryBuffer 	'XSIS-RS232-Basics.st'RS232Model 	'XSIS-RS232-Basics.st'RS232SendController 	'XSIS-RS232-Basics.st'RS232SystemController 	'XSIS-RS232-Basics.st'RS232TextView 	'XSIS-RS232-Basics.st'ScreenController 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController accelerateCursorPlace: 	'AnalystScreenController.st'ScreenController analystVersionInfo 	'AnalystScreenController.st'ScreenController auditOn 	'AnalystScreenController.st'ScreenController autoMenuShow: 	'AnalystScreenController.st'ScreenController backupUser: 	'AnalystScreenController.st'ScreenController backupUserMenuChoice 	'AnalystScreenController.st'ScreenController browseRecover 	'CV4-ScreenControllerSmalltalk.st'ScreenController class changeOITMenu 	'AnalystScreenController.st'ScreenController class initialize 	'CV4-ScreenControllerChanges.st'ScreenController class initializeBlueButtonMenu 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController class initializeOITMenu 	'AnalystScreenController.st'ScreenController class initializeSmalltalkSubmenu 	'CV4-ScreenControllerSmalltalk.st'ScreenController class initializeSystemControlsSubmenu 	'AnalystScreenController.st'ScreenController class initializeUserProfileSubmenu 	'AnalystScreenController.st'ScreenController class initializeYellowButtonMenu 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController class makeScreenColor:logChange: 	'AnalystScreenController.st'ScreenController class oitMenu 	'AnalystScreenController.st'ScreenController clipboardFunction: 	'AnalystScreenController.st'ScreenController collapseDisplay 	'CV4-ScreenControllerChanges.st'ScreenController connect 	'CV4-ScreenControllerSmalltalk.st'ScreenController crashRecover 	'CV4-ScreenControllerSmalltalk.st'ScreenController defer 	'CV4-ScreenControllerSmalltalk.st'ScreenController editOIT 	'AnalystScreenController.st'ScreenController editTimeZonesMenu 	'AnalystScreenController.st'ScreenController editUsersFile 	'AnalystScreenController.st'ScreenController fileOutChanges 	'CV4-ScreenControllerSmalltalk.st'ScreenController fileServer 	'CV4-ScreenControllerSmalltalk.st'ScreenController findOne 	'CV4-ScreenControllerChanges.st'ScreenController garbageCollect 	'CV4-ScreenControllerChanges.st'ScreenController idleForm 	'AnalystScreenController.st'ScreenController idleStart 	'AnalystScreenController.st'"!crossRefSummaryPart05"ScreenController initialize 	'CV4-ScreenControllerChanges.st'ScreenController initializeBlueButtonMenu 	'CV4-ScreenControllerChanges.st'ScreenController inspectChanges 	'CV4-ScreenControllerSmalltalk.st'ScreenController isControlActive 	'CV4-ScreenControllerChanges.st'ScreenController isControlWanted 	'CV4-ScreenControllerChanges.st'	'AnalystScreenController.st'ScreenController logOut 	'AnalystScreenController.st'ScreenController makeNewChartOrGraphicPad 	'AnalystScreenController.st'ScreenController noChanges 	'CV4-ScreenControllerSmalltalk.st'ScreenController openAutoBook 	'AnalystScreenController.st'ScreenController openBrowser 	'CV4-ScreenControllerSmalltalk.st'ScreenController openChangeList 	'CV4-ScreenControllerSmalltalk.st'ScreenController openClock 	'AnalystScreenController.st'ScreenController openCommandBar 	'AnalystScreenController.st'ScreenController openDigitalClock 	'AnalystScreenController.st'ScreenController openFileList 	'CV4-ScreenControllerSmalltalk.st'ScreenController openInfoCenter 	'AnalystScreenController.st'ScreenController openOIT 	'AnalystScreenController.st'ScreenController openSystemWorkspace 	'CV4-ScreenControllerSmalltalk.st'ScreenController openTextWindow 	'AnalystScreenController.st'ScreenController openTranscript 	'CV4-ScreenControllerSmalltalk.st'ScreenController openUserGuide 	'AnalystScreenController.st'ScreenController openWorkspace 	'CV4-ScreenControllerSmalltalk.st'ScreenController openWorkspaceOnFile 	'CV4-ScreenControllerSmalltalk.st'ScreenController openXDECenter 	'AnalystScreenController.st'ScreenController printAuditor 	'AnalystScreenController.st'ScreenController printEntireScreen 	'CV4-ScreenControllerSmalltalk.st'ScreenController printerName 	'AnalystScreenController.st'ScreenController printFramedArea 	'CV4-ScreenControllerSmalltalk.st'ScreenController quit 	'CV4-ScreenControllerSmalltalk.st'	'WatchforRS232onQuit-changes.st'ScreenController releaseExternalViews 	'CV4-ScreenControllerSmalltalk.st'ScreenController remoteLogin 	'CV4-ScreenControllerSmalltalk.st'ScreenController request:for:default: 	'CV4-ScreenControllerChanges.st'ScreenController restoreDisplay 	'CV4-ScreenControllerChanges.st'ScreenController restoreUserMenuChoice 	'AnalystScreenController.st'ScreenController saveThenQuit 	'CV4-ScreenControllerSmalltalk.st'	'WatchforRS232onQuit-changes.st'ScreenController screenColor: 	'AnalystScreenController.st'ScreenController scrollMenuSpeed 	'AnalystScreenController.st'ScreenController selectAndClose 	'CV4-ScreenControllerChanges.st'ScreenController setSystemFont: 	'AnalystScreenController.st'ScreenController showCoreAndOopsLeft 	'CV4-ScreenControllerChanges.st'ScreenController showDateAndTime 	'CV4-ScreenControllerChanges.st'ScreenController showDiskSpace 	'CV4-ScreenControllerChanges.st'ScreenController showResources 	'CV4-ScreenControllerChanges.st'ScreenController wipeOut 	'AnalystScreenController.st'ScrollController controlInitialize 	'ScrollBarChanges.st'ScrollController initialize 	'ScrollBarChanges.st'ScrollController scroll 	'ScrollBarChanges.st'ScrollController scrollDown 	'ScrollBarChanges.st'ScrollController scrollUp 	'ScrollBarChanges.st'ScrollMenu 	'XSIS-SpecialMenus.st'SearchPath 	'StuffForLaterDV6Merge.st'SecondABListController 	'XSIS-AutoBook.st'SecondABListView 	'XSIS-AutoBook.st'Semaphore critical: 	'Signal-mm.st'SequenceableCollection = 	'StuffForLaterMerge.st'SequenceableCollection indexOf:ifAbsent: 	'StuffForLaterMerge.st'SerialPort 	'NP-SerialPort-1108.st'Set includes: 	'StuffForLaterMerge.st'SharedDeque 	'SharedDeque.st'SharedObject 	'SharedObject.st'Signal 	'Signal-mm.st'Signal noHandler 	'lc-notifier.st'Signal resumeWith: 	'kl-SignalVersionCompatibility.st'Signal unwindAndDo: 	'kl-SignalVersionCompatibility.st'Signal unwindAndRetry 	'kl-SignalVersionCompatibility.st'Signal unwindWith: 	'kl-SignalVersionCompatibility.st'SimpleQuerier 	'XSIS-Querying.st'SortedCollection = 	'StuffForLaterMerge.st'SortedCollection sort:to: 	'SortedCollection-JS-HeapSort.st'SortedLinearFit 	'XSIS-Charts.st'SortedSpline 	'XSIS-Charts.st'SparseMatrix 	'XSIS-Matrices.st'Spline displayOn:at:clippingBox:rule:mask: 	'CV4-GraphicsPathsChanges.st'Spline hardcopyOn: 	'CV4-SplineChanges.st'Spline hardcopyOn:roundEnds: 	'CV4-SplineChanges.st'SpreadsheetCell 	'XSIS-Spreadsheets.st'SpreadsheetController 	'XSIS-Spreadsheets.st'SpreadsheetDictionary 	'XSIS-Spreadsheet-Support.st'SpreadsheetHolder 	'XSIS-Spreadsheets.st'SpreadsheetRule 	'XSIS-Spreadsheets.st'SpreadsheetView 	'XSIS-Spreadsheets.st'Sprite 	'XSIS-Animation.st'SSDataBase 	'XSIS-Spreadsheet-Support.st'StackedBarChart 	'XSIS-Charts.st'StackedLineChart 	'XSIS-Charts.st'StackListController 	'XSIS-ChartEditor.st'StandardSystemController 	'CV4-SSControllerChanges.st'StandardSystemController blueButtonActivity 	'CV4-SSControllerChanges.st'StandardSystemController class initialize 	'CV4-SSControllerChanges.st'StandardSystemController close 	'CV4-SSControllerChanges.st'StandardSystemController closeAndUnschedule 	'CV4-SSControllerChanges.st'StandardSystemController collapse 	'CV4-SSControllerChanges.st'	'SysWindows-patches-nonTek.st'StandardSystemController controlTerminate 	'CV4-SSControllerChanges.st'StandardSystemController expand 	'CV4-SSControllerChanges.st'	'SysWindows-patches-nonTek.st'StandardSystemController findOne 	'CV4-SSControllerChanges.st'StandardSystemController frame 	'CV4-SSControllerChanges.st'StandardSystemController getLinks 	'CV4-SSControllerChanges.st'StandardSystemController help 	'CV4-SSControllerChanges.st'StandardSystemController move 	'CV4-SSControllerChanges.st'StandardSystemController open 	'SysWindows-patches-nonTek.st'StandardSystemController restoreFullView 	'CV4-SSControllerChanges.st'StandardSystemController smashOne 	'CV4-SSControllerChanges.st'StandardSystemController smashThem 	'CV4-SSControllerChanges.st'StandardSystemSpreadsheetController 	'XSIS-Spreadsheets.st'StandardSystemView 	'CV4-StandardSystemView-nonTek.st'StandardSystemView accept 	'CV4-StandardSystemViewChanges.st'StandardSystemView cancel 	'CV4-StandardSystemViewChanges.st'StandardSystemView changeClassification: 	'CV4-StandardSystemViewChanges.st'StandardSystemView class labelTag 	'CV4-StandardSystemViewChanges.st'StandardSystemView class labelTag: 	'CV4-StandardSystemViewChanges.st'StandardSystemView class model:label:minimumSize:helpIndex: 	'CV4-StandardSystemViewChanges.st'StandardSystemView classifyLabel 	'CV4-StandardSystemViewChanges.st'StandardSystemView classifyLabel: 	'CV4-StandardSystemViewChanges.st'StandardSystemView collapse 	'CV4-StandardSystemViewChanges.st'StandardSystemView containsPoint: 	'CV4-StandardSystemViewChanges.st'StandardSystemView deEmphasizeView 	'CV4-StandardSystemViewChanges.st'StandardSystemView displayBorder 	'CV4-StandardSystemViewChanges.st'StandardSystemView displayClassification 	'CV4-StandardSystemViewChanges.st'StandardSystemView displayTextReverse 	'CV4-StandardSystemViewChanges.st'StandardSystemView displayView 	'CV4-StandardSystemViewChanges.st'StandardSystemView erase 	'CV4-StandardSystemViewChanges.st'StandardSystemView expand 	'CV4-StandardSystemViewChanges.st'StandardSystemView expand2 	'CV4-StandardSystemViewChanges.st'StandardSystemView getFrame 	'CV4-StandardSystemViewChanges.st'StandardSystemView helpIndex 	'CV4-StandardSystemViewChanges.st'StandardSystemView helpIndex: 	'CV4-StandardSystemViewChanges.st'StandardSystemView label: 	'CV4-StandardSystemViewChanges.st'StandardSystemView labelDisplayBox 	'CV4-StandardSystemViewChanges.st'StandardSystemView lastFullFrame 	'CV4-StandardSystemViewChanges.st'StandardSystemView lastLabelLocation 	'CV4-StandardSystemViewChanges.st'StandardSystemView lastLabelLocation: 	'CV4-StandardSystemViewChanges.st'"!crossRefSummaryPart06"StandardSystemView minimumSize: 	'CV4-StandardSystemViewChanges.st'StandardSystemView nearestVertexTo: 	'CV4-StandardSystemViewChanges.st'StandardSystemView release 	'CV4-StandardSystemViewChanges.st'StandardSystemView resize 	'CV4-StandardSystemViewChanges.st'StandardSystemView restoreFullView 	'CV4-StandardSystemViewChanges.st'StandardSystemView suitcase 	'CV4-StandardSystemViewChanges.st'Stats 	'XSIS-Spreadsheet-Support.st'StrikeFont ascent: 	'CV4-StrikeFontChanges.st'StrikeFont asPrinterWidthsFont 	'CV4-StrikeFontChanges.st'StrikeFont charsInString:fitting: 	'CV4-StrikeFontChanges.st'StrikeFont descent: 	'CV4-StrikeFontChanges.st'StrikeFont glyphs: 	'CV4-StrikeFontChanges.st'StrikeFont isRemote 	'CV4-StrikeFontChanges.st'StrikeFont maxWidth: 	'CV4-StrikeFontChanges.st'StrikeFont newFromStrike: 	'CV4-StrikeFontChanges.st'StrikeFont raster: 	'CV4-StrikeFontChanges.st'StrikeFont setStopConditions 	'CV4-StrikeFontChanges.st'StrikeFont storeOn: 	'CV4-StrikeFontChanges.st'StrikeFont strikeFont 	'CV4-StrikeFontChanges.st'StrikeFont strikeLength 	'CV4-StrikeFontChanges.st'StrikeFont type 	'CV4-StrikeFontChanges.st'StrikeFont widthOfString: 	'CV4-StrikeFontChanges.st'StrikeFont xOffset 	'CV4-StrikeFontChanges.st'StrikeFont xTable: 	'CV4-StrikeFontChanges.st'String = 	'StuffForLaterMerge.st'String acronym 	'CV4-StringChanges.st'String asForm 	'kl-UseFastTextDisplayScanner.st'String displayAt: 	'kl-UseFastTextDisplayScanner.st'String displayOn:at: 	'kl-UseFastTextDisplayScanner.st'String findBackwardString:startingAt: 	'CV4-StringChanges.st'String isNumeric 	'CV4-StringChanges.st'String openFile 	'CV4-StringChanges.st'String openNewFile 	'CV4-StringChanges.st'String openOldFile 	'CV4-StringChanges.st'String paddedToWidth:inStyle:font: 	'CV4-StringChanges.st'String specialReplaceFrom:to:with:startingAt: 	'CV4-StringChanges.st'String stripLeadingAndTrailingSpaces 	'CV4-StringChanges.st'String stripLeadingSpaces 	'CV4-StringChanges.st'StringHolderController class initialize 	'CV4-SHolderControllerChanges.st'StringHolderController fontIt 	'CV4-SHolderControllerChanges.st'StringHolderController initialize 	'CV4-SHolderControllerChanges.st'StringHolderController initializeYellowButtonMenu 	'CV4-SHolderControllerChanges.st'StringHolderController put:in: 	'CV4-SHolderControllerChanges.st'StringHolderView defaultControllerClass 	'Big-Paragraphs-useThem-changes.st'StringHolderView editString: 	'Big-Paragraphs-useThem-changes.st'StringHolderView initialize 	'Big-Paragraphs-useThem-changes.st'StringHolderView updateRequest 	'CV4-SHolderViewChanges.st'StructureController 	'InfoCenter-Structure.st'StructureParagraph 	'InfoCenter-Structure.st'StructureView 	'InfoCenter-Structure.st'Suitcase 	'XSIS-Suitcase.st'Sum 	'XSIS-Spreadsheet-Support.st'SwitchElement 	'XSIS-Forms-Elements.st'Symbol asString 	'StuffForLaterMerge.st'SyntaxError textMenu 	'CV4-SyntaxErrorChanges.st'SystemDictionary addToAnalystVersion: 	'AnalystVersionTracker.st'SystemDictionary getImagePrefix 	'StuffForLaterDV6Merge.st'SystemDictionary lowSpaceNotificationLoop 	'LowSpaceGarbageCollect-AB.st'SystemDictionary moveChangesFromFileNumber:toFileNumber:toFileStream: 	'kl-SourceFilesAt3.st'SystemDictionary nilOrganizationsForClasses: 	'kl-OopConservingOrganizers.st'SystemDictionary rehashBadSets 	'RehashBadSets.st'SystemDictionary version 	'AnalystVersionTracker.st'SystemDictionary versionName 	'StuffForLaterDV6Merge.st'SystemOrganizer fileOutCategory: 	'CV4-SystemOrganizerChanges.st'SystemTracer 	cv4FinalRemovalsTables 	'XSIS-Tables.st'TablesCompositionScanner 	'XSIS-Tables.st'TekController 	'XSIS-RS232-Applics.st'TekModel 	'XSIS-RS232-Applics.st'Test1108AsyncSerialPort 	'Test1108AsyncSerialPort.st'Text emphasisAt: 	'CV4-TextStyleChanges.st'Text findBackwardString:startingAt: 	'CV4-TextChanges.st'Text sameAs: 	'CV4-TextChanges.st'TextLineInterval = 	'StuffForLaterMerge.st'TextList class initializeWithFontAt: 	'CV4-TextListChanges.st'TextList leftMarginForCompositionForLine: 	'CV4-TextListChanges.st'TextStyle alignment: 	'CV4-TextStyleChanges.st'TextStyle baseline 	'CV4-TextStyleChanges.st'TextStyle class getNumForStrikeFont: 	'CV4-TextStyleChanges.st'TextStyle fontAt: 	'CV4-TextStyleChanges.st'TextStyle lineGrid 	'CV4-TextStyleChanges.st'TextStyle marginTabAt:side: 	'CV4-TextStyleChanges.st'TextStyle nextTabXFrom:leftMargin:rightMargin: 	'CV4-TextStyleChanges.st'TextStyle outputMedium: 	'CV4-TextStyleChanges.st'TextStyle pressScale 	'CV4-TextStyleChanges.st'TextStyle tabsArray 	'CV4-TextStyleChanges.st'TextStyle tabWidth 	'CV4-TextStyleChanges.st'TextView defaultControllerClass 	'Big-Paragraphs-useThem-changes.st'ThirdABListController 	'XSIS-AutoBook.st'ThirdABListView 	'XSIS-AutoBook.st'Time < 	'0711-kp-date-time-changes.st'Time = 	'0711-kp-date-time-changes.st'Time class readFrom: 	'0711-kp-date-time-changes.st'Time printOn: 	'CV4-TimeChanges.st'TreeMenu 	'XSIS-SpecialMenus.st'UnknownDate 	'0711-kp-date-time-changes.st'UnknownTime 	'0711-kp-date-time-changes.st'User 	'XSIS-Interface.st'UserFillController 	'XSIS-Interface.st'UserProfile 	'CV4-UserProfileChanges.st'UserProfile addFileServer: 	'CV4-UserProfileChanges.st'UserProfile addPrinter: 	'CV4-UserProfileChanges.st'UserProfile class initialize 	'CV4-UserProfileChanges.st'UserProfile class selectPrinter: 	'CV4-UserProfileChanges.st'UserProfile clearItAll 	'CV4-UserProfileChanges.st'UserProfile connect 	'CV4-UserProfileChanges.st'UserProfile connect: 	'CV4-UserProfileChanges.st'UserProfile connectName 	'CV4-UserProfileChanges.st'UserProfile connectPassword 	'CV4-UserProfileChanges.st'UserProfile domain 	'CV4-UserProfileChanges.st'UserProfile domain:organization: 	'CV4-UserProfileChanges.st'UserProfile fileServerChoices 	'CV4-UserProfileChanges.st'UserProfile login 	'CV4-UserProfileChanges.st'UserProfile organization 	'CV4-UserProfileChanges.st'UserProfile printerChoices 	'CV4-UserProfileChanges.st'UserProfile selectFileServer 	'CV4-UserProfileChanges.st'UserProfile selectPrinter 	'CV4-UserProfileChanges.st'UserProfile userName: 	'CV4-UserProfileChanges.st'UserProfile userPassword 	'CV4-UserProfileChanges.st'UserProfile userPassword: 	'CV4-UserProfileChanges.st'UserProfile userRName 	'CV4-UserProfileChanges.st'UTime 	'XSIS-Animation.st'WordArray fromFileStream: 	'CV4-WordArrayChanges.st'WordArray specialReplaceFrom:to:with:startingAt: 	'CV4-WordArrayChanges.st'WordArray toFileStream: 	'CV4-WordArrayChanges.st'XDEInterfaceController 	'XSIS-InterfaceXDE.st'XDEInterfaceModel 	'XSIS-InterfaceXDE.st'XYChart 	'XSIS-Charts.st'ZonedTime 	'TimeZone-Clocks.st'"!featuresSummaryPart01"0711-kp-date-time-changes.st	amorphousFeatureamorphousFeature	450-amorphousFeatureAnalyst-changeMenuFont.st	base1FeatureAnalyst-fileRelated-patches-Tek.st	base2FeatureAnalyst-UserProfile-patches-Tek.st	base3FeatureanalystFontsFeature	220-analystFontsFeatureAnalystIcons1.strike	analystFontsFeatureAnalystScreenController.st	460-AnalystScreenController.stanalystSpreadsheetFeature	570-analystSpreadsheetFeatureAnalystVersionTracker.st	amorphousFeatureAssociationlessDictionary.st	base1FeatureAsyncSerialPort.st	rs232FeatureBackground-DelayAndProtect3Changes.st	backgroundFeaturebackgroundFeature	510-backgroundFeaturebackgroundProtectEtherFeature	backgroundFeaturebase1Feature	250-base1Featurebase2Feature	260-base2Featurebase3Feature	270-base3Featurebase4Feature	290-base4FeatureBig-Paragraphs-maxSizeChange.st	base4FeatureBig-Paragraphs-useThem-changes.st	base4FeatureBitBltAndForm-tek-adds.st	rs232FeatureBuild-AnalystArchitect.st	BuilderBuild-Architect.st	Builderbuild1100EiaPool	rs232FeaturechangesManagementActualFeature	changesManagementFeaturechangesManagementFeature	230-changesManagementFeaturechartWindowFeature	550-chartWindowFeatureClassifiedStandardSystemController.st	base4FeatureClassifiedStringHolderController.st	infoCenterFeatureConnectIdle.st	amorphousFeatureCream12.strike	analystFontsFeatureCursorChanges.st	base4FeatureCV4-ActionMenuChanges.st	base3FeatureCV4-AltoFileDirectoryChanges.st	machineSpecificFeatureCV4-AltoFileHint.st	machineSpecificFeatureCV4-BinaryChoiceChanges.st	base3FeatureCV4-BinaryChoiceViewChanges.st	base3FeatureCV4-BitEditorChanges.st	base3FeatureCV4-BrowserChanges.st	base3FeatureCV4-ByteArrayChanges.st	base2FeatureCV4-CharacterBlockScannerChanges.st	base1FeatureCV4-CharacterScannerChanges.st	base1FeatureCV4-ClassOrganizerChanges.st	base3FeatureCV4-CListControllerChanges.st	base3FeatureCV4-CompositionScannerChanges.st	base1FeatureCV4-ControlManagerChanges-Tek.st	base2FeatureCV4-ControlManagerChanges.st	base2FeatureCV4-DateChanges.st	base2FeatureCV4-DebuggerChanges.st	base3FeatureCV4-DictionaryInspectorChanges.st	base3FeatureCV4-DisplayScannerChanges.st	base1FeatureCV4-DisplayScreenChanges.st	base4FeatureCV4-EncoderChanges.st	base3FeatureCV4-EtherWorldChanges.st	machineSpecificFeatureCV4-FileChanges.st	base3FeatureCV4-FileDirectoryChanges-11wIFS.st	base2FeatureCV4-FileDirectoryChanges-PS.st	base2FeatureCV4-FileDirectoryChanges.st	base2FeatureCV4-FileListChanges.st	base3FeatureCV4-FileModelChanges.st	base2FeatureCV4-FileStream-Printing-changes.st	base4FeatureCV4-FillInTheBlankChanges.st	base2FeatureCV4-FITBlankControllerChanges.st	base2FeatureCV4-FloatChanges.st	base2FeatureCV4-FormChanges-Tek.st	base1FeatureCV4-FormChanges.st	base1FeatureCV4-FormHolderViewChanges.st	base1FeatureCV4-GraphicsPathsChanges.st	base4FeatureCV4-InspectorChanges.st	base3FeatureCV4-IntegerAsFloatChanges-1100.st	base2FeatureCV4-IntegerChanges.st	base2FeatureCV4-LinearFitChanges.st	base1FeatureCV4-ListView-nonTek.st	base2FeatureCV4-ListView-Tek.st	base2FeatureCV4-ListViewChanges.st	base2FeatureCV4-MagnitudeChanges.st	base2FeatureCV4-MouseMenuControllerChanges.st	base1FeatureCV4-NotifierControllerChanges.st	base3FeatureCV4-NumberChanges.st	base3FeatureCV4-ObjectChanges.st	base3FeatureCV4-OrderedCollectionChanges.st	base3FeatureCV4-ParaEditor-NonTek.st	base2FeatureCV4-ParaEditor-Tek.st	base2FeatureCV4-ParagraphChanges.st	base1FeatureCV4-ParagraphEditorChanges.st	base2FeatureCV4-ParserChanges.st	base3FeatureCV4-PointChanges.st	base1FeatureCV4-ProjectChanges.st	base2FeatureCV4-ProjectControllerChanges.st	base3FeatureCV4-RectangleChanges.st	base4FeatureCV4-RemoveFormEditor.st	base3FeatureCV4-ScreenController-Tek.st	screenControllerFeatureCV4-ScreenControllerChanges-PS.st	screenControllerFeatureCV4-ScreenControllerChanges.st	screenControllerFeatureCV4-ScreenControllerSmalltalk.st	screenControllerFeatureCV4-SHolderControllerChanges.st	base2FeatureCV4-SHolderViewChanges.st	base2FeatureCV4-SocketChanges.st	base3FeatureCV4-SplineChanges.st	base2FeatureCV4-SSControllerChanges.st	base4FeatureCV4-StandardSystemView-nonTek.st	base4FeatureCV4-StandardSystemView-Tek.st	base4FeatureCV4-StandardSystemViewChanges.st	base4FeatureCV4-StrikeFontChanges-Tek.st	base2FeatureCV4-StrikeFontChanges.st	base2FeatureCV4-StringChanges.st	base2FeatureCV4-SyntaxErrorChanges.st	base3FeatureCV4-SystemOrganizerChanges.st	base2FeatureCV4-TextChanges.st	base2FeatureCV4-TextListChanges.st	base1FeatureCV4-TextStyleChanges.st	base1FeatureCV4-TimeChanges.st	base2FeatureCV4-UserProfileChanges.st	base3FeatureCV4-WordArrayChanges.st	base2Featurecv4FinalRemovals	cv4FinalRemovalsFeaturecv4FinalRemovalsFeature	350-cv4FinalRemovalsFeaturedataBaseFeature	560-dataBaseFeatureDirectoryHierarchy-lists.st	base1FeatureEMV-1100-GarbageCollector.st	machineSpecificFeatureFastLists.st	base4FeatureFastTextDisplayScanner.st	base1FeatureFastUserInterface-use.st	amorphousFeatureFileStream-NS-Changes.st	machineSpecificFeatureFormChangesForHeaderStreams.st	base4FeatureFormFilingChanges.st	analystSpreadsheetFeatureGacha10.strike	analystFontsFeatureHelvetica10.strike	analystFontsFeatureHelvetica10b.strike	analystFontsFeatureHelvetica12.strike	analystFontsFeatureHelvetica14.strike	analystFontsFeatureHelvetica18.strike	analystFontsFeatureHelvetica24.strike	analystFontsFeatureHelvetica7.strike	analystFontsFeatureIdle.st	amorphousFeatureidleBalloonFormFeature	amorphousFeatureInfoCenter-Graph-Tek.st	infoCenterFeatureInfoCenter-Graph.st	infoCenterFeatureInfoCenter-Structure-Tek.st	infoCenterFeatureInfoCenter-Structure.st	infoCenterFeatureinfoCenterFeature	530-infoCenterFeatureinterpressFeature	printingFeatureinterpressInit	interpressFeatureKeepCursorInView.st	base2Featurekl-CondenseChanges-nonPS20.st	changesManagementActualFeaturekl-CondenseChanges-PS20.st	changesManagementActualFeaturekl-FormsStrikeFont-nonTek4407.st	base4Featurekl-FormsStrikeFont-Tek4407.st	base4Featurekl-FormsStrikeFont.st	base4Featurekl-OopConservingOrganizers.st	oopConservingOrganizersFeaturekl-OopConsOrganizers-Pool-patch.st	oopConservingOrganizersFeaturekl-QuadWordAlignedRemoteStrings.st	changesManagementActualFeaturekl-RemoteFiles.st	base1Featurekl-SignalVersionCompatibility.st	base4Featurekl-SourceFilesAt3.st	changesManagementActualFeaturekl-UseFastTextDisplayScanner.st	base1Featurelc-notifier.st	amorphousFeatureLowSpaceGarbageCollect-AB.st	machineSpecificFeatureLRUCacheDictionary.st	base1FeaturemachineSpecificFeature	330-machineSpecificFeaturemapWindowFeature	580-mapWindowFeaturenilFeature	idleBalloonFormFeature	backgroundProtectEtherFeature	backgroundProtectEtherFeatureNP-SerialPort-1108.st	rs232FeatureOldEnglish18.strike	analystFontsFeatureOopConservingDictionary.st	base1FeatureoopConservingOrganizersFeature	480-oopConservingOrganizersFeaturePilotFile-Stretch-addns.st	machineSpecificFeaturePool.st	base1FeaturePools-System-Changes.st	base1FeaturePopUpMenu-addHelp.st	base1FeaturePopUpMenu-usefulStuff.st	base1FeaturePosStream-changesForKermit.st	rs232FeaturepostBuild	400-postBuildpressFeature	machineSpecificFeaturepressInit1	machineSpecificFeaturePreview-Page.st	previewWindowFeaturePreview-Support.st	previewWindowFeaturePreviewPage-Tek.st	previewWindowFeaturepreviewWindowFeature	640-previewWindowFeatureprintingFeature	500-printingFeatureRehashBadSets.st	base1Featurerml-Signal-oldEther-fix.st	base4Featurers232Feature	610-rs232FeaturescreenControllerFeature	280-screenControllerFeatureScrollBarChanges-Tek.st	base4FeatureScrollBarChanges.st	base4FeatureSemaphoreCommForSerialPort-PS.st	rs232FeatureSerialPort-1100.st	rs232FeatureSerialPort-1108.st	rs232FeaturesetAnalystGlobals"!featuresSummaryPart02"	amorphousFeaturesetLongIdleTime	amorphousFeatureSharedDeque.st	backgroundFeature	machineSpecificFeature	machineSpecificFeature	backgroundFeatureSharedObject.st	backgroundFeature	machineSpecificFeature	machineSpecificFeature	backgroundFeatureSignal-mm.st	analystSpreadsheetFeature	base4Feature	base4Feature	analystSpreadsheetFeatureSignal-retry-PS.st	base4FeatureSmalltalkBalloon.form	idleBalloonFormFeatureSortedCollection-JS-HeapSort.st	base4FeaturestripExamplesFeature	300-stripExamplesFeatureStripper.st	stripExamplesFeatureStuffForLaterDV6Merge.st	machineSpecificFeatureStuffForLaterMerge.st	240-StuffForLaterMerge.stswitchExistingPools	base1FeatureSysWindows-patches-nonTek.st	base4FeatureSysWindows-patches-Tek.st	base4FeatureTest1108AsyncSerialPort.st	rs232FeatureTimesRoman10.strike	analystFontsFeatureTimesRoman10b.strike	analystFontsFeatureTimesRoman10i.strike	analystFontsFeatureTimesRoman12.strike	analystFontsFeatureTimesRoman12b.strike	analystFontsFeatureTimesRoman12i.strike	analystFontsFeatureTimesRoman14.strike	analystFontsFeatureTimesRoman18.strike	analystFontsFeatureTimesRoman24.strike	analystFontsFeatureTimeZone-Clocks.st	630-TimeZone-Clocks.stWatchforRS232onQuit-changes.st	rs232FeatureXerox-NSPrinting-Tek.st	interpressFeatureXerox-NSPrinting.st	interpressFeatureXSIS-Animation.st	590-XSIS-Animation.stXSIS-Auditor.st	amorphousFeatureXSIS-AutoBook.st	620-XSIS-AutoBook.stXSIS-Background.st	backgroundFeatureXSIS-Big-Paragraphs.st	base4FeatureXSIS-Boxes.st	infoCenterFeature	amorphousFeature	analystSpreadsheetFeature	amorphousFeature	infoCenterFeature	analystSpreadsheetFeatureXSIS-ChartEditor.st	chartWindowFeatureXSIS-Charts.st	chartWindowFeatureXSIS-Classification.st	infoCenterFeatureXSIS-ConfigFiles-Tek.st	amorphousFeatureXSIS-ConfigFiles.st	amorphousFeatureXSIS-ControlBox.st	infoCenterFeature	amorphousFeature	analystSpreadsheetFeature	amorphousFeature	infoCenterFeature	analystSpreadsheetFeatureXSIS-DataBase.st	dataBaseFeatureXSIS-DataControl.st	base2FeatureXSIS-FileModel.st	540-XSIS-FileModel.stXSIS-FixedFiles.st	dataBaseFeature	chartWindowFeature	mapWindowFeature	chartWindowFeature	dataBaseFeature	mapWindowFeatureXSIS-Forms-Elements.st	amorphousFeatureXSIS-Forms.st	amorphousFeatureXSIS-Help.st	520-XSIS-Help.stXSIS-ImageEditor.st	base4FeatureXSIS-InfoCenter-Tek.st	infoCenterFeatureXSIS-InfoCenter.st	infoCenterFeatureXSIS-Interface.st	amorphousFeatureXSIS-InterfaceXDE.st	machineSpecificFeatureXSIS-LogInOut.st	amorphousFeatureXSIS-MapEditor-PS.st	mapWindowFeatureXSIS-MapEditor.st	mapWindowFeatureXSIS-MapSupport-PS.st	mapWindowFeatureXSIS-MapSupport.st	mapWindowFeatureXSIS-Matrices.st	analystSpreadsheetFeature	infoCenterFeature	infoCenterFeature	analystSpreadsheetFeatureXSIS-NewOutlines.st	600-XSIS-NewOutlines.stXSIS-Paths-PS.st	base4FeatureXSIS-Paths.st	base4FeatureXSIS-Querying.st	infoCenterFeature	amorphousFeature	chartWindowFeature	dataBaseFeature	analystSpreadsheetFeature	mapWindowFeature	amorphousFeature	infoCenterFeature	chartWindowFeature	dataBaseFeature	analystSpreadsheetFeature	mapWindowFeatureXSIS-RS232-Applics.st	rs232FeatureXSIS-RS232-Basics.st	rs232FeatureXSIS-RS232-Kermit.st	rs232FeatureXSIS-SerialPort-PS.st	rs232FeatureXSIS-SpecialFileStreams-Tek.st	base4FeatureXSIS-SpecialFileStreams.st	analystSpreadsheetFeature	base4Feature	base4Feature	analystSpreadsheetFeatureXSIS-SpecialMenus.st	base1FeatureXSIS-Spreadsheet-Support.st	analystSpreadsheetFeatureXSIS-Spreadsheets-Tek-4406.st	analystSpreadsheetFeatureXSIS-Spreadsheets.st	analystSpreadsheetFeatureXSIS-Suitcase.st	infoCenterFeatureXSIS-Tables.st	dataBaseFeature"!ftpSummaryPart01"	(FileStream oldFileNamed: 'AnalystST80-DV6-1108.5List.cm') edit.""Ftp IFSName directory/c AnalystST80-DV6-1108.5>St store/uva ^AnalystST80-DV6-1108.5List.cm ^^directory/c  retrieve/ua ^0711-kp-date-time-changes.st Analyst-changeMenuFont.st AnalystIcons1.strike AnalystScreenController.st AnalystVersionTracker.st AssociationlessDictionary.st AsyncSerialPort.st Background-DelayAndProtect3Changes.st Big-Paragraphs-useThem-changes.st BitBltAndForm-tek-adds.st Build-AnalystArchitect.st Build-Architect.st ClassifiedStandardSystemController.st ClassifiedStringHolderController.st ConnectIdle.st Cream12.strike CursorChanges.st CV4-ActionMenuChanges.st CV4-BinaryChoiceChanges.st CV4-BinaryChoiceViewChanges.st CV4-BitEditorChanges.st CV4-BrowserChanges.st CV4-ByteArrayChanges.st CV4-CharacterBlockScannerChanges.st CV4-CharacterScannerChanges.st CV4-ClassOrganizerChanges.st CV4-CListControllerChanges.st CV4-CompositionScannerChanges.st CV4-ControlManagerChanges.st CV4-DateChanges.st CV4-DebuggerChanges.st CV4-DictionaryInspectorChanges.st CV4-DisplayScannerChanges.st CV4-DisplayScreenChanges.st CV4-EncoderChanges.st CV4-FileDirectoryChanges.st CV4-FileListChanges.st CV4-FileModelChanges.st CV4-FileStream-Printing-changes.st CV4-FillInTheBlankChanges.st CV4-FITBlankControllerChanges.st CV4-FormChanges.st CV4-FormHolderViewChanges.st CV4-GraphicsPathsChanges.st CV4-InspectorChanges.st CV4-IntegerChanges.st CV4-LinearFitChanges.st CV4-ListView-nonTek.st CV4-ListViewChanges.st CV4-MagnitudeChanges.st CV4-MouseMenuControllerChanges.st CV4-NotifierControllerChanges.st CV4-NumberChanges.st CV4-ObjectChanges.st CV4-OrderedCollectionChanges.st CV4-ParaEditor-NonTek.st CV4-ParagraphChanges.st CV4-ParagraphEditorChanges.st CV4-ParserChanges.st CV4-PointChanges.st CV4-ProjectChanges.st CV4-ProjectControllerChanges.st CV4-RectangleChanges.st CV4-RemoveFormEditor.st CV4-ScreenControllerChanges.st CV4-ScreenControllerSmalltalk.st CV4-SHolderControllerChanges.st CV4-SHolderViewChanges.st CV4-SplineChanges.st CV4-SSControllerChanges.st CV4-StandardSystemView-nonTek.st CV4-StandardSystemViewChanges.st CV4-StrikeFontChanges.st CV4-StringChanges.st CV4-SyntaxErrorChanges.st CV4-SystemOrganizerChanges.st CV4-TextChanges.st CV4-TextListChanges.st CV4-TextStyleChanges.st CV4-TimeChanges.st CV4-UserProfileChanges.st CV4-WordArrayChanges.st DirectoryHierarchy-lists.st FastLists.st FastTextDisplayScanner.st FastUserInterface-use.st FileStream-NS-Changes.st FormChangesForHeaderStreams.st FormFilingChanges.st Gacha10.strike Helvetica10.strike Helvetica10b.strike Helvetica12.strike Helvetica14.strike Helvetica18.strike Helvetica24.strike Helvetica7.strike Idle.st InfoCenter-Graph.st InfoCenter-Structure.st KeepCursorInView.st kl-CondenseChanges-nonPS20.st kl-FormsStrikeFont-nonTek4407.st kl-FormsStrikeFont.st kl-OopConservingOrganizers.st kl-OopConsOrganizers-Pool-patch.st kl-QuadWordAlignedRemoteStrings.st kl-RemoteFiles.st kl-SignalVersionCompatibility.st kl-SourceFilesAt3.st kl-UseFastTextDisplayScanner.st lc-notifier.st LowSpaceGarbageCollect-AB.st LRUCacheDictionary.st NP-SerialPort-1108.st OldEnglish18.strike OopConservingDictionary.st PilotFile-Stretch-addns.st Pool.st Pools-System-Changes.st PopUpMenu-addHelp.st PopUpMenu-usefulStuff.st PosStream-changesForKermit.st Preview-Page.st Preview-Support.st RehashBadSets.st ScrollBarChanges.st SharedDeque.st SharedObject.st Signal-mm.st SmalltalkBalloon.form SortedCollection-JS-HeapSort.st StuffForLaterDV6Merge.st StuffForLaterMerge.st SysWindows-patches-nonTek.st Test1108AsyncSerialPort.st TimesRoman10.strike TimesRoman10b.strike TimesRoman10i.strike TimesRoman12.strike TimesRoman12b.strike TimesRoman12i.strike TimesRoman14.strike TimesRoman18.strike TimesRoman24.strike TimeZone-Clocks.st WatchforRS232onQuit-changes.st Xerox-NSPrinting.st XSIS-Animation.st XSIS-Auditor.st XSIS-AutoBook.st XSIS-Background.st XSIS-Big-Paragraphs.st XSIS-Boxes.st XSIS-ChartEditor.st XSIS-Charts.st XSIS-Classification.st XSIS-ConfigFiles.st XSIS-ControlBox.st XSIS-DataBase.st XSIS-DataControl.st XSIS-FileModel.st XSIS-FixedFiles.st XSIS-Forms-Elements.st XSIS-Forms.st XSIS-Help.st XSIS-ImageEditor.st XSIS-InfoCenter.st XSIS-Interface.st XSIS-InterfaceXDE.st XSIS-LogInOut.st XSIS-MapEditor.st XSIS-MapSupport.st XSIS-Matrices.st XSIS-NewOutlines.st XSIS-Paths.st XSIS-Querying.st XSIS-RS232-Applics.st XSIS-RS232-Basics.st XSIS-RS232-Kermit.st XSIS-SpecialFileStreams.st XSIS-SpecialMenus.st XSIS-Spreadsheet-Support.st XSIS-Spreadsheets.st XSIS-Suitcase.st XSIS-Tables.st ^"!logOf220xanalystFontsFeaturePart01"220-analystFontsFeature - Preliminary Pass: Locating files - (27 April 1987 5:38:41 pm )AnalystArchitect analystFontsFeature.	TimesRoman10.strike	TimesRoman10b.strike	TimesRoman10i.strike	TimesRoman12.strike	TimesRoman12b.strike	TimesRoman12i.strike	TimesRoman18.strike	Helvetica12.strike	Helvetica14.strike	Helvetica18.strike	Helvetica24.strike	Helvetica7.strike	TimesRoman14.strike	TimesRoman24.strike	Helvetica10.strike	Helvetica10b.strike	Cream12.strike	OldEnglish18.strike	AnalystIcons1.strike	Gacha10.strike220-analystFontsFeature - Final Pass: Reading files - (27 April 1987 5:55:58 pm )AnalystArchitect analystFontsFeature.220-analystFontsFeature uses 315 oops and 38798 wordsBefore: oops left = 29462; core left = 873342After: oops left = 29147; core left = 834544((27 April 1987 5:58:02 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf230xchangesManagementFeaturePart01"230-changesManagementFeature - Preliminary Pass: Locating files - (27 April 1987 5:39:15 pm )AnalystArchitect changesManagementFeature.		AnalystArchitect changesManagementActualFeature.		kl-SourceFilesAt3.st		kl-CondenseChanges-nonPS20.st		kl-QuadWordAlignedRemoteStrings.st230-changesManagementFeature - Final Pass: Reading files - (27 April 1987 5:59:55 pm )AnalystArchitect changesManagementFeature.		AnalystArchitect changesManagementActualFeature.		kl-SourceFilesAt3.st			4067 bytes. 12 April 1987 9:34:33 pm			ClassDescription moveChangesFromFileNumber:toFileNumber:toFileStream: - add			ClassOrganizer moveChangedCommentFromFileNumber:toFileNumber:toFileStream: - add			SystemDictionary moveChangesFromFileNumber:toFileNumber:toFileStream: - add			99 oops and 4207 words		kl-CondenseChanges-nonPS20.st			593 bytes. 22 April 1987 8:08:55 pm			ClassDescription moveChangesTo: - change			28 oops and 971 words		kl-QuadWordAlignedRemoteStrings.st			4504 bytes. 24 February 1987 2:39:10 pm			Behavior printMethodChunk:on:moveSource:toFile: - remove			ClassDescription printMethodChunk:on:moveSource:toFile: - change			RemoteString string - change			RemoteString string:onFileNumber:toFile: - change			52 oops and 3475 words230-changesManagementFeature uses 160 oops and 7794 wordsBefore: oops left = 29795; core left = 874788After: oops left = 29635; core left = 866994((27 April 1987 6:06:04 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf240xStuffForLaterMergexstPart01"240-StuffForLaterMerge.st - Preliminary Pass: Locating files - (27 April 1987 5:39:32 pm )StuffForLaterMerge.st240-StuffForLaterMerge.st - Final Pass: Reading files - (27 April 1987 6:07:57 pm )StuffForLaterMerge.st	3764 bytes. 18 February 1987 7:02:11 pm	BlockContext join: - add	Object ~~ - change	Quadrangle displayOn: - change	SequenceableCollection = - change	SequenceableCollection indexOf:ifAbsent: - change	Set includes: - change	SortedCollection = - change	String = - change	Symbol asString - change	TextLineInterval = - change	94 oops and 2859 words240-StuffForLaterMerge.st uses 84 oops and 2536 wordsBefore: oops left = 29769; core left = 873838After: oops left = 29685; core left = 871302((27 April 1987 6:09:21 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf250xbase1FeaturePart01"250-base1Feature - Preliminary Pass: Locating files - (27 April 1987 5:39:41 pm )AnalystArchitect base1Feature.	RehashBadSets.st	AssociationlessDictionary.st	OopConservingDictionary.st	LRUCacheDictionary.st	FastTextDisplayScanner.st	kl-UseFastTextDisplayScanner.st	PopUpMenu-addHelp.st	PopUpMenu-usefulStuff.st	Analyst-changeMenuFont.st	XSIS-SpecialMenus.st	Pool.st	Pools-System-Changes.st	AnalystArchitect switchExistingPools.	kl-RemoteFiles.st	DirectoryHierarchy-lists.st	CV4-TextStyleChanges.st	CV4-TextListChanges.st	CV4-DisplayScannerChanges.st	CV4-ParagraphChanges.st	CV4-FormChanges.st	CV4-FormHolderViewChanges.st	CV4-MouseMenuControllerChanges.st	CV4-CompositionScannerChanges.st	CV4-CharacterBlockScannerChanges.st	CV4-CharacterScannerChanges.st	CV4-LinearFitChanges.st	CV4-PointChanges.st250-base1Feature - Final Pass: Reading files - (27 April 1987 6:11:13 pm )AnalystArchitect base1Feature.	RehashBadSets.st		643 bytes. 30 April 1984 1:34:05 pm		SystemDictionary rehashBadSets - add		-7 oops and -82 words	AssociationlessDictionary.st		2993 bytes. 5 March 1987 9:10:10 pm		AssociationlessDictionary - add		73 oops and 2109 words	OopConservingDictionary.st		3775 bytes. 5 March 1987 9:10:47 pm		OopConservingDictionary - add		74 oops and 2134 words	LRUCacheDictionary.st		3863 bytes. 5 March 1987 9:10:29 pm		LRUCacheDictionary - add		44 oops and 2565 words	FastTextDisplayScanner.st		13201 bytes. 5 February 1987 12:48:02 pm		FastTextDisplayScanner - add		1352 oops and 15968 words	kl-UseFastTextDisplayScanner.st		709 bytes. 18 December 1986 5:03:04 pm		String asForm - add		String displayAt: - change		String displayOn:at: - change		36 oops and 2022 words	PopUpMenu-addHelp.st		8403 bytes. 5 February 1987 1:31:53 pm		PopUpMenu class initialize - add		PopUpMenu doHelp:with: - add		PopUpMenu helpFor:on: - add		PopUpMenu labels:font:lines: - change		PopUpMenu manageMarker - change		PopUpMenu pullOutHelps: - add		PopUpMenu removeTrailingCR: - add		PopUpMenu showHelp - add		PopUpMenu startUp: - change		PopUpMenu startUp:withHeading: - change		PopUpMenu startUpAndWaitForSelectionAt: - change		PopUpMenu unDisplayHelp: - add		140 oops and 4543 words	PopUpMenu-usefulStuff.st		2860 bytes. 5 February 1987 1:34:34 pm		PopUpMenu child - add		PopUpMenu class on: - add		PopUpMenu class on:title: - add		PopUpMenu font: - add		PopUpMenu markerOn: - change		PopUpMenu rescan - change		PopUpMenu selectionIndex: - add		PopUpMenu storeOn: - add		64 oops and 2091 words	Analyst-changeMenuFont.st		274 bytes. 5 February 1987 1:33:05 pm		PopUpMenu class labels:lines: - change		23 oops and 686 words	XSIS-SpecialMenus.st		41175 bytes. 2 April 1987 8:33:12 pm		FakeCollection - add		NonprogrammerMenu - add		NonprogrammerMessages - add		RemoteMenuController - add		ScrollMenu - add		TreeMenu - add		1102 oops and 27249 words	Pool.st		3297 bytes. 7 March 1987 6:00:26 pm		Pool - add		90 oops and 3380 words	Pools-System-Changes.st		5433 bytes. 24 March 1987 3:56:17 pm		ChangeSet fileOutClassChanges:on: - change		ClassDescription allPoolRefsIn: - add		ClassDescription fileOutCategory:on:moveSource:toFile: - change		ClassDescription fileOutChangedMessages:on:moveSource:toFile: - change		ClassDescription fileOutMessage:on:moveSource:toFile: - change		ClassDescription fileOutOn:moveSource:toFile: - change		ClassDescription printPoolChunks:on: - add		ClassDescription printSharedPoolChunk:on: - add		Metaclass sharedPools - add		39 oops and 4583 words	AnalystArchitect switchExistingPools.		5 oops and 91 words	kl-RemoteFiles.st		6946 bytes. 29 July 1986 1:05:11 pm		DirectoryHierarchy - add		FileStream class findDirectoryForFileNamed:andEvaluateThisBlock: - add		FileStream class getFileName:list: - add		FileStream class getNamesOfDirectoriesContaining:list: - add		FileStream class getNewFileName:list: - add		FileStream class getOldFileName:list: - add		FileStream class isRoot: - add		FileStream class openFile:list: - add		FileStream class openNewFile:list: - add		FileStream class openOldFile:list: - add		FileStream class trivialFullName:list: - add		FileStream class tryToGetFileNameFrom:list: - add		Object class getFileName: - add		Object class getNewFileName: - add		Object class getOldFileName: - add		Object class listOfFileDirectories - add		Object class openFile: - add		Object class openNewFile: - add		Object class openOldFile: - add		Object getFileName: - add		Object getNewFileName: - add		Object getOldFileName: - add		Object openFile: - add		Object openNewFile: - add		Object openOldFile: - add		188 oops and 6075 words	DirectoryHierarchy-lists.st		982 bytes. 9 February 1985 8:57:27 pm		DirectoryHierarchy AnnotationModel - add		DirectoryHierarchy ContainerModel - add		DirectoryHierarchy ImageEditor - add		DirectoryHierarchy KeyFileList - add		DirectoryHierarchy MapEditor - add		DirectoryHierarchy Object - change		DirectoryHierarchy OutlineView - add		69 oops and 1669 words	CV4-TextStyleChanges.st		3567 bytes. 21 July 1986 4:34:44 pm		Text emphasisAt: - change		TextStyle alignment: - change		TextStyle baseline - change		TextStyle class getNumForStrikeFont: - add		TextStyle fontAt: - change		TextStyle lineGrid - change		TextStyle marginTabAt:side: - change		TextStyle nextTabXFrom:leftMargin:rightMargin: - change		TextStyle outputMedium: - change		TextStyle pressScale - add		TextStyle tabsArray - add		TextStyle tabWidth - change		92 oops and 2873 words	CV4-TextListChanges.st		1086 bytes. 8 February 1985 6:00:54 pm		TextList class initializeWithFontAt: - add		TextList leftMarginForCompositionForLine: - add		-1 oops and 380 words	CV4-DisplayScannerChanges.st		15158 bytes. 21 July 1986 4:30:39 pm		DisplayScanner - change		DisplayScanner checkEmphasis - change		DisplayScanner cr - change		DisplayScanner crossedX - change		DisplayScanner displayLines:in:clippedBy: - change		DisplayScanner doesDisplaying - change		DisplayScanner endOfRun - change		DisplayScanner fontAscentDelta - change		DisplayScanner lineY - add		DisplayScanner onePixelBackspace - change		DisplayScanner onePixelSpace - change		DisplayScanner paddedSpace - change		DisplayScanner pressTabOrSpace - add		DisplayScanner setStopConditions - change		DisplayScanner tab - change		539 oops and 15429 words	CV4-ParagraphChanges.st		14296 bytes. 21 July 1986 4:33:16 pm		Paragraph asForm - change		Paragraph asPressParagraph - add		Paragraph asPrinterWidthsParagraph - add		Paragraph class examplePrinterWidths - add		Paragraph class forPressWithText:style:compositionRectangle: - add		Paragraph class withText:style: - change		Paragraph class withText:style:compositionRectangle:clippingRectangle: - change		Paragraph extendSelection:to:using: - add		Paragraph leftMarginForCompositionForLine: - change		Paragraph leftMarginForCompositionForStartIndex: - add		Paragraph leftMarginForCompositionIfFirst: - add		Paragraph leftMarginForDisplayForLine: - change		Paragraph mouseSelect:to: - change		Paragraph newPage: - add		Paragraph newPage:in: - add		Paragraph outputMedium - change		Paragraph pressFile - add		Paragraph pressOn: - add		Paragraph recomposeIn:clippingBox: - change		Paragraph rightMarginForComposition - change		Paragraph rightMarginForDisplay - change		Paragraph updateCompositionHeight - change		Paragraph visibleRectangle - change		229 oops and 13807 words	CV4-FormChanges.st		8367 bytes. 13 November 1986 9:46:43 pm		Form class - change		Form class initializeMasks - change		Form class readAISFile: - add		Form class screen - add		Form class setScreenMask: - add		Form computeBoundingBox - change		Form edit - change		Form editAt: - change		Form fill:rule:mask: - change		Form hardcopy - add		Form hardcopyOnFileNamed: - add		Form hardcopyOnFileNamed:scale:landscape: - add		Form isAllWhite - change		Form valueAt:put: - change"!logOf250xbase1FeaturePart02"		Form writeCAIS: - add		773 oops and 60933 words	CV4-FormHolderViewChanges.st		179 bytes. 21 February 1985 6:48:54 pm		FormHolderView updateRequest - add		25 oops and 695 words	CV4-MouseMenuControllerChanges.st		2716 bytes. 17 December 1986 5:46:44 pm		MouseMenuController blueButtonActivity - change		MouseMenuController getLastSelectionIn: - add		MouseMenuController performBlueSelections - add		MouseMenuController performTreeBackwards: - add		MouseMenuController performYellowSelections - add		MouseMenuController redButtonActivity - change		MouseMenuController yellowButtonActivity - change		68 oops and 2598 words	CV4-CompositionScannerChanges.st		4975 bytes. 8 April 1985 3:30:35 pm		CompositionScanner composeLine:fromCharacterIndex:inParagraph: - change		CompositionScanner crossedX - change		CompositionScanner onePixelBackspace - change		CompositionScanner onePixelSpace - change		CompositionScanner resetFont - change		CompositionScanner rightX - change		CompositionScanner setStopConditions - change		49 oops and 3590 words	CV4-CharacterBlockScannerChanges.st		5282 bytes. 27 March 1985 2:07:29 pm		CharacterBlockScanner buildCharacterBlockIn: - change		CharacterBlockScanner characterBlockAtPoint:in: - change		CharacterBlockScanner characterBlockForIndex:in: - change		CharacterBlockScanner onePixelBackspace - change		CharacterBlockScanner onePixelSpace - change		CharacterBlockScanner setStopConditions - change		36 oops and 2448 words	CV4-CharacterScannerChanges.st		4000 bytes. 21 July 1986 4:27:12 pm		CharacterScanner characterNotInFont - change		CharacterScanner scanPrinterCharactersFrom:to:in:rightX:stopConditions: - add		CharacterScanner scanPrinterWidthsCharactersFrom:to:in:rightX:stopConditions:displaying: - add		37 oops and 2572 words	CV4-LinearFitChanges.st		1179 bytes. 20 July 1984 2:54:36 pm		LinearFit hardcopyOn: - add		LinearFit hardcopyOn:roundEnds: - add		40 oops and 1439 words	CV4-PointChanges.st		763 bytes. 20 July 1984 6:11:29 pm		Point class numbersReverseInit: - add		Point fromPress:value: - add		Point hidePress:complete: - add		Point numbersDo: - add		Point numbersInit: - add		Point numbersReverseDo: - add		Point numbersReverseInit: - add		Point pressCode - add		43 oops and 2061 words250-base1Feature uses 4954 oops and 175106 wordsBefore: oops left = 29705; core left = 872463After: oops left = 24751; core left = 697357((27 April 1987 6:43:20 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf260xbase2FeaturePart01"260-base2Feature - Preliminary Pass: Locating files - (27 April 1987 5:40:27 pm )AnalystArchitect base2Feature.	CV4-SplineChanges.st	CV4-StrikeFontChanges.st	CV4-StringChanges.st	CV4-SystemOrganizerChanges.st	CV4-FileDirectoryChanges.st	XSIS-DataControl.st	CV4-ParaEditor-NonTek.st	CV4-ParagraphEditorChanges.st	CV4-ListView-nonTek.st	CV4-ListViewChanges.st	CV4-ProjectChanges.st	CV4-IntegerChanges.st	CV4-MagnitudeChanges.st	CV4-DateChanges.st	CV4-TimeChanges.st	CV4-TextChanges.st	CV4-WordArrayChanges.st	CV4-ByteArrayChanges.st	CV4-ControlManagerChanges.st	CV4-SHolderControllerChanges.st	CV4-SHolderViewChanges.st	KeepCursorInView.st	CV4-FillInTheBlankChanges.st	CV4-FITBlankControllerChanges.st	CV4-FileModelChanges.st260-base2Feature - Final Pass: Reading files - (27 April 1987 6:45:29 pm )AnalystArchitect base2Feature.	CV4-SplineChanges.st		941 bytes. 20 July 1984 2:58:52 pm		Spline hardcopyOn: - add		Spline hardcopyOn:roundEnds: - add		-5 oops and 339 words	CV4-StrikeFontChanges.st		4335 bytes. 24 March 1987 3:40:04 pm		StrikeFont ascent: - change		StrikeFont asPrinterWidthsFont - add		StrikeFont charsInString:fitting: - add		StrikeFont descent: - add		StrikeFont glyphs: - change		StrikeFont isRemote - add		StrikeFont maxWidth: - add		StrikeFont newFromStrike: - change		StrikeFont raster: - add		StrikeFont setStopConditions - add		StrikeFont storeOn: - add		StrikeFont strikeFont - add		StrikeFont strikeLength - add		StrikeFont type - add		StrikeFont widthOfString: - add		StrikeFont xOffset - add		StrikeFont xTable: - add		116 oops and 4403 words	CV4-StringChanges.st		3585 bytes. 7 April 1987 6:55:59 pm		String acronym - add		String findBackwardString:startingAt: - add		String isNumeric - add		String openFile - add		String openNewFile - add		String openOldFile - add		String paddedToWidth:inStyle:font: - add		String specialReplaceFrom:to:with:startingAt: - change		String stripLeadingAndTrailingSpaces - add		String stripLeadingSpaces - add		71 oops and 2627 words	CV4-SystemOrganizerChanges.st		303 bytes. 5 February 1987 9:12:07 pm		SystemOrganizer fileOutCategory: - change		22 oops and 628 words	CV4-FileDirectoryChanges.st		3287 bytes. 24 April 1987 12:34:45 pm		FileDirectory copy:to: - add		FileDirectory findFiles:inList:inclusive:addTo: - add		FileDirectory makeNewFileName:withSuffix: - add		FileDirectory renameKey:newName: - add		62 oops and 3385 words	XSIS-DataControl.st		33841 bytes. 10 April 1987 5:58:39 pm		ClipBuffer - add		ClipEntry - add		DataControl - add		557 oops and 17871 words	CV4-ParaEditor-NonTek.st		2094 bytes. 11 April 1987 4:46:25 pm		ParagraphEditor - change		ParagraphEditor class initialize - change		ParagraphEditor cr: - add		ParagraphEditor tab: - add		-3 oops and 860 words	CV4-ParagraphEditorChanges.st		13164 bytes. 3 April 1987 9:25:57 pm		ParagraphEditor again - change		ParagraphEditor class copyText: - add		ParagraphEditor class fontSubMenu - add		ParagraphEditor class initFontMenu - add		ParagraphEditor closeTypeIn - change		ParagraphEditor copySelection - change		ParagraphEditor copySelection: - change		ParagraphEditor cut - change		ParagraphEditor cut: - change		ParagraphEditor fileIt - add		ParagraphEditor findIt - add		ParagraphEditor findOnceAndReplace:with: - add		ParagraphEditor findOrReplace - add		ParagraphEditor fontIt - add		ParagraphEditor hardcopy - add		ParagraphEditor initialText - add		ParagraphEditor maxCanPaste - add		ParagraphEditor paste - change		ParagraphEditor pasteInfoText: - add		ParagraphEditor put - add		ParagraphEditor scrollRectangleHeight - change		ParagraphEditor scrollView: - change		ParagraphEditor selectCurrentTypeIn: - change		ParagraphEditor sometimesCloseTypeIn - add		ParagraphEditor stripCarraigeReturns - add		ParagraphEditor timeStamp - add		PositionableStream peekForMore: - add		717 oops and 13400 words	CV4-ListView-nonTek.st		277 bytes. 30 July 1986 9:15:14 pm		ListView - change		199 oops and 4983 words	CV4-ListViewChanges.st		3541 bytes. 30 July 1986 9:15:29 pm		ListView deselect - change		ListView displaySelectionBox - change		ListView findSelection: - change		ListView insideSelectionBox - add		ListView list: - change		ListView listTitle: - add		ListView minimumSelection - change		ListView selectionBox - change		ListView topDelimiter: - change		93 oops and 2824 words	CV4-ProjectChanges.st		649 bytes. 20 July 1984 3:52:04 pm		Project - change		Project class initialize - change		Project class top - add		Project projectWindows - add		6 oops and 33 words	CV4-IntegerChanges.st		917 bytes. 5 March 1985 10:34:57 pm		Integer printOn:base:minimumDigits: - add		Integer printOn:base:minimumDigits:fillWith: - add		Integer printStringRadix:minimumDigits:fillWith: - add		30 oops and 721 words	CV4-MagnitudeChanges.st		1719 bytes. 20 July 1984 4:01:40 pm		Magnitude - reorganize		Magnitude printFormat: - add		Magnitude printOn:format: - add		38 oops and 1605 words	CV4-DateChanges.st		268 bytes. 20 July 1984 4:05:31 pm		Date printFormat: - remove		Date printOn: - change		Date printOn:format: - remove		13 oops and 375 words	CV4-TimeChanges.st		450 bytes. 20 July 1984 4:06:57 pm		Time printOn: - change		19 oops and 464 words	CV4-TextChanges.st		383 bytes. 18 September 1986 10:30:35 pm		Text findBackwardString:startingAt: - add		Text sameAs: - add		28 oops and 742 words	CV4-WordArrayChanges.st		2522 bytes. 28 April 1986 12:21:09 pm		WordArray fromFileStream: - change		WordArray specialReplaceFrom:to:with:startingAt: - change		WordArray toFileStream: - change		0 oops and 1058 words	CV4-ByteArrayChanges.st		1123 bytes. 28 April 1986 12:22:31 pm		ByteArray specialReplaceFrom:to:with:startingAt: - change		22 oops and 1220 words	CV4-ControlManagerChanges.st		2306 bytes. 20 July 1984 6:48:50 pm		ControlManager backgroundColor: - add		ControlManager bailOut - add		ControlManager collapse - add		ControlManager initialize - change		52 oops and 2186 words	CV4-SHolderControllerChanges.st		1624 bytes. 17 December 1986 5:27:42 pm		StringHolderController class initialize - change		StringHolderController fontIt - add		StringHolderController initialize - change		StringHolderController initializeYellowButtonMenu - change		StringHolderController put:in: - add		73 oops and 14314 words	CV4-SHolderViewChanges.st		260 bytes. 26 February 1985 12:00:23 pm		StringHolderView updateRequest - change		23 oops and 703 words	KeepCursorInView.st		717 bytes. 9 February 1987 2:39:44 pm		BinaryChoiceController isControlActive - change		Controller keepCursorIn: - add		Controller keepCursorInView - add		43 oops and 1077 words	CV4-FillInTheBlankChanges.st		890 bytes. 26 February 1987 11:58:21 pm		FillInTheBlank class request:default: - add		FillInTheBlankView editString:linegrid:baseline: - add		33 oops and 869 words	CV4-FITBlankControllerChanges.st		1969 bytes. 11 April 1987 4:55:02 pm		CRFillInTheBlankController - reorganize		CRFillInTheBlankController cr: - change		CRFillInTheBlankController readKeyboard - remove		FillInTheBlankController - change		FillInTheBlankController - reorganize		FillInTheBlankController bailOut - add		FillInTheBlankController class - reorganize		FillInTheBlankController class initialize - add		FillInTheBlankController initializeYellowButtonMenu - add		85 oops and 2642 words	CV4-FileModelChanges.st		1005 bytes. 28 July 1984 12:55:44 pm		FileModel put: - add		FileModel textMenu - change		38 oops and 1431 words260-base2Feature uses 2043 oops and 71399 wordsBefore: oops left = 28504; core left = 848561After: oops left = 26461; core left = 777162((27 April 1987 7:04:48 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf270xbase3FeaturePart01"270-base3Feature - Preliminary Pass: Locating files - (27 April 1987 5:41:15 pm )AnalystArchitect base3Feature.	CV4-OrderedCollectionChanges.st	CV4-NumberChanges.st	CV4-ProjectControllerChanges.st	CV4-ObjectChanges.st	CV4-BinaryChoiceChanges.st	CV4-BinaryChoiceViewChanges.st	CV4-BitEditorChanges.st	CV4-RemoveFormEditor.st	CV4-FileListChanges.st	CV4-UserProfileChanges.st	CV4-ActionMenuChanges.st	CV4-ClassOrganizerChanges.st	CV4-ParserChanges.st	CV4-BrowserChanges.st	CV4-CListControllerChanges.st	CV4-DebuggerChanges.st	CV4-NotifierControllerChanges.st	CV4-InspectorChanges.st	CV4-DictionaryInspectorChanges.st	CV4-EncoderChanges.st	CV4-SyntaxErrorChanges.st270-base3Feature - Final Pass: Reading files - (27 April 1987 7:07:31 pm )AnalystArchitect base3Feature.	CV4-OrderedCollectionChanges.st		1137 bytes. 4 September 1984 2:56:10 pm		OrderedCollection add:atIndex: - add		OrderedCollection realIndexFrom: - add		OrderedCollection removeObjectAt: - add		44 oops and 1305 words	CV4-NumberChanges.st		858 bytes. 20 July 1984 6:24:40 pm		Number class readNumberFrom: - add		37 oops and 1148 words	CV4-ProjectControllerChanges.st		516 bytes. 27 July 1984 5:18:06 pm		ProjectController class initialize - change		23 oops and 903 words	CV4-ObjectChanges.st		2219 bytes. 10 April 1987 6:03:00 pm		Object booboo: - add		Object class createAnalystDataItem: - add		Object confirm: - change		Object confirm:yesLabel:noLabel: - add		26 oops and 2488 words	CV4-BinaryChoiceChanges.st		1967 bytes. 1 November 1986 6:46:39 pm		BinaryChoice class myMessage:displayAt:centered:ifTrue:ifFalse: - add		BinaryChoice class myMessage:displayAt:centered:yesLabel:noLabel:ifTrue:ifFalse: - add		BinaryChoiceController centerCursorInView - change		47 oops and 1851 words	CV4-BinaryChoiceViewChanges.st		4660 bytes. 23 July 1984 11:55:18 am		BinaryChoiceView class buildSingleSwitchFor:width: - add		BinaryChoiceView class buildSwitchesFor:width:yesLabel:noLabel: - add		BinaryChoiceView class openBooBooOn:message:displayAt:centered: - add		BinaryChoiceView class openBooBooOn:message:displayAt:centered:yesLabel:noLabel: - add		120 oops and 3289 words	CV4-BitEditorChanges.st		3613 bytes. 13 June 1986 1:26:47 pm		BitEditor class bitEdit:at:scale:remoteView: - change		BitEditor class buildColorMenu:colorCount: - remove		BitEditor class initialize - change		BitEditor controlActivity - change		BitEditor isControlActive - change		104 oops and 2801 words	CV4-RemoveFormEditor.st		478 bytes. 12 April 1987 9:00:36 pm		FormButtonCache - remove		FormEditor - remove		FormMenuController - remove		FormMenuView - remove		FormView defaultControllerClass - remove		-332 oops and -5290 words	CV4-FileListChanges.st		2117 bytes. 28 July 1984 12:58:32 pm		FileList acceptPattern:from: - change		FileList fileListMenu - change		FileList patternMenu - change		72 oops and 3736 words	CV4-UserProfileChanges.st		8173 bytes. 31 July 1986 10:09:08 pm		UserProfile - change		UserProfile - reorganize		UserProfile addFileServer: - add		UserProfile addPrinter: - add		UserProfile class initialize - add		UserProfile class selectPrinter: - remove		UserProfile clearItAll - add		UserProfile connect - change		UserProfile connect: - change		UserProfile connectName - change		UserProfile connectPassword - change		UserProfile domain - add		UserProfile domain:organization: - add		UserProfile fileServerChoices - add		UserProfile login - change		UserProfile organization - add		UserProfile printerChoices - add		UserProfile selectFileServer - add		UserProfile selectPrinter - add		UserProfile userName: - change		UserProfile userPassword - change		UserProfile userPassword: - add		UserProfile userRName - change		137 oops and 4969 words	CV4-ActionMenuChanges.st		326 bytes. 3 October 1986 12:39:47 pm		ActionMenu selectors - add		ActionMenu storeOn: - add		24 oops and 659 words	CV4-ClassOrganizerChanges.st		680 bytes. 31 July 1984 3:10:36 pm		ClassOrganizer putCommentOnFile:numbered:moveSource: - change		22 oops and 554 words	CV4-ParserChanges.st		1443 bytes. 5 February 1987 9:19:18 pm		Parser makeNewSymbol:startingAt: - change		65 oops and 1616 words	CV4-BrowserChanges.st		4071 bytes. 28 July 1984 12:51:24 pm		Browser categoryMenu - change		Browser classMenu - change		Browser protocolMenu - change		Browser selectorMenu - change		Browser textMenu - change		41 oops and 4933 words	CV4-CListControllerChanges.st		1275 bytes. 28 July 1984 1:04:20 pm		ChangeListController class initialize - change		-21 oops and 2295 words	CV4-DebuggerChanges.st		983 bytes. 28 July 1984 1:09:36 pm		Debugger contextMenu - change		26 oops and 1534 words	CV4-NotifierControllerChanges.st		511 bytes. 28 July 1984 1:11:42 pm		NotifierController model: - change		29 oops and 1055 words	CV4-InspectorChanges.st		431 bytes. 28 July 1984 1:15:27 pm		Inspector textMenu - change		29 oops and 921 words	CV4-DictionaryInspectorChanges.st		605 bytes. 28 July 1984 1:17:12 pm		DictionaryInspector fieldMenu - change		28 oops and 1095 words	CV4-EncoderChanges.st		891 bytes. 30 July 1984 2:04:56 pm		Encoder undeclared: - change		36 oops and 1347 words	CV4-SyntaxErrorChanges.st		459 bytes. 28 July 1984 1:22:45 pm		SyntaxError textMenu - change		-32 oops and -185 words270-base3Feature uses 345 oops and 26165 wordsBefore: oops left = 27741; core left = 805858After: oops left = 27396; core left = 779693((27 April 1987 7:17:32 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf280xscreenControllerFeaturePart01"280-screenControllerFeature - Preliminary Pass: Locating files - (27 April 1987 5:42:05 pm )AnalystArchitect screenControllerFeature.	CV4-ScreenControllerSmalltalk.st	CV4-ScreenControllerChanges.st280-screenControllerFeature - Final Pass: Reading files - (27 April 1987 7:19:50 pm )AnalystArchitect screenControllerFeature.	CV4-ScreenControllerSmalltalk.st		4473 bytes. 3 April 1987 9:34:06 pm		ScreenController browseRecover - add		ScreenController class initializeSmalltalkSubmenu - add		ScreenController connect - add		ScreenController crashRecover - add		ScreenController defer - change		ScreenController fileOutChanges - add		ScreenController fileServer - add		ScreenController inspectChanges - add		ScreenController noChanges - add		ScreenController openBrowser - change		ScreenController openChangeList - add		ScreenController openFileList - change		ScreenController openSystemWorkspace - change		ScreenController openTranscript - change		ScreenController openWorkspace - change		ScreenController openWorkspaceOnFile - add		ScreenController printEntireScreen - add		ScreenController printFramedArea - add		ScreenController quit - change		ScreenController releaseExternalViews - add		ScreenController remoteLogin - add		ScreenController saveThenQuit - add		99 oops and 5946 words	CV4-ScreenControllerChanges.st		6695 bytes. 3 April 1987 9:47:16 pm		ScreenController - change		ScreenController class initialize - change		ScreenController class initializeBlueButtonMenu - add		ScreenController class initializeYellowButtonMenu - add		ScreenController collapseDisplay - add		ScreenController findOne - add		ScreenController garbageCollect - add		ScreenController initialize - change		ScreenController initializeBlueButtonMenu - add		ScreenController isControlActive - change		ScreenController isControlWanted - change		ScreenController request:for:default: - add		ScreenController restoreDisplay - change		ScreenController selectAndClose - add		ScreenController showCoreAndOopsLeft - add		ScreenController showDateAndTime - add		ScreenController showDiskSpace - add		ScreenController showResources - add		359 oops and 14412 words280-screenControllerFeature uses 445 oops and 19708 wordsBefore: oops left = 27947; core left = 825207After: oops left = 27502; core left = 805499((27 April 1987 7:23:48 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf290xbase4FeaturePart01"290-base4Feature - Preliminary Pass: Locating files - (27 April 1987 5:42:18 pm )AnalystArchitect base4Feature.	CV4-GraphicsPathsChanges.st	XSIS-Paths.st	XSIS-ImageEditor.st	CursorChanges.st	ScrollBarChanges.st	CV4-DisplayScreenChanges.st	CV4-RectangleChanges.st	CV4-StandardSystemView-nonTek.st	CV4-StandardSystemViewChanges.st	CV4-SSControllerChanges.st	ClassifiedStandardSystemController.st	SysWindows-patches-nonTek.st	FastLists.st	CV4-FileStream-Printing-changes.st	XSIS-SpecialFileStreams.st	FormChangesForHeaderStreams.st	kl-FormsStrikeFont.st	kl-FormsStrikeFont-nonTek4407.st	SortedCollection-JS-HeapSort.st	Signal-mm.st	kl-SignalVersionCompatibility.st	XSIS-Big-Paragraphs.st	Big-Paragraphs-useThem-changes.st290-base4Feature - Final Pass: Reading files - (27 April 1987 7:25:58 pm )AnalystArchitect base4Feature.	CV4-GraphicsPathsChanges.st		1081 bytes. 26 October 1984 9:44:44 am		Spline displayOn:at:clippingBox:rule:mask: - change		31 oops and 1222 words	XSIS-Paths.st		5776 bytes. 10 February 1987 7:37:04 pm		NewArc - add		NewCircle - add		366 oops and 4805 words	XSIS-ImageEditor.st		51102 bytes. 21 April 1987 10:01:52 pm		ImageEditor - add		ImageEditorTextCollector - add		1207 oops and 41501 words	CursorChanges.st		8051 bytes. 30 April 1986 8:28:53 pm		Cursor - change		Cursor class bottomLeft - add		Cursor class garbage - add		Cursor class grabBar - add		Cursor class initialize - change		Cursor class mouse - add		Cursor class topRight - add		106 oops and 11352 words	ScrollBarChanges.st		5875 bytes. 3 April 1987 10:21:03 pm		Cursor - change			Conflicts with ('CursorChanges.st' )		Cursor class myInitialize - add		Cursor class upDown - add		ListController computeMarkerRegion - change		ListView findSelection: - change			Conflicts with ('CV4-ListViewChanges.st' )		ParagraphEditor computeMarkerRegion - change		ScrollController controlInitialize - change		ScrollController initialize - change		ScrollController scroll - change		ScrollController scrollDown - change		ScrollController scrollUp - change		132 oops and 4029 words	CV4-DisplayScreenChanges.st		2334 bytes. 8 December 1986 4:56:35 pm		DisplayScreen outline:while:width:halftone: - add		DisplayScreen zoom:to:speed: - add		312 oops and 3967 words	CV4-RectangleChanges.st		6651 bytes. 18 September 1986 10:27:51 pm		Rectangle class fromUser: - change		Rectangle class fromUser:gridOrigin: - add		Rectangle class fromUser:gridOrigin:withExtent: - add		Rectangle class fromUserAspectRatio: - change		Rectangle class fromUserAtVertex:withExtent: - add		Rectangle class fromUserMinExtent:maxExtent:outlineColor: - add		Rectangle class fromUserWithExtent: - add		Rectangle class fromUserWithReduceFromMax: - add		Rectangle class numbersReverseInit: - add		Rectangle class pointsInit: - add		Rectangle numbersDo: - add		Rectangle numbersInit: - add		Rectangle numbersReverseDo: - add		Rectangle numbersReverseInit: - add		Rectangle pointsDo: - add		Rectangle pointsInit: - add		Rectangle userChangeCornerMinExtent:maxExtent:grid:gridOrigin:outlineColor: - add		116 oops and 6717 words	CV4-StandardSystemView-nonTek.st		416 bytes. 30 July 1986 9:24:40 pm		StandardSystemView - change		125 oops and 5551 words	CV4-StandardSystemViewChanges.st		11623 bytes. 8 December 1986 4:59:58 pm		StandardSystemView accept - add		StandardSystemView cancel - add		StandardSystemView changeClassification: - add		StandardSystemView class labelTag - add		StandardSystemView class labelTag: - add		StandardSystemView class model:label:minimumSize:helpIndex: - add		StandardSystemView classifyLabel - add		StandardSystemView classifyLabel: - add		StandardSystemView collapse - change		StandardSystemView containsPoint: - change		StandardSystemView deEmphasizeView - change		StandardSystemView displayBorder - add		StandardSystemView displayClassification - add		StandardSystemView displayTextReverse - add		StandardSystemView displayView - change		StandardSystemView erase - change		StandardSystemView expand - change		StandardSystemView expand2 - add		StandardSystemView getFrame - change		StandardSystemView helpIndex - add		StandardSystemView helpIndex: - add		StandardSystemView label: - change		StandardSystemView labelDisplayBox - change		StandardSystemView lastFullFrame - add		StandardSystemView lastLabelLocation - add		StandardSystemView lastLabelLocation: - add		StandardSystemView minimumSize: - change		StandardSystemView nearestVertexTo: - add		StandardSystemView release - change		StandardSystemView resize - change		StandardSystemView restoreFullView - add		StandardSystemView suitcase - add		231 oops and 6059 words	CV4-SSControllerChanges.st		7694 bytes. 2 April 1987 9:02:25 pm		StandardSystemController - change		StandardSystemController blueButtonActivity - add		StandardSystemController class initialize - change		StandardSystemController close - change		StandardSystemController closeAndUnschedule - change		StandardSystemController collapse - change		StandardSystemController controlTerminate - change		StandardSystemController expand - change		StandardSystemController findOne - add		StandardSystemController frame - add		StandardSystemController getLinks - add		StandardSystemController help - add		StandardSystemController move - change		StandardSystemController restoreFullView - add		StandardSystemController smashOne - add		StandardSystemController smashThem - add		113 oops and 7642 words	ClassifiedStandardSystemController.st		2032 bytes. 31 January 1987 8:02:51 pm		ClassifiedStandardSystemController - add		77 oops and 3769 words	SysWindows-patches-nonTek.st		994 bytes. 6 May 1986 12:30:52 pm		StandardSystemController collapse - change			Conflicts with ('CV4-SSControllerChanges.st' )		StandardSystemController expand - change			Conflicts with ('CV4-SSControllerChanges.st' )		StandardSystemController open - change		33 oops and 1001 words	FastLists.st		8156 bytes. 21 July 1986 4:25:25 pm		FastTextList - add		ListView list: - change			Conflicts with ('CV4-ListViewChanges.st' )		178 oops and 5851 words	CV4-FileStream-Printing-changes.st		811 bytes. 28 April 1986 9:27:19 pm		FileStream asPressPrinter - add		FileStream sendEFTP: - add		FileStream sendEFTPtoPrinter:numOfCopies:numTries:sendMsgsTo: - add		FileStream toPrinter:numOfCopies:numTries:sendMsgsTo: - add		4 oops and 3247 words	XSIS-SpecialFileStreams.st		28095 bytes. 10 April 1987 5:57:18 pm		EncryptedFileStream - add		HeaderFileStream - add		MixedFileStream - add		510 oops and 16158 words	FormChangesForHeaderStreams.st		2993 bytes. 10 April 1987 6:05:56 pm		Form class readFrom: - change		Form class readFromSuitcase: - add		Form writeAsDataItem: - add		76 oops and 2609 words	kl-FormsStrikeFont.st		2878 bytes. 6 January 1987 7:45:48 pm		FormsStrikeFont - add		669 oops and 5957 words	kl-FormsStrikeFont-nonTek4407.st		2729 bytes. 24 September 1986 2:26:36 pm		Form - change		Form class initializeMasks - change			Conflicts with ('CV4-FormChanges.st' )		Form class masks - add		560 oops and 7185 words	SortedCollection-JS-HeapSort.st		1266 bytes. 27 August 1986 2:09:38 pm		SortedCollection sort:to: - change		37 oops and 1407 words	Signal-mm.st		13331 bytes. 9 February 1987 2:51:02 pm		Object doesNotUnderstand: - change		Object error: - change		Semaphore critical: - change		Signal - add		275 oops and 9312 words	kl-SignalVersionCompatibility.st		1068 bytes. 26 March 1986 7:55:22 pm		Signal resumeWith: - add		Signal unwindAndDo: - add		Signal unwindAndRetry - add		Signal unwindWith: - add		34 oops and 1256 words	XSIS-Big-Paragraphs.st		49041 bytes. 17 December 1986 3:37:43 pm		BigAlwaysAcceptCodeController - add		BigCodeController - add		BigOnlyWhenSelectedCodeController - add		BigParagraph - add		BigParagraphEditor - add		BigStringHolderController - add		BigTextController - add"!logOf290xbase4FeaturePart02"		2417 oops and 81980 words	Big-Paragraphs-useThem-changes.st		3124 bytes. 15 April 1986 8:44:42 pm		ChangeController - change		CodeView defaultControllerClass - change		CodeView update: - change		FileList class open - change		FillInTheBlankView initialize - add		OnlyWhenSelectedCodeView defaultControllerClass - change		StringHolderView defaultControllerClass - change		StringHolderView editString: - change		StringHolderView initialize - change		TextView defaultControllerClass - change		34 oops and 1111 words290-base4Feature uses 7427 oops and 240654 wordsBefore: oops left = 27660; core left = 816491After: oops left = 20233; core left = 575837((27 April 1987 8:07:00 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf300xstripExamplesFeaturePart01"300-stripExamplesFeature - Preliminary Pass: Locating files - (27 April 1987 5:43:04 pm )AnalystArchitect stripExamplesFeature.300-stripExamplesFeature - Final Pass: Reading files - (27 April 1987 8:09:27 pm )AnalystArchitect stripExamplesFeature.300-stripExamplesFeature uses -16 oops and -87 wordsBefore: oops left = 25907; core left = 768840After: oops left = 25923; core left = 768927((27 April 1987 8:10:14 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf330xmachineSpecificFeaturePart01"330-machineSpecificFeature - Preliminary Pass: Locating files - (27 April 1987 5:43:13 pm )AnalystArchitect machineSpecificFeature.	StuffForLaterDV6Merge.st	PilotFile-Stretch-addns.st	LowSpaceGarbageCollect-AB.st	AnalystArchitect pressInit1.	FileStream-NS-Changes.st	SharedObject.st	SharedDeque.st	XSIS-InterfaceXDE.st330-machineSpecificFeature - Final Pass: Reading files - (27 April 1987 8:12:28 pm )AnalystArchitect machineSpecificFeature.	StuffForLaterDV6Merge.st		4223 bytes. 27 April 1987 12:23:24 pm		PilotCalls - comment		PilotFileDirectory - comment		PilotFileStream - comment		SearchPath - comment		SystemDictionary getImagePrefix - change		SystemDictionary versionName - change		28 oops and 4119 words	PilotFile-Stretch-addns.st		2618 bytes. 3 October 1986 12:43:11 pm		PilotFileDirectory copy:to: - add		PilotFileDirectory copyFileNamed:to: - remove		PilotFileDirectory findFiles:inList:inclusive:addTo: - add		PilotFileDirectory makeNewFileName:withSuffix: - add		41 oops and 2148 words	LowSpaceGarbageCollect-AB.st		1467 bytes. 17 April 1987 2:08:46 pm		SystemDictionary lowSpaceNotificationLoop - change		30 oops and 1607 words	AnalystArchitect pressInit1.		5 oops and 44 words	FileStream-NS-Changes.st		796 bytes. 28 April 1986 9:04:40 pm		FileStream toPrinter:numOfCopies:numTries:sendMsgsTo: - change			Conflicts with ('CV4-FileStream-Printing-changes.st' )		36 oops and 1091 words	SharedObject.st		2559 bytes. 10 February 1987 9:03:26 pm		SharedObject - add		71 oops and 2186 words	SharedDeque.st		2515 bytes. 10 February 1987 9:03:12 pm		SharedDeque - add		43 oops and 961 words	XSIS-InterfaceXDE.st		20404 bytes. 10 February 1987 7:35:52 pm		PrintFrom1108 - add		XDEInterfaceController - add		XDEInterfaceModel - add		557 oops and 15592 words330-machineSpecificFeature uses 758 oops and 25636 wordsBefore: oops left = 25910; core left = 768512After: oops left = 25152; core left = 742876((27 April 1987 8:19:41 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf350xcv4FinalRemovalsFeaturePart01"350-cv4FinalRemovalsFeature - Preliminary Pass: Locating files - (27 April 1987 5:43:35 pm )AnalystArchitect cv4FinalRemovalsFeature.	AnalystArchitect cv4FinalRemovals.350-cv4FinalRemovalsFeature - Final Pass: Reading files - (27 April 1987 8:22:02 pm )AnalystArchitect cv4FinalRemovalsFeature.	AnalystArchitect cv4FinalRemovals.		Benchmark - remove		Checker - remove		SystemTracer - remove		-408 oops and -10650 words350-cv4FinalRemovalsFeature uses -410 oops and -10604 wordsBefore: oops left = 25514; core left = 760546After: oops left = 25924; core left = 771150((27 April 1987 8:23:03 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf400xpostBuildPart01"400-postBuild - Preliminary Pass: Locating files - (27 April 1987 5:43:46 pm )AnalystArchitect postBuild.400-postBuild - Final Pass: Reading files - (27 April 1987 8:25:19 pm )AnalystArchitect postBuild.	247 oops and 29317 words400-postBuild uses 254 oops and 29371 wordsBefore: oops left = 25911; core left = 771809After: oops left = 25657; core left = 742438((27 April 1987 8:26:53 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf450xamorphousFeaturePart01"450-amorphousFeature - Preliminary Pass: Locating files - (27 April 1987 5:43:53 pm )AnalystArchitect amorphousFeature.	AnalystArchitect setAnalystGlobals.	XSIS-ConfigFiles.st	Idle.st	ConnectIdle.st	AnalystArchitect setLongIdleTime.		AnalystArchitect idleBalloonFormFeature.		SmalltalkBalloon.form	XSIS-Interface.st	FastUserInterface-use.st	XSIS-Boxes.st	XSIS-Querying.st	XSIS-ControlBox.st	XSIS-LogInOut.st	XSIS-Forms.st	XSIS-Forms-Elements.st	lc-notifier.st	0711-kp-date-time-changes.st	XSIS-Auditor.st	AnalystVersionTracker.st450-amorphousFeature - Final Pass: Reading files - (27 April 1987 8:29:14 pm )AnalystArchitect amorphousFeature.	AnalystArchitect setAnalystGlobals.		4 oops and 42 words	XSIS-ConfigFiles.st		16748 bytes. 28 February 1987 6:49:26 pm		ConfigFile - add		ConfigFileModel - add		EditStringHolder - add		EditStringHolderController - add		663 oops and 12952 words	Idle.st		9898 bytes. 5 March 1987 10:01:15 pm		Idle - add		256 oops and 8329 words	ConnectIdle.st		963 bytes. 15 May 1986 8:25:57 pm		InputState nextEvent:with: - change		28 oops and 1123 words	AnalystArchitect setLongIdleTime.		3 oops and 624 words		AnalystArchitect idleBalloonFormFeature.				AnalystArchitect nilFeature.	XSIS-Interface.st		8604 bytes. 21 April 1987 10:07:20 pm		User - add		UserFillController - add		255 oops and 7009 words	FastUserInterface-use.st		1851 bytes. 5 February 1987 11:21:21 am		FillInTheBlank class request:default: - change			Conflicts with ('CV4-FillInTheBlankChanges.st' )		Object booboo: - change			Conflicts with ('CV4-ObjectChanges.st' )		Object confirm: - change			Conflicts with ('CV4-ObjectChanges.st' )		Object confirm:yesLabel:noLabel: - change			Conflicts with ('CV4-ObjectChanges.st' )		48 oops and 1803 words	XSIS-Boxes.st		43363 bytes. 10 February 1987 6:24:24 pm		BoxController - add		BoxView - add		ConnectedBoxView - add		GrapherController - add		752 oops and 22379 words	XSIS-Querying.st		14401 bytes. 19 January 1987 7:22:34 pm		KeywordQuerier - add		Querier - add		QuerierController - add		QuerierView - add		SimpleQuerier - add		433 oops and 11707 words	XSIS-ControlBox.st		37346 bytes. 11 April 1987 4:57:58 pm		DBox - add		DBoxController - add		DBoxFillController - add		DBoxKeywordFillController - add		DBoxParaFillController - add		DBoxQuerier - add		DBoxQueryController - add		DBoxView - add		753 oops and 26365 words	XSIS-LogInOut.st		15185 bytes. 21 April 1987 9:57:04 pm		LogInOut - add		1053 oops and 14363 words	XSIS-Forms.st		38875 bytes. 11 April 1987 7:15:56 pm		ClickBuffer - add		FormsController - add		FormsEditController - add		FormsFillController - add		FormsModel - add		FormsView - add		LockedFormsController - add		923 oops and 25697 words	XSIS-Forms-Elements.st		38956 bytes. 28 February 1987 6:53:11 pm		ExecuteElement - add		FillElement - add		FormsElement - add		ImageElement - add		ImmediateExecuteElement - add		InfoCenterElement - add		LabelElement - add		OneOfElement - add		SwitchElement - add		781 oops and 19006 words	lc-notifier.st		3232 bytes. 31 July 1986 9:12:20 pm		NotifierView class reportContext: - add		Object doesNotUnderstand: - change			Conflicts with ('Signal-mm.st' )		Object error: - change			Conflicts with ('Signal-mm.st' )		Signal noHandler - change		89 oops and 2786 words	0711-kp-date-time-changes.st		3868 bytes. 25 March 1987 2:46:13 pm		Date < - change		Date class readFrom: - change		Time < - change		Time = - change		Time class readFrom: - change		UnknownDate - add		UnknownTime - add		59 oops and 1903 words	XSIS-Auditor.st		3820 bytes. 10 September 1986 6:02:57 pm		Auditor - add		115 oops and 1436 words	AnalystVersionTracker.st		1189 bytes. 24 April 1987 8:30:05 pm		SystemDictionary addToAnalystVersion: - add		SystemDictionary version - change		39 oops and 2448 words450-amorphousFeature uses 5994 oops and 155002 wordsBefore: oops left = 25958; core left = 760122After: oops left = 19964; core left = 605120((27 April 1987 9:10:55 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf460xAnalystScreenControllerxstPart01"460-AnalystScreenController.st - Preliminary Pass: Locating files - (27 April 1987 5:44:41 pm )AnalystScreenController.st460-AnalystScreenController.st - Final Pass: Reading files - (27 April 1987 9:13:51 pm )AnalystScreenController.st	16043 bytes. 21 April 1987 10:19:01 pm	ScreenController - change		Conflicts with ('CV4-ScreenControllerChanges.st' )	ScreenController accelerateCursorPlace: - add	ScreenController analystVersionInfo - add	ScreenController auditOn - add	ScreenController autoMenuShow: - add	ScreenController backupUser: - add	ScreenController backupUserMenuChoice - add	ScreenController class changeOITMenu - add	ScreenController class initializeBlueButtonMenu - change		Conflicts with ('CV4-ScreenControllerChanges.st' )	ScreenController class initializeOITMenu - add	ScreenController class initializeSystemControlsSubmenu - add	ScreenController class initializeUserProfileSubmenu - add	ScreenController class initializeYellowButtonMenu - change		Conflicts with ('CV4-ScreenControllerChanges.st' )	ScreenController class makeScreenColor:logChange: - add	ScreenController class oitMenu - add	ScreenController clipboardFunction: - add	ScreenController editOIT - add	ScreenController editTimeZonesMenu - add	ScreenController editUsersFile - add	ScreenController idleForm - add	ScreenController idleStart - add	ScreenController isControlWanted - change		Conflicts with ('CV4-ScreenControllerChanges.st' )	ScreenController logOut - add	ScreenController makeNewChartOrGraphicPad - add	ScreenController openAutoBook - add	ScreenController openClock - add	ScreenController openCommandBar - add	ScreenController openDigitalClock - add	ScreenController openInfoCenter - add	ScreenController openOIT - add	ScreenController openTextWindow - add	ScreenController openUserGuide - add	ScreenController openXDECenter - add	ScreenController printAuditor - add	ScreenController printerName - add	ScreenController restoreUserMenuChoice - add	ScreenController screenColor: - add	ScreenController scrollMenuSpeed - add	ScreenController setSystemFont: - add	ScreenController wipeOut - add	815 oops and 40106 words460-AnalystScreenController.st uses 810 oops and 39814 wordsBefore: oops left = 23214; core left = 703276After: oops left = 22404; core left = 663462((27 April 1987 9:18:36 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf480xoopConservingOrganizersFeaturePart01"480-oopConservingOrganizersFeature - Preliminary Pass: Locating files - (27 April 1987 5:44:49 pm )AnalystArchitect oopConservingOrganizersFeature.	kl-OopConservingOrganizers.st	kl-OopConsOrganizers-Pool-patch.st480-oopConservingOrganizersFeature - Final Pass: Reading files - (27 April 1987 9:21:18 pm )AnalystArchitect oopConservingOrganizersFeature.	kl-OopConservingOrganizers.st		15026 bytes. 24 April 1987 9:06:30 pm		Class copy - change		Class copyForValidation - change		Class obsolete - change		Class rename: - change		ClassDescription collapse - add		ClassDescription fileOutOn:moveSource:toFile: - change			Conflicts with ('Pools-System-Changes.st' )		ClassDescription moveChangesTo: - change			Conflicts with ('kl-CondenseChanges-nonPS20.st' )		ClassDescription organization - change		ClassOrganizer - change		ClassOrganizer class rehash - add		ClassOrganizer collapsedForClass:fromFileNumber:toFileNumber:toFile: - add		ClassOrganizer setDefaultList - change		Metaclass copy - change		Metaclass copyForValidation - change		SystemDictionary nilOrganizationsForClasses: - add		825 oops and 15607 words	kl-OopConsOrganizers-Pool-patch.st		1250 bytes. 24 March 1987 10:02:32 pm		ClassDescription fileOutOn:moveSource:toFile: - change			Conflicts with ('Pools-System-Changes.st' 'kl-OopConservingOrganizers.st' )		58 oops and 1050 words480-oopConservingOrganizersFeature uses 801 oops and 14778 wordsBefore: oops left = 22670; core left = 681192After: oops left = 21869; core left = 666414((27 April 1987 9:24:17 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf500xprintingFeaturePart01"500-printingFeature - Preliminary Pass: Locating files - (27 April 1987 5:45:00 pm )AnalystArchitect printingFeature.		AnalystArchitect interpressFeature.		Xerox-NSPrinting.st		AnalystArchitect interpressInit.500-printingFeature - Final Pass: Reading files - (27 April 1987 9:26:54 pm )AnalystArchitect printingFeature.		AnalystArchitect interpressFeature.		Xerox-NSPrinting.st			84458 bytes. 24 March 1987 3:33:18 pm			DisplayPrintFont - add			Interpress - add			PrintFont - add			PrintScanner - add			PrintStyle - add			3344 oops and 81596 words		AnalystArchitect interpressInit.			8 oops and 1513 words500-printingFeature uses 3340 oops and 82860 wordsBefore: oops left = 22686; core left = 681768After: oops left = 19346; core left = 598908((27 April 1987 9:40:32 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf510xbackgroundFeaturePart01"510-backgroundFeature - Preliminary Pass: Locating files - (27 April 1987 5:45:15 pm )AnalystArchitect backgroundFeature.	SharedObject.st	SharedDeque.st	XSIS-Background.st	Background-DelayAndProtect3Changes.st		AnalystArchitect backgroundProtectEtherFeature.				AnalystArchitect nilFeature.510-backgroundFeature - Final Pass: Reading files - (27 April 1987 9:43:19 pm )AnalystArchitect backgroundFeature.	SharedObject.st - skipping: Encountered earlier.	SharedDeque.st - skipping: Encountered earlier.	XSIS-Background.st		43107 bytes. 31 January 1987 8:00:14 pm		BackgroundController - add		BackgroundPrinter - add		743 oops and 25761 words	Background-DelayAndProtect3Changes.st		3970 bytes. 7 May 1986 12:46:15 pm		Controller controlLoop - change		ControlManager searchForActiveController - change		ControlManager suicideLeapInto: - add		InputState keyAt:put: - change		Paragraph class usingPrinterWidthsText: - add		62 oops and 2694 words		AnalystArchitect backgroundProtectEtherFeature.				AnalystArchitect nilFeature - skipping: Encountered earlier.510-backgroundFeature uses 790 oops and 28316 wordsBefore: oops left = 21025; core left = 654700After: oops left = 20235; core left = 626384((27 April 1987 9:51:05 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf520xXSISxHelpxstPart01"520-XSIS-Help.st - Preliminary Pass: Locating files - (27 April 1987 5:45:34 pm )XSIS-Help.st520-XSIS-Help.st - Final Pass: Reading files - (27 April 1987 9:53:50 pm )XSIS-Help.st	2510 bytes. 28 February 1987 6:54:54 pm	Helper - add	115 oops and 2854 words520-XSIS-Help.st uses 114 oops and 2603 wordsBefore: oops left = 20539; core left = 645191After: oops left = 20425; core left = 642588((27 April 1987 9:55:15 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf530xinfoCenterFeaturePart01"530-infoCenterFeature - Preliminary Pass: Locating files - (27 April 1987 5:45:42 pm )AnalystArchitect infoCenterFeature.	XSIS-Boxes.st	XSIS-Querying.st	XSIS-ControlBox.st	XSIS-Matrices.st	ClassifiedStringHolderController.st	XSIS-Classification.st	XSIS-Suitcase.st	XSIS-InfoCenter.st	InfoCenter-Structure.st	InfoCenter-Graph.st530-infoCenterFeature - Final Pass: Reading files - (27 April 1987 9:57:55 pm )AnalystArchitect infoCenterFeature.	XSIS-Boxes.st - skipping: Encountered earlier.	XSIS-Querying.st - skipping: Encountered earlier.	XSIS-ControlBox.st - skipping: Encountered earlier.	XSIS-Matrices.st		34318 bytes. 29 January 1987 12:04:06 pm		AdjacencyMatrix - add		Matrix - add		SparseMatrix - add		490 oops and 20192 words	ClassifiedStringHolderController.st		2419 bytes. 17 December 1986 3:39:27 pm		ClassifiedStringHolderController - add		40 oops and 3483 words	XSIS-Classification.st		54867 bytes. 10 April 1987 5:51:11 pm		Classification - add		ClassificationScheme - add		DataItem - add		DataItemPointer - add		1928 oops and 32137 words	XSIS-Suitcase.st		3097 bytes. 31 July 1986 7:39:08 pm		Suitcase - add		90 oops and 1843 words	XSIS-InfoCenter.st		173965 bytes. 17 April 1987 10:07:53 am		ContainerListController - add		ContainerListView - add		ContainerModel - add		InformationCenter - add		4803 oops and 135765 words	InfoCenter-Structure.st		4952 bytes. 26 March 1986 8:29:40 pm		StructureController - add		StructureParagraph - add		StructureView - add		52 oops and 2936 words	InfoCenter-Graph.st		31000 bytes. 28 February 1987 7:02:42 pm		ICGStandardSystemController - add		InfoCenterGraphController - add		InfoCenterGraphView - add		2081 oops and 33279 words530-infoCenterFeature uses 9417 oops and 226689 wordsBefore: oops left = 20450; core left = 643987After: oops left = 11033; core left = 417298((27 April 1987 10:41:23 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf540xXSISxFileModelxstPart01"540-XSIS-FileModel.st - Preliminary Pass: Locating files - (27 April 1987 5:46:07 pm )XSIS-FileModel.st540-XSIS-FileModel.st - Final Pass: Reading files - (27 April 1987 10:44:39 pm )XSIS-FileModel.st	51718 bytes. 10 April 1987 5:53:50 pm	AnnotationController - add	AnnotationModel - add	BioController - add	ComposeSystemController - add	ComposeTextController - add	FileStringHolder - add	KeyFileList - add	1200 oops and 34226 words540-XSIS-FileModel.st uses 1191 oops and 33921 wordsBefore: oops left = 18129; core left = 576846After: oops left = 16938; core left = 542925((27 April 1987 10:53:30 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf550xchartWindowFeaturePart01"550-chartWindowFeature - Preliminary Pass: Locating files - (27 April 1987 5:46:15 pm )AnalystArchitect chartWindowFeature.	XSIS-Querying.st	XSIS-FixedFiles.st	XSIS-Charts.st	XSIS-ChartEditor.st550-chartWindowFeature - Final Pass: Reading files - (27 April 1987 10:56:31 pm )AnalystArchitect chartWindowFeature.	XSIS-Querying.st - skipping: Encountered earlier.	XSIS-FixedFiles.st		46975 bytes. 10 April 1987 5:52:38 pm		ClassifiedFixedFileStream - add		FixedFileFilter - add		FixedFileStream - add		781 oops and 28298 words	XSIS-Charts.st		53483 bytes. 8 January 1987 5:38:55 pm		BarChart - add		Chart - add		ClusteredBarChart - add		LineChart - add		PieChart - add		SortedLinearFit - add		SortedSpline - add		StackedBarChart - add		StackedLineChart - add		XYChart - add		3998 oops and 51556 words	XSIS-ChartEditor.st		53132 bytes. 25 April 1987 6:32:23 pm		ChartEditor - add		CreateController - add		DataListController - add		DataListModel - add		DataListStandardSystemController - add		DataListView - add		StackListController - add		2987 oops and 45562 words550-chartWindowFeature uses 7721 oops and 124713 wordsBefore: oops left = 17627; core left = 562620After: oops left = 9906; core left = 437907((27 April 1987 11:20:29 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf560xdataBaseFeaturePart01"560-dataBaseFeature - Preliminary Pass: Locating files - (27 April 1987 5:46:31 pm )AnalystArchitect dataBaseFeature.	XSIS-Querying.st	XSIS-FixedFiles.st	XSIS-Tables.st	XSIS-DataBase.st560-dataBaseFeature - Final Pass: Reading files - (27 April 1987 11:23:45 pm )AnalystArchitect dataBaseFeature.	XSIS-Querying.st - skipping: Encountered earlier.	XSIS-FixedFiles.st - skipping: Encountered earlier.	XSIS-Tables.st		11203 bytes. 13 November 1986 7:49:49 pm		Tables - add		TablesCompositionScanner - add		823 oops and 12711 words	XSIS-DataBase.st		93091 bytes. 11 April 1987 7:13:25 pm		DataBase - add		DatabaseFormsController - add		DatabaseFormsEditController - add		DatabaseFormsModel - add		DBStandardSystemController - add		DBTextController - add		DFieldListController - add		DFieldListView - add		DHitListController - add		DHitListView - add		DQueryListController - add		DQueryListView - add		DReportListController - add		DReportListView - add		FieldParagraph - add		FieldStringView - add		1671 oops and 54298 words560-dataBaseFeature uses 2473 oops and 66462 wordsBefore: oops left = 16257; core left = 535052After: oops left = 13784; core left = 468590((27 April 1987 11:41:14 pm ) save as AnalystST80-DV6-1108.5.im)"!logOf570xanalystSpreadsheetFeaturePart01"570-analystSpreadsheetFeature - Preliminary Pass: Locating files - (27 April 1987 5:46:47 pm )AnalystArchitect analystSpreadsheetFeature.	Signal-mm.st	XSIS-Boxes.st	XSIS-Querying.st	XSIS-ControlBox.st	XSIS-SpecialFileStreams.st	XSIS-Matrices.st	XSIS-Spreadsheet-Support.st	XSIS-Spreadsheets.st	FormFilingChanges.st570-analystSpreadsheetFeature - Final Pass: Reading files - (27 April 1987 11:44:34 pm )AnalystArchitect analystSpreadsheetFeature.	Signal-mm.st - skipping: Encountered earlier.	XSIS-Boxes.st - skipping: Encountered earlier.	XSIS-Querying.st - skipping: Encountered earlier.	XSIS-ControlBox.st - skipping: Encountered earlier.	XSIS-SpecialFileStreams.st - skipping: Encountered earlier.	XSIS-Matrices.st - skipping: Encountered earlier.	XSIS-Spreadsheet-Support.st		13824 bytes. 11 November 1985 8:28:30 pm		Label - add		SpreadsheetDictionary - add		SSDataBase - add		Stats - add		Sum - add		274 oops and 6875 words	XSIS-Spreadsheets.st		130621 bytes. 18 April 1987 6:58:45 pm		CellStringHolderController - add		LabelSwitch - add		LabelSwitchController - add		LabelSwitchView - add		SpreadsheetCell - add		SpreadsheetController - add		SpreadsheetHolder - add		SpreadsheetRule - add		SpreadsheetView - add		StandardSystemSpreadsheetController - add		4288 oops and 91764 words	FormFilingChanges.st		1686 bytes. 25 July 1985 12:58:43 pm		Form class readFromStream: - add		Form writeOnStream: - add		39 oops and 2287 words570-analystSpreadsheetFeature uses 4535 oops and 100313 wordsBefore: oops left = 15203; core left = 508577After: oops left = 10668; core left = 408264((28 April 1987 12:08:48 am ) save as AnalystST80-DV6-1108.5.im)"!logOf580xmapWindowFeaturePart01"580-mapWindowFeature - Preliminary Pass: Locating files - (27 April 1987 5:47:11 pm )AnalystArchitect mapWindowFeature.	XSIS-Querying.st	XSIS-FixedFiles.st	XSIS-MapSupport.st	XSIS-MapEditor.st580-mapWindowFeature - Final Pass: Reading files - (28 April 1987 12:12:14 am )AnalystArchitect mapWindowFeature.	XSIS-Querying.st - skipping: Encountered earlier.	XSIS-FixedFiles.st - skipping: Encountered earlier.	XSIS-MapSupport.st		7093 bytes. 10 February 1987 6:20:26 pm		MapFileList - add		MapForm - add		MapTransformationTable - add		MapView - add		198 oops and 5467 words	XSIS-MapEditor.st		60158 bytes. 17 April 1987 1:36:00 pm		MapEditor - add		4294 oops and 65234 words580-mapWindowFeature uses 4440 oops and 69289 wordsBefore: oops left = 14171; core left = 482313After: oops left = 9731; core left = 413024((28 April 1987 12:23:15 am ) save as AnalystST80-DV6-1108.5.im)"!logOf590xXSISxAnimationxstPart01"590-XSIS-Animation.st - Preliminary Pass: Locating files - (27 April 1987 5:47:27 pm )XSIS-Animation.st590-XSIS-Animation.st - Final Pass: Reading files - (28 April 1987 12:26:39 am )XSIS-Animation.st	25417 bytes. 10 February 1987 7:38:38 pm	Animation - add	Sprite - add	UTime - add	812 oops and 17243 words590-XSIS-Animation.st uses 807 oops and 16966 wordsBefore: oops left = 13751; core left = 469019After: oops left = 12944; core left = 452053((28 April 1987 12:31:43 am ) save as AnalystST80-DV6-1108.5.im)"!logOf600xXSISxNewOutlinesxstPart01"600-XSIS-NewOutlines.st - Preliminary Pass: Locating files - (27 April 1987 5:47:35 pm )XSIS-NewOutlines.st600-XSIS-NewOutlines.st - Final Pass: Reading files - (28 April 1987 12:35:04 am )XSIS-NewOutlines.st	83587 bytes. 21 April 1987 9:57:53 pm	ChapterController - add	OutlineController - add	OutlineEditController - add	OutlineList - add	OutlineView - add	1586 oops and 47251 words600-XSIS-NewOutlines.st uses 1577 oops and 46943 wordsBefore: oops left = 13468; core left = 463380After: oops left = 11891; core left = 416437((28 April 1987 12:48:05 am ) save as AnalystST80-DV6-1108.5.im)"!logOf610xrs232FeaturePart01"610-rs232Feature - Preliminary Pass: Locating files - (27 April 1987 5:47:44 pm )AnalystArchitect rs232Feature.	NP-SerialPort-1108.st	AsyncSerialPort.st	XSIS-RS232-Basics.st	WatchforRS232onQuit-changes.st	XSIS-RS232-Applics.st	BitBltAndForm-tek-adds.st	PosStream-changesForKermit.st	XSIS-RS232-Kermit.st	Test1108AsyncSerialPort.st610-rs232Feature - Final Pass: Reading files - (28 April 1987 12:51:34 am )AnalystArchitect rs232Feature.	NP-SerialPort-1108.st		13301 bytes. 20 August 1985 8:27:38 pm		SerialPort - add		288 oops and 8590 words	AsyncSerialPort.st		4393 bytes. 6 April 1987 2:16:40 pm		AsyncSerialPort - add		108 oops and 3156 words	XSIS-RS232-Basics.st		61139 bytes. 28 March 1987 8:53:30 pm		MessageView - add		RS232Controller - add		RS232DisplayLine - add		RS232DisplayMem - add		RS232Memory - add		RS232MemoryBuffer - add		RS232Model - add		RS232SendController - add		RS232SystemController - add		RS232TextView - add		1159 oops and 42608 words	WatchforRS232onQuit-changes.st		528 bytes. 18 September 1985 10:12:44 pm		ScreenController quit - change			Conflicts with ('CV4-ScreenControllerSmalltalk.st' )		ScreenController saveThenQuit - change			Conflicts with ('CV4-ScreenControllerSmalltalk.st' )		24 oops and 820 words	XSIS-RS232-Applics.st		61420 bytes. 19 January 1987 7:25:25 pm		FunctionKeyEditor - add		FunctionKeyEditorController - add		RS232FunctionKeys - add		RS232FunctionKeysController - add		RS232FunctionKeysView - add		RS232GraphicsDisplayMem - add		TekController - add		TekModel - add		2094 oops and 49799 words	BitBltAndForm-tek-adds.st		3122 bytes. 5 February 1987 3:56:08 pm		BitBlt drawFrom:to:segmentLength: - add		BitBlt drawSegLoopX:Y:segLen:spaceLen: - add		Form drawSegLine:from:to:clippingBox:rule:mask:segmentLength: - add		43 oops and 2264 words	PosStream-changesForKermit.st		89 bytes. 3 June 1986 7:46:10 pm		PositionableStream release - add		19 oops and 520 words	XSIS-RS232-Kermit.st		35684 bytes. 18 September 1986 9:46:57 pm		RS232Kermit - add		462 oops and 21373 words	Test1108AsyncSerialPort.st		4431 bytes. 31 July 1986 8:36:38 pm		Test1108AsyncSerialPort - add		49 oops and 1329 words610-rs232Feature uses 4147 oops and 127554 wordsBefore: oops left = 12828; core left = 441569After: oops left = 8681; core left = 314015((28 April 1987 1:21:15 am ) save as AnalystST80-DV6-1108.5.im)"!logOf620xXSISxAutoBookxstPart01"620-XSIS-AutoBook.st - Preliminary Pass: Locating files - (27 April 1987 5:48:11 pm )XSIS-AutoBook.st620-XSIS-AutoBook.st - Final Pass: Reading files - (28 April 1987 1:25:03 am )XSIS-AutoBook.st	36936 bytes. 10 April 1987 5:34:39 pm	ABFormController - add	AutoBook - add	AutoBookListController - add	AutoBookListView - add	AutoBookStandardSystemController - add	AutoBookTextController - add	AutoBookTextView - add	FirstABListController - add	FirstABListView - add	SecondABListController - add	SecondABListView - add	ThirdABListController - add	ThirdABListView - add	878 oops and 22438 words620-XSIS-AutoBook.st uses 873 oops and 22163 wordsBefore: oops left = 10859; core left = 400627After: oops left = 9986; core left = 378464((28 April 1987 1:32:44 am ) save as AnalystST80-DV6-1108.5.im)"!logOf630xTimeZonexClocksxstPart01"630-TimeZone-Clocks.st - Preliminary Pass: Locating files - (27 April 1987 5:48:19 pm )TimeZone-Clocks.st630-TimeZone-Clocks.st - Final Pass: Reading files - (28 April 1987 1:36:22 am )TimeZone-Clocks.st	11415 bytes. 28 February 1987 7:27:17 pm	ClockController - add	ClockView - add	DigitalClockView - add	ZonedTime - add	341 oops and 8714 words630-TimeZone-Clocks.st uses 312 oops and 8274 wordsBefore: oops left = 10346; core left = 391127After: oops left = 10034; core left = 382853((28 April 1987 1:39:35 am ) save as AnalystST80-DV6-1108.5.im)"!logOf640xpreviewWindowFeaturePart01"640-previewWindowFeature - Preliminary Pass: Locating files - (27 April 1987 5:48:26 pm )AnalystArchitect previewWindowFeature.	Preview-Support.st	Preview-Page.st((27 April 1987 5:51:39 pm ) save as AnalystST80-DV6-1108.5.im)640-previewWindowFeature - Final Pass: Reading files - (28 April 1987 1:43:12 am )AnalystArchitect previewWindowFeature.	Preview-Support.st		61527 bytes. 6 February 1987 8:19:06 pm		PreviewCharacterBlockScanner - add		PreviewCompositionScanner - add		PreviewDisplayScanner - add		PreviewTabController - add		PreviewTabView - add		PreviewTextLineInterval - add		RectForm - add		934 oops and 44788 words	Preview-Page.st		165851 bytes. 10 April 1987 5:31:34 pm		PreviewPage - add		PreviewPageController - add		PreviewPageView - add		5386 oops and 110289 words640-previewWindowFeature uses 6292 oops and 154430 wordsBefore: oops left = 10142; core left = 386469After: oops left = 3850; core left = 232039((28 April 1987 2:18:05 am ) save as AnalystST80-DV6-1108.5.im)"! !!LRUCacheDictionary class methodsFor: 'instance creation'!new	^self new: 1!new: anInteger	^super new: anInteger * 2! !!OopConservingDictionary class methodsFor: 'instance creation'!new: anInteger	^super new: anInteger * 2! !!OopConservingDictionary class methodsFor: 'examples'!example1	| consonants |	consonants _ self new.	$a asciiValue to: $z asciiValue do:		[:asciiValue |		consonants at: asciiValue asCharacter put: asciiValue - $a asciiValue + 1].	$a asciiValue to: $z asciiValue do:		[:asciiValue | asciiValue asCharacter isVowel ifTrue: [consonants removeKey: asciiValue asCharacter]].	consonants inspect.	"OopConservingDictionary example1."!example2	| dict |	dict _ self new: 100.	100 to: 5000 by: 100 do:		[:each |		dict at: each put: each ln].	1000 to: 5000 by: 1000 do:		[:each |		dict removeKey: each.].	dict halt; inspect.	"OopConservingDictionary example2."! !!Pool class methodsFor: 'instance creation'!named: aSymbol	| pool |	(Smalltalk includesKey: aSymbol)		ifTrue: 			[pool _ Smalltalk at: aSymbol.			pool class == Pool 				ifFalse: [^self error: 'Pool ' , aSymbol , ' cannot be created due to conflict']]		ifFalse: 			[Smalltalk at: aSymbol put: (pool _ Pool new).			pool name: aSymbol].	^pool!named: aSymbol includes: anotherSymbol 	| pool |	(Smalltalk includesKey: aSymbol)		ifTrue: 			[pool _ Smalltalk at: aSymbol.			pool class == Pool 				ifFalse: [^self error: 'Pool ' , aSymbol , ' cannot be created due to conflict'].			pool addVariable: anotherSymbol]		ifFalse: 			[Smalltalk at: aSymbol put: (pool _ Pool new).			pool name: aSymbol.			pool addVariable: anotherSymbol]! !!Pool class methodsFor: 'private-initial conversion'!replace: oldPool with: newPool	oldPool associationsDo: [:each | newPool noCheckAdd: each].	oldPool become: newPool! !SpreadsheetDictionary class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!FixedFileFilter class comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986. All rights reserved.'!!FixedFileFilter class methodsFor: 'instance creation'!on: aString	"construct a filter from the string given.  aString is parsed as follows:	<fieldName> <operator> <value> <conjunction> <fieldName> <operator> <value> ...	{Where}		<fieldName> ::= a string of indeterminate length {surrounded by single quotes}		<operator> ::= < | > | = | <= | >= | ~ | contains | ~contains 	{the 'contains' operator is an inclusion operator for strings, for instance ('kurt' contains 'urt') would be true, but ('kurt' contains 'utr') is false}		<value> ::= a Smalltalk expression yielding a string literal or number constant		<conjunction> ::= and | or | xor	Parentheses are NOT permitted.  Expressions are evaluated from left to right."	^self new constructFilterFrom: aString"(FixedFileFilter on: '''name'' contains ''Kurt'' or ''name'' contains ''Leslee''') inspect""((FixedFileStream fileNamed: 'beta') allRecordsFitting:(FixedFileFilter on: '''name'' contains ''Kurt'' xor ''rank'' contains ''Slave''')) inspect"! !!FixedFileFilter class methodsFor: 'examples'!quickQueryOn: fileName 	"make a quick query on the file mentioned in fileName."	"(FixedFileFilter quickQueryOn: 'gamma') inspect"	| answer theFile theCollection |	Cursor normal showWhile: [FillInTheBlank			request: (Text string: '                                What is your query                                ' emphasis: 4)			displayAt: Sensor cursorPoint			centered: true			action: [:answer | answer]			initialAnswer: Text new asParagraph].	theFile _ FixedFileStream fileNamed: fileName.	theCollection _ theFile allRecordsFitting: (FixedFileFilter on: answer).	theFile close.	^theCollection! !!Classification class methodsFor: 'initialize'!initialize	"set up the defaults for this class"  "Classification initialize"	ClassByte _ 2.	ModifierCountByte _ 10.	ControlSize _ 14.! !!Classification class methodsFor: 'utility'!classAndModsFromHeaderString: aString	"aString looks like: (Class,Mod1,Mod2,Mod3,...,Modn)"	| aStream arr result temp |	aString == nil		ifTrue: [^(Array with: 1 with: nil)]		ifFalse: [aStream _ ReadStream on: (aString copyFrom: 2 to: aString size - 1).				arr _ OrderedCollection new.				result _ Array new: 2.				result at: 1 put: (DCM convert: (aStream upTo: $,) to: #classIndex).				[aStream atEnd] whileFalse:					[temp _ (aStream upTo: $,).					(DCM abbrevModifiers includes: temp) ifTrue: [arr add: temp]].				result at: 2 put: (arr isEmpty ifTrue: [nil] ifFalse: [arr]).				^result]! !!Classification class methodsFor: 'instance creation'!array: aSymbolArray	| theNewCClass | 	theNewCClass _ self new.	theNewCClass classification: (aSymbolArray first == nil		ifTrue:[1]		ifFalse:[DCM convert: aSymbolArray first asString to: #classIndex]).	2 to: aSymbolArray size do: [:each |		theNewCClass addModifier: (aSymbolArray at: each)].	^theNewCClass!fromHeaderString: aString	"aString looks like: (Class,Mod1,Mod2,Mod3,...,Modn)"	| arr temp theNewCClass |	arr _ self classAndModsFromHeaderString: aString.	theNewCClass _ self new.	theNewCClass classification: (arr at: 1).	(arr at: 2) == nil ifFalse: [(arr at: 2) do: [:each | theNewCClass addModifier: each]].	^theNewCClass!fromUser	"Classification fromUser"	| newClass | 	newClass _ self new.	self fromUser: newClass!fromUser: aClassification	"Classification fromUser"	| newClass answer | 	newClass _ self new.	answer _ DCM getNewClassification: aClassification qboxArray.	answer == nil ifTrue:[^nil].	newClass setFromArray: answer.	^newClass!fromUser: aClassification title: titleString	"Classification fromUser"	| newClass answer | 	newClass _ self new.	answer _ DCM getNewClassification: aClassification qboxArray title: titleString.	answer == nil ifTrue:[^nil].	newClass setFromArray: answer.	^newClass!new	^self new: DCM maxSize!readFromString: theString	| newClassification | 	"read me from this String or else"	newClassification _ self new: theString size.	newClassification replaceFrom: 1 to: theString size withString: theString startingAt: 1.	^newClassification! !!Classification class methodsFor: 'access'!controlSize	^ControlSize! !!DataItem class methodsFor: 'instance creation'!locked: locked classification: classification modifiers: modifiers type: type dataType: aDataType label: label filename: filename bPointers: bPointers fPointers: fPointers atIndex: centerIndex	"set up the stuff"	| newInfoLabel modifiersSize position bPointersSize fPointersSize temp |	modifiers == nil ifTrue: [modifiersSize _ 0] ifFalse: [modifiersSize _ modifiers size].	bPointers == nil ifTrue: [bPointersSize _ 0] ifFalse: [bPointersSize _ (bPointers size)].	fPointers == nil ifTrue: [fPointersSize _ 0] ifFalse: [fPointersSize _ (fPointers size)].	newInfoLabel _ self new: ControlSize + modifiersSize + (bPointersSize * 4) + (fPointersSize * 4) +  label size  + filename size.	newInfoLabel at: LockedByte put: (locked ifTrue: [$L] ifFalse: [$U]) asciiValue.	newInfoLabel at: ClassByte put: (classification class = SmallInteger		ifTrue: [classification]		ifFalse: [DCM convert: classification to: #classIndex]).	newInfoLabel at: ModifierCountByte put: modifiersSize.	newInfoLabel at: TypeByte put: (self typeIndexFor: type).	newInfoLabel at: DataTypeByte put: aDataType.	(centerIndex < 256)		ifTrue:[newInfoLabel at: IndexByte put: 0; at: (IndexByte+1) put: centerIndex]		ifFalse:[newInfoLabel  at: IndexByte put: (centerIndex digitAt:2); at: (IndexByte+1) put: (centerIndex digitAt: 1)].	(bPointersSize < 256)		ifTrue:[newInfoLabel at: BPointerCountByte put: 0; at: (BPointerCountByte+1) put: bPointersSize]		ifFalse:[newInfoLabel  at: BPointerCountByte put: (bPointersSize digitAt:2); at: (BPointerCountByte+1) put: (bPointersSize digitAt: 1)].	(fPointersSize < 256)		ifTrue:[newInfoLabel at: FPointerCountByte put: 0; at: (FPointerCountByte+1) put: fPointersSize]		ifFalse:[newInfoLabel  at: FPointerCountByte put: (fPointersSize digitAt:2); at: (FPointerCountByte+1) put: (fPointersSize digitAt: 1)].	newInfoLabel at: LabelSizeByte put: label size.	newInfoLabel at: FileNameSizeByte put: filename size.	position _ ControlSize.	modifiersSize = 0 ifFalse:		[modifiers do: [:each | position _position + 1.		newInfoLabel at: position put: (DCM convert: each to: #modIndex)]].	position _ position + 1.	newInfoLabel replaceFrom: position to: position + label size - 1 withString: label startingAt: 1.	position _ position + label size.	newInfoLabel replaceFrom: position to: position + filename size - 1 withString: filename startingAt: 1.	position _ position + filename size.	bPointersSize = 0 ifFalse: [bPointers do: [:each | ((each at: 3)< 256)		 ifTrue:[newInfoLabel at: position put: (each at: 1); at: position +1 put: (each at: 2); at: position+2 put: 0; at: position+3 put: (each at: 3)]		 ifFalse:[newInfoLabel  at: position put: (each at: 1); at: position+1 put: (each at: 2); at: position+2 put: ((each at: 3) digitAt:2); at: position+3 put: ((each at: 3) digitAt:1)].		 position _position + 4]].		fPointersSize = 0 ifFalse: [fPointers do: [:each | ((each at: 3)< 256)		 ifTrue:[newInfoLabel at: position put: (each at: 1); at: position +1 put: (each at: 2); at: position+2 put: 0; at: position+3 put: (each at: 3)]		 ifFalse:[newInfoLabel  at: position put: (each at: 1); at: position+1 put: (each at: 2); at: position+2 put: ((each at: 3) digitAt:2); at: position+3 put: ((each at: 3) digitAt:1)].		 position _position + 4]].	^newInfoLabel!locked: locked classification: classification modifiers: modifiers type: type label: label filename: filename bPointers: bPointers fPointers: fPointers atIndex: centerIndex 	^self		locked: locked		classification: classification		modifiers: modifiers		type: type		dataType: 0		label: label		filename: filename		bPointers: bPointers		fPointers: fPointers		atIndex: centerIndex!readMeFrom: theStream	| size newFolderLabel aString | 	"read me from this stream or else"	size _ Integer readFrom: theStream.	theStream skip: 1.	size = 0 ifTrue: [^nil].	newFolderLabel _ self new: size.	aString _ theStream next: size.	newFolderLabel replaceFrom: 1 to: size withString: aString startingAt: 1.	^newFolderLabel!readMeFromString: theString	| size newFolderLabel | 	"read me from this string"	size _ theString size.	newFolderLabel _ self new: size.	newFolderLabel replaceFrom: 1 to: size withString: theString startingAt: 1.	^newFolderLabel!type: type label: theLabel atIndex: centerIndex 	^self		locked: false		classification: 1		modifiers: nil		type: (self typeIndexFor: type)		dataType: 0		label: theLabel		filename: nil		bPointers: nil		fPointers: nil		atIndex: centerIndex!type: type label: theLabel filename: theFilename atIndex: centerIndex 	^self		locked: false		classification: 1		modifiers: nil		type: (self typeIndexFor: type)		label: theLabel		filename: theFilename		bPointers: nil		fPointers: nil		atIndex: centerIndex!type: type label: theLabel filename: theFilename bPointers: bPointers atIndex: centerIndex 	^self		locked: false		classification: 1		modifiers: nil		type: (self typeIndexFor: type)		label: theLabel		filename: theFilename		bPointers: bPointers		fPointers: nil		atIndex: centerIndex!type: theType label: theLabel fPointers: pointers atIndex: centerIndex 	^self		locked: false		classification: 1		modifiers: nil		type: (self typeIndexFor: theType)		dataType: 0		label: theLabel		filename: nil		bPointers: nil		fPointers: pointers		atIndex: centerIndex! !!DataItem class methodsFor: 'initialize'!initialize	"set up the defaults for this class" "DataItem initialize"	LockedByte _ 1.	FileNameSizeByte _ 3.	BPointerCountByte _ 4.	FPointerCountByte _ 6.	LabelSizeByte _ 8.	DataTypeByte _ 9.	FlagByte _ 11.	TypeByte _ 12.	IndexByte _ 13.	DefaultClass _ 1.	(DataTypes _ OrderedCollection new) add: #Folder ; add: #Item; add: #Keyword! !!DataItem class methodsFor: 'access'!typeIndexFor: aType	"return the index for the symbol Folder in the default type"	(aType isKindOf: Integer) ifTrue: [^aType].	^((DataTypes indexOf: aType) max: 1)! !Label class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Label class methodsFor: 'protocol name'!fromString: aString 	"Answer a new String that is a copy of the argument, aString."	"Label fromString: 'abcde'"		| newString |	newString _ self new: aString size.	1 to: aString size do: [:i | newString at: i put: (aString at: i)].	^newString! !!MapTransformationTable class methodsFor: 'instance creation'!windowingTransformation: aWindowingTransformation xOrY: xOrY destinationStart: aNumber1 destinationStop: aNumber2	| destinationStart destinationStop margin scale shiftAmount sourceStart sourceStop temp translation |	(xOrY sameAs: #x) ifTrue:		[scale _ aWindowingTransformation scale x.		translation _ aWindowingTransformation translation x].	(xOrY sameAs: #y) ifTrue:		[scale _ aWindowingTransformation scale y.		translation _ aWindowingTransformation translation y].	margin _ ((aNumber2 - aNumber1) abs + 402.0) timesTwoPower: -2.	destinationStart _ (aNumber1 min: aNumber2) - margin.	destinationStop _ (aNumber1 max: aNumber2) + margin.	sourceStart _ destinationStart - translation / scale.	sourceStop _ destinationStop - translation / scale.	sourceStop < sourceStart ifTrue:		[temp _ sourceStart.		sourceStart _ sourceStop.		sourceStop _ temp.		temp _ destinationStart.		destinationStart _ destinationStop.		destinationStop _ temp].	shiftAmount _ 1 - ((sourceStop - sourceStart / (destinationStop - destinationStart)) exponent).	(xOrY sameAs: #x) ifTrue:		[temp _ (sourceStart + sourceStop) timesTwoPower: -1.		[temp < 0.0] whileTrue:			[sourceStart _ sourceStart + 2r1.0e32.			sourceStop _ sourceStop + 2r1.0e32.			temp _ temp + 2r1.0e32			].		[temp < 2r1.0e32] whileFalse:			[sourceStart _ sourceStart - 2r1.0e32.			sourceStop _ sourceStop - 2r1.0e32.			temp _ temp - 2r1.0e32			]		].	^(self new: ((sourceStop - sourceStart) timesTwoPower: shiftAmount) rounded + 1)		offset: (sourceStart timesTwoPower: shiftAmount) rounded - 1		shiftAmount: shiftAmount		scale: scale		translation: translation;		destinationStart: destinationStart rounded		destinationStop: destinationStop rounded! !!DataItemPointer class methodsFor: 'initialize'!certainty: cert type: type index: aIndex 	^self with: cert with: type with: aIndex!index: aIndex	^self certainty: DefaultCert type: (DataMaster linkTypeFor: #contains) index: aIndex!type: type index: aIndex	^self certainty: DefaultCert type: type index: aIndex! !PreviewTextLineInterval class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewTextLineInterval class methodsFor: 'instance creation'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger margins: lrMargins alignment: alignment	"Answer an instance of me with the arguments as the start, stop points, number of	spaces in the line, and width of the padding."	| newSelf |	newSelf _ super from: startInteger to: stopInteger by: 1.	^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger margins: lrMargins alignment: alignment! !!Point class methodsFor: 'instance creation'!numbersReverseInit: aBlock	^self new numbersReverseInit: aBlock! !!Signal class methodsFor: 'initialization'!initialize	"this must be done whenever certain messages are recompiled."	"Signal initialize."	CatchAllSignal _ self new.	DoHandleMethod _ self compiledMethodAt: #do:handle: .	OnUnwindDoMethod _ self class compiledMethodAt: #do:onUnwindDo: .	SignalMethod _ self compiledMethodAt: #signal: .	SignalNoReturnMethod _ self compiledMethodAt: #signalNoReturn: .! !!Signal class methodsFor: 'examples'!complexExample	"this exercises the resumeWith: and unwindAndDo: handling techniques."	| s t |	s _ Signal new.	^ s do: ['resume (with a result for signal),', s signal] 		handle: [s signalReturn: (			' or handle',			(s do: [Signal do: [s signal, 'not seen'] onUnwindDo: [t _ ' and fixing things'] ]		 		handle: [s handleReturnDoing: [t _ ' (after unwinding', t, ')' ] ] ),		' with a result for do:handle:' ) ]!doRetryExample	"this is an implementation of whileTrue: "	| a testBlock loopBlock loop |	a _ 0.	testBlock _ [a < 100].	loopBlock _ [a _ a + 1].	loop _ Signal new.	loop do: [testBlock value ifTrue: [loopBlock value. loop signal]]		handle: [loop doRetry].	testBlock _ loopBlock _ nil.  "plug oop leak"!handleReturnExamples"simple unwinding""| s |s _ Signal new.s do: [s signal, 'never get here']  handle: [s handleReturn: 'do:handle: gets this result'] ""note when t gets changed""| s t |s _ Signal new.t _ 'start'.s do: [Signal do: [s signal] onUnwindDo: [t _ 'unwinding']]  handle: [s handleReturnDoing: [t _ t, ' and handling']].""can also handle by restarting the do:handle:""| n sig |n _ 0.sig _ Signal new.sig do: [Signal do: [sig signal] onUnwindDo: [n _ n+1] ]	handle: [n > 2 ifTrue: [sig handleReturn: n]					ifFalse: [sig doRetry] ].""unwinding can fix problems(there is an unwind handler in the new version of critical:)""| sem sig |sig _ Signal new.sem _ Semaphore forMutualExclusion.sig do: [sem critical: ['sem is now locked'. sig signal] ]	handle: [sig handleReturnDoing: [sem wait. 'sem cleared in unwind'] ]."!signalReturnExamples"simple resumption""| s |s _ Signal new.s do: [s signal, ' and go on']  handle: [s signalReturnWith: 'give a result for signal message'].""handler may be found far away in stack""| s |s _ Signal new.s do: [	s do: [s signal, ' then resume inside']		  handle: ['no handling here'] ]  handle: [s signalReturnWith: 'handle signal in outer handler']."!someBadExamples"what happens when no block handles the signal""Signal new signal: 'notifier label if I am not handled' ""| sig |sig _ Signal new.sig do: [sig signal: 'unhandled signal'] handle: []""attempt to resume when no signal is in force""Signal new handleReturn: 'cannot handle; no signal'.".! !!Signal class methodsFor: 'unwinding'!do: aBlock onUnwindDo: unwindBlock	"evaluate aBlock.	if unwind propagates thru thisContext,		then the unwindBlock stored here will be evaluated;		it should correct any mess due to failure of aBlock to complete."	^ aBlock value!unwindTo: aContext	"run all unwind blocks found in do:onUnwindDo: contexts		from this context to aContext.	unwind blocks should never execute ^ during this phase.	return aContext"	| unwindContext |	unwindContext _ thisContext. "even catch unwinds between here and signal"	[true] whileTrue: [		[(unwindContext _ unwindContext sender)			== aContext ifTrue: [^ aContext].		 unwindContext method == OnUnwindDoMethod] whileFalse: [].  "find next unwinder"				(unwindContext at: 2) shallowCopy value.  "run the unwind block" ].! !!Signal class methodsFor: 'utilities'!activeSignal	"return the nearest active signal in this execution stack,	 or nil if none active"		| context |	context _ thisContext.	[(context _ context sender) == nil] whileFalse: [		context method == SignalMethod			ifTrue: [^ context receiver] ].	^ nil!catchAll	"the signal whose handleBlocks will be invoked for any active signal"	^ CatchAllSignal!do: doBlock catch: signalCollection handle: handleBlock	"if the active signal is in signalCollection,	 then invoke the handleBlock."	^ CatchAllSignal do: doBlock		handle: [(signalCollection includes: self activeSignal) ifTrue: [handleBlock value]]!do: aBlock handle: handleBlock"catch any signal and give handleBlock a crack at it"	^ CatchAllSignal do: aBlock handle: handleBlock! !Pool named: #TextConstants includes: #DefaultTextStyle!!Paragraph class methodsFor: 'instance creation'!forPressWithText: aText style: aTextStyle compositionRectangle: compRect	"Answer with a PressParagraph. Composition rectangle is scaled by	PressFile pressScale and destinationForm is set to PressPrinter DefaultFrame."	| pressParagraph pressCompositionRectangle pressTextStyle |	aTextStyle outputMedium: #PressPrinter.	pressParagraph _		super new			compositionRectangle: compRect			text: aText			style: aTextStyle			offset: 0@0			outputMedium: #PressPrinter			fitWidth: false.	pressParagraph destinationForm: compRect.	pressParagraph clippingRectangle: compRect.	pressParagraph compositionRectangle right > PressPrinter DefaultDoverRectangle right		ifTrue:	[self error: 'right margin off page, clipping not implemented in press paragraphs']		ifFalse:	[^pressParagraph]!usingPrinterWidthsText: aText	^super new		compositionRectangle: DefaultCompositionRectangle		text:	aText		style: (PressOrInterpress == #Press				ifTrue: [DefaultTextStyle copy]				ifFalse: [PrintStyle default])		offset: (0@0)		outputMedium: #DisplayPrinterWidths		fitWidth: true!withText: aText style: aTextStyle 	"Answer an instance of me with text set to aText and style set to aTextStyle."	^super new		compositionRectangle: DefaultCompositionRectangle		text:	aText		style: aTextStyle		offset: (0@0)		outputMedium: aTextStyle outputMedium		fitWidth: true!withText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect 	| para |	para _ super new		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: (0@0)		outputMedium: aTextStyle outputMedium		fitWidth: false.	para clippingRectangle: clipRect.	^para! !!Paragraph class methodsFor: 'examples'!examplePrinterWidths	"This simple example illustrates how to display a few lines of text on the screen at 	the current cursor point."	| para point |	point _ Sensor waitButton.	para _ 'this is the first line of charactersand this is the second line comprising this TextForm.' asParagraph.	para outputMedium: #DisplayPrinterWidths.	para displayOn: Display at: point.	para		displayOn: Display at: point + (0 @ para height)		clippingBox: Display boundingBox		rule: Form over		mask: Form gray	"Paragraph examplePrinterWidths" "then click a mouse button"! !!BigParagraph class methodsFor: 'instance creation'!forPressWithText: aText style: aTextStyle compositionRectangle: compRect	"I shouldn't to this."	self shouldNotImplement! !FieldParagraph class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!FieldParagraph class methodsFor: 'instance creation'!withFields: fields values: values emphasis: emphasis style: style compositionRectangle: compRect clippingRectangle: clipRect	| maxWidth str protected oldPos para |	maxWidth _ fields inject: 0 into:		[:max :this | max max:			((style fontAt: emphasis) widthOfString: this,': ') ].	str _ WriteStream on: (String new: 40).	protected _ OrderedCollection new.	1 to: fields size do:		[:i |		oldPos _ str position +1.		i>1 ifTrue: [str cr].		str nextPutAll: ( ((fields at: i),': ') paddedToWidth: maxWidth			inStyle: style font: emphasis) .		protected add: (oldPos to: str position).		str nextPutAll: ((values at: i) class == String ifTrue:[values at: i] ifFalse:[(values at: i) printString]) ].	para _ super		withText: String new		style: style		compositionRectangle: compRect		clippingRectangle: clipRect.	para restIndent: (maxWidth negated // style tabWidth) negated * style tabWidth.	para text: str contents asText fields: protected emphasis: emphasis.	^para! !!TextList class methodsFor: 'class initialization'!initializeWithFontAt: fontIndex	| font |	ListStyle _ DefaultTextStyle copy.	font _ ListStyle fontAt: fontIndex.	ListStyle lineGrid: font height + 1.	ListStyle baseline: font ascent - 1	"TextList initializeWithFontAt: 1.		DisplayText allInstancesDo:		[:text | text textStyle: TextStyle default]"! !PreviewPage class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewPage class methodsFor: 'initialization'!initialize	"PreviewPage initialize"	| pressInch interpressInch | 	Grid _ 8 @ 16.	BufferSize _ 4500.	VarSaveList _ #(gutter endText columns minorHeading majorHeading tabUnit grid printerOffset defaultMargins tabsArray tabs tabPool tabNames).	Delimiter _ Character value: 255.	DefaultMargins  _ OopConservingDictionary new.	MinMargins  _ OopConservingDictionary new.	(Smalltalk includesKey: #PressFile) ifTrue:		[pressInch _ 79.375 * PressFile pressScale.		DefaultMargins at: #Press put: (pressInch @ pressInch corner: 0.75 * pressInch @ pressInch).		MinMargins at: #Press put: (pressInch / 4.0 @ (0.75 * pressInch) corner: pressInch / 4.0 @ (0.75 * pressInch))].	(Smalltalk includesKey: #PrintStyle) ifTrue:		[interpressInch _ 79.375 * PrintStyle pressScale.		DefaultMargins at: #Interpress put:  (interpressInch @ interpressInch corner: 0.75 * interpressInch @ interpressInch).		MinMargins at: #Interpress put:  (interpressInch / 4.0 @ (0.75 * interpressInch) corner: interpressInch / 4.0 @ (0.75 * interpressInch))]!withText: aText 	"Answer an instance of me with text set to aText and style set to the system's default text style"	| para style |	style	_ PressOrInterpress == #Press		ifTrue: [DefaultTextStyle copy]		ifFalse: [PrintStyle default].	(para _ self withText: aText style: style) initialize.	^para! !!PreviewPage class methodsFor: 'instance creation'!newFrom: aSuitcase	| newSelf | 	newSelf _ self new.	aSuitcase spare == nil		ifFalse: [newSelf initTabsFrom: aSuitcase spare].	newSelf var at: #suitcase put: aSuitcase.	^newSelf! !!PreviewPage class methodsFor: 'make file'!formTextFrom: stringOrText	| ws s runs | 	(stringOrText isKindOf: Text)		ifTrue: [^stringOrText]		ifFalse: [(ws _ ReadStream on: stringOrText) reset.				s _ ws upTo: 255 asCharacter.				runs _ Compiler evaluate: (ws next: (stringOrText size - ws position)).				^Text string: s runs: runs]!makeFileWithText: theText annoDict: annoDict lkcm: lkcm portrait: aBoolean	"lkcm is an Array of 4 containing label string, keyword string, classification, modifiers"	| textToUse fileName aFile |	textToUse _ theText isEmpty		ifTrue: [Text string: (String with: Character space) emphasis: (Smalltalk at: #UserFont ifAbsent: [1])]		ifFalse: [self formTextFrom: theText].	fileName _ Disk makeNewFileName: (lkcm at: 1) withSuffix: (DataMaster previewSuffixFor: (aBoolean ifTrue: [#portrait] ifFalse: [#landscape])).	Cursor execute showWhile:	 [(HeaderFileStream fileNamed: fileName) readWrite; writeHeaderLabel: (lkcm at: 1) class: (lkcm at: 3) mods: (lkcm at: 4) dataType: (DataMaster giveMe: #iconIndex for: fileName).	aFile _ (FileStream fileNamed: fileName, (DataMaster giveMe: #specialSuffixString for: #preview asString)) readWrite.	  ComposeTextController putText: textToUse inStream: aFile usingAnnoDict: annoDict.	  aFile close].	^fileName! !SortedLinearFit class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!SortedSpline class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!NewArc class methodsFor: 'examples'!example	"Click the button somewhere on the screen.  The designated point will	be the center of an Arc with radius 50 with beginAngle 1.5*pi and endAngle 2.0*pi."	| aNewArc aForm |	aForm _ Form new extent: 2 @ 2.		aForm black.						"turn it black"	aNewArc _ NewArc new.	aNewArc form: aForm.					"set the form for display"	aNewArc radius: 150.0.	aNewArc center: Sensor waitButton.	aNewArc beginAngle: 0 * (Float pi).	aNewArc endAngle: 2.0 * (Float pi).	aNewArc displayOn: Display.	Sensor waitButton	"NewArc example."! !!Form class methodsFor: 'class initialization'!initializeMasks"	Form initializeMasks.	"	| anArray masksExtent masksOffset fsf |	anArray _ Array new: 16.	masksExtent _ 16 @ 16.	masksOffset _ 0 @ 0.	anArray atAllPut: 0.	whiteMask _ self extent: masksExtent fromArray: anArray offset: masksOffset.	anArray atAllPut: 2r1111 * 16r1111.	blackMask _ self extent: masksExtent fromArray: anArray offset: masksOffset.	anArray atAll: (1 to: anArray size by: 2) put: 2r0101 * 16r1111.	anArray atAll: (2 to: anArray size by: 2) put: 2r1010 * 16r1111.	grayMask _ self extent: masksExtent fromArray: anArray offset: masksOffset.	anArray atAll: (1 to: anArray size by: 2) put: 2r1101 * 16r1111.	anArray atAll: (2 to: anArray size by: 2) put: 2r0111 * 16r1111.	darkGrayMask _ self extent: masksExtent fromArray: anArray offset: masksOffset.	lightGrayMask _ darkGrayMask deepCopy reverse.	anArray atAll: (1 to: anArray size by: 4) put: 2r1000 * 16r1111.	anArray atAll: (2 to: anArray size by: 2) put: 0.	anArray atAll: (3 to: anArray size by: 4) put: 2r0010 * 16r1111.	veryLightGrayMask _  self extent: masksExtent fromArray: anArray offset: masksOffset.		fsf _ Masks _ FormsStrikeFont new name: name.	fsf, 16rCC with: #stripe.	fsf, 16rFF with: #black.	fsf, 16r55, 16r55, 16rAA, 16rAA with: #gray.	fsf, 16r88, 16r88, 16r00, 16r00, 16r22, 16r22, 16r00, 16r00 with: #veryLightGray.	fsf, 16r77, 16r77, 16rDD, 16rDD with: #darkGray.	fsf, 16r03, 16r03, 16r0C, 16r0C, 16r30, 16r30, 16rC0, 16rC0 with: nil.	fsf, ((fsf at: 6) deepCopy reflect: 0 @ 1) with: nil.	fsf, (fsf at: 6) deepCopy reverse with: nil.	fsf, 16r10, 16r10, 16r00, 16r00 with: #pinStripe.	fsf, (fsf at: #pinStripe) deepCopy reverse with: nil.	fsf, 16rFF, 16rFF, 16r55, 16r55, 16r55, 16r55, 16r55, 16r55 with: nil.	fsf, 16r88, 16r88, 16r22, 16r22 with: #lightGray.	fsf, ((fsf at: 6) reflect: 0 @ 1) deepCopy reverse with: nil.	fsf,		(	(Form extent: 16@16)				spread: (0@0 corner: 8@16)				from: (fsf at: #stripe) deepCopy				by: 2				spacing: 0				direction: 1@0		) with: nil.	fsf, 16r00 with: #white.	fsf, 16r44 with: nil.	fsf, (fsf at: 16) deepCopy reverse with: nil.	fsf, 16rFF, 16rFF, 16r44, 16r44, 16r44, 16r44, 16r44, 16r44 with: nil.	fsf, (fsf at: 11) deepCopy reverse with: nil.	fsf, ((fsf at: #stripe) deepCopy rotateBy: 1) with: nil.	fsf, (fsf at: 18) deepCopy reverse with: nil.	fsf, 16r11, 16r11, 16r22, 16r22, 16r44, 16r44, 16r88, 16r88 with: #slant.! !!Form class methodsFor: 'instance creation'!readAISFile: file	"Answer an instance of me with bitmap initialized from the external (compressed) AIS file named fileName."	| form line headerWords height width lineBlt xorBlt |	file readOnly; reset; binary.	file nextWord = 8r102252 ifFalse: [file error: 'invalid AIS (Form) file'].	headerWords _ file nextWord.		"next word is 6 bits of part type and 10 bits of part length"	(file nextWord bitShift: -10) = 1 ifFalse: [self error: 'raster part expected'].	height _ file nextWord.	width _ file nextWord. 	"pixels per scan"	file skip: 4.				"skip scan-direction and samples/pixel"	file nextWord = 2 ifFalse: [self error: 'Compressed-Array encoding expected'].	file nextWord = 1 ifFalse: [self error: '1 bit/sample expected'].	file wordPosition: headerWords.	form _ self extent: width@height.	line _ Form byteScanLineOfWidth: width.	lineBlt _ BitBlt destForm: form sourceForm: line		halftoneForm: nil combinationRule: Form over		destOrigin: 0@0 sourceOrigin: 0@0		extent: width@1 clipRect: form boundingBox. 	xorBlt _ BitBlt destForm: form sourceForm: form		halftoneForm: nil combinationRule: Form reverse		destOrigin: 0@0 sourceOrigin: 0@0		extent: width@1 clipRect: form boundingBox. 	0 to: height-1 do:		[:y |		line bits runDecodeFrom: file. 	"run-decode the bytes"		lineBlt destY: y; copyBits. 		"and xor with previous line"		xorBlt sourceY: y-1; destY: y; copyBits].	file close.	form reverse. 	"since AIS formats consider 0=black"	^form!readFrom: fileName 	"Answer an instance of me with bitmap initialized from the external	file named fileName.  The file format is:  fileCode, extent, offset, bits."	| newForm file w h code whereDataBegins theBits |	file _ (HeaderFileStream fileNamed: fileName) readOnly binary.	newForm _ self new.	Cursor read showWhile:		[		code _ file nextWord.		"reads fileCode"		code = 1		ifFalse:			[  "Unless code matches AIS password, punt (give up)."			code = "-31574" 33962 ifFalse: [file close. ^(self new extent: 8 @ 8) black].			whereDataBegins _ file nextWord.			file nextWord.  "Skip APH"			h _ file nextWord.			"This code won't work too well unless this w is a multiple of 16."			w _ file nextWord.			file wordPosition: whereDataBegins."			newForm offset: 0 @ 0."			]		ifTrue:			[			w _ file nextWord.			h _ file nextWord.			newForm offset: file nextWord @ file nextWord.			].		theBits _ WordArray new: ((w + 15) bitShift: -4) * h.		newForm extent: w @ h offset: 0 @ 0 bits: theBits."		newForm bits: theBits.		newForm white."		theBits fromFileStream: file.		].	file close.	^newForm!readFromStream: fileStream	"Answer an instance of me with bitmap initialized from the external 	fileStream.  The fileStream format is:  fileCode(1), extent, offset, bits."	| newForm newWidth newHeight theBits fileStreamPosition offsetX offsetY next |	fileStream readOnly; binary.	next _ fileStream nextWord.	next = 1 ifFalse: [^(Form new extent: 8 @ 8) black].	"reads fileCode"	newForm _ self new.	newWidth _ fileStream nextWord"ASCII".	newHeight _ fileStream nextWord"ASCII".	newForm extent: newWidth @ newHeight.	offsetX _ fileStream nextWord"ASCII".	offsetY _ fileStream nextWord"ASCII".	offsetX > 32767 ifTrue: [offsetX _ offsetX - 65536].	"stored two's-complement"	offsetY > 32767 ifTrue: [offsetY _ offsetY - 65536].	"stored two's-complement"	theBits _ WordArray new: ((newWidth + 15) bitShift: -4) * newHeight.	newForm extent: newWidth @ newHeight offset: offsetX @ offsetY bits: theBits.	theBits fromFileStream: fileStream.	fileStream text.	^newForm!readFromSuitcase: theSuitcase 	"Answer an instance of me with bitmap initialized from the external	file named in theSuitcase.  The file format is:  fileCode, extent, offset, bits.	If the file has a header, use it to update theSuitcase properly"	| newForm file w h code whereDataBegins theBits |	file _ (HeaderFileStream fileNamed: theSuitcase dataItem filename) readOnly binary.	theSuitcase updateFromHeaderIn: file.	newForm _ self new.	Cursor read showWhile:		[		code _ file nextWord.		"reads fileCode"		code = 1		ifFalse:			[  "Unless code matches AIS password, punt (give up)."			code = "-31574" 33962 ifFalse: [file close. ^(self new extent: 8 @ 8) black].			whereDataBegins _ file nextWord.			file nextWord.  "Skip APH"			h _ file nextWord.			"This code won't work too well unless this w is a multiple of 16."			w _ file nextWord.			file wordPosition: whereDataBegins.			]		ifTrue:			[			w _ file nextWord.			h _ file nextWord.			newForm offset: file nextWord @ file nextWord.			].		theBits _ WordArray new: ((w + 15) bitShift: -4) * h.		newForm extent: w @ h offset: 0 @ 0 bits: theBits.		theBits fromFileStream: file.		].	file close.	^newForm! !!Form class methodsFor: 'mask constants'!masks	^Masks!screen	"Answer the form denoting screen mask."	^screenMask!setScreenMask: aMask 	screenMask _ aMask! !!Cursor class methodsFor: 'class initialization'!initialize	"Create all the standard cursors		Cursor origin		Cursor corner		Cursor read		Cursor write		Cursor wait		Cursor mouse		Cursor blank		Cursor xeq		Cursor square		Cursor normal		Cursor crossHair		Cursor marker		Cursor up		Cursor down		Cursor topRight		Cursor bottomLeft		Cursor grabBar"	OriginCursor _   		(Cursor			extent: 16@16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: -2@-2).	CornerCursor _ 		(Cursor 			extent: 16@16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -14@-14).	ReadCursor _  		(Cursor			extent: 16@16			fromArray: #(		2r0000110000000110		2r0001001000001001		2r0001001000001001		2r0010000000010000		2r0100000000100000		2r1111101111100000		2r1000010000100000		2r1000010000100000		2r1011010110100000		2r0111101111000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0@0).	WriteCursor _ (Cursor	extent: 16@16	fromArray: #(		2r0000000000000110		2r0000000000001111		2r0000000000010110		2r0000000000100100		2r0000000001001000		2r0000000010010000		2r0000000100100000		2r0000001001000011		2r0000010010000010		2r0000100100000110		2r0001001000001000		2r0010010000001000		2r0111100001001000		2r0101000010111000		2r0110000110000000		2r1111111100000000)	offset: 0@0).	WaitCursor _ 		  (Cursor			extent: 16@16			fromArray: #(		2r1111111111111111		2r1100000000000011		2r0110000000000110		2r0011000110001100		2r0001101111011000		2r0000111110110000		2r0000011111100000		2r0000001111000000		2r0000001111000000		2r0000011101100000		2r0000110100110000		2r0001100100011000		2r0011001110001100		2r0110111111000110		2r1101111111110011		2r1111111111111111)			offset: 0@0).	MouseCursor _ 		  (Cursor			extent: 16@16			fromArray: #(		2r1111111111111111		2r1000000000000001		2r1111101111011111		2r1100101111010011		2r1100101111010011		2r1100101111010011		2r1100101111010011		2r1100101111010011		2r1100101111010011		2r1100101111010011		2r1111101111011111		2r1000000000000001		2r1000000000000001		2r1000000000000001		2r1000000000000001		2r1111111111111111)			offset: 0@0).	BlankCursor _ Cursor new.	XeqCursor _ 		(Cursor			extent: 16@16			fromArray: #(		2r0000001000000100		2r0000010010011000		2r0001100010010000		2r0010000100100000		2r1111111111110000		2r1100000000111100		2r1100000000111110		2r1100000000110011		2r1100000000110011		2r1100000000110011		2r1100000000110011		2r1100000000111110		2r1100000000111100		2r1111111111100000		2r0111111111000000		2r0111111111000000)	offset: 0@0).	SquareCursor _ 		(Cursor			extent: 16@16			fromArray: #(		2r0		2r0		2r0		2r0		2r0		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: -8@-8).	NormalCursor _   		(Cursor			extent: 16@16			fromArray: #(		2r1000000000000000		2r1100000000000000		2r1110000000000000		2r1111000000000000		2r1111100000000000		2r1111110000000000		2r1111111000000000		2r1111100000000000		2r1111100000000000		2r1001100000000000		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0@0).	CrossHairCursor _   		(Cursor			extent: 16@16			fromArray: #(		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r1111111111111110		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0)			offset: -7@-7).	MarkerCursor _ 		Cursor			extent: 16@16			fromArray: #(		2r0		2r0		2r0		2r0000001000000000		2r0000001110000000		2r0000001111100000		2r1111111111111000		2r1111111111111110		2r1111111111111000		2r0000001111100000		2r0000001110000000		2r0000001000000000		2r0		2r0		2r0		2r0)			offset: -7@-7.	UpCursor _ 		Cursor 			extent: 16@16			fromArray: #(		2r1000000000000000		2r1100000000000000		2r1110000000000000		2r1111000000000000		2r1111100000000000		2r1111110000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)	 		offset: 0@-7.	DownCursor _		 Cursor 			extent: 16@16			fromArray: #(		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r0000110000000000		2r1111110000000000		2r0111110000000000		2r0011110000000000		2r0001110000000000		2r0000110000000000		2r0000010000000000)			offset: -5@-7.	TopRightCursor _ 		  (Cursor	extent: 16@16	fromArray: #(		2r1111111111111111		2r1111111111111111		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011)	offset: -14@-2).BottomLeftCursor _	(Cursor	extent: 16@16	fromArray: #(		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1111111111111111		2r1111111111111111)	offset: -2@-14).	GrabBarCursor _   		(Cursor			extent: 16@16			fromArray: #(		2r0000000000000000		2r0000000000000000		2r0000000000000000		2r0000000000000000		2r0000000000000000		2r0000100000010000		2r0000110000110000		2r0111111001111111		2r0111111111111111		2r0111111001111111		2r0000110000110000		2r0000100000010000		2r0000000000000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: -8@-8).	GarbageCursor _		(Cursor			extent: 16@16			fromArray: #(		2r0000110000000100		2r1000011000000100		2r1000010001000100		2r1100010011011000		2r0100010110010000		2r0100000010010000		2r0100000010010000		2r0010000010000000		2r0110100000010000		2r0000110100110000		2r0001111111110000		2r0011111111111100		2r0011001111110100		2r0010111100111100		2r0111111101111110		2r1111111111111111)	offset: 0@0)."Cursor initialize"!myInitialize		"Cursor myInitialize"	UpDownCursor _ Cursor				extent: 16 @ 16				fromArray: #(			2r0000000100000000			2r0000001110000000			2r0000011111000000			2r0000111111100000			2r0001111111110000			2r0011111111111000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0011111111111000			2r0001111111110000			2r0000111111100000			2r0000011111000000			2r0000001110000000			2r0000000100000000 )				offset: -7 @ -7.	UpCursor _ Cursor				extent: 16 @ 16				fromArray: #(			2r0000000100000000			2r0000001110000000			2r0000011111000000			2r0000111111100000			2r0001111111110000			2r0011111111111000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000000000000000			2r0000000000000000)				offset: -7 @ -7.	DownCursor _ Cursor				extent: 16 @ 16				fromArray: #(			2r0000000000000000			2r0000000000000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0000011111000000			2r0011111111111000			2r0001111111110000			2r0000111111100000			2r0000011111000000			2r0000001110000000			2r0000000100000000)				offset: -7 @ -7! !!Cursor class methodsFor: 'constants'!bottomLeft	"Answer the instance of me that is the shape of the bottom left corner of a 	rectangle. "	^BottomLeftCursor!garbage	^GarbageCursor!grabBar	"Answer the instance of me that is a grab bar."	^GrabBarCursor!mouse	"Answer the instance of me that is the shape of mouse."	^MouseCursor!topRight	"Answer the instance of me that is the shape of the top right corner of a 	rectangle. "	^TopRightCursor!upDown	"Answer the instance of me that is the shape of an updowncursor."	^UpDownCursor! !!MapForm class methodsFor: 'instance creation'!new	^super new latLonBox: (0.0@0.0 extent: 45.0@45.0)! !!Matrix class methodsFor: 'instance creation'!new: rows by: columns	"Produce a new Matrix, a collection of rows and columns.  The actual Matrix is an OrderedCollection of Orderedcollections.  "	| theNewMatrix |	theNewMatrix _ super new.	theNewMatrix collection: (Array new: rows * columns).	theNewMatrix xySize: columns @ rows.	^theNewMatrix!readFromString: aString	| newMatrix cr aStream wid hgt |	cr _ Character cr.	aStream _ ReadStream on: aString.	wid _ (aStream upTo: cr) asNumber.	hgt _ (aStream upTo: cr) asNumber.	newMatrix _ Matrix new: hgt by: wid.	1 to: wid do: [:x |		1 to: hgt do: [:y | 			newMatrix atPoint: x @ y put: (aStream upTo: cr) asNumber]].	^newMatrix! !!Matrix class methodsFor: 'examples'!example	"Matrix example"	"Matrix example upperTriangularForm"	"Matrix example determinant"	"Matrix example invert * Matrix example"	| mat |	mat _ Matrix new: 3 by: 3.	mat atPoint: 1 @ 1 put: 3.	mat atPoint: 1 @ 2 put: 5.	mat atPoint: 1 @ 3 put: 9.	mat atPoint: 2 @ 1 put: 1.	mat atPoint: 2 @ 2 put: -4.	mat atPoint: 2 @ 3 put: 2.	mat atPoint: 3 @ 1 put: 6.	mat atPoint: 3 @ 2 put: 1.	mat atPoint: 3 @ 3 put: -8.	^mat! !SpreadsheetHolder class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SpreadsheetHolder class methodsFor: 'class initialization'!initialize	"SpreadsheetHolder initialize."	AllHoldersDict _ SpreadsheetDictionary new.! !!SpreadsheetHolder class methodsFor: 'instance creation'!new: rows by: columns	| sheet cellSpace xGrid yGrid | 	sheet _ super new: rows by: columns.	sheet nilCell: ((SpreadsheetCell in: sheet) xcell: 0; ycell: 0).	sheet setTo: sheet nilCell.	xGrid _ Array new: columns.	yGrid _ Array new: rows.	1 to: columns do: [:cell | xGrid at: cell put: (cell * 90)].	1 to: rows do: [:cell | yGrid at: cell put: (cell * 25)].	sheet xGrid: xGrid.	sheet yGrid: yGrid.	sheet badRef: ('---------------' asForm offset: -5 @ -5).	sheet clearUpdates.	^sheet!readFrom: aStream 	"Create a new SpreadsheetHolder from aStream."	| rows columns cell newHolder allFrame xGrid yGrid allRules aRule references code contents referencesSize refSize theRef refSymb frameSize |	Cursor read show.	"read the elements for reconstruction of all literal frames in rules"	aStream peek = $N		ifTrue: "new file format"			[allFrame _ OrderedCollection new: 100.			[aStream peek = $N] whileTrue:				[aStream next.				frameSize _ (aStream upTo: Character cr) asNumber.				allFrame _ allFrame, (Compiler evaluate: (aStream next: frameSize)).				aStream next]]		ifFalse: "old file format"			[allFrame _ Compiler evaluate: (aStream upTo: Character cr)].	"read the cell gridding"	xGrid _ Compiler evaluate: (aStream upTo: Character cr).	yGrid _ Compiler evaluate: (aStream upTo: Character cr).	"create the new holder"	newHolder _ SpreadsheetHolder new: yGrid size by: xGrid size.	newHolder xGrid: xGrid; yGrid: yGrid.	"read and reconstuct all rules.  read references, then reconstruct literal frame, then reproduce rest of rule from bytecodes"	(aStream atEnd or: [aStream peek ~= $<])		ifFalse: 			[allRules _ OrderedCollection new.			[aStream peek = Character newPage]				whileFalse: 					[aStream upTo: Character cr.					aRule _ SpreadsheetRule new.					references _ OrderedCollection new.					referencesSize _ (aStream upTo: Character space) asNumber.					1 to: referencesSize do: 						[:index | 						refSize _ (aStream upTo: Character space) asNumber.						theRef _ Array new: refSize.						refSymb _ aStream upTo: Character space.						theRef at: 1 put: ((refSymb at: 1) = $'								ifTrue: [refSymb copyFrom: 2 to: refSymb size - 1]								ifFalse: [refSymb asSymbol]).						2 to: theRef size do: [:innerdex | theRef at: innerdex put: (aStream upTo: Character space) asNumber].						references add: theRef].					aStream next.					"Gobble cr"					aRule references: references.					aRule string: (aStream upTo: 160 asCharacter).					aStream next.					"Gobble cr"					aRule compileCodeFrom: (aStream upTo: Character cr)						with: allFrame.					allRules add: aRule]].	"read the cell's location, insert the contents and point at the proper rule"	[aStream atEnd or: [aStream peek ~= Character newPage]]		whileFalse: 			[aStream next.			"Gobble newPage (signifies beginning of new cell)"			(cell _ SpreadsheetCell new) holder: newHolder.			cell xcell: (aStream upTo: $@) asNumber.			cell ycell: (aStream upTo: Character cr) asNumber.			cell updateFlag: false.			code _ aStream next.			aStream next.			"Gobble space"			"optimize read in on most used objects and special cases"			self setContentsOf: cell from: aStream withCode: code inHolder: newHolder.			aStream upTo: Character space.			aRule _ (aStream upTo: Character cr) asNumber.			aRule = 0 ifFalse: [cell rule: (allRules at: aRule)].			newHolder				atRow: cell ycell				column: cell xcell				put: cell].	newHolder setAllRules.	aStream close.	Cursor normal show.	^newHolder! !!SpreadsheetHolder class methodsFor: 'accessing instances'!allSheets	"return the spreadsheet dictionary holding all active sheets"	"SpreadsheetHolder allSheets inspect"	^AllHoldersDict! !!SpreadsheetHolder class methodsFor: 'private'!contentsFrom: aStream	| contents | 	contents _ aStream upTo: $>.	[aStream peek ~= $R]		whileTrue: [contents _ contents , (aStream upTo: $>)].	^contents!setContentsOf: cell from: aStream withCode: code inHolder: newHolder 	code = $* ifTrue: [cell contents: (Compiler evaluate: (self contentsFrom: aStream))].	code = $B ifTrue: [cell contents: newHolder badRef].	code = $N ifTrue: [cell contents: (self contentsFrom: aStream) asNumber].	code = $S ifTrue: [cell contents: (String readFromString: (self contentsFrom: aStream))].	code = $L ifTrue: [cell contents: (Label fromString: (self contentsFrom: aStream))].	code = $Y ifTrue: [cell contents: (self contentsFrom: aStream) asSymbol].	code = $F ifTrue: [cell contents: (FileStream fileNamed: ((self contentsFrom: aStream)					copyUpTo: Character cr)) readWrite].	code = $D ifTrue: [cell contents: (ClassifiedFixedFileStream fileNamed: ((self contentsFrom: aStream)					copyUpTo: Character cr))].	code = $t ifTrue: [cell contents: true].	code = $f ifTrue: [cell contents: false].	code = $n ifTrue: [cell contents: nil].	code = $P		ifTrue: 			[cell contents: (Form readFromStream: aStream)]! !!SparseMatrix class methodsFor: 'instance creation'!new: rows by: columns	"Produce a new SparseMatrix, a collection of rows and columns.  The actual SparseMatrix is an dictionary of dictionaries."	| theNewMatrix |	theNewMatrix _ super new.	theNewMatrix collection: OopConservingDictionary new.	theNewMatrix xySize: columns @ rows.	^theNewMatrix! !!AdjacencyMatrix class methodsFor: 'instance creation'!new	| theNewMatrix | 	theNewMatrix _ super new.	theNewMatrix collection: OopConservingDictionary new.	theNewMatrix numberOfNodes: 0.	^theNewMatrix!withNodes: numberOfNodes	"Produce a new AdjacencyMatrix for a number of nodes equal to numberOfNodes"	| theNewMatrix |	theNewMatrix _ self new: numberOfNodes.	theNewMatrix numberOfNodes: numberOfNodes.	^theNewMatrix! !!AdjacencyMatrix class methodsFor: 'examples'!example	| theAdjMatrix |	theAdjMatrix _ AdjacencyMatrix withNodes: 9.	theAdjMatrix connect: 1 to: 2.	theAdjMatrix connect: 1 to: 3.	theAdjMatrix connect: 2 to: 3.	theAdjMatrix connect: 2 to: 4.	theAdjMatrix connect: 3 to: 5.	theAdjMatrix connect: 4 to: 7.	theAdjMatrix connect: 5 to: 6.	theAdjMatrix connect: 5 to: 7.	theAdjMatrix connect: 5 to: 8.	theAdjMatrix connect: 5 to: 9.	theAdjMatrix connect: 6 to: 7.	theAdjMatrix connect: 6 to: 9.	theAdjMatrix connect: 7 to: 8.	theAdjMatrix connect: 8 to: 9.^theAdjMatrix"AdjacencyMatrix example shortestPathFrom: 1 to: 9""AdjacencyMatrix example longestPathFrom: 1 to: 9""AdjacencyMatrix example spanningTree""AdjacencyMatrix example graphIsConnected"!example2	| theAdjMatrix |	theAdjMatrix _ AdjacencyMatrix withNodes: 9.	theAdjMatrix connect: 1 to: 2 withWeight: 1.	theAdjMatrix connect: 1 to: 3 withWeight: 2.	theAdjMatrix connect: 2 to: 3 withWeight: 1.	theAdjMatrix connect: 2 to: 4 withWeight: 3.	theAdjMatrix connect: 3 to: 5 withWeight: 1.	theAdjMatrix connect: 3 to: 6 withWeight: 4.	theAdjMatrix connect: 4 to: 7 withWeight: 1.	theAdjMatrix connect: 5 to: 6 withWeight: 1.	theAdjMatrix connect: 5 to: 7 withWeight: 3.	theAdjMatrix connect: 5 to: 8 withWeight: 1.	theAdjMatrix connect: 5 to: 9 withWeight: 1.	theAdjMatrix connect: 6 to: 7 withWeight: 1.	theAdjMatrix connect: 6 to: 9 withWeight: 18.	theAdjMatrix connect: 7 to: 8 withWeight: 1.	theAdjMatrix connect: 8 to: 9 withWeight: 1.^theAdjMatrix"AdjacencyMatrix example2 shortestPathFrom: 1 to: 9""AdjacencyMatrix example2 longestPathFrom: 1 to: 9""AdjacencyMatrix example2 graphIsATree""AdjacencyMatrix example2 graphIsConnected"!example3	| theAdjMatrix |	theAdjMatrix _ AdjacencyMatrix withNodes: 4.	theAdjMatrix connect: 1 to: 2.	theAdjMatrix connect: 1 to: 3.	theAdjMatrix connect: 1 to: 4.	theAdjMatrix connect: 2 to: 1.	theAdjMatrix connect: 2 to: 3.	theAdjMatrix connect: 2 to: 4.	theAdjMatrix connect: 3 to: 1.	theAdjMatrix connect: 3 to: 2.	theAdjMatrix connect: 3 to: 4.	theAdjMatrix connect: 4 to: 1.	theAdjMatrix connect: 4 to: 2.	theAdjMatrix connect: 4 to: 3.^theAdjMatrix"AdjacencyMatrix example3 graphIsRegular""AdjacencyMatrix example3 graphIsComplete""AdjacencyMatrix example3 graphIsATree""AdjacencyMatrix example3 graphIsConnected""AdjacencyMatrix example3 addNode"! !!AdjacencyMatrix class methodsFor: 'private'!new: rows	"Produce a new AdjacencyMatrix, a collection of rows and columns.  The actual Matrix is an OrderedCollection of Orderedcollections.  "	| theNewMatrix |	theNewMatrix _ super new: rows by: rows.	theNewMatrix numberOfNodes: 0.	^theNewMatrix! !!ClipBuffer class methodsFor: 'initialization'!initialize	| newClip | 	"ClipBuffer initialize"	Smalltalk at: #Clipboard put: (newClip _ self new).	newClip doNotShow; noStacking! !!ClipBuffer class methodsFor: 'clipboard control panel'!openCommandBar	"ClipBuffer openCommandBar"	| label centers formsModel |	label _ #Clipboard asString.	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: FormsModel)			and: [each model name = label]].	formsModel _ FormsModel named: label.	formsModel		addControlPanel: ExecuteElement		labels: #(show hide LIFO FIFO single 'drop one' clear)		messages: #( show doNotShow lastInFirstOut firstInFirstOut noStacking retrieve clear)		targetController: Clipboard		boundingBox: (0@0 extent: 440@30).	FormsView		openOn: formsModel		backgroundColor: Form lightGray! !!ClipBuffer class methodsFor: 'instance creation'!new	^super new initialize! !!RS232DisplayLine class methodsFor: 'As yet unclassified'!emptyLine: lineLength	^(self new initialize: lineLength)!initialize	"RS232DisplayLine initialize"	BlankString _ String new: 200 withAll: $ .! !!ClassOrganizer class methodsFor: 'system compression'!rehash	"Create CachedClassNames (IdentityDictionary) and Store (OrderedCollection) if they don't already exist. If they do already exist, there may be holes where entries got allocated, but then deallocated."	| categoriesString className index newStore newSerialNumber newCachedClassNames |	newSerialNumber _ 0.	CachedClassNames == nil ifTrue: [CachedClassNames _ IdentityDictionary new.].	newCachedClassNames _ IdentityDictionary "new: (100 max: CachedClassNames size * 2)" new.	newStore _ Array new: CachedClassNames size * 8 + 1.	CachedClassNames associationsDo:		[:each |		"I only want to copy valid stuff to newCachedClassNames and newStore. If something has gotten screwed up, there is a remote possibility that the CachedClassNames dictionary contains a name which no longer exists as a global, and there is even a remote posibility that the name is indeed in use as a global, but as the name of something else, so I check not only to see whether the name is in the SystemDictionary, but also to be sure that the name really does represent the name of a class."		((Smalltalk at: each key ifAbsent: [nil]) class isKindOf: Metaclass) ifTrue:			[index _ each value - 1 * 8 + 2.			((Store at: index + 3) == nil and: [(Store at: index + 7) == nil.]) ifFalse:				[newCachedClassNames at: each key put: (newSerialNumber _ newSerialNumber + 1).				newStore					replaceFrom: newSerialNumber - 1 * 8 + 2					to: newSerialNumber * 8 + 1					with: Store					startingAt: index.				]			].		].	newStore at: 1 put: newSerialNumber.	Store _ newStore asOrderedCollection.	CachedClassNames _ newCachedClassNames.! !!FileList class methodsFor: 'instance creation'!open	"FileList open"	"Create and schedule a view of a new instance of me such that the instance references the files named in the argument, aFileNameList, that can be found in the directory, aFileDirectory."	| topView aFileList patternView |	aFileList _ self new list: OrderedCollection new.	topView _ StandardSystemView model: aFileList label: 'File List' minimumSize: 200 @ 200.	patternView _		CodeView on: aFileList aspect: #pattern change: #acceptPattern:from:				menu: #patternMenu initialSelection: nil.	topView addSubView: patternView in: (0@0 extent: 1@0.07) borderWidth: 1.	patternView controller: BigAlwaysAcceptCodeController new.	topView addSubView:			(SelectionInListView on: aFileList aspect: #fileName change: #fileName:				list: #fileNameList menu: #fileListMenu initialSelection: #fileName)		in: (0@0.07 extent: 1@0.23) borderWidth: 1.	topView addSubView:			(OnlyWhenSelectedCodeView on: aFileList aspect: #text change: #acceptText:from:				menu: #textMenu initialSelection: nil selection: #isSelected)		in: (0@0.3 extent: 1@0.7) borderWidth: 1.	topView controller open! !!Querier class methodsFor: 'initialization'!initialize	"Querier initialize" "Sets up the constant lists of operators and conjunctions."	MenuFont _ TextStyle default fontAt: (TextStyle getNumForStrikeFont: 'Helvetica12').	OperatorList _ #( '<' '>' '=' '<=' '>=' '~' 'contains' 'doesntContain' ).	OperatorMenu _ PopUpMenu new		labels: 'backspace\cancel\<\>\=\<=\>=\~\contains\~contains' withCRs		font: MenuFont		lines: #( 2 ).	ValueMenu _ PopUpMenu new		labels: 'backspace\cancel\enter value' withCRs		font: MenuFont		lines: #( 2 ).	ConjunctionList _ #( 'and' 'or' 'xor' ).	ConjunctionMenu _ PopUpMenu new		labels: 'backspace\cancel\ACCEPT\and\or\xor' withCRs		font: MenuFont		lines: #( 2 3 )! !!Querier class methodsFor: 'instance creation'!request: aString withFields: fieldNames types: fieldTypes	"Create an instance, and return the string it got from the user."	| aQuerier |	aQuerier _ self new initializeWithFields: fieldNames types: fieldTypes.	QuerierView openOn: aQuerier message: aString.	^ aQuerier contents! !!Querier class methodsFor: 'examples'!example	"Open up a sample Querier, which will return the finished query."	^ Querier request: 'Hi. I''m a Querier.  Enter your query:'		withFields: #( 'Field1' 'Field2' 'Field3' 'Zog' )		types: #( 'string' 'number' 'string' 'number' )	"Querier example."    "<-- Execute this with PrintIt"! !!SimpleQuerier class methodsFor: 'instance creation'!request: aString withFields: fieldNames	"Create an instance, and return the string it got from the user."	"SimpleQuerier request:'Enter fields' withFields:#('a' 'b' 'c' 'd' 'e' 'f' 'g' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'a' 'b' 'c' 'd' 'e' 'f' 'g')"	| aSimpleQuerier |	aSimpleQuerier _ self new initializeWithFields: fieldNames.	QuerierView openOn: aSimpleQuerier message: aString.	^ aSimpleQuerier contents! !!KeywordQuerier class methodsFor: 'initialization'!initialize	"KeywordQuerier initialize"	LogicList _ #( 'and' 'or' 'and not' 'or not' ).	LogicMenu _ PopUpMenu new		labels: 'backspace\cancel\ACCEPT\and\or\and not\or not' withCRs		font: MenuFont		lines: #( 2 3 ).	^super initialize! !!KeywordQuerier class methodsFor: 'instance creation'!request: aString withFields: fieldNames	"Create an instance, and return the string it got from the user."	"KeywordQuerier request:'Enter fields' withFields:#('a' 'b' 'c' 'd' 'e' 'f' 'g' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'a' 'b' 'c' 'd' 'e' 'f' 'g')"	| aKeywordQuerier |	aKeywordQuerier _ self new initializeWithFields: fieldNames.	QuerierView openOn: aKeywordQuerier message: aString.	^  aKeywordQuerier answers! !!UserProfile class methodsFor: 'class initialization'!initialize	"UserProfile initialize."	"Set the default user profile attributes."	DefaultUserName _ 'userName'.	DefaultRegistry _ nil. "means no Grapevine"	DefaultPrinterName _ 'printerName'.	DefaultIFSName _ 'IFSName'.	CurrentProfile _ self new.! !!SerialPort class methodsFor: 'class intialization'!initialize	ParameterIndices _ OopConservingDictionary new.	ParameterIndices at: #lineType put: 2.	ParameterIndices at: #lineSpeed put: 3.	ParameterIndices at: #characterLength put: 4.	ParameterIndices at: #stopBits put: 5.	ParameterIndices at: #parity put: 6.	ParameterIndices at: #frameTimeout put: 7.	ParameterIndices at: #syncCharacter put: 8.	ParameterIndices at: #syncCount put: 9.	ParameterIndices at: #dataTerminalReady put: 11.	ParameterIndices at: #requestToSend put: 12.	ParameterIndices at: #dataSetReady put: 13.	ParameterIndices at: #clearToSend put: 14.	ParameterIndices at: #dataCarrierDetect put: 15.	ParameterIndices at: #breakDetected put: 16.	ParameterIndices at: #sendBreak put: 17.	ParameterIndices at: #bufferSize put: 21.	ParameterIndices at: #numOfInputBuffers put: 22.	ParameterIndices at: #numOfOutputBuffers put: 23.	ParameterIndices at: #thresholdNumOfInput put: 31.	ParameterIndices at: #inputRequestTimeout put: 32.	"SerialPort initialize"! !!SerialPort class methodsFor: 'public accessing'!maxPortNumber	"Answer the number of ports available on the machine."	<primitive: 200>		^0! !AsyncSerialPort class comment:'Copyright (c) Xerox Corporation, 1985, 1986.'!!AsyncSerialPort class methodsFor: 'initialize'!initialize	NoData _ -1.	"this is just to have a non ascii character to return from nextByte to indicate that no data was received"!NoData	^NoData! !Test1108AsyncSerialPort class comment:'Copyright (c) Xerox Corporation, 1985, 1986.'!!Test1108AsyncSerialPort class methodsFor: 'avoid primitive'!maxPortNumber	^1! !!FileStream class methodsFor: 'instance creation'!openFile: fileDesignator list: aListOfFileDirectories	"Look for the file named 'fileDesignator' in each of the directories in aListOfFileDirectories until a directory is found which contains the file. Answer a FileStream on a File designated by the string fileDesignator."	^self fileNamed: (self getFileName: fileDesignator list: aListOfFileDirectories)!openNewFile: fileDesignator list: aListOfFileDirectories	"Look for the file named 'fileDesignator' in each of the directories in aListOfFileDirectories until a directory is found which contains the file. Answer a FileStream on a new File designated by the string fileDesignator."	^self newFileNamed: (self getFileName: fileDesignator list: aListOfFileDirectories)!openOldFile: fileDesignator list: aListOfFileDirectories	"Look for the file named 'fileDesignator' in each of the directories in aListOfFileDirectories until a directory is found which contains the file. Answer a FileStream on an old File designated by the string fileDesignator."	| fName |	(fName _ self getOldFileName: fileDesignator list: aListOfFileDirectories) == nil ifTrue: [^nil].	^self oldFileNamed: fName! !!FileStream class methodsFor: 'file names'!getFileName: fileDesignator list: aListOfFileDirectories	"Look for the file named 'fileDesignator' in each of the directories in aListOfFileDirectories until a directory is found which contains the file. Return the file's full name."	| fullName |	fullName _ self trivialFullName: fileDesignator list: aListOfFileDirectories.	fullName == nil ifFalse: [^fullName].	fullName _ self getOldFileName: fileDesignator list: aListOfFileDirectories.	fullName == nil ifTrue:	"The file wasn't found in any of the directories. Name a new one"		[fullName _ aListOfFileDirectories first, fileDesignator.].	^fullName!getNewFileName: fileDesignator list: aListOfFileDirectories	"Answer the fullname of a new File designated by the string fileDesignator, or nil if the argument is not a new file name."	| fiddledList |	fiddledList _ (self isRoot: fileDesignator)		ifTrue: [Array with: String new.]		ifFalse: [aListOfFileDirectories.].	^(self getNamesOfDirectoriesContaining: fileDesignator list: fiddledList) isEmpty		ifTrue: [fiddledList first, fileDesignator.]		ifFalse: [nil.]!getOldFileName: fileDesignator list: aListOfFileDirectories	"Return the full name of the file, or nil."	| fiddledList |	fiddledList _ (self isRoot: fileDesignator)		ifTrue: [Array with: String new.]		ifFalse: [aListOfFileDirectories.].	^self tryToGetFileNameFrom: fileDesignator list: fiddledList! !!FileStream class methodsFor: 'utilities'!isRoot: aFileName	| aCharacter |	aCharacter _ aFileName at: 1. 	aCharacter == $/ ifTrue: [^true].	aCharacter == $< ifTrue: [^true].	aCharacter == $[ ifTrue: [^true].	^false!trivialFullName: fileDesignator list: aListOfFileDirectories	(self isRoot: fileDesignator) ifTrue: [^fileDesignator].	aListOfFileDirectories size = 1 ifTrue:		[^aListOfFileDirectories first, fileDesignator].	^nil! !!FileStream class methodsFor: 'private'!findDirectoryForFileNamed: fullName andEvaluateThisBlock: directoryAndNameBlock	| dir fName |	(FileDirectory respondsTo: #forName:setDirectoryAndNameIn:)		ifTrue: [FileDirectory forName: fullName setDirectoryAndNameIn: directoryAndNameBlock.]		ifFalse:			[dir _ FileDirectory				directoryFromName: fullName				setFileName: [:dummy | fName _ dummy].			directoryAndNameBlock value: dir value: fName.			].!getNamesOfDirectoriesContaining: aFileName list: aListOfFileDirectories	"Look for the file named 'aFileName' in each of the directories in aListOfFileDirectories. Return a list of the directories which contain the file."	| "file" fiddledName result | 	result _ OrderedCollection new.	(fiddledName _ aFileName) last = $. ifTrue:		[fiddledName _ aFileName copyFrom: 1 to: aFileName size - 1].	aListOfFileDirectories do:		[:eachDirectoryName |		self			findDirectoryForFileNamed: eachDirectoryName, fiddledName			andEvaluateThisBlock:				[:dir :fName |				"file _ dir find: (dir initFileName: fName).				file == nil ifFalse: [result add: eachDirectoryName.]."				(dir includesKey: fName) ifTrue: [result add: eachDirectoryName.].				].		].	^result!tryToGetFileNameFrom: fileDesignator list: aListOfFileDirectories	"Look for the file named 'fileDesignator' in each of the directories in aListOfFileDirectories until a directory is found which contains the file."	aListOfFileDirectories do:		[:eachDirectoryName |		self			findDirectoryForFileNamed: eachDirectoryName, fileDesignator			andEvaluateThisBlock:				[:dir :fName | (dir includesKey: fName) ifTrue: [^fName].].		].	"The file wasn't found in any of the directories."	^nil! !!Number class methodsFor: 'instance creation'!readNumberFrom: aStream 	" Answer an instance of Number as described on the stream, aStream. Skip leading spaces."	| denominator fracpos fraction negative value |	"skip leading spaces"	[aStream peekFor: Character space] whileTrue.	"now read the number"	negative _ aStream peekFor: $-.	value _  (aStream peekFor: $.) ifTrue: [aStream skip: -1. 0] ifFalse: [Integer readFrom: aStream].	(aStream peekFor: $.)		ifTrue: 			[fracpos _ aStream position.			fraction _ Integer readFrom: aStream radix: 10.			fracpos _ aStream position - fracpos.			denominator _ 10.0 raisedTo: fracpos.			fraction _ fraction asFloat / denominator.			value _ value asFloat + fraction			].	^negative ifTrue: [value negated] ifFalse: [value]! !!Date class methodsFor: 'instance creation'!readFrom: aStream	"Read a Date from the stream in any of the forms:		<day> <monthName> <year>		(5 April 1982; 5-APR-82)		<monthName> <day> <year>		(April 5, 1982)		<monthNumber> <day> <year>	(4/5/82)"	| day month |	aStream atEnd ifTrue: [^UnknownDate new].	aStream peek = $u ifTrue:[^UnknownDate new].	aStream peek isDigit ifTrue: [day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1.  aStream atEnd ifTrue:[^UnknownDate new]].	aStream peek isLetter		ifTrue:		"number/name... or name..."			[month _ WriteStream on: (String new: 10).			[aStream peek isLetter] whileTrue: [month nextPut: aStream next].			month _ month contents.			day isNil ifTrue:		"name/number..."				[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].				day _ Integer readFrom: aStream]]		ifFalse:		"number/number..."			[month _ Date nameOfMonth: day.			day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	^self newDay: day month: month year: (Integer readFrom: aStream)	"Date readFrom: (ReadStream on: '5APR82')"! !!Time class methodsFor: 'instance creation'!readFrom: aStream	"Read a Time from the stream in the form:		<hour>:<minute>:<second> <am/pm>	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"	| hour minute second |	aStream atEnd ifTrue: [^UnknownTime new].	aStream peek = $u ifTrue:[^UnknownTime new].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1.  aStream atEnd ifTrue:[^UnknownTime new]].	hour _ Integer readFrom: aStream.	minute _ 0.	second _ 0.	(aStream peekFor: $:) ifTrue:		[minute _ Integer readFrom: aStream.		(aStream peekFor: $:) ifTrue:			[second _ Integer readFrom: aStream]].	aStream skipSeparators.	(aStream atEnd not and: [aStream peek isLetter])		ifTrue:			[aStream next asLowercase = $p				ifTrue: [hour < 12 ifTrue: [hour _ hour + 12]]				ifFalse: [hour >= 12 ifTrue: [hour _ hour - 12]].			(aStream peekFor: $m) ifFalse: [aStream peekFor: $M]].	^self fromSeconds: 60*(60*hour+minute)+second	"Time readFrom: (ReadStream on: '12pm')"! !!ZonedTime class methodsFor: 'private'!currentTime: formatted atZone: zone	"If formatted is #seconds, answer with the total seconds from Jan 1 1901 	corrected for time zone and daylight savings time.	Otherwise, answer an array of (Date today, Time now)."	| secondCount d dd t dfirst dlast m570 m571 |	secondCount _ LargePositiveInteger new: 4.	self secondClockInto: secondCount.	secondCount _ secondCount truncated.	zone < 0		ifTrue: "American DST calculation"			[m571 _ 305. "October 31"			m570 _ ((0 - zone) bitShift: 11) bitOr: 121 "April 30"]		ifFalse: "European DST calculation"			[m571 _ 274. "September 30"			m570 _ ((zone bitShift: 11) bitOr: 91"March 31") - 32768].  	"adjust for time zone"	secondCount _ 		secondCount 			+ ((m570 >= 0					ifTrue: [-1]	"west"					ifFalse: [1]	"east")				* (3600 * ((m570 bitAnd: 30720) bitShift: -11) 							+ (60 * ((m571 bitAnd: 32256) bitShift: -9)))).	"Guess the number of days since Jan 1 1901."	d _ Date fromDays: secondCount // 86400.	"The formatted test makes it possible to skip some work if all you want is to correct 	the total number of seconds.  secondCount \\ 86400 is the number of seconds that	were left over from the estimate of days"	formatted==#seconds ifFalse: [t _ Time fromSeconds: secondCount \\ 86400].	"check for daylight savings time (DST). correct DST parameters for nonleap 	years and round to previous Sunday if necessary"	"day of the year on or before which DST takes effect"	dfirst _ m570 bitAnd: 511.	(dfirst = 366		ifTrue: [false"DST not in effect"]		ifFalse: [(dd _ d day) >= (dfirst _ dfirst + d leap - 1)				ifTrue: 					["day of the year on or before which DST ends"					dlast _ (m571 bitAnd: 511) + d leap - 1.					dd < dlast and: 						[dd < ((Date newDay: dlast year: d year)								previous: #Sunday) day]]				ifFalse: ["possibly earlier than or at beginning of range"						dd >= ((Date newDay: dfirst year: d year)								previous: #Sunday) day]])		ifTrue: [formatted==#seconds					ifTrue: ["daylight savings time in effect. add an hour"							secondCount _ secondCount + 3600]					ifFalse: [t hours = 23								ifTrue: 									[d _ d addDays: 1.									t hours: 0]								ifFalse: [t hours: t hours + 1]]].	formatted==#seconds		ifTrue: [^secondCount]		ifFalse: [^Array with: d with: t]!dateAndTimeNowAtZone: zone	"Replies with date and time array offset by zone hours from GMT (see ZonedTime nowAtZone:)"	^self currentTime: #dateAndTime atZone: zone!nowAtZone: zone	"Replies with a new instance of time offset from GMT by zone hours (i.e., west coast's zone is -8)"	^(self dateAndTimeNowAtZone: zone) at: 2!todayAtZone: zone	"Returns today's date at the time zone"	^(self dateAndTimeNowAtZone: zone) at: 1! !Chart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Chart class methodsFor: 'class initialization'!initialize"	Chart initialize.	""Set up the various colors (patterns) to be used in charts."	MaskArray _ Form masks.! !!Chart class methodsFor: 'instance creation'!new	"set default behaviors for a new pie chart."	| newSelf | 	newSelf _ super new.	newSelf isLabeled: false.	newSelf labeledByPercent: false.	newSelf isFilled: false.	newSelf isAutoScaled: true.	newSelf isLegended: false.	newSelf title: nil.	newSelf emphasis: 13.	newSelf maskArray: (1 to: MaskArray maxAscii - MaskArray minAscii + 1).	^newSelf! !PieChart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!PieChart class methodsFor: 'examples'!example	"produces a simple pie chart in the upper left corner of the screen. labeled by percent values."	| aPie aRectangle aForm |	aRectangle _ Rectangle fromUser.	aForm _ Form fromDisplay: aRectangle.	aForm white.	aPie _ PieChart new.	aPie isLabeled:true.	aPie labeledByPercent:true.	aPie isFilled:true.	aPie labelArray:#('820' 'Dorado' 'Dolphin' 'Dandelion' 'Daffodil').	aPie dataArray: #(1 3 5 7 9).	aPie title: '     Zerox (not Xerox) Sales'.	aPie displayOn: aForm .	aForm displayOn: Display at: 0@0.	"PieChart example."! !BarChart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!BarChart class methodsFor: 'examples'!example	"produces a simple Bar chart in the upper left corner of the screen. labeled by percent values."	| aBar aRectangle aForm |	aRectangle _ Rectangle fromUser.	aForm _ Form fromDisplay: aRectangle.	aBar _ BarChart new.	aBar isLabeled:true.	aBar isLegended:true.	aBar labeledByPercent:true.	aBar isFilled:true.	aBar labelArray:#('820' 'Dorado' 'Dolphin' 'Dandelion' 'Daffodil' ).	aBar dataArray: #(10 30 65 15 80).	aBar title: '     Zerox (not Xerox) Sales'.	aBar displayOn: aForm .	aForm displayOn: Display at: 0@0.	"BarChart example."! !StackedBarChart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!StackedBarChart class methodsFor: 'examples'!example	"produces a simple Bar chart in the upper left corner of the screen. labeled by percent values."	| aStackedBar aRectangle aForm |	aRectangle _ Rectangle fromUser.	aForm _ Form fromDisplay: aRectangle.	aStackedBar _ StackedBarChart new.	aStackedBar isLabeled:true.	aStackedBar isLegended:true.	aStackedBar labelsInStack: #('internal' 'external' 'arboreal' 'ethereal' 'kickback' 'lossleader' 'loss').	aStackedBar labelArray:#('820' 'Dorado' 'Dolphin' 'Dandelion' 'Daffodil' ).	aStackedBar dataArray: #(#(5 5 1 2 3 4 5) #(10 15 2 4 6 8 10) #(50 15 3 6 9 12 15) #(10 25 4 8 12 16 20) #(11 80 1 2 4 8 16)).	aStackedBar title: '     Zerox (not Xerox) Sales'.	aStackedBar displayOn: aForm .	aForm displayOn: Display at: 0@0.	"StackedBarChart example."! !XYChart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!XYChart class methodsFor: 'examples'!example	| aXY aRectangle aForm |	aRectangle _ Rectangle fromUser.	aForm _ Form fromDisplay: aRectangle.	aXY _ XYChart new.	aXY dataArray: #(10 30 65 15 80 90).	aXY title: '     Zerox (not Xerox) Sales'.	aXY displayOn: aForm .	aForm displayOn: Display at: 0@0.	"XYChart example."! !!XYChart class methodsFor: 'instance creation'!new	| newXY | 	newXY _ super new.	newXY type: #dot.	newXY dot: (Form dotOfSize: 4).	^newXY! !StackedLineChart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!StackedLineChart class methodsFor: 'examples'!example	"produces a Stacked Line chart in the upper left corner of the screen."	| aStackedLine aRectangle aForm |	aRectangle _ Rectangle fromUser.	aForm _ Form fromDisplay: aRectangle.	aStackedLine _ StackedLineChart new.	aStackedLine isLabeled:true.	aStackedLine isLegended:true.	aStackedLine labelsInStack: #('internal' 'external' 'arboreal' 'ethereal' 'kickback' 'lossleader' 'loss').	aStackedLine labelArray:#('820' 'Dorado' 'Dolphin' 'Dandelion' 'Daffodil' ).	aStackedLine dataArray: #(#(5 5 1 2 3 4 5) #(10 15 2 4 6 8 10) #(50 15 3 6 9 12 15) #(10 25 4 8 12 16 20) #(11 80 1 2 4 8 16)).	aStackedLine title: '     Zerox (not Xerox) Sales'.	aStackedLine displayOn: aForm .	aForm displayOn: Display at: 0@0.	"StackedLineChart example."! !ClusteredBarChart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!ClusteredBarChart class methodsFor: 'examples'!example	"produces a simple Bar chart in the upper left corner of the screen. labeled by percent values."	| aClusteredBar aRectangle aForm |	aRectangle _ Rectangle fromUser.	aForm _ Form extent: ((aRectangle width) @ (aRectangle height)).	aClusteredBar _ ClusteredBarChart new.	aClusteredBar isLabeled:true.	aClusteredBar isLegended:true.	aClusteredBar labelsInStack: #('internal' 'external' 'arboreal' 'ethereal' 'kickback' 'lossleader' 'loss').	aClusteredBar labelArray:#('820' 'Dorado' 'Dolphin' 'Dandelion' 'Daffodil' ).	aClusteredBar dataArray: #(#(5 5 1 2 3 4 5) #(10 15 2 4 6 8 10) #(50 15 3 6 9 12 15) #(10 25 4 8 12 16 20) #(11 80 1 2 4 8 16)).	aClusteredBar title: '     Zerox (not Xerox) Sales'.	aClusteredBar displayOn: aForm .	aForm displayOn: Display at: 0@0.	"ClusteredBarChart example."! !LineChart class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!LineChart class methodsFor: 'examples'!example	"produces a simple Bar chart in the upper left corner of the screen. labeled by percent values."	| aLine aRectangle aForm |	aRectangle _ Rectangle fromUser.	aForm _ Form fromDisplay: aRectangle.	aLine _ LineChart new.	aLine isLabeled:true.	aLine labelArray:#('820' 'Dorado' 'Dolphin' 'Dandelion' 'Daffodil' ).	aLine dataArray: #(10 30 65 15 80).	aLine title: '     Zerox (not Xerox) Sales'.	aLine displayOn: aForm .	aForm displayOn: Display at: 0@0.	"LineChart example."! !!User class methodsFor: 'class initialization'!initialize	"User initialize"	UserTextStyle _ TextStyle default firstIndent: 2; restIndent: 2; rightIndent: 2.	UserFastScanner _ FastTextDisplayScanner new.	MyFillController _ UserFillController new.	MyFillController initialize.	MyFillView _ FillInTheBlankView new.	MyFillIn _ FillInTheBlank new.	MyFillView model: MyFillIn controller: MyFillController.	MyFillView borderWidth: 1.	ThumbsUp _		Cursor			extent: 16@16			fromArray: 				#(16 104 72 120 136 136 3980 4227 8192 16128 8192 16128 8192 7943 2056 4080 )			offset: -15@0.	ThumbsDown _		Cursor			extent: 16@16			fromArray:				#(4080 2056 7943 8192 16128 8192 16128 8192 4227 3980 136 136 120 72 104 16 )			offset: 0@0! !!User class methodsFor: 'messages'!booboo: aString 	"User booboo: 'No error exists here at all.'"	self booboo: aString align: #center!booboo: aString align: aSymbol	"User booboo: 'No error exists here at all.'"	| rect savedForm theString flag point boundedPoint |	theString _ aString asText, (Text string: 'Click mouse to continue.' emphasis: 2).	rect _ self boundingRectFor: theString.	savedForm _ Form fromDisplay: rect.	self bound: rect.	self display: theString in: rect align: aSymbol.	[point _ Sensor cursorPoint.	boundedPoint _ (point max: rect origin) min: rect corner.	point = boundedPoint ifFalse:[Sensor cursorPoint: boundedPoint].	flag _ Sensor anyButtonPressed & (rect containsPoint: Sensor cursorPoint).		flag]		whileFalse:			[Processor yield.			((Smalltalk includesKey: #BackgroundDelay) and: [BackgroundDelay ~= 0])					ifTrue: [(Delay forMilliseconds: BackgroundDelay) wait]].	[Sensor anyButtonPressed] whileTrue: [].	Cursor normal show.	savedForm		displayOn: Display		at: rect origin!confirm: aString 		^self confirm: aString trueMessage: 'yes' falseMessage: 'no'!confirm: aString trueMessage: trueString falseMessage: falseString 	"10 timesRepeat: [User confirm: 'No.' trueMessage: 'Absolutely and without doubt' falseMessage: 'Nyet']"	| rect savedForm flag yesRect noRect point yesWidth noWidth pressed sel hiLit |	rect _ (self boundingRectFor: aString)				expandBy: 0 @ 14.	yesWidth _ (UserFastScanner widthOfString: trueString emphasis: 1) + 7.	noWidth _ (UserFastScanner widthOfString: falseString emphasis: 1) + 7.	rect width < (yesWidth * 2) ifTrue: [rect extent: yesWidth * 2 @ rect height].	rect width < (noWidth * 2) ifTrue: [rect extent: noWidth * 2 @ rect height].	rect width < 100 ifTrue: [rect extent: 100 @ rect height].	rect width even ifFalse: [rect extent: rect extent + (1 @ 0)].	rect _ self				center: rect				about: Sensor cursorPoint				in: Display boundingBox.	yesRect _ rect left @ (rect bottom - 30) extent: rect width // 2 - 1 @ 30.	noRect _ rect left + (rect width // 2) - 3 @ (rect bottom - 30) extent: rect width // 2 + 3 @ 30.	savedForm _ Form fromDisplay: rect.	self bound: (rect origin extent: rect extent - (0 @ 28)).	self display: aString in: rect.	self bound: yesRect.	self bound: noRect.	self		display: trueString		in: yesRect		at: 0 @ 4.	self		display: falseString		in: noRect		at: 0 @ 4.	Cursor normal show.		["bound the point to stay within the rectangle"	point _ Sensor cursorPoint.	pressed _ Sensor anyButtonPressed.	(point >= yesRect origin and: [point <= noRect corner])		ifFalse: 			[point _ (point max: yesRect origin) min: noRect corner.			Sensor cursorPoint: point].	"set the cursor appropriately"	Cursor currentCursor: (point x < noRect left ifTrue: [ThumbsUp] ifFalse: [ThumbsDown]).	pressed		ifTrue: 			[sel _ Cursor currentCursor == ThumbsUp.			sel == hiLit				ifFalse: 					[hiLit == nil ifFalse: [self highlight: (hiLit								ifTrue: [yesRect]								ifFalse: [noRect])].					hiLit _ sel.					self highlight: (hiLit							ifTrue: [yesRect]							ifFalse: [noRect])]].	sel == nil | pressed]		whileTrue: [Processor yield.					((Smalltalk includesKey: #BackgroundDelay) and: [BackgroundDelay ~= 0])						ifTrue: [(Delay forMilliseconds: BackgroundDelay) wait]].	Cursor normal show.	savedForm displayOn: Display at: rect origin.	^sel!request: aString default: replyString	| rect replyRect savedForm answer | 	"10 timesRepeat:[User request: 'Whaddya want, anyway?' default: 'Nothing.']"	Answer _ nil.	rect _ self boundingRectFor: aString.	rect width < 200 ifTrue: [rect right: rect right + (200 - rect width)].	replyRect _ rect bottomLeft extent: rect width @ 30.	savedForm _ Form fromDisplay: (rect merge: replyRect).	self bound: (rect expandBy: (0@0 extent: 0@2)).	self bound: replyRect.	self display: aString in: (rect insetBy: 2).	self display: replyString in: (replyRect insetBy: 7@3) align: #leftFlush.	self startFillControllerIn: (replyRect insetBy: 2@2) default: replyString.	savedForm		displayOn: Display		at: rect origin.	Sensor cursorPoint: rect center.	Answer == nil ifTrue:[^ScheduledControllers bailOut].	^Answer! !!User class methodsFor: 'private'!bound: rect	Display		fill: rect		rule: Form over		mask: Form black.	Display		fill: (rect insetBy: 2)		rule: Form over		mask: Form white.!boundingRectFor: title 	| width point rect height |	width _ (UserFastScanner				widthOfText: title asText				textStyle: UserTextStyle				maxWidth: 500)				+ 10.	height _ (title occurrencesOf: Character cr) + 1 * 22.	point _ Sensor cursorPoint.	rect _ point x - (width // 2) @ (point y - (height // 2)) extent: width @ height.	(Display boundingBox contains: rect)		ifFalse: [rect _ rect moveBy: (rect amountToTranslateWithin: Display boundingBox)].	^rect!center: aRect about: aPoint in: aBoundingBox	| answer | 	answer _ aRect align: aRect center with: aPoint.	answer _ answer moveBy: (answer amountToTranslateWithin: aBoundingBox).	^answer!display: aString in: rect	self		displayText: aString asText		alignment: #center		on: Display		at: rect origin		clippingBox: rect		rule: Form over		mask: Form black.!display: aString in: rect align: aSymbol	self		displayText: aString asText		alignment: aSymbol		on: Display		at: rect origin		clippingBox: rect		rule: Form over		mask: Form black.!display: aString in: rect at: aPoint	self		displayText: aString asText		alignment: #center		on: Display		at: rect origin + aPoint		clippingBox: rect		rule: Form over		mask: Form black.!displayText: aText alignment: aSymbol on: aDisplayObject at: aPoint clippingBox: aRectangle rule: combinationRule mask: mask 	| align |	align _ aSymbol == #rightFlush				ifTrue: [1]				ifFalse: [aSymbol == #leftFlush						ifTrue: [0]						ifFalse: [2]].	UserTextStyle alignment: align.	UserFastScanner		displayText: aText		textStyle: UserTextStyle		destForm: aDisplayObject		leftMargin: aPoint x		rightMargin: aRectangle right		destY: aPoint y		halftoneForm: mask		combinationRule: combinationRule		clipX: aRectangle left + 2		clipY: aRectangle top + 2		clipWidth: aRectangle width - 4		clipHeight: aRectangle height - 4!highlight: rect	Display		fill: (rect insetBy: 2)		rule: Form reverse		mask: Form gray.	Display		fill: (rect insetBy: 4)		rule: Form reverse		mask: Form gray!startFillControllerIn: aRectangle default: value	Sensor cursorPoint: (aRectangle origin + (7@2)).	MyFillIn action: [:answer | Answer _ answer].	MyFillView		window: (0@0 extent: aRectangle extent)		viewport: aRectangle.	MyFillView editString: value asText.	MyFillController reset.	MyFillController startUp! !!RS232Memory class methodsFor: 'initialize'!initialize	"RS232Memory initialize"	BufferSize _ 8000.	DefaultEmphasis _ TextStyle getNumForStrikeFont: 'Gacha10'.	HighlightEmphasis _ TextStyle getNumForStrikeFont: 'Gacha10B'.	UnderlineEmphasis _  (TextConstants at: #DefaultTextStyle) underlinedFontFor: DefaultEmphasis.! !!RS232Memory class methodsFor: 'access'!defaultEmphasis	^DefaultEmphasis!highlightEmphasis	^HighlightEmphasis!underlineEmphasis	^UnderlineEmphasis! !!RS232Memory class methodsFor: 'instance creation'!new	^self basicNew initialize! !!Helper class methodsFor: 'initialize'!initialize	"Helper initialize."	HelpYellowButtonMenu _ActionMenu		labels:'more help{Search the user guide for matches to the current selection.}' withCRs		selectors: #(search)! !LabelSwitch class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SharedDeque class methodsFor: 'instance creation'!new	"Answer a new instance of SharedDeque with 10 elements."	^self new: 10!new: anInteger	^super new init: anInteger! !!InformationCenter class methodsFor: 'instance creation'!newFor: aNameAndPassword	"make a new information center with the provided name and password in a 2 element array."	"(InformationCenter newFor: #('dummy' 'hello')) inspect "	| theCenter |	theCenter _ InformationCenter new.	theCenter initialize: aNameAndPassword.	^theCenter! !!InformationCenter class methodsFor: 'external copy buffer access'!getItemInCopyBuffer	Clipboard nextClass == DataItem		ifTrue: [^Clipboard retrieve]		ifFalse: [^nil]!getTextFromTransferBuffer	"return nil or the name of a file in which text has been stored in non-annotated format"	| fileName englishDataType theItem newName entry entryCenter |	entry _ Clipboard next.	entryCenter _ entry propertyAt: #center.	(theItem _ entry contents) class == DataItem ifTrue:		[(fileName _ theItem filename) == nil ifFalse:			[englishDataType _ DataMaster giveMe: #englishString for: fileName.			(englishDataType = #text or: [englishDataType = #outline]) ifTrue:				[englishDataType = #text					ifTrue: [Clipboard retrieveEntry.							^ComposeTextController makeSimpleTextFileFromSuitcase: (Suitcase new packTheSuitcaseFrom: entryCenter name forItem: theItem)]					ifFalse: [newName _ OutlineList makeSimpleTextFileFromSuitcase: (Suitcase new packTheSuitcaseFrom: entryCenter name forItem: theItem).							^newName == nil ifTrue: [nil] ifFalse: [Clipboard retrieveEntry. newName]]]]].	Clipboard booboo.	^nil! !!InformationCenter class methodsFor: 'initialize'!initialize	"InformationCenter initialize"	DataStart _ 5.	ActiveCenters _ Dictionary new.	PossibleCenters _ OrderedCollection new.! !!InformationCenter class methodsFor: 'filing items'!fileNameData: englishDataType defaultSuitcase: defaultSuitcase defaultKeys: defaultKeys askMethod: askFilingMethod askClass: askClass	"ask the user for the label, key words, filing method if askFilingMethod is true, and info center. Return the file name and information center key line in a 4 element array with aDataItem at 1, key words at 2, filing method at 3, and info center name at 4."	"if englishDataType is nil, then just put the filename from defaultSuitcase dataItem in the new dataItem's filename"	| return iCS labels selects defaults returnArray answer modArray fileName defaultItem |	return _ Array new: 4.	defaultItem _ defaultSuitcase dataItem.	(iCS _ OrderedCollection new) add: 'Info center:'.	(PossibleCenters isEmpty or: [PossibleCenters size = 1]) ifTrue: [self openSomeInfoCenter == nil ifTrue: [^return]].	PossibleCenters do: [:key | iCS add: key].	iCS remove: #Scavenge asString ifAbsent: [].	(labels _ OrderedCollection new) add: (Array with: #Name:); add: (Array with: #Keywords:); add: iCS.	(selects _ OrderedCollection new) add: #fill; add: #keyword; add: #multipleSelect.	(defaults _ OrderedCollection new) add: defaultItem label; add: defaultKeys; add: ((iCS includes: LastUsedCenterName) ifTrue: [LastUsedCenterName] ifFalse: [iCS at: 2]).	askClass ifTrue:		[returnArray _ DCM setUpDBoxStartingAt: 4.		1 to: (returnArray at: 1) size do:			[:each | labels add: ((returnArray at: 1) at: each).			 selects add: ((returnArray at: 2) at: each)].		defaults add: defaultSuitcase classification classification.		DCM modifiers isEmpty ifFalse:[defaults add:  defaultSuitcase classification modifiers]].	askFilingMethod ifTrue: [labels add: #('Filing Method:' manual auto). selects add: #select. defaults add: #auto].	answer _ DBoxView		openFor: selects		title: 'File request'		labels: labels		defaults: defaults		commands: #(accept cancel bailOut)		autoAccept: false		links: (askClass ifTrue: [returnArray at: 3] ifFalse: [Array new])		linksBy: (askClass ifTrue: [returnArray at: 4] ifFalse: [Array new]).	answer == nil ifTrue: [^return].	(answer at: 3) == nil ifTrue: [^return].	(answer at: 3) do: [:eachCenter | (self check: eachCenter) ifFalse: [^return]].	englishDataType == nil		ifTrue: [fileName _ defaultItem filename]		ifFalse: [Cursor wait showWhile: [fileName _ Disk makeNewFileName: (answer at: 1) withSuffix: (DataMaster giveMe: #suffixString for: englishDataType asString)]].	askClass ifTrue: [modArray _ DCM returnDBoxAnswer: answer startingAt: 4].	return at: 1 put: (DataItem locked: defaultItem isLocked classification: (askClass ifTrue: [modArray at: 1] ifFalse: [defaultSuitcase classification classification]) modifiers: (askClass ifTrue: [modArray at: 2] ifFalse: [defaultSuitcase classification modifiers]) type: defaultItem type label: (answer at: 1) filename: fileName bPointers: nil fPointers: nil atIndex: 0).	return at: 2 put: (answer at: 2).	return at: 4 put: (answer at: 3).	askFilingMethod		ifTrue: [return at: 3 put: (answer at: answer size) asSymbol]		ifFalse: [return at: 3 put: #auto].	^ return!putFileNameAway: array	"put this item in the inbox and the copy buffer, then file it using the requested method"	| theItem center theCenters  theCleanItem |	theCenters _ array at: 4.	theCleanItem _ (array at: 1) copy.	1 to: theCenters size do:		[:i |		LastUsedCenterName _ theCenters at: i.		center _ self centerFor: LastUsedCenterName.		theItem _ (i = 1 ifTrue: [array at: 1 "the original"] ifFalse: [theCleanItem copy]).		center addThis: theItem linkType: (center linkTypeFor: #contains) to: center inbox.		theItem addBPointer: center inboxIndex type: (center linkTypeFor: #contains).		center setKeywordsForItemAt: theItem centerIndex to: (array at: 2).		i = 1 ifTrue:			[ContainerModel message: 'The available Item Reference is:', theItem iconDisplayString.			Clipboard clip: theItem.			Clipboard last propertyAt: #pointer put: (DataItemPointer index: theItem centerIndex).			Clipboard last propertyAt: #center put: center].		(array at: 3) = #auto 			ifFalse:				[center updateClassFor: theItem.				center showFolderList: theItem]			ifTrue: [(center fileAway: theItem) ifFalse: [center updateClassFor: theItem]]]!putFileNameAwayWithCheck: array	"The new item may actually be an overwrite of an old one, so check that first and if it is, just modify the old item and put it in the copy buffer, an allow the file it away too, although it will remain in its current location"	| theItem center overwrittenDataItem theCenters theCleanItem |	theCenters _ array at: 4.	theCleanItem _ (array at: 1) copy.	1 to: theCenters size do:		[:i |		LastUsedCenterName _ theCenters at: i.		center _ self centerFor: LastUsedCenterName.		theItem _ (i = 1 ifTrue: [array at: 1 "the original"] ifFalse: [theCleanItem copy]).		(overwrittenDataItem _ self lookForLabel: nil andKeys: nil dataType: theItem type fileName: theItem filename inUser: LastUsedCenterName) == nil			ifFalse: "just fix up overwrittenDataItem with the new label, class, and keys"				[center modifyItemAt: overwrittenDataItem centerIndex with: (Array with: theItem label with: (array at: 2) with: theItem classification with: theItem modifiers) at: 0.				theItem _ overwrittenDataItem]			ifTrue: "this is a regular new item putFileNameAway"				[center addThis: theItem linkType: (center linkTypeFor: #contains) to: center inbox.				theItem addBPointer: center inboxIndex type: (center linkTypeFor: #contains).				center setKeywordsForItemAt: theItem centerIndex to: (array at: 2)].		i = 1 ifTrue:			[ContainerModel message: 'The available Item Reference is:', theItem iconDisplayString.			Clipboard clip: theItem.			Clipboard last propertyAt: #pointer put: (DataItemPointer index: theItem centerIndex).			Clipboard last propertyAt: #center put: center].		(array at: 3) = #auto 			ifFalse:				[overwrittenDataItem == nil ifTrue: [center updateClassFor: theItem].				center showFolderList: theItem]			ifTrue:				[(center fileAway: theItem) ifFalse: [center updateClassFor: theItem]]]! !!InformationCenter class methodsFor: 'access'!activeCenters	^ActiveCenters!centerFor: fcUser	fcUser == nil ifTrue: [^nil].	^(self activeCenters at: fcUser ifAbsent: [^nil])!centerSuffix	^'.center'!dataStart	^DataStart!doesInfoUsersIncludeThisCenter: aCenterName	"see if the information center exists"	PossibleCenters do: [:each| (each sameAs: aCenterName) ifTrue: [^true]].	^ false!lastUsedCenterName	^LastUsedCenterName!lastUsedCenterName: centerName	LastUsedCenterName _ centerName!possibleCenters	^PossibleCenters!possibleCenters: centerNames	PossibleCenters _ centerNames.	(PossibleCenters includes: #Scavenge asString)		ifFalse: [self addNewInfoCenter: (Array with: #Scavenge asString with: String new)]!removeCenter: aCenterName	ActiveCenters removeKey: aCenterName ifAbsent:[]!saveAndClearAll	ActiveCenters == nil ifTrue: [ActiveCenters _ OopConservingDictionary new].	ActiveCenters keys do: 		[:aName | (aName sameAs: #Scavenge asString)			ifFalse: [(ActiveCenters at: aName) save].		ActiveCenters removeKey: aName].	Clipboard removeUsing: [:each | each contents class == DataItem].!updateClassFor: dataItem in: thisCenterName	| theCenter | 	theCenter _ self centerFor: thisCenterName.	theCenter updateClassFor: dataItem! !!InformationCenter class methodsFor: 'open a Center'!addNewInfoCenter: anArray	"anArray contains name and password for a new information center "	| newCollection aDictionary newCenter |	anArray at: 1 put: ((anArray at: 1) asFileName).	(self doesInfoUsersIncludeThisCenter: (anArray at: 1)) ifTrue: [self booboo: 'This Information Center already exists.Please open it from the list'.		^nil].	newCenter _ self newFor: anArray.	newCenter name = #Scavenge		ifFalse:[newCenter save.			self possibleCenters add: (LastUsedCenterName _ (anArray at: 1)).			self activeCenters at: LastUsedCenterName put: newCenter.			self closeCenterChoiceBar]		ifTrue:[self possibleCenters add: (anArray at: 1).			self activeCenters at: (anArray at: 1) put: newCenter].	^LastUsedCenterName!check: aUser	"see if this user's information center has been read in and if not, read it in. Return whether successfully available"	| thePassword theCenter | 	(self activeCenters includesKey: aUser) ifTrue: [^true].	Cursor read showWhile: [thePassword _ self getPasswordFor: aUser].	thePassword == nil ifFalse:		[FillInTheBlank			requestPassword: 'Please enter the password for ', (ContainerModel fixName: aUser)			displayAt: Sensor cursorPoint			centered: true			action: [:response | response]			initialAnswer: String new.		(thePassword sameAs: response)			ifFalse: [self booboo: 'Improper password. Access denied.'. ^false]].	theCenter _ self newFor: (Array with: aUser with: thePassword).	theCenter restore.	^ true!closeCenterChoiceBar	"InformationCenter closeCenterChoiceBar."	ScheduledControllers scheduledControllers do:		[:each | ((each model isKindOf: FormsModel) and:			[each model name = 'Information Centers'])				ifTrue: [each closeAndUnschedule]]!getPasswordFor: aUser	"check the password for this center file"	|  password theStream owner |	theStream _ self openFile: (aUser, self centerSuffix).	theStream readOnly.	password _ theStream upTo:  $\.	owner_ theStream upTo: Character cr.	theStream setToEnd.	theStream close.	password = String new ifTrue: [^nil].	owner = UserName		ifTrue:[^nil]		ifFalse:[^password]!getTheInfoCenterName: withScavenge	| labels theReturn infoName thePossibleCenters |	thePossibleCenters _ PossibleCenters deepCopy.	withScavenge ifFalse: [thePossibleCenters remove: 'Scavenge' ifAbsent: []].	labels _ Array with: (#('info center:'), thePossibleCenters, #(addNew)) with: #('enter name:') with: #(password:).	theReturn _ DBoxView		openFor: #(select fill password)		title: 'Information Centers'		labels: labels		defaults: (Array with: (Array with: ((thePossibleCenters includes: LastUsedCenterName) ifTrue: [LastUsedCenterName] ifFalse: [nil])) with: String new with: String new)		commands: #(accept cancel bailOut)		autoAccept: true		links: (Array with: (Array with: 1@(thePossibleCenters size + 1) with: 2@1 with: 3@1)).	theReturn == nil ifTrue: [^nil].	infoName _ theReturn at: 1.	infoName == #addNew		ifTrue: [ ((theReturn at: 2) == nil or:[(theReturn at: 2) isEmpty]) ifTrue: [^nil].			infoName _ self addNewInfoCenter: (Array with: (theReturn at: 2) with: (theReturn at: 3)).			infoName == nil ifTrue: [^nil]].	LastUsedCenterName _ infoName.	^infoName!makeNewCenter	| theReturn infoName |	theReturn _ DBoxView		openFor: #(fill password)		title: 'New Information Center'		labels: (Array with: #('enter name:') with: #(password:))		defaults: (Array with: String new with: String new)		commands: #(accept cancel bailOut)		autoAccept: true.	theReturn == nil ifTrue: [^nil].	((theReturn at: 1) == nil or:[(theReturn at: 1) isEmpty]) ifTrue: [^nil].	infoName _ self addNewInfoCenter: (Array with: (theReturn at: 1) with: (theReturn at: 2)).	self open: infoName!open: aString	"This opens a information/user guide window for the user"	(self check: aString) ifFalse: [^self].	(aString sameAs: #Scavenge)		ifTrue: [(ContainerModel createForIndexOrItem: 1 inCenter: (self activeCenters at: aString) )				scheduleTheFolder: 'Scavenge Center'				usingMenu: 7				width: 4				helpMessage: #Folder]		ifFalse: [(ContainerModel createForIndexOrItem: 1 inCenter: (self  activeCenters at: aString) )				scheduleTheFolder: aString , '''s Info Center'				usingMenu: 1				width: 1				helpMessage: #Folder]!openCenterChoiceBar	"InformationCenter openCenterChoiceBar"	| label centers formsModel |	label _ 'Information Centers'.	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: FormsModel)			and: [each model name = label]].	centers _ self possibleCenters deepCopy.	centers add: 'Make New Center'.	formsModel _ FormsModel named: label.	formsModel		addControlPanel: InfoCenterElement		labels: centers		messages: centers		targetController: ScreenController someInstance		boundingBox: (0@0 extent: 500@30).	FormsView		openOn: formsModel		backgroundColor: Form lightGray!openSomeInfoCenter	"get all of the info center names minus the Scavenge center"	| infoName |	infoName _ self getTheInfoCenterName: false.	infoName == nil ifTrue: [^nil].	(self check: infoName) ifFalse: [^ nil]! !!InformationCenter class methodsFor: 'searching'!getAllFileReferencesToThisFile: theFileName putIn: aCollection	"get all the basic files that any information center knows about.  If the information center is in memory get the file names from there; if not, go to the disk and read the .center file to find out what files it holds"	| aCenter saveIt |	saveIt _ LastUsedCenterName.	PossibleCenters do:		[:infoCenterName |		(ActiveCenters includesKey: infoCenterName)			ifTrue:				[aCenter _ self centerFor: infoCenterName.				aCenter getAllFileRefsTo: theFileName putIn: aCollection]			ifFalse:				[(Disk includesKey: infoCenterName , '.center') ifTrue:					[aCenter _ self newFor: (Array with: infoCenterName with: nil).					aCenter restore.					aCenter getAllFileRefsTo: theFileName putIn: aCollection.					self removeCenter: infoCenterName]]].	LastUsedCenterName _ saveIt!getAllFilesInAllCentersExcept: centerName return: theFileSet	"get all the basic files that any information center knows about.  If the information center is in memory get the file names from there; if not, go to the disk and read the .center file to find out what files it holds"	| aCenter saveIt |	saveIt _ LastUsedCenterName.	PossibleCenters do:		[:infoCenterName |		infoCenterName = centerName			ifFalse:[ (ActiveCenters includesKey: infoCenterName)				ifTrue:					[aCenter _ self centerFor: infoCenterName.					aCenter getAllFilesStartingAt: aCenter fileCabinetIndex putIn: theFileSet linkType: nil extended: false]				ifFalse:					[(Disk includesKey: infoCenterName , '.center') ifTrue:						[aCenter _ self newFor: (Array with: infoCenterName with: nil).						aCenter restore.						aCenter getAllFilesStartingAt: aCenter fileCabinetIndex putIn: theFileSet linkType: nil extended: false.						self removeCenter: infoCenterName]]]].	LastUsedCenterName _ saveIt!lookForLabel: labelString andKeys: keyString dataType: dataType fileName: filename inUser: centerName	"return the first item find in fcUser that has a match for every argument. If labelString and/or keyString are nil it won't bother trying to match them. If fcUser is nil, try each user currently in memory until a match is found" 	| center size eachItem fileCabinet | 	centerName == nil ifTrue:		[InformationCenter activeCenters keysDo:			[:iC |			eachItem _ self lookForLabel: labelString andKeys: keyString dataType: dataType fileName: filename inUser: iC.			eachItem == nil ifFalse: [LastUsedCenterName _ iC. ^eachItem]].			^nil].	center _ (InformationCenter activeCenters at: centerName ifAbsent: [^nil]).	center == nil ifTrue: [^nil].	fileCabinet _ center fileCabinet.	(size _ fileCabinet size) < center dataStart ifTrue: [^nil].	center dataStart to: size do:		[:theIndex |		eachItem _ fileCabinet at: theIndex.		eachItem == nil ifFalse:			[(dataType == nil				ifTrue:[(filename == nil or: [eachItem filename = filename]) and: [(labelString == nil or: [eachItem label = labelString]) and: [keyString == nil or: [keyString = (center keywordStringFor: eachItem)]]]]				ifFalse:[eachItem type = dataType and: [(filename == nil or: [eachItem filename = filename]) and: [(labelString == nil or: [eachItem label = labelString]) and: [keyString == nil or: [keyString = (center keywordStringFor: eachItem)]]]]])				ifTrue: [^eachItem]]].	^nil!lookInInfoCentersFor: aString	aString isEmpty ifTrue: [^self booboo:'There has to be a selection.'].	InformationCenter openSomeInfoCenter = nil ifTrue: [^ self].	(self centerFor: LastUsedCenterName) lookForThisString: aString startingWith: nil!openFromFileName: aString	"this is used by Spreadsheets"	"try to find this object in a filed in information center and open a view on it"	| theItem |  	theItem _ self lookForLabel: nil andKeys: nil dataType: #Item fileName: aString inUser: nil.	theItem == nil ifTrue: [^self booboo: 'Sorry I can not find ', aString].	DataMaster viewSelection: theItem withSuitcase: (Suitcase new packTheSuitcaseFrom: LastUsedCenterName forItem: theItem)! !!InformationCenter class methodsFor: 'q box access'!getNewKeyFor: oldKey withKeywords: keywordString dBoxTitle: dBoxTitle askClass: askClass	"return the answer array for this guy"	| defaultArray labelArray answer selectArray returnArray mods |	(defaultArray _ OrderedCollection new) add: oldKey label; add: keywordString.	(selectArray _ OrderedCollection new) add: #fill; add: #keyword.	(labelArray _ OrderedCollection new) add: #(Name); add: #(Keywords).	askClass ifTrue:		[defaultArray add: oldKey classification ; add: oldKey modifiers.		returnArray _ DCM setUpDBoxStartingAt: 3.		 1 to: (returnArray at: 1) size do:			[:each | labelArray add: ((returnArray at: 1) at: each).			 selectArray add: ((returnArray at: 2) at: each)]].	answer _DBoxView		openFor: selectArray		title: dBoxTitle		labels: labelArray		defaults: defaultArray		commands: #(accept cancel bailOut)		autoAccept: askClass not		links: (askClass ifTrue: [returnArray at: 3] ifFalse: [Array new])		linksBy: (askClass ifTrue: [returnArray at: 4] ifFalse: [Array new]).	answer == nil ifTrue: [^nil].	answer size = 3		ifTrue: [mods _oldKey modifiers]		ifFalse:[mods _ (askClass ifTrue: [answer at: 4] ifFalse: [oldKey modifiers])].	^Array with: (answer at: 1) with: (answer at: 2) with: (askClass ifTrue: [answer at: 3] ifFalse: [oldKey classification]) with: mods! !!InformationCenter class methodsFor: 'Auditing'!auditThis: theArray 	"1 the action	2 the item	3 the folder	4 the center"	Auditor absoluteAdd: (theArray at: 1) printString , ' item: ' , (theArray at: 2) printString , ' folder: ' , (theArray at: 3) printString , ' center: ' , (theArray at: 4) printString! !!ClassificationScheme class methodsFor: 'initialize'!classificationFileName	^'Classifications'!initialize	| newClassificationScheme | 	"ClassificationScheme initialize"	newClassificationScheme _ self new.	newClassificationScheme setup.	Smalltalk at: #DCM put: newClassificationScheme!writeDefaultClassification	| theStream | 	"ClassificationScheme writeDefaultClassification"	theStream _ (ClassificationScheme openFile: self classificationFileName) writeShorten.	theStream nextPutAll: 'Xerox5IntXPersXPrivXRegInternal Use OnlyXerox PersonalXerox PrivateXerox Registered6Xerox Special Information SystemsVista LaboratoryDraftDo Not CopyMemoNoteXSISVistaDraftNo CopyMemoNote51@3 2@41@4 2@41@5 2@42@1 2@5 2@62@2 2@5 2@6'.	theStream close! !!PopUpMenu class methodsFor: 'instance creation'!initialize	"PopUpMenu initialize"	| temp |	(Smalltalk includesKey: #MenuHelpConstants) ifFalse:			[Smalltalk at: #MenuHelpConstants put: ((Smalltalk includesKey: #OopConservingDictionary) ifTrue: [OopConservingDictionary new] ifFalse: [Dictionary new])].	(Smalltalk at: #MenuHelpConstants)		at: #accept put: 'Accept changes in the text.';		at: #cancel put: 'Cancel changes you have made.';		at: #again put: 'Repeat the last replacement in the text.';		at: #undo put: 'Undo the effects of the last command.';		at: #copy put: 'Copy the selected text into the copy buffer, for later pasting.';		at: #cut put: 'Delete the selected text.\The text is put in the copy buffer, for later pasting.' withCRs;		at: #paste put: 'Paste in text from the copy buffer.'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn	after each item indexed by anArray."	^ self new labels: aString font: (TextStyle default fontAt: 7) lines: anArray!on: aCollection 	"Show a menu of the given collection.  Return nil if no element is chosen."	"PopUpMenu on: #(1 2 3 'abcd' #ghi)"	| aStream index |	aStream _ WriteStream on: (String new: 200).	aCollection do: 		[:sel | 		(sel isKindOf: String)			ifTrue: [aStream nextPutAll: sel]			ifFalse: [aStream nextPutAll: sel printString].		aStream cr].	aStream skip: -1.	index _ (PopUpMenu labels: aStream contents) startUp.	index > 0		ifTrue: [^aCollection at: index]		ifFalse: [^nil]!on: aCollection title: aString	"Show a menu of the given collection.  Return nil if no element is chosen."	"PopUpMenu on: #(1 2 3 'abcd' #ghi) title: 'frogs'"	| aStream index |	aStream _ WriteStream on: (String new: 200).	aCollection do: 		[:sel | 		(sel isKindOf: String)			ifTrue: [aStream nextPutAll: sel]			ifFalse: [aStream nextPutAll: sel printString].		aStream cr].	aStream skip: -1.	index _ (PopUpMenu labels: aStream contents) startUp: #RedButton withHeading: aString.	index > 0		ifTrue: [^aCollection at: index]		ifFalse: [^nil]! !!TreeMenu class methodsFor: 'examples'!example| root A B C C1 |A _ (TreeMenu labels:'a1a2a3') answers: #(a1 a2 a3).B _ (TreeMenu labels:'b1b2b3') answers: #(b1 b2 b3).C1 _ (TreeMenu labels:'TF') answers: #(true false); children: (Array with: false with: false).C _ (TreeMenu labels:'c1~c2~c3~') children: (Array with: C1 with: C1 copy with: C1 copy); answers: #(c1 c2 c3).root _ (TreeMenu labels:'A~B~C~') children: (Array with: A with: B with: C); answers: #(A B C).^ root startUp: #yellowButton"TreeMenu example"!numberExample	"test of dynamic children"	| menu n m |	menu _ TreeMenu labels:'  0    1    2    3    4    5    6    7    8    9  '.	menu answers: #(0 1 2 3 4 5 6 7 8 9).	menu children: [:me | me copy].	menu resultBlock: [:first :last |		n _ last answer.		m _ 1.		[(last _ last parent) notNil] whileTrue: [n _ (m _ m * 10) * last answer + n].		n].^menu!parseExample	"TreeMenu parseExample"	| root |	root _ TreeMenu createMenuFrom: '-A _ yourself	a1 _ a1Selector	-a2 _ a2Selector	a3 _ yourself		a31 _ a31Selector		a32 _ a32SelectorB _ yourself	b1 _ b1Selector	b2 _ b2Selector	b3 _ b3SelectorC _ something'.	^root startUp: #yellowButton!resultExample| root A B C C1 s |A _ (TreeMenu labels:'chartreusefuchsiavermilion') answers: #(chartreuse fuchsia vermilion)"; children: false".B _ (TreeMenu labels:'loquatpersimmonchayote') answers: #(loquat persimmon chayote)"; children: false".C _ (TreeMenu labels:'axolotllemurpeccarywombat') "children: false;" answers: #(axolotl lemur peccary wombat).root _ (TreeMenu labels:'colorfruitbeast') children: (Array with: A with: B with: C); answers: #(color fruit beast); resultBlock: [:first :last | first == last ifTrue: [first answer] ifFalse: [first answer, ' ', last answer]].^ root "TreeMenu resultExample startUp: #yellowButton 'fruit ' 'color vermilion' "!sweepExample| root A B C C1 s |A _ (TreeMenu labels:'chartreusefuchsiavermilion') answers: #(chartreuse fuchsia vermilion); children: false.B _ (TreeMenu labels:'loquatpersimmonchayote') answers: #(loquat persimmon chayote); children: false.C _ (TreeMenu labels:'axolotllemurpeccarywombat') children: false; answers: #(axolotl lemur peccary wombat).root _ (TreeMenu labels:'colorfruitbeast') children: (Array with: A with: B with: C); answers: #(color fruit beast); resultBlock: [:first :last |	.s _ first answer.	((first _ first child) isKindOf: TreeMenu) ifTrue: [s _ s, ' ', first answer].	s].^ root "Smalltalk at: #SweepExample put: (TreeMenu sweepExample).SweepExample startUp: #yellowButton "! !!TreeMenu class methodsFor: 'hokey accessing'!at: aKeyOrIndex	"Like to see me do impersonations? Watch me imitate a Collection (For plug-in compatibility with PopMenus in MouseMenuControllers.).""	(aKeyOrIndex isKindOf: Symbol) ifFalse: [^(#yourself)] ifTrue: [^aKeyOrIndex]."	^(#performYellowSelections)! !!TreeMenu class methodsFor: 'string parser'!createMenuFrom: aString	| aStream |  	aStream _ ReadStream on: aString.	^self createMenuFrom: aStream atLevel: 0!createMenuFrom: aStream atLevel: anInteger 	"TreeMenu parseExample"	| cr tab children answers lines index labels label level menu answer return nxt |	cr _ Character cr.	tab _ Character tab.	children _ OrderedCollection new.	answers _ OrderedCollection new.	lines _ OrderedCollection new.	index _ 1.	labels _ String new.	[(nxt _ aStream next) == tab]		whileTrue: [].	nxt == $[		ifTrue: 			[return _ Compiler evaluate: (aStream upTo: $]).			aStream upTo: cr.			^return]		ifFalse: [aStream skip: -1].	label _ (aStream upTo: $_) stripLeadingAndTrailingSpaces.	label first == $-		ifTrue: 			[label _ label copyFrom: 2 to: label size.			lines add: index].	labels _ labels, label, (String with: cr).	answer _ (aStream upTo: cr) stripLeadingAndTrailingSpaces.	answer first == $[		ifTrue: [answers add: (Compiler evaluate: (answer copyFrom: 2 to: answer size - 1))]		ifFalse: [answers add: answer asSymbol].	children add: nil.	[aStream atEnd]		whileFalse: 			[level _ 0.			[aStream next == tab]				whileTrue: [level _ level + 1].			aStream skip: -1.			level > anInteger ifTrue: [children at: index put: (self createMenuFrom: aStream atLevel: level)].			level < anInteger				ifTrue: 					[aStream skip: level negated.					menu _ TreeMenu labels: labels lines: lines asArray.					menu answers: answers asArray.					menu children: children asArray.					^menu].			level = anInteger				ifTrue: 					[label _ (aStream upTo: $_) stripLeadingAndTrailingSpaces.					label first == $-						ifTrue: 							[label _ label copyFrom: 2 to: label size.							lines add: index + 1].					labels _ labels, label, (String with: cr).					answer _ (aStream upTo: cr) stripLeadingAndTrailingSpaces.					answer first == $[						ifTrue: [answers add: (Compiler evaluate: (answer copyFrom: 2 to: answer size - 1))]						ifFalse: [answers add: answer asSymbol].					children add: nil.					index _ index + 1]].	menu _ TreeMenu labels: labels lines: lines asArray.	menu answers: answers asArray.	menu children: children asArray.	^menu! !!TreeMenu class methodsFor: 'initialization'!accelerateCursorPlace: trueOrFalse	"TreeMenu accelerateCursorPlace: false."	AccelerateCursorPlace _ trueOrFalse  "whether to keep the cursor away from middle of menu"!initialize	"TreeMenu initialize"	| temp |	PopUpChildren _ true.  "do one level look-ahead"	AccelerateCursorPlace _ true.	"move the cursor away from middle of menu"	(Smalltalk includesKey: #MenuHelpConstants) ifFalse:			[Smalltalk at: #MenuHelpConstants put: ((Smalltalk includesKey: #OopConservingDictionary) ifTrue: [OopConservingDictionary new] ifFalse: [Dictionary new])].	(Smalltalk at: #MenuHelpConstants)		at: #accept put: 'Accept changes in the text.';		at: #cancel put: 'Cancel changes you have made.';		at: #again put: 'Repeat the last replacement in the text.';		at: #undo put: 'Undo the effects of the last command.';		at: #copy put: 'Copy the selected text into the copy buffer, for later pasting.';		at: #cut put: 'Delete the selected text.\The text is put in the copy buffer, for later pasting.' withCRs;		at: #paste put: 'Paste in text from the copy buffer.';		at: #save put: 'Save the contents to disk.';		at: #restore put: 'Get the last saved contents from the disk.';		at: #hardcopy put: 'Hardcopy the window contents.';		at: #search put: 'Search for selected text in labels and keywords of an info center.';		at: 'file as new item' asSymbol put: 'Save the contents as a new item in an info center';		at: 'strip CRs' asSymbol put: 'Replace single carridge returns with spaces.';		at: 'time stamp' asSymbol put: 'Replace current selection with the date and time.';		at: 'do it' asSymbol put: 'Evaluate the selected expression.';		at: 'print it' asSymbol put: (temp _ 'Evaluate the selected expression and print the result.');		at: 'compute it' asSymbol put: temp!popUpChildren: trueOrFalse"TreeMenu popUpChildren: false."	PopUpChildren _ trueOrFalse.  "whether to automatically do one level look-ahead"!subResultingResultBlock	| newFirst | 	^[:first :last |		newFirst _ last.		[newFirst == first		or: [newFirst parent answer == #yourself		or: [newFirst resultBlock ~~ nil]]]			whileFalse: [newFirst _ newFirst parent].		(newFirst == first or: [newFirst resultBlock == nil])			ifFalse: [newFirst resultBlock value: newFirst value: last]			ifTrue: [newFirst == last						ifTrue: [last answer]						ifFalse: [Array with: newFirst answer with: last answer]]]!usefulResultBlock	| newFirst | 	^[:first :last |		newFirst _ last.		[newFirst == first or: [newFirst parent answer == #yourself]] whileFalse: [newFirst _ newFirst parent].		newFirst == last ifTrue: [last answer] ifFalse: [Array with: newFirst answer with: last answer]]! !!ScrollMenu class methodsFor: 'instance'!new: anInteger on: arg	"(ScrollMenu new: 7 on: (2 to: 100 by: 2)) startUp: #redButton "	"set maxLines to anInteger; use list to construct the menu.list can be:	<Integer> > 0	menu gives choice of 1 to n	<Interval>		menu gives choice of m to n by step	<String>			use as labels	<Collection>		construct labels from printString's	"	| s list menu |	(arg isKindOf: String)		ifTrue: [s _ arg]		ifFalse: [			s _ WriteStream on: (String new: 250).			list _ arg.			(arg isKindOf: Integer) ifTrue: [list _ 1 to: arg].			list do: [ :i | s space; nextPutAll: i printString; space; cr ].			s _ s contents.			s _ s copyFrom: 1 to: s size - 1 ].	menu _ self labels: s.	(list isKindOf: Interval) ifTrue: [menu answers: list].	^ menu maxLines: anInteger! !!ScrollMenu class methodsFor: 'initialization'!initialize	self scrollMsec: 80.!scrollMsec: msec"ScrollMenu scrollMsec: 80"	ScrollMsec _ msec.! !!NonprogrammerMenu class methodsFor: 'class initialization'!initialize	"NonprogrammerMenu initialize"	InhibitProgramming _ false! !!NonprogrammerMenu class methodsFor: 'accessing'!inhibitProgramming	^InhibitProgramming!makeWheel: aBoolean	InhibitProgramming _ aBoolean not! !PrintFont class comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.'!!PrintFont class methodsFor: 'instance creation'!fromWidth: fileName 	"Answer a new instance of me determined by reading the file whose name	is fileName followed by '.width'."	^self new newFromWidth: fileName!readFrom: fileName 	"Answer an instance of me if one named fileName already exists in the system or by reading the file whose name is fileName followed by '.width'."	^(Disk includesKey: (fileName copyUpTo: $.), '.width')		ifTrue: [self new newFromWidth: fileName]		ifFalse: [nil]! !DisplayPrintFont class comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.'!!Animation class methodsFor: 'class initialization'!initialize	"Animation initialize"	YellowButtonMenu _ PopUpMenu labels: 'stepresumealter parametersabort' lines: #(2 ).	ProgrammerMenu _ PopUpMenu labels: 'inspectclock locationset directionchange parameterpaste image' lines: #().! !Interpress class comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.'!!Interpress class methodsFor: 'instance creation'!fileNamed: fileName"Answer a new instance of me determined by file name (argument)."	^self fileNamed: fileName printStyle: PrintStyle default!fileNamed: fileName printStyle: aPrintStyle"Answer a new instance of me determined by aPrintStyle(argument)."	^super new fileNamed: fileName setPrintStyle: aPrintStyle!form:aForm^(self printStyle: PrintStyle default) form:aForm!new"Answer a new instance of me determined by aPrintStyle (argument)."	^self fileNamed:'Scratch.interpress$' printStyle: PrintStyle default!of: aFileStream	^super new of: aFileStream!printStyle: aPrintStyle"Answer a new instance of me determined by aPrintStyle(argument)."	^self fileNamed:'Scratch.interpress$' printStyle: aPrintStyle!text:aText^ (self printStyle:PrintStyle default) text:aText!withText: aText printStyle: aPrintStyle	| anInterpress | 	anInterpress _ self printStyle: aPrintStyle.	anInterpress initializeWithText:aText.	^anInterpress!withText: aText printStyle: aPrintStyle hardCopyOnFileNamed: aFileName	| anInterpress | 	anInterpress _ self fileNamed: aFileName printStyle: aPrintStyle.	anInterpress initializeWithText: aText.	^anInterpress! !!Interpress class methodsFor: 'initialization'!defaultFontsConversionArray	DefaultFontsConversionArray == nil		ifTrue: [self initFontsConversionArray].	^DefaultFontsConversionArray!initBeginPageBodies	"Interpress initBeginPageBodies"	| fileStream int |	fileStream _ (FileStream fileNamed: 'junkForInterpressSetup') readWrite binary.	int _ self new of: fileStream.	int headerOfMaster.	int beginMaster.	int makePreamble.	int close.	fileStream reopen; reset.	BeginPageBodies _ ByteArray new: fileStream size.	fileStream next: BeginPageBodies size into: BeginPageBodies.	fileStream close.	Disk removeKey: 'junkForInterpressSetup'.	^BeginPageBodies!initFontsConversionArray	"Initialize DefaultFontsConversionArray. Every strike font in the default TextStyle will be mapped to a print font."	"Interpress initFontsConversionArray"	| strikeFonts printFonts defaultPrintFont aStrikeFont fontInfo size face aPrintFontName found savedIndex aPrintFont | 	strikeFonts _ TextStyle default fontArray.	printFonts _ PrintStyle default fontArray.	defaultPrintFont _ (printFonts at: 1) fontName asUppercase.	DefaultFontsConversionArray _ Array new: strikeFonts size.	1 to: strikeFonts size do: [:fontIndex |		aStrikeFont _ strikeFonts at: fontIndex.		fontInfo _ aStrikeFont familySizeFace.	"returns an array of family, size and face"		size _ fontInfo at: 2.		face _#('' '-BOLD' '-ITALIC' '' '' '' '') at: ((fontInfo at: 3) + 1).		aPrintFontName			_ DefaultFontMappings at: (fontInfo at: 1) ifAbsent: [defaultPrintFont].		aPrintFontName _ aPrintFontName, face.		found _ false.		savedIndex _ ((fontInfo at: 3)\\ 3)  + 1.		"default to 1, 2 or 3 according to emphasis, if no suitable substitute found"		1 to: printFonts size do: [:i |		found			ifFalse: [aPrintFont _ printFonts at: i.					(aPrintFont fontSize = size or: [aPrintFont fontSize = (size + 1)])						ifTrue: [savedIndex _ i.								aPrintFont fontName asUppercase = aPrintFontName									ifTrue: [found _ true]]]].		DefaultFontsConversionArray at: fontIndex put: savedIndex].	^DefaultFontsConversionArray!initialize	"DefaultFontMappings is a dictionary where the keys are strike font family names and values are the Interpress printer font family names. UpperBounds is an array, its nth element is the value of expression 256 raisedTo: (n - 1)."	"Interpress initialize."	DefaultFontMappings _ OopConservingDictionary new: 12.	DefaultFontMappings		at: 'TIMESROMAN' put: 'CLASSIC';		at: 'HELVETICA' put: 'MODERN';		at: 'CREAM' put: 'CLASSIC';		at: 'OLDENGLISH' put: 'CLASSIC';		at: 'CHARMICONS' put: 'MODERN';		at: 'GACHA' put: 'TITAN-PRINTWHEEL'.	UpperBounds _ #(1 256 65536 16777216 "4294967296 1099511627776 281474976710656 72057594037927936 18446744073709551616")! !!Interpress class methodsFor: 'public'!getRunsAndTextEnd: aFileStream 	| size pos |	aFileStream position: (size _ aFileStream size) - 1.	aFileStream next = $) ifFalse: [^Array with: (RunArray new: size withAll: 1) with: size].	aFileStream position: (size _ aFileStream size) - 1.	pos _ size - 1.	[pos <= 1 | (aFileStream next asciiValue = 255)]		whileFalse: 			[pos _ pos - 1.			aFileStream position: pos].	aFileStream position: pos + 1.	^ Array with: (Compiler evaluate: (aFileStream next: size - pos - 1)) with: pos! !!FastTextList class methodsFor: 'class initialization'!initialize	"FastTextList initialize."	Stops _ Array new: 258.	Stops atAllPut: nil.	ListStyle _ TextStyle default copy.	ListStyle gridForFont: 1 withLead: 3  "to scrunch the lines together."!initializeWithFontAt: fontIndex	| font |	ListStyle _ DefaultTextStyle copy.	font _ ListStyle fontAt: fontIndex.	ListStyle lineGrid: font height + 3.	ListStyle baseline: font ascent - 1	"FastTextList initializeWithFontAt: 1.		DisplayText allInstancesDo:		[:text | text textStyle: TextStyle default]"! !!FastTextList class methodsFor: 'instance creation'!onList: aList	^ self new		setList: aList font: (ListStyle fontAt: 1)!onList: aList font: aFont	^ self new		setList: aList font: aFont!onList: aList fontAt: aFontNumber	^ self new		setList: aList font: (ListStyle fontAt: aFontNumber)! !PreviewDisplayScanner class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!PreviewCompositionScanner class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewCompositionScanner class methodsFor: 'initialization'!initialize	"PreviewCompositionScanner initialize"	self setMinimumSpacing!setMinimumSpacing	"PreviewCompositionScanner setMinimumSpacing"	MinimumSpacing	_ PressOrInterpress == #Interpress		ifTrue: [640]		ifFalse: [1280]! !!FastTextDisplayScanner class methodsFor: 'class initialization'!initialize"	FastTextDisplayScanner initialize.	"	defaultCacheSize _ 3.	defaultInfoSize _ 500.	StopsCache _ LRUCacheDictionary new: 10.	NoStops _ Array new: 258.! !!FastTextDisplayScanner class methodsFor: 'instance creation'!infoSize: anInteger1 cacheSize: anInteger2	^super new infoSize: anInteger1 cacheSize: anInteger2!new	^self infoSize: defaultInfoSize cacheSize: defaultCacheSize! !!FastTextDisplayScanner class methodsFor: 'accessing'!defaultCacheSize	^defaultCacheSize!defaultInfoSize	^defaultInfoSize! !TablesCompositionScanner class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!PrintScanner class comment:'Copyright (c) Xerox Corporation, 1987. All rights reserved.'!!UTime class methodsFor: 'instance creation'!date: aDate time: aTime 	^UTime time: aTime date: aDate!time: aTime date: aDate 	| universalTime |	(universalTime _ self new) time: aTime; date: aDate.	^universalTime! !SpreadsheetController class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SpreadsheetController class methodsFor: 'class initialization'!initialize	"SpreadsheetController initialize"	". . . initializes the yellow button pop-up menu."	YellowButtonMenu  _ 		PopUpMenu			labels:				('clear\update\copy\cut\paste\copy rule\paste rule\display links\details\save sheet\hardcopy') withCRs			lines: #(2 5 7 9).	YellowButtonMessages _		#( clearCell updateCell copy cut paste ruleCopy rulePaste displayLinks details save hardcopy)! !!FormsController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button pop-up menu the field list."	FormsYellowButtonMenu _ TreeMenu createMenuFrom:'edit form{alter this form} _ editcopy form{copy entire form} _ clipFormsave form{save this form} _ save'.	FormsYellowButtonMessages _ TreeMenu	"FormsController initialize"! !!ImageEditor class methodsFor: 'class initialization'!initialize	"ImageEditor initialize"		". . . creates the tree menus."	IconFontNumber _ TextStyle getNumForStrikeFont: self iconFontName.	LabelFontNumber _ TextStyle getNumForStrikeFont: 'Helvetica10b'.	(AnnotationEditorYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [AnnotationEditorYellowButtonMenu letGo].	AnnotationEditorYellowButtonMenu _ (TreeMenu labels: 'resetacceptcancelcopypasteeraseinvertmagnifysavehardcopy' lines: #(1 4 6 9)) answers: #(setVariables accept cancel copy paste erase invert magnify putMap hardcopyImage).	ActivityMenu == nil ifFalse:[ ActivityMenu letGo. ActivityMenu _ nil].	BrushMenu == nil ifFalse:[ BrushMenu letGo. BrushMenu _ nil].	ColorMenu == nil ifFalse:[ ColorMenu letGo. ColorMenu _ nil].	GridMenu == nil ifFalse:[ GridMenu letGo. GridMenu _ nil].	ModeMenu == nil ifFalse:[ ModeMenu letGo. ModeMenu _ nil]! !!ImageEditor class methodsFor: 'instance creation'!createMenuedViewWith: formViewBordered	| aView formView menuView onSide |	formView _ formViewBordered firstSubView.	onSide _ (formView boundingBox extent y > 600).	menuView _ formView controller createMenuView: onSide not.	aView _ View new.	aView		addSubView: formViewBordered;		addSubView: menuView		align: (onSide				ifTrue: [menuView viewport leftCenter]				ifFalse: [menuView viewport topCenter])		with: (onSide				ifTrue: [formViewBordered viewport rightCenter + (8@0)]				ifFalse: [formViewBordered viewport bottomCenter + (0@8)]);		window: (aView window expandBy: (10@10 extent: 0@0));		insideColor: Form lightGray "white";		borderWidth: 1.	formView controller setVariables.	^aView!createNewEditor: whichType title: theTitle	| theFileName answers x y values labels |	Cursor wait show.	whichType = #Standard		ifTrue:[^ self createNewImageOnForm: (Form extent: 512@512) theLabel: theTitle].	whichType = #FullPage		ifTrue: [^ self createNewImageOnForm: (Form extent: 640@800) theLabel: theTitle]. "520@720"	whichType =#Landscape		ifTrue:[^ self createNewImageOnForm: (Form extent: 800@586) theLabel: theTitle]. "720@520 "	whichType = #InputSize		ifTrue:[labels _ #(('height in inches:' ) ('width in inches:' )).			answers _DBoxView				openFor: #(fill fill)				title: 'Input the height and width of ', theTitle				labels: labels				defaults: (Array with: (String with: $2) with: (String with: $3)).				answers == nil ifTrue:[^nil].			1 to: 2 do: [:i | (answers at: i) isNumeric				ifFalse: [self booboo: 'Input should have been numeric.'.					^self createNewEditor: whichType title: theTitle]].			y _ (((answers at: 1) asNumber) * 79) asInteger.				y < 800 ifFalse: [self booboo: 'Selected area was too high, 9 inches is the max.'.					^self createNewEditor: whichType title: theTitle].			x _ (((answers at: 2) asNumber) * 79) asInteger.				x < 910 ifFalse: [self booboo: 'Selected area was too low, 11.5 inches is the max.'.					^self createNewEditor: whichType title: theTitle].			^ self createNewImageOnForm: (Form extent: x@y) theLabel: theTitle].	whichType = #FrameSize		ifTrue:[^ self createNewImageOnForm: ((Form fromUser ) white) theLabel: theTitle].	whichType = #FromScreen		ifTrue:[^ self createNewImageOnForm: Form fromUser theLabel: theTitle]!createOnForm: aForm	"Creates a StandardSystemView for an AnnotationEditor on the form aForm."	^self createStandardSystemViewWith:		(self createMenuedViewWith:			(self createBorderedViewOnForm: aForm))!createStandardSystemViewWith: aView	| topView |	^(topView _ StandardSystemView new)		addSubView: aView;		label: self name;		minimumSize: topView viewport extent;		maximumSize: topView viewport extent;		helpIndex: #Image!openOnForm: aForm	"Create and schedule an instance of me on the form aForm."	| topView |	topView _ self createNewImageOnForm: aForm theLabel: #ImageEditor asString.	topView controller open!openOnForm: aForm at: originPoint	"Create and schedule an instance of me on the form aForm whose view origin is	originPoint."	| topView |	topView _ self createOnForm: aForm.	topView controller 		openDisplayAt: originPoint + (topView viewport extent//2)! !!ImageEditor class methodsFor: 'menu accessing'!activityMenu	| temporaryArray |ActivityMenu == nil ifTrue: [	temporaryArray _ Array new: 9.	temporaryArray at: 5 put: ((TreeMenu labels: 'open curve{select pts in sequence; click middle button to draw}closed curve{select pts in sequence; click middle button to draw}open linear{select pts in sequence; click middle button to draw}closed linear{select pts in sequence; click middle button to draw}') answers: #(opnCurve clCurve opnLinear clLinear)).	ActivityMenu _ (TreeMenu labels: 'draw{copy brush to image while button pressed}stamp{each click copies brush to image once}line{press at start pt., release at end pt.}curve{press at start pt., release at end pt., click at mid pt.}splinesrectangle{frame outside of rect.}circle{press at center pt., release at radius}block{frame rect. to be filled}fill{frame limits of fill; click inside area to be filled}' lines: #(4 7) ) answers: #(draw stamp line curve yourself rectangle circle block fill); children: temporaryArray].	^ActivityMenu!brushMenu	| temporaryArray1 temporaryArray2 |	BrushMenu == nil ifTrue: [temporaryArray1 _ Array new: 6.	temporaryArray1 at: 2 put: ((TreeMenu labels: '90180270') answers: #(rotate90 rotate180 rotate270)). 	(temporaryArray2 _ Array new: 14)			at: 2 put: (IconSubmenu _ self initializeIconMenu);			at: 3 put: (SymbolSubmenu _ self initializeSymbolMenu);			at: 4 put: ((TreeMenu labels: 'invertrotatemirrormagnifyshrinkborder') answers: #(invertBrush yourself horizontalReflection magnifyBrush shrink borderBrush); children: temporaryArray1).		BrushMenu _ (TreeMenu labels: 'defaulticonssymbolsaltersquareroundrectanglecircleframesurroundcopypastesavehardcopy{hardcopy brush}' lines: #(1 3 4 6 8 10 )) answers: #(defaultBrush icon symbol yourself square dot rectangleBrush circleBrush newSourceForm grabArbitraryImage copyBrush pasteBrush fileOutForm hardcopyBrush); children: temporaryArray2].	^BrushMenu!colorMenu	| delta performer rectangle newForm |ColorMenu == nil ifTrue: [	ColorMenu _ (TreeMenu labels: '	blackdark graygraylight grayvery light gray whitestripepin stripeslant(copy)(paste)' lines: #(1 2 3 4 5 6 7 8 9) ) answers: #(colorBlack colorDarkGray colorGray colorLightGray colorVeryLightGray colorWhite colorStripe colorPinStripe colorSlant copyColor pasteColor).	rectangle _ 0@0 corner: 28@ColorMenu form height.	rectangle _ rectangle scaleBy: 1 @ (1.0 / ColorMenu answers size).	delta _ 0 @ rectangle height.	newForm _ Form extent: ColorMenu form width + 28 @ ColorMenu form height.	ColorMenu form displayOn: newForm at: 28@0.	ColorMenu form: newForm height: ColorMenu form height / ColorMenu answers size.	#(black darkGray gray lightGray veryLightGray white stripe pinStripe slant) do:		[:eachColor |		performer _ (self class canUnderstand: eachColor)			ifTrue: [self] ifFalse: [Form].		ColorMenu form			fill: (rectangle rounded insetBy: 2@1)			rule: Form reverse			mask: (performer perform: eachColor).		rectangle moveBy: delta]].	^ColorMenu!gridMenuGridMenu == nil ifTrue: [	GridMenu _ (TreeMenu labels:'on/offspacing')			answers: #(toggleGridding changeGridding);			children: (Array with: ((TreeMenu labels: 'xy') answers: #(toggleyGridding togglexGridding)) with: nil)].	^GridMenu!initializeBrushListMenu: anArray font: fontNumber maxLines: nLines	| answers aCharacter labels |	labels _ WriteStream on: String new.	answers _ anArray copy.	1 to: answers size do:		[:i |		aCharacter _ (answers at: i).		answers at: i put: aCharacter.		i = 1			ifTrue: [labels space; space; nextPut: aCharacter; space; space]			ifFalse: [labels cr; nextPut: aCharacter]		].	^(ScrollMenu new labels: labels contents font: (TextStyle default fontAt: fontNumber) lines: #()) maxLines: nLines; answers: answers!initializeIconMenu	^self initializeBrushListMenu: #($H $J $K $L $C $D $E $M $N $O $i $p $q $r $t $u $v $w $x $y $z) font: IconFontNumber maxLines: 10!initializeSymbolMenu	| anArray menu|	anArray _ #($% $& $) $( $* $. $A $B $F $G $I $R $S $a $b $c $d).	menu _ self initializeBrushListMenu: anArray font: IconFontNumber maxLines: 10.	menu children: (self initializeBrushListMenu: #($1 $2 $3 $4 $5 $6 $7) font: IconFontNumber maxLines: 7).	^menu!modeMenu	"(ModeMenu isKindOf: TreeMenu)		ifTrue: [ModeMenu letGo]."ModeMenu == nil ifTrue: [	ModeMenu _ (TreeMenu labels: 'overunderreverseerase'  lines: #()) answers: #(overMode underMode reverseMode eraseMode)].	^ModeMenu! !!ImageEditor class methodsFor: 'private'!createBorderedViewOnForm: aForm	| formView |	formView _ FormHolderView new		model: aForm;		controller: self new.	^View new		addSubView: formView;		borderWidth: 2!iconFontName	^'AnalystIcons1'! !!ImageEditor class methodsFor: 'new colors'!pinStripe	^Form extent: 16@16 fromArray: #(		16r1010 0 16r1010 0		16r1010 0 16r1010 0		16r1010 0 16r1010 0		16r1010 0 16r1010 0) offset: 0@0!slant	^Form extent: 16@16 fromArray: #(		16r1111 16r2222 16r4444 16r8888		16r1111 16r2222 16r4444 16r8888		16r1111 16r2222 16r4444 16r8888		16r1111 16r2222 16r4444 16r8888) offset: 0@0!stripe	^Form extent: 16@16 fromArray: #(		4r30303030 4r30303030 4r30303030 4r30303030 		4r30303030 4r30303030 4r30303030 4r30303030		4r30303030 4r30303030 4r30303030 4r30303030		4r30303030 4r30303030 4r30303030 4r30303030) offset: 0@0! !!ImageEditor class methodsFor: 'open from info center'!createNewImageOnForm: aForm theLabel: aLabel	| theSuitcase | 	aForm extent <= (910@800)		ifTrue: [	theSuitcase _ (Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem type: #Item label: aLabel atIndex: 0)).	self createNewImageOnForm: aForm withSuitcase: theSuitcase].	self booboo: aForm extent printString, ' is too big to display'.	Cursor normal show!createNewImageOnForm: aForm withSuitcase: aSuitcase	"Creates a StandardSystemView for a MapDraw on the form aForm."	| aImageDraw aView formViewBordered textView topView width |	formViewBordered _ self createBorderedViewOnForm: aForm.	aImageDraw _ formViewBordered firstSubView controller.	aImageDraw mapControl: aSuitcase dataItem filename.	aView _ self createMenuedViewWith: formViewBordered.	aView borderWidth: 1.	width _ aView window extent x.	textView _ TextCollectorView new		model: TextCollector new;		window: (0 @ 0 extent: width @ 50);		controller: ImageEditorTextCollector new;		insideColor: Form white;		borderWidth: 1.	aImageDraw transcriptController: textView controller.	(topView _ StandardSystemView new)		model: aForm;		addSubView: textView;		addSubView: aView below: textView;		controller: ClassifiedStandardSystemController new;		label: (aSuitcase dataItem label);		borderWidth: 1;		minimumSize: topView viewport extent;		maximumSize: topView viewport extent;		helpIndex: #Sketch.	topView classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.	Cursor normal show.	topView controller open!hardcopyWithSuitcase: suitcase	(Smalltalk includesKey: #BackgroundPrinter) ifFalse: [^self booboo: 'Printing is not installed'].	BackgroundPrinter printForm: (Form readFromSuitcase: suitcase) suitcase: suitcase!openWithSuitcase: aSuitcase	"Create an instance of me on a new form designated by the user from a file designated by the user."	Cursor wait show.	self createNewImageOnForm: (Form readFromSuitcase: aSuitcase) withSuitcase: aSuitcase! !!ImageEditor class methodsFor: 'examples'!formFromDisplay	"Create an instance of me on a new form designated by the user at a location 	designated by the user."	Form fromUser edit	"ImageEditor formFromDisplay."!newForm	"Create an instance of me on a new form at a location designated by the user."	(Form new extent: 300@300) edit	"ImageEditor newForm."!newFormAtOrigin	"Create an instance of me on a new form at location 100,100."	(Form new extent: 300@300) editAt: 100@100	"ImageEditor newFormAtOrigin."! !!MapEditor class methodsFor: 'class initialization'!initialize	| newMenu selection |	"MapEditor initialize"	" . . . creates the tree menus"	HintSize _ 7.	HeaderSize _ 28.	HintsBufferSize _ HeaderSize lcm: 512.  "Integral number of segment hints (necessary) and integral number of (Alto) file pages (for efficiency)."	DataBufferSize _ 8 * 512.	DataFormatToLatLonWindowingTransformation _ WindowingTransformation		scale: (Point x: 360.0 y: 180.0) / 2r1.0e32		translation: (0.0@-90.0).	TempMapName _ 'TEMPZOOM'.	(MapYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [MapYellowButtonMenu letGo].	MapYellowButtonMenu _ (TreeMenu labels:'resetacceptcancelcopypasteeraseinvertmagnifysave filehardcopydatabaseslocationredraw mapzoomanimate' lines: #(1 7 10 12)).	MapYellowButtonMenu		children: ((Array new: 15)				at: 11 put: self initializeDatabaseSubmenu;				at: 12 put: self initializeOtherSubmenu;				yourself);		answers: #(setVariables accept cancel copy paste erase invert magnify putMap hardcopyImage yourself yourself drawMap zoom animate)!initializeDatabaseSubmenu	"Initialize the map database branch of the Map window TreeMenu."	^(TreeMenu labels:'display databasesquery & displayselect & searchshow full recordmake new databasemodify database linksadd to databaseremove placeredisplay all' lines: #(1 4 6))		answers: #( dataDisplay dataDisplayQuery selectPlace showRecord makeNewMapDatabase modifyDatabaseLinks addPointToDatabase removePlace redisplayAllPoints);		children: ((Array new: 9) yourself)!initializeOtherSubmenu	"Initialize the other branch of the Map window TreeMenu."  	^(TreeMenu labels:'lat/lonlat/lon griddist/bearing' lines: #(2))		answers: #(latLonBig geogGrid distanceBearingBig);		children: ((Array new: 3) yourself)! !!MapEditor class methodsFor: 'instance creation'!createNewOnForm: aForm withSuitcase: aSuitcase	"Creates a StandardSystemView for a MapEditor on aForm."	| aMapEditor aView formViewBordered latLonDistBearView pictureList theListView topView width theListFile |	formViewBordered _ self createBorderedViewOnForm: aForm.	aMapEditor _ formViewBordered firstSubView controller.	aMapEditor mapWaitingToBeDrawn: aSuitcase dataItem filename.	aView _ self createMenuedViewWith: formViewBordered.	aView borderWidth: 1.	width _ aView window extent x.	latLonDistBearView _ TextCollectorView new		model: TextCollector new;		controller: ImageEditorTextCollector new;		window: (0 @ 0 extent: width @ 50);		insideColor: Form white;		borderWidth: 1.	aMapEditor transcriptController: latLonDistBearView controller.	(Disk includesKey: aSuitcase dataItem filename, (DataMaster mapSuffixFor: #mapList)) ifTrue: [theListFile _ aSuitcase dataItem filename].	theListFile == nil ifFalse:		[latLonDistBearView window: (0 @ 0 extent: (width - 240) @ 50);			borderWidth: 1.		(pictureList _ MapFileList new list: OrderedCollection new)			newListAndPattern: theListFile;			whereToPutIt: aMapEditor view.		theListView _ ListView new			model: pictureList controller: ListController new;			list: pictureList list;			window: (0 @ 0 extent: 240 @ 50);			borderWidth: 1].	(topView _ StandardSystemView new)		controller: ClassifiedStandardSystemController new;		addSubView: latLonDistBearView;		addSubView: aView		below: latLonDistBearView.	theListFile isNil ifFalse: [topView addSubView: theListView toRightOf: latLonDistBearView].	topView		label: aSuitcase dataItem label;		model: aForm;		borderWidth: 1;		minimumSize: topView viewport extent;		maximumSize: topView viewport extent;		helpIndex: #Map.	topView addDependent: aSuitcase.	topView classifyLabel: aSuitcase classification.	^topView!drawNewMapWithSuitcase: aSuitcase"	Open a MapEditor window, then draw this map.	controlFileName	<String> the name of the map's .control file (The extension '.control' will be automatically appended to controlFileName.)	windowLabelString	<String> to be used as the window's label	"	| aspectPoint mapRectangle fileStream |	fileStream _ self openOldFile: aSuitcase dataItem filename, (DataMaster giveMe: #specialSuffixString for: #map asString).	fileStream == nil ifTrue: [^self booboo: 'Cannot find control file for ',aSuitcase dataItem filename].	fileStream readOnly.	mapRectangle _ Rectangle numbersReverseInit: [Number readNumberFrom: fileStream].	fileStream close.	aspectPoint _ mapRectangle extent * (((mapRectangle origin y + mapRectangle corner y / 2) degreesToRadians cos) @ 1).	self drawNewMapWithSuitcase: aSuitcase extent: (self fromUserAspectRatio: aspectPoint) extent!drawNewMapWithSuitcase: aSuitcase extent: mapScreenExtent"	aSuitcase	<Suitcase> object that containes all of the windows opening parameters	mapScreenExtent	<Point>	the x and y dimensions of the MapForm to be created	"	(self createNewOnForm: (MapForm new extent: mapScreenExtent) withSuitcase: aSuitcase) controller open!openOnOldMap: aSuitcase	"Creates a StandardSystemView for a MapEditor on aForm."	| theName aForm formViewBordered aMapEditor aView width latLonDistBearView theListFile pictureList theListView topView |	theName _ aSuitcase dataItem filename.	aForm _ (MapForm readFromSuitcase: aSuitcase).	formViewBordered _ self createBorderedViewOnForm: aForm.	aMapEditor _ formViewBordered firstSubView controller.	aMapEditor mapControl: theName withSuitcase: aSuitcase.	aView _ self createMenuedViewWith: formViewBordered.	aView borderWidth: 1.	width _ aView window extent x.	latLonDistBearView _ TextCollectorView new		model: TextCollector new;		controller: ImageEditorTextCollector new;		window: (0 @ 0 extent: width @ 50);		insideColor: Form white;		borderWidth: 1.	aMapEditor transcriptController: latLonDistBearView controller.	(Disk includesKey: theName, (DataMaster mapSuffixFor: #mapList)) ifTrue: [theListFile _ theName].	theListFile == nil ifFalse:		[latLonDistBearView window: (0 @ 0 extent: (width - 240) @ 50);			borderWidth: 1.		(pictureList _ MapFileList new list: OrderedCollection new)			newListAndPattern: theListFile;			whereToPutIt: aMapEditor view.		theListView _ ListView new			model: pictureList controller: ListController new;			list: pictureList list;			window: (0 @ 0 extent: 240 @ 50);			borderWidth: 1].	(topView _ StandardSystemView new)		controller: ClassifiedStandardSystemController new;		model: aForm;		addSubView: latLonDistBearView;		addSubView: aView		below: latLonDistBearView.	theListFile isNil ifFalse: [topView addSubView: theListView toRightOf: latLonDistBearView].	topView		label: aSuitcase dataItem label;		minimumSize: topView viewport extent;		maximumSize: topView viewport extent;		borderWidth: 1;		helpIndex: #Map.	topView addDependent: aSuitcase.	topView classifyLabel: aSuitcase classification.	topView controller open!openWithSuitcase: aSuitcase"	Open a MapEditor window on a MapForm read from a file.theFileName	<String>	the name of the file from which the MapForm is to be readaLabel	<String> to be used as the window's label"	(aSuitcase dataItem filename == nil or: [(self getOldFileName: aSuitcase dataItem filename) == nil])		ifTrue: [self drawNewMapWithSuitcase: aSuitcase]		ifFalse: [self openOnOldMap: aSuitcase]! !!MapEditor class methodsFor: 'private'!createBorderedViewOnForm: aForm	| formView |	formView _ MapView new		model: aForm;		controller: self new.	^View new		addSubView: formView;		borderWidth: 1!fromUserAspectRatio: aspectPoint 	"Answer an instance of Rectangle that is determined by having the user 	designate the top left and bottom right corners, constrained so the aspect 	ratio is determined by aspectPoint."	| rectangle extent ratio |	Cursor origin showWhile: [rectangle _ Sensor waitButton extent: 1 @ 1].	ratio _ aspectPoint y / aspectPoint x.	Cursor corner		showWhile: 			[Sensor cursorPoint: rectangle corner.			Display				outline: 					[extent _ Sensor cursorPoint - rectangle origin max: 1 @ 1.					extent y * aspectPoint x > (aspectPoint y * extent x)						ifTrue: [extent x: (extent y / ratio) rounded]	"constrain width"						ifFalse: [extent y: (extent x * ratio) rounded].	"constrain height"					extent y + 75 > Display height						ifTrue: 							[extent y: Display height - 75.			"constrain the whole thing in y"							extent x: (extent y / ratio) rounded].							extent x + 175 > Display width						ifTrue: 							[extent x: Display width - 175.			"constrain the whole thing in y"							extent y: (extent x * ratio) rounded.].							rectangle extent: extent]				while: [Sensor anyButtonPressed]				width: 2				halftone: Form gray].	^rectangle	"MapEditor fromUserAspectRatio: Sensor waitButton"!headerToLatLonTransformation	^DataFormatToLatLonWindowingTransformation! !ChartEditor class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!ChartEditor class methodsFor: 'instance creation'!createBorderedViewOnForm: aForm theStuff: anArray	| formView |	formView _ FormHolderView new		model: aForm;		controller: ((self new) unpackData: anArray ).	^View new		addSubView: formView;		borderWidth: 1!createBorderedViewOnForm: aForm withFileSet: fileName imageFileName: imageFileName	| formView | 	formView _ FormHolderView new		model: aForm;		controller: self new.	formView controller mapControl: imageFileName.	formView controller loadFromFile: fileName.	^View new		addSubView: formView;		borderWidth: 1!createNewImageOnForm: aForm withSuitcase: aSuitcase andData: theData	| theFileName formViewBordered aView textView chartEditor topView |	theFileName _ aSuitcase dataItem filename.	theData == nil		ifTrue:			[theFileName == nil				ifTrue: [formViewBordered _ self createBorderedViewOnForm: aForm]				ifFalse: [formViewBordered _ self							createBorderedViewOnForm: aForm							withFileSet: theFileName, (DataMaster giveMe: #specialSuffixString for: #chart asString)							imageFileName: theFileName]]		ifFalse: [formViewBordered _ self createBorderedViewOnForm: aForm theStuff: theData].	(aView _ self createMenuedViewWith: formViewBordered) borderWidth: 1.	textView _ (TextCollectorView new) model: TextCollector new;		controller: ImageEditorTextCollector new;		window: (0 @ 0 extent: aView window extent x @ 50);		insideColor: Form white;		borderWidth: 1.	(chartEditor _ formViewBordered firstSubView controller) firstTime: (theFileName == nil or: [theData ~= nil]);		transcriptController: textView controller.	(topView _ StandardSystemView new) model: aForm;		controller: ClassifiedStandardSystemController new;		addSubView: textView;		addSubView: aView below: textView;		label: aSuitcase dataItem label;		borderWidth: 1;		minimumSize: topView viewport extent;		maximumSize: topView viewport extent;		helpIndex: #Chart.	topView classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.	Cursor normal show.	topView controller open!openWithSuitcase: aSuitcase	"Creates a StandardSystemView for an ChartEditor on the form sepcified in the suitcase."	Cursor wait show.	self createNewImageOnForm: (Form readFromSuitcase: aSuitcase) withSuitcase: aSuitcase andData: nil! !!ChartEditor class methodsFor: 'class initialization'!initialize	"ChartEditor initialize"	". . . creates the tree menus."	(ChartEditorYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [ChartEditorYellowButtonMenu letGo].	ChartEditorYellowButtonMenu _ TreeMenu createMenuFrom:'-reset _ setVariablesaccept _ accept-cancel _ cancelcopy _ copy-paste _ pasteerase _ erase-magnify _ magnifyredraw _ chartDataNowchange chart _ yourself	parameters _ chartData	size _ resize	add labels _ label	add legend _ legend-change data _ yourself	replace data _ makeNew	modify data _ modify	sum data _ compressDatasave _ putMaphardcopy _ hardcopyImage'! !LabelSwitchController class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!StandardSystemController class methodsFor: 'class initialization'!initialize	"StandardSystemController  initialize"	ScheduledBlueButtonMenu _ TreeMenu labels:'help{Create a help window for this window}connections {access any connections to this item}close others{Close all other windows}select and close{Select window(s) to be closed}find{Activate another window of your choice}move{Move this window}frame{Move and/or change the size of this window}collapse{Collapse this window down to a label}close self{Close this window}'		lines: #(1 4 8 ).	ScheduledBlueButtonMessages _ #( help getLinks smashThem smashOne findOne move expand collapse close ).	MenuWhenCollapsed _ (TreeMenu labels:'help{Create a help window for this window}connections {access any connections to this item}close others{Close all other windows}select and close{Close the selected window}find{Activate another window of your choice}move{Move this label}frame{Open the window at a selected position}expand{Open the window, and return it to its last position}close self{Close this window}'		lines: #(1 4 8)) answers: #(help getLinks smashThem smashOne findOne move frame restoreFullView close)! !StandardSystemSpreadsheetController class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!DBStandardSystemController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!BackgroundController class methodsFor: 'initialize'!initialize	"BackgroundController initialize"	". . . initializes the yellow button tree and pop-up menus and corresponding messages."	WindowLocation _ 778@22.	AccessProtect _ Semaphore forMutualExclusion.	DisplayUpdate _ true.	(BackgroundYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [BackgroundYellowButtonMenu letGo].	self initializeQueueEntryMenu.	BackgroundYellowButtonMenu _ ((TreeMenu labels:'show currentmodify currentabort currentempty queueshow queue itemmodify queue itemremove from queuemove to frontrestart queue' lines: #(4 8))		children: ((Array new: 9)			at: 5 put: QueueEntryMenu;			at: 6 put: QueueEntryMenu;			at: 7 put: QueueEntryMenu;			at: 8 put: QueueEntryMenu; yourself);		answers: #(showCurrent modCurrent abortCurrent emptyQueue showEntry modEntry removeEntry moveEntry restartQueue))!initializeQueueEntryMenu	| tempMenu |	tempMenu _ ScrollMenu new: 5 on: String new.	QueueEntryMenu == nil		ifTrue: [QueueEntryMenu _ tempMenu]		ifFalse:			[BackgroundPrinter numWaiting = 0 ifFalse:				[tempMenu _ ScrollMenu new: 5 on: BackgroundPrinter numWaiting]].	QueueEntryMenu become: tempMenu.	^QueueEntryMenu! !!BackgroundController class methodsFor: 'instance access'!accessInstanceDo: aBlock	AccessProtect critical: [aBlock value]!backgroundAccess	self accessInstanceDo:		[AccessInstance == nil			ifTrue: [(AccessInstance _ self new) openBackgroundView]			ifFalse:				[AccessInstance reprieve.				 self initializeQueueEntryMenu.				 AccessInstance initializeYellowButtonMenu]].	^AccessInstance!closeBackgroundAccess	self accessInstanceDo:		[AccessInstance == nil ifFalse:			[AccessInstance commitSuicide: true]]!endIdleMode	| bc |	bc _ AccessInstance.	bc == nil ifFalse: [bc view clearInside; displayView].	DisplayUpdate _ true!idleMode	| bc |	bc _ AccessInstance.	bc == nil ifFalse: [DisplayUpdate _ false. bc idleForeground]!unprotectedBackgroundAccess	^AccessInstance! !!ClassifiedStandardSystemController class methodsFor: 'initialize'!initialize	"ClassifiedStandardSystemController  initialize"	ClassifiedBlueButtonMenu _ (TreeMenu labels:'help{Create a help window for this window}connections {access any connections to this item}classification{Change the classification of this window}close others{Close all other windows}select and close{Close the selected window}find{Activate another window of your choice}move{Move this window}frame{Move and/or change the size of this window}collapse{Collapse this window down to a label}close self{Close this window}'		lines: #(1 5 9 )) answers: #(help getLinks changeClassification smashThem smashOne findOne move expand collapse close).	ClassifiedBlueButtonMessages _ FakeCollection withAll: #performBlueSelections! !!BitEditor class methodsFor: 'private'!bitEdit: aForm at: magnifiedFormLocation scale: scaleFactor remoteView: remoteView	"Creates a BitEditor on aForm. That is, aForm is a small image that will 	change as a result of the BitEditor changing a second and magnified 	view of me. magnifiedFormLocation is where the magnified form is to be 	located on the screen. scaleFactor is the amount of magnification. This 	method implements a scheduled view containing both a small and 	magnified view of aForm. Upon accept, aForm is updated."	| aFormView scaledFormView bitEditor topView extent menuView lowerRightExtent |	scaledFormView _ FormHolderView new model: aForm.	scaledFormView scaleBy: scaleFactor.	bitEditor _ self new.	bitEditor setColor: #black.	scaledFormView controller: bitEditor.	topView _ StandardSystemView new.	remoteView == nil ifTrue: [topView label: 'Bit Editor'].	topView borderWidth: 2.	topView insideColor: Form white.	topView addSubView: scaledFormView.	remoteView == nil		ifTrue:  "If no remote view, then provide a local view of the form"			[aFormView _ FormView new model: scaledFormView workingForm.			aFormView controller: NoController new.			(aForm isMemberOf: OpaqueForm) ifTrue:				[scaledFormView insideColor: Form gray.				aFormView insideColor: Form white].			aForm height < 50				ifTrue: [aFormView borderWidthLeft: 0 right: 2 top: 0 bottom: 2]				ifFalse: [aFormView borderWidthLeft: 0 right: 2 top: 0 bottom: 2].			topView addSubView: aFormView above: scaledFormView]		 ifFalse:  "Otherwise, the remote one should view the same form"			[remoteView model: scaledFormView workingForm].	lowerRightExtent _ remoteView == nil			ifTrue:				[(scaledFormView viewport width - aFormView viewport width) @					(aFormView viewport height max: 50)]			ifFalse:				[scaledFormView viewport width @ 50].	topView minimumSize: extent.	topView maximumSize: extent.	topView translateBy: magnifiedFormLocation.	^topView! !!BitEditor class methodsFor: 'initialize'!initialize	"The Bit Editor is the only controller to override the use of the blue button with	a different pop-up menu.  Initialize this menu."	YellowButtonMenu _ PopUpMenu labels:'accept{Store changes to the Form.}cancel{Cancel changes to the Form.}'.	YellowButtonMessages _ #(accept cancel )		"BitEditor initialize."! !!FormsEditController class methodsFor: 'class initalization'!initialize	"Initialize the yellow button pop-up menu the field list."	FEYellowButtonMenu _ TreeMenu createMenuFrom:'add _ makeAnElementOfType:	label{make an inactive label} _ [#LabelElement]	fill in{make an element to hold and edit text} _ [#FillElement]	switch{make an on-off switch element} _ [#SwitchElement]	choice{make a one-of choice element} _ [#OneOfElement]	execute{make a special action button} _ [#ExecuteElement]	image{insert an image element} _ [#ImageElement]-delete{remove the selected element}_ deleteElementedit{alter the selected element} _ editElementmove{move the selected element} _ moveElementduplicate{make a duplicate of the selected element} _ duplicate-reshape{alter the shape of the element} _ reshapeElementredisplay{redisplay the form} _ redisplayrename form{rename this form} _ rename-save form{save this form} _ saveget code{get the code equivalent for this form} _ clipCodeend edit{begin using this form} _ endEdit'.	FEYellowButtonMenu resultBlock: TreeMenu usefulResultBlock.	FEYellowButtonMessages _ TreeMenu	"FormsEditController initialize"! !Pool named: #TextConstants includes: #Ctrlf!Pool named: #TextConstants includes: #Ctrlw!Pool named: #TextConstants includes: #CR!Pool named: #TextConstants includes: #ESC!Pool named: #TextConstants includes: #Cut!Pool named: #TextConstants includes: #BS!Pool named: #TextConstants includes: #Paste!Pool named: #TextConstants includes: #Ctrlt!Pool named: #TextConstants includes: #Tab!Pool named: #TextConstants includes: #BS2!!ParagraphEditor class methodsFor: 'class initialization'!fontSubMenu	FontMenu == nil ifTrue: [self initFontMenu].	^FontMenu!initFontMenu	| formText formString start stop tempMenu |	formString _ String new.	#(' fixed width 10 ' ' sans-serif 14 ' ' sans-serif 12 ' ' sans-serif 10 ' ' sans-serif 7 ' ' serif 18 ' ' serif 14 ' ' serif 12 ' ' serif 10 ') do: [:fontName | 6 timesRepeat: [formString _ fontName, formString]].	formString _ formString copyFrom: 1 to: formString size - 1. "get rid of CR on end"	tempMenu _ (ScrollMenu new labels: formString font: (TextStyle default fontAt: 35) lines: #() ) maxLines: 9; answers: #(1 2 3 40 41 42 4 5 6 43 44 45 25 26 27 64 65 66 7 8 9 46 47 48 22 23 24 61 62 63 31 32 33 70 71 72 10 11 12 49 50 51 13 14 15 52 53 54 37 38 39 76 77 78).	formText _ formString asText.	start _ 1.	1 to: (tempMenu answers size) do: [ :i |  stop _ formText findString: '' startingAt: start.	stop = 0 ifTrue:[stop _ formText size.].	formText emphasizeFrom: start to: stop with: (tempMenu answers at: i).	start _ stop + 1.].	tempMenu form become: formText asParagraph asForm.	tempMenu selectBlock: nil. "don't want to see No Help"	FontMenu == nil		ifTrue: [FontMenu _ tempMenu]		ifFalse: [FontMenu become: tempMenu].	^FontMenu"ParagraphEditor initFontMenu"!initialize	"Initialize the yellow button menu information, the keyboard map for special	control characters, and the shared buffers for copying text across views and	managing undo."	CurrentSelection _ UndoSelection _ Text new.	TextEditorYellowButtonMenu _ PopUpMenu labels:'againundocopycutpasteacceptcancelputhardcopyalignfit'	lines: #(2 5 7).	TextEditorYellowButtonMessages _ 		#(again undo copySelection cut paste accept cancel put hardcopy align fit).	Keyboard _ Array new: 256.	Keyboard		atAllPut: #normalCharacter:;		at: Cut asciiValue + 1 put: #cut:;		at: Paste asciiValue + 1 put: #paste:;		at: ESC asciiValue + 1 put: #selectCurrentTypeIn:;		at: BS asciiValue + 1 put: #backspace:;		at: Ctrlw asciiValue + 1 put: #backWord:;		at: Ctrlt asciiValue + 1 put: #displayIfTrue:;		at: Ctrlf asciiValue + 1 put: #displayIfFalse:;		at: CR asciiValue + 1 put: #cr:;		at: Tab asciiValue + 1 put: #tab:;		at: 132 + 1 put: #displayDate:.	"ctrl-d"	#(159 144 143 128 127 129 131 180 149 135 223 208		"fonts"		137 201											"underline, unUnderline"		166 230											"bold, unbold"		150 214											"italic, unitalic"		151												"clear emphasis")	do: 		["CTL-1 thru 9, and 0, CTLSHIFT 1-2			CTL-, CTLSHIFT-"		:i |	Keyboard at: i + 1 put: #changeEmphasis:].	#(213 7 218 249 219 15) do: 		[:i | "ctl open brackets"		Keyboard at: i + 1 put: #enclose:].	Keyboard at: BS2 asciiValue + 1 put: #leaveBrackets:.	"ParagraphEditor initialize."! !!ParagraphEditor class methodsFor: 'utility'!copyText: aText	aText class == Text		ifTrue: [Clipboard clip: (CurrentSelection _ UndoSelection _ LastTyped _ aText)]		ifFalse: [aText class == String ifTrue: [self copyText: aText asText]]! !!BigParagraphEditor class methodsFor: 'instance creation'!new	"Answer a new instance of me with a null BigParagraph to be edited."	^ self newParagraph:		(BigParagraph withText: '' asText)! !!BigStringHolderController class methodsFor: 'class initialization'!initHexFontMenu	| formText formString start stop tempMenu |	formString _ String new.	#(' fixed width 10 ' ' sans-serif 14 ' ' sans-serif 12 ' ' sans-serif 10 ' ' sans-serif 7 ' ' serif 18 ' ' serif 14 ' ' serif 12 ' ' serif 10 ') do: [:fontName | 6 timesRepeat: [formString _ fontName, formString]].	formString _ formString copyFrom: 1 to: formString size" - 1". "get rid of CR on end"	formString _ formString, ' Hexadecimal'.	tempMenu _ (ScrollMenu new labels: formString font: (TextStyle default fontAt: 35) lines: #() ) maxLines: 9; answers: #(1 2 3 40 41 42 4 5 6 43 44 45 25 26 27 64 65 66 7 8 9 46 47 48 22 23 24 61 62 63 31 32 33 70 71 72 10 11 12 49 50 51 13 14 15 52 53 54 37 38 39 76 77 78 100).	formText _ formString asText.	start _ 1.	1 to: (tempMenu answers size - 1) do: [ :i |  stop _ formText findString: '' startingAt: start.	stop = 0 ifTrue:[stop _ formText size.].	formText emphasizeFrom: start to: stop with: (tempMenu answers at: i).	start _ stop + 1.].	tempMenu form become: formText asParagraph asForm.	FontMenu == nil		ifTrue: [FontMenu _ tempMenu]		ifFalse: [FontMenu become: tempMenu].	^FontMenu	"BigStringHolderController initHexFontMenu"!initialize		"BigStringHolderController initialize"	". . . initializes the yellow button Tree menu and corresponding messages."	(CodeYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [CodeYellowButtonMenu letGo].	CodeYellowButtonMenu _ 		TreeMenu  			labels: 'againundocopycutpastedo itprint itacceptcancelput{Save to disk the contents of the window.}hardcopy{Print out the contents of the window.}time stamp{Past the current date/time into the window.}fonts{Move to right to select font.}' 			lines: #(2 5 7 9).	CodeYellowButtonMenu children:			((Array new: 13)				at: 13 put: self fontSubMenu;				yourself);		answers: #(again undo copySelection cut paste doIt printIt accept cancel put hardcopy timeStamp fontIt).! !!ComposeTextController class methodsFor: 'class initialization'!initialize	"ComposeTextController initialize"	" . . . creates the tree menu"	(ComposeYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [ComposeYellowButtonMenu letGo].	ComposeYellowButtonMenu _ TreeMenu createMenuFrom:'again _ again-undo _ undocopy _ copySelectioncut _ cut-paste _ pastesave _ putstrip CRs _ stripCarraigeReturnssearch _ findIt-hardcopy _ hardcopyTextannotation _ yourself	[ComposeTextController initializeAnnotationSubmenu]fonts{Move to right to select font to apply to selected text} _ fontIt	[ComposeTextController fontSubMenu]-utilities{Move to right for more commands} _ yourself	find/replace{find and/or replace} _ findOrReplace	-add as key word{Add the selected word as a keyword on this item} _ addKeyWord	-time stamp _ timeStamp	restore _ get	-erase file{Erase the saved version of this file} _ erase	compute it _ printIt	generate table{Make table from selected text and put it in copy buffer} _ makeTablefile as new item _ fileIt'!initializeAnnotationSubmenu	" Initialize the  'Annotation' branch of the compose center TreeMenu."	^(TreeMenu labels: 'create{Make the selected text into an annotation}display{Display the selected annotation in an annotation window}expand{Replace the selected annotation with it''s contents}')				answers: #( annotateCreate annotateDisplay annotateExpand)! !!ComposeTextController class methodsFor: 'anno conversions'!makeSimpleTextFileFromSuitcase: aSuitcase	"return nil or the name of a file in which the text in the copy buffer has been stored in non-annotated format"	| fileName fileStream annoModel fullInputFileName |	(fullInputFileName _ self getOldFileName: aSuitcase dataItem filename) == nil ifTrue: [self booboo: 'Cannot find file'. ^nil].	annoModel _ AnnotationModel fileStream: (HeaderFileStream fileNamed: fullInputFileName) withSuitcase: aSuitcase.	annoModel contents isEmpty ifTrue: [^nil].	Cursor execute showWhile: [	fileName _ Disk makeNewFileName: 'TMPVZZZZ' withSuffix: (DataMaster giveMe: #suffixString for: #text asString).	fileStream _ (HeaderFileStream fileNamed: fileName) readWrite.	fileStream writeHeaderFor: aSuitcase dataItem.	self putText: annoModel contents inStream: fileStream usingAnnoDict: annoModel annoDictionary.	fileStream close].	^fileName!previewText: theText annoDict: annoDict withStartSuitcase: startSuitcase portrait: aBoolean	| fileName suitcase |	fileName _ PreviewPage makeFileWithText: theText annoDict: annoDict lkcm: (Array with: #TMPV asString, UserName with: String new with: startSuitcase classification classification with: startSuitcase classification modifiers) portrait: aBoolean.	suitcase _ Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem locked: startSuitcase dataItem isLocked classification: startSuitcase classification classification modifiers: startSuitcase classification modifiers type: #Item label: startSuitcase dataItem label filename: fileName bPointers: nil fPointers: nil atIndex: 0).	suitcase spare: startSuitcase spare.	PreviewPageView openWithSuitcase: suitcase!putText: theText inStream: fileStream usingAnnoDict: annoDict	| runs values sourceText |	theText isEmpty ifTrue: [^self].	runs _ OrderedCollection new.	values _ OrderedCollection new.	((annoDict == nil or: [annoDict isEmpty]) not and: [self confirm: 'With any annotations?'] )		ifTrue: 			[Cursor wait showWhile: [self storeText: theText withAnnos: annoDict on: fileStream runsOn: runs valuesOn: values]]		ifFalse: 			[Cursor wait showWhile: [			sourceText _				(annoDict == nil or: [annoDict isEmpty])					ifTrue: [theText] ifFalse: [self removeAnnosIn: annoDict fromText: theText].			runs _ sourceText runs runs.			values _ sourceText runs values.			fileStream nextPutAll: sourceText string]].	fileStream nextPut: (Character value: 255); nextPut: Character cr; store: (RunArray runs: runs values: values).!removeAnnosIn: annoDict fromText: theText	| sourceText omitPosArray stream character nextCharacter startAnnotation annoString | 	sourceText _ theText copy.	omitPosArray _ OrderedCollection new.	stream _ ReadStream on: sourceText.	[stream atEnd]		whileFalse: 			[character _ stream next.			 character = $:				ifTrue: 					[nextCharacter _ stream next.					nextCharacter = $:						ifTrue: 							[startAnnotation _ stream position - 1.							stream skipTo: $:.							stream skipTo: $:.							omitPosArray add: (Array with: startAnnotation with: stream position)]]].	omitPosArray		reverseDo: 			[:posPair | 			annoString _ sourceText string copyFrom: posPair first to: posPair last.			(annoDict includesKey: annoString) ifTrue:					[sourceText						replaceFrom: posPair first						to: posPair last						with: Text new]].	^sourceText!storeText: theText withAnnos: annoDict on: aFileStream runsOn: runs valuesOn: values	| orderedKeys annotation | 	aFileStream nextPutAll: theText.	runs addAllLast: theText runs runs.	values addAllLast: theText runs values.	aFileStream nextPut: Character cr; nextPut: Character cr; nextPutAll: 'APPENDIX'.	runs add: 10.	values add: 4.	orderedKeys _ annoDict keys asSortedCollection.	orderedKeys do: 		[:key | 		annotation _ annoDict at: key.		(annotation isKindOf: Text)			ifFalse: 				[annoDict at: key put: (Object readFrom: (ReadStream on: annotation)).				annotation _ annoDict at: key].		(annotation size > 0 and: [annotation last asciiValue = 13]) ifTrue: [annotation _ annotation copyFrom: 1 to: annotation size - 1].		aFileStream nextPut: Character cr; nextPut: Character cr; nextPutAll: key; nextPut: Character cr; nextPutAll: annotation.		runs add: key size + 3; addAllLast: annotation runs runs.		values add: 2; addAllLast: annotation runs values]! !!ComposeTextController class methodsFor: 'para conversion'!collectAnnotations: annoDict	| entries newObj orderedKeys annotation keyEmp ts | 	entries _ OrderedCollection new.	newObj _ NewParagraph create.	ts _ TextStyle default.	newObj contents: (Text string: 'APPENDIX' emphasis: (FontMaster findFont: (ts fontAt: 4) ofMedium: #Display)).	entries add: newObj.	orderedKeys _ annoDict keys asSortedCollection.	keyEmp _ FontMaster findFont: (ts fontAt: 31) ofMedium: #Display.	orderedKeys do: 		[:key | 		annotation _ annoDict at: key.		(annotation isKindOf: Text)			ifFalse: 				[annoDict at: key put: (Object readFrom: (ReadStream on: annotation)).				annotation _ annoDict at: key].		(annotation size > 0 and: [annotation last asciiValue = 13]) ifTrue: [annotation _ annotation copyFrom: 1 to: annotation size - 1].		newObj _ NewParagraph create.		newObj contents: (Text string: key, (String with: CR) emphasis: keyEmp), (Text string: annotation string emphasis: 4).		entries add: newObj].	^entries!convertTextToParagraphs: theText	| entries newObj |	theText isEmpty ifTrue: [^OrderedCollection new].	entries _ DocumentEditor convertRegularText: theText.	(entries last isKindOf: Text)		ifTrue: [newObj _ NewParagraph create.				newObj contents: entries last.				entries removeLast; add: newObj].	^entries!makeDocumentFileFromSuitcase: aSuitcase	"return nil or the name of a file in which the text in the copy buffer has been stored in non-annotated format"	| fileName fileStream annoModel fullInputFileName |	(fullInputFileName _ self getOldFileName: aSuitcase dataItem filename) == nil ifTrue: [self booboo: 'Cannot find file'. ^nil].	annoModel _ AnnotationModel fileStream: (HeaderFileStream fileNamed: fullInputFileName) withSuitcase: aSuitcase.	annoModel contents isEmpty ifTrue: [^nil].	Cursor execute showWhile: [	fileName _ Disk makeNewFileName: 'TMPVZZZZ' withSuffix: (DataMaster giveMe: #suffixString for: #document asString).	fileStream _ (HeaderFileStream fileNamed: fileName) readWrite.	fileStream writeHeaderFor: aSuitcase dataItem.	self writeParaText: annoModel contents inStream: fileStream usingAnnoDict: annoModel annoDictionary.	fileStream close].	^fileName!writeParaText: theText inStream: fileStream usingAnnoDict: annoDict	| sourceText withAnno paras |	sourceText _ theText.	withAnno _ (annoDict == nil or: [annoDict isEmpty]) not and: [self confirm: 'With any annotations?'].	withAnno		ifFalse: [(annoDict == nil or: [annoDict isEmpty])					ifFalse: [sourceText _ self removeAnnosIn: annoDict fromText: theText]].	paras _ self convertTextToParagraphs: sourceText.	paras do: [:each | each storeOn: fileStream].	withAnno		ifTrue: [Cursor wait showWhile:					[paras _ self collectAnnotations: annoDict.					paras do: [:each | each storeOn: fileStream]]].! !!AnnotationController class methodsFor: 'initialization'!initialize	"AnnotationController initialize"	" . . . creates the tree menu"	(AnnotationYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [AnnotationYellowButtonMenu letGo].	AnnotationYellowButtonMenu _ TreeMenu createMenuFrom:'again _ again-undo _ undocopy _ copySelectioncut _ cut-paste _ pasteannotation _ yourself	[AnnotationController initializeAnnotationSubmenu]-fonts _ fontIt	[AnnotationController fontSubMenu]search _ findIttime stamp _ timeStampcompute it _ printIt'! !!RS232Controller class methodsFor: 'initialize'!initialize		"RS232Controller initialize"	". . . initializes the yellow button tree and pop-up menus and corresponding messages."	(RS232YellowButtonMenu isKindOf: TreeMenu)		ifTrue: [RS232YellowButtonMenu letGo].	RS232YellowButtonMenu _ ((TreeMenu labels:'clear memoryagainundocopycutpastefile itstrip CRssearchhardcopyfontspagingend browse' lines: #(1 3 6 11 12))		children: ((Array new: 13)			at: 11 put: self fontSubMenu;			at: 12 put: self initializePagingMenu; yourself);		answers: #(clearBuffer again undo copySelection cut paste fileIt stripCarraigeReturns findIt hardcopy fontIt yourself endBrowse))!initializeFirstScrollingPagesMenu	"Initialize the 'page..' branch of the paging.. TreeMenu."	| tempMenu numPages |	numPages _ 1.	self initializeScrollingPagesMenu.	tempMenu _ ScrollMenu new: 5 on: 1.	FirstPagesMenu == nil		ifTrue: [FirstPagesMenu _ tempMenu]		ifFalse:			[RS232Collector == nil ifFalse:				[numPages _ RS232Collector contentsStream totalPages.				tempMenu _ ScrollMenu new: 5 on: numPages]].	tempMenu children: PagesMenu.	FirstPagesMenu become: tempMenu.	^FirstPagesMenu!initializePagingMenu	"Initialize the 'paging -->' branch of the RS232 browsing state TreeMenu."	self initializeFirstScrollingPagesMenu.	^(TreeMenu labels: 'get prev pageget next pageget page(s)add next page(s)add prev page(s)')		answers: #(prevPage nextPage getPage appendNext includePrev);		children:			((Array new: 5)				at: 3 put: FirstPagesMenu;				yourself)!initializeScrollingPagesMenu	"Initialize the 'page..' branch of the paging.. TreeMenu."	| tempMenu |	PagesMenu == nil		ifTrue: [^(PagesMenu _ ScrollMenu new: 5 on: 1)].	tempMenu _ ScrollMenu new: 5 on: 		(RS232Collector == nil			ifTrue: [1]			ifFalse: [RS232Collector contentsStream totalPages]).	PagesMenu become: tempMenu.	^PagesMenu! !ClassifiedStringHolderController class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ClassifiedStringHolderController class methodsFor: 'As yet unclassified'!initialize		"ClassifiedStringHolderController initialize"	". . . initializes the yellow button Tree menu and corresponding messages."	(UserYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [UserYellowButtonMenu letGo].	UserYellowButtonMenu _ 		TreeMenu  			labels: 'againundocopycutpasteacceptcancelfonts{Move to right to select font}hardcopyfile as new itemtime stampcompute it' 			lines: #(2 5 7 9).	UserYellowButtonMenu children:			((Array new: 12)				at: 8 put: self fontSubMenu;				yourself);		answers: #(again undo copySelection cut paste accept cancel fontIt hardcopy fileIt timeStamp printIt).! !!StructureController class methodsFor: 'As yet unclassified'!initialize	"Initialize the yellow  button pop-up menu for the structure pane."	StructureYellowButtonMenu _ PopUpMenu labels: 'openhardcopy'.	StructureYellowButtonMessages _ #(getSelection getSelectionHardcopy)	"StructureController initialize"! !OutlineEditController class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!OutlineEditController class methodsFor: 'initialization'!initialize	"OutlineEditController initialize"	self initMainMenu.	self initUGMenu!initializeUtilitiesSubmenu	^(TreeMenu		labels: 'hardcopy{Print out the contents of the window.}file as new itemstrip CRsspawntime stampcompute it'		lines: #(3 4))		answers: #(hardcopy fileIt stripCarraigeReturns spawn timeStamp printIt)!initMainMenu	"OutlineEditController initMainMenu"	(OutYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [OutYellowButtonMenu letGo].	OutYellowButtonMenu _  TreeMenu labels: 'againundocopycutpasteacceptcancelfonts{Move to right to select font.}utilities' 			lines: #(2 5 7).	OutYellowButtonMenu children:			((Array new: 9)				at: 8 put: self fontSubMenu;				at: 9 put: self initializeUtilitiesSubmenu;				yourself);		answers: #(again undo copySelection cut paste accept cancel fontIt yourself).!initUGMenu		"OutlineEditController initUGMenu"	". . . initializes the yellow button Tree menu and corresponding messages."	(UGYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [UGYellowButtonMenu letGo].	UGYellowButtonMenu _ 		TreeMenu createMenuFrom: 'find _ findagain _ again-copy _ copySelectionutilities _ yourself	[OutlineEditController  initializeUtilitiesSubmenu]'! !!XDEInterfaceController class methodsFor: 'public access'!displayCritical	^DisplayCritical! !!XDEInterfaceController class methodsFor: 'initialization'!initialize	"XDEInterfaceController initialize."	DisplayCritical	_ (Smalltalk includesKey: #XDEInterfaceModel)		ifTrue: [XDEInterfaceModel displayCritical]		ifFalse: [Semaphore new].! !!StringHolderController class methodsFor: 'class initialization'!initialize		"StringHolderController initialize"	". . . initializes the yellow button Tree menu and corresponding messages."	(CodeYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [CodeYellowButtonMenu letGo].	CodeYellowButtonMenu _ 		TreeMenu  			labels: 'againundocopycutpastedo itprint itacceptcancelput{Save to disk the contents of the window.}hardcopy{Print out the contents of the window.}time stamp{Past the current date/time into the window.}fonts{Move to right to select font.}' 			lines: #(2 5 7 9).	CodeYellowButtonMenu children:			((Array new: 13)				at: 13 put: self fontSubMenu;				yourself);		answers: #(again undo copySelection cut paste doIt printIt accept cancel put hardcopy timeStamp fontIt)! !!AutoBookTextController class methodsFor: 'As yet unclassified'!initialize		"AutoBookTextController initialize"	". . . initializes the yellow button pop-up menu and corresponding messages."	| fullMenu restrictedMenu |	fullMenu _ 		PopUpMenu 			labels: 'againundocopycutpastedoItprintItacceptcancelputhardcopysearch text' 			lines: #(2 5 7 9).	restrictedMenu _ 		PopUpMenu 			labels: 'againundocopycutpasteacceptcancelputhardcopysearch text' 		lines: #(2 5 7).	AutoBookYellowButtonMenu _ NonprogrammerMenu new fullMenu: fullMenu; restrictedMenu: restrictedMenu.	AutoBookYellowButtonMessages _ NonprogrammerMessages new		fullMessageList: #(again undo copySelection cut paste doIt printIt accept cancel put hardcopy findIt);		restrictedMessageList: #(again undo copySelection cut paste accept cancel put hardcopy findIt)! !CellStringHolderController class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!CellStringHolderController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button pop-up menu and corresponding messages."	"	CellStringHolderController initialize"	AcceptSignal _ Signal new.	CellCodeYellowButtonMenu _		PopUpMenu			labels: 'again\undo\copy\cut\paste\accept\cancel' withCRs			lines: #(2 5).	CellCodeYellowButtonMessages _		#(again undo copySelection cut paste accept cancel)! !!CellStringHolderController class methodsFor: 'accessing'!AcceptSignal	^AcceptSignal! !DBTextController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DBTextController class methodsFor: 'class initialization'!initialize	"DBTextController initialize"	(DBTextYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [DBTextYellowButtonMenu letGo].	DBTextYellowButtonMenu _ TreeMenu createMenuFrom:'again _ again-undo _ undocopy _ copySelectioncut _ cut-paste _ pasterequire{Remove any hits not having the selected value in the selected field} _ require-exclude{Remove any hits having the selected value in the selected field} _ excludeblank record{Display a blank form for creating a new record} _ newRecordreset record{Restore this record to the original contents} _ cancel-classify{Set classification of this record} _ classifyadd record{Add the contents as a new record.} _ acceptAndAdd-overwrite record{Replace selected record with contents, or add if no selection.} _ acceptutilities _ yourself	compute _ printIt	search text{Search InformationCenters for the selected text} _ findIt'! !!RS232SendController class methodsFor: 'initialize'!initialize		"RS232SendController initialize"	". . . initializes the yellow button pop-up menu and corresponding messages."	(RS232YellowButtonMenu isKindOf: TreeMenu)		ifTrue: [RS232YellowButtonMenu letGo].	RS232YellowButtonMenu _ 		(TreeMenu labels: 'clear memoryagainundocopycutpastebrowsekermitre-sendfix' lines: #(1 3 6 7 8))		answers: #(clearBuffer again undo copySelection cut paste getText generalKermit sendLastLine getLastLine)! !!TekController class methodsFor: 'As yet unclassified'!initialize	"TekController initialize"	". . . initializes the yellow button pop-up menu and corresponding messages."	(TekYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [TekYellowButtonMenu letGo].	OnOffMenu _ (TreeMenu labels: 'OFF\ON' withCRs lines: #()) answers: #($N"off" $Y"on").	SubMenu _ (TreeMenu labels:'entire imageframed area' lines: #()) answers: #($E"ntire" $F"ramed").	TekYellowButtonMenu _ 		(TreeMenu labels: 'againundocopycutpastebrowsere-sendfixalways echopageresetcapture graphicshardcopyfile outcopy' lines: #(2 5 6 9 11))		children: ((Array new: 15)			at: 12 put: OnOffMenu;			at: 13 put: SubMenu;			at: 14 put: SubMenu;			at: 15 put: SubMenu; yourself);		answers: #(again undo copySelection cut paste getText sendLastLine getLastLine alwaysEcho page reset captureGraphics hardcopyGraphics fileOutGraphics copyGraphics)! !!ImageEditorTextCollector class methodsFor: 'initialize'!initialize		"ImageEditorTextCollector initialize"	". . . initializes the yellow button Tree menu and corresponding messages."	(IEYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [IEYellowButtonMenu letGo].	IEYellowButtonMenu _ 		TreeMenu  			labels: 'againundocopycutpastesearchcompute ittime stamp{Past the current date/time into the window.}fonts{Move to right to select font.}' 			lines: #(2 5 8).	IEYellowButtonMenu children:			((Array new: 9)				at: 9 put: self initIEFontMenu;				yourself);		answers: #(again undo copySelection cut paste findIt printIt timeStamp fontIt)!initIEFontMenu	| formText formString start stop tempMenu newMenu |	formString _ ' cream 12  OldEnglish 18 '.	#(' fixed width 10 ' ' sans-serif 24        ' ' sans-serif 14 ' ' sans-serif 12 ' ' sans-serif 10 ' ' sans-serif 7 ' ' serif 18 ' ' serif 14 ' ' serif 12 ' ' serif 10 ') do: [:fontName | 3 timesRepeat: [formString _ fontName, formString]].	tempMenu _ (ScrollMenu new labels: formString font: (TextStyle default fontAt: 35) lines: #() ) maxLines: 9; answers: #(1 2 3 4 5 6 25 26 27 7 8 9 22 23 24 31 32 33 10 11 12 13 14 15 19 20 21 37 38 39 34 35).	formText _ formString asText.	start _ 1.	1 to: (tempMenu answers size) do: [ :i |  stop _ formText findString: '' startingAt: start.	stop = 0 ifTrue:[stop _ formText size.].	formText emphasizeFrom: start to: stop with: (tempMenu answers at: i).	start _ stop + 1.].	tempMenu form become: formText asParagraph asForm.	newMenu _ ((TreeMenu labels: 'plainunderlined') answers: #($p $u)) children: (Array new: 2 withAll: tempMenu).	IEFontSubmenu == nil		ifTrue: [IEFontSubmenu _ newMenu]		ifFalse: [IEFontSubmenu become: newMenu].	^IEFontSubmenu"ImageEditorTextCollector initIEFontMenu"! !CreateController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!CreateController class methodsFor: 'initialize'!initialize	"CreateController initialize"	Menu _ ActionMenu labels:'againundocopycutpastedo itprint itacceptcancelchart{Draw the chart from this data.}' lines: #(2 5 7 9).	MenuMessage _ #(again undo copySelection cut paste doIt printIt accept cancel drawChart ).	^Menu! !!CreateController class methodsFor: 'instance creation'!editOpen: aStringHolder label: aString from: aParent type: type data: theData label: theLabel stack: theStack 	"Create a StandardSystemView of the model, aStringHolder, as viewed by an  instance of me. The label of the view is aString." 	| firstWindow secondWindow thirdWindow topView aList temp labelSpace dataSpace s t aSuitcase |	Cursor wait show.	(firstWindow _ StringHolderView container: aStringHolder) window: (0 @ 0 extent: 1000 @ 40).	firstWindow controller: self new.	aParent child: firstWindow controller.	firstWindow controller parent: aParent.	(secondWindow _ DataListView new) window: (0 @ 0 extent: 1000 @ 140);		borderWidth: 1; 		controller: (StackListController new whichType: type);		model: DataListModel new.	(thirdWindow _ DataListView new) window: (0 @ 0 extent: 1000 @ 420);		borderWidth: 1; 		controller: (DataListController new whichType: type);		model: DataListModel new.	(topView _ StandardSystemView new) helpIndex: #ChartData;		borderWidth: 1;		controller: DataListStandardSystemController new;		model: firstWindow model;		addSubView: firstWindow;		label: aString;		minimumSize: 300 @ 350;		maximumSize: 1000 @ 600.	topView controller chartIt: false.	aSuitcase _ aParent view topView suitcase.	topView classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.			thirdWindow model dataList: theData.			thirdWindow model labelList: theLabel.			aList _ OrderedCollection new.			labelSpace _ DataListModel labelSpace.			dataSpace _ DataListModel dataSpace.			type = #stacked				ifTrue: 					[secondWindow model stackList: theStack.					secondWindow list: theStack.					self setTopDelimiterIn: thirdWindow from: theStack backSpace: labelSpace frontSpace: dataSpace.					1 to: theLabel size do: 						[:each | temp _ thirdWindow model padString: (theLabel at: each) withSpaceInBack: labelSpace.						(theData at: each) do: [:i | s _ thirdWindow model padString: (i printString) withSpaceInFront: dataSpace.						temp _ temp , s].						aList add: temp].					thirdWindow list: aList.					topView addSubView: secondWindow below: firstWindow; addSubView: thirdWindow below: secondWindow]				ifFalse: 					[1 to: theLabel size do: [:each | s _ secondWindow model padString: (theLabel at: each) withSpaceInBack: labelSpace.t _ secondWindow model padString: (theData at: each) printString withSpaceInFront: dataSpace.aList add: s,t].					thirdWindow list: aList.					topView addSubView: thirdWindow below: firstWindow].	Cursor normal show.	topView controller open!setTopDelimiterIn: theView from: stackList backSpace: bSpace frontSpace: fSpace	| topDelimiter s | 	topDelimiter _ theView model padString: (String with: Character space) withSpaceInBack: bSpace.	stackList do: [ : each | s _ theView model padString: each withSpaceInFront: fSpace.	topDelimiter _ topDelimiter , s].	theView topDelimiter: topDelimiter! !!ProjectController class methodsFor: 'class initialization'!initialize	"ProjectViewController initialize"	" . . . initializes the menu for the yellow mouse button."	ProjectYellowButtonMenu _ 		PopUpMenu			labels: 'againundocopycutpasteacceptcancelputhardcopyenter{Enter the project.}'			lines: #(2 5 7 9).	ProjectYellowButtonMessages _ 			#(again undo copySelection cut paste accept cancel put hardcopy enter)! !!FillInTheBlankController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button pop-up menu and corresponding messages."	FillInYellowButtonMenu _ 		PopUpMenu 			labels: 'againundocopycutpasteaccept{Accept the current text and continue.}cancelbail out' 		lines: #(2 5 7).	FillInYellowButtonMessages _ 		#(again undo copySelection cut paste accept cancel bailOut)	"FillInTheBlankController initialize"! !!FormsFillController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button pop-up menu and corresponding messages."	FormsYellowButtonMenu _ TreeMenu createMenuFrom: 'again _ again-undo _ undocopy _ copySelectioncut _ cut-paste _ paste-search _ findIt-cancel _ cancelfonts _ fontIt	[ParagraphEditor fontSubMenu]'.	FormsYellowButtonMessages _ TreeMenu	"FormsFillController initialize. FillElement initialize"! !!DBoxFillController class methodsFor: 'initialization'!initialize	"Initialize the yellow button pop-up menu and corresponding messages."	DBoxYellowButtonMenu _ TreeMenu createMenuFrom: 'again _ again-undo _ undocopy _ copySelectioncut _ cut-paste _ paste-cancel _ cancelfonts  _ fontIt	[ParagraphEditor fontSubMenu]'.	DBoxYellowButtonMessages _ TreeMenu	"DBoxFillController initialize"! !!DBoxKeywordFillController class methodsFor: 'initialization'!initialize	"Initialize the yellow button pop-up menu and corresponding messages."	DBoxKYellowButtonMenu _ PopUpMenu labels: 'againundocopycutpastecancelkeywords' lines: #(2 5).	DBoxKYellowButtonMessages _ 		#(again undo copySelection cut paste cancel addKeyword)	"DBoxKeywordFillController initialize"! !PreviewPageController class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewPageController class methodsFor: 'initialization'!initialize	"PreviewPageController initialize"	self initMainMenu.	self initSelectedMenu.!initMainMenu	"PreviewPageController initialize"	(PreviewMainMenu isKindOf: TreeMenu)		ifTrue: [PreviewMainMenu letGo].	PreviewMainMenu _ TreeMenu createMenuFrom: 'again _ again-undo _ undocopy _ copySelectioncut _ cut-paste _ pastesave _ save-hardcopy _ hardcopytabs{Set tabs for currently selected lines} _ displayTabs	apply{Use an existing tab set} _ [$A]	edit{Alter existing or make new tab set} _ [$E]justify{Move to right to select justification for currently selected lines} _ justifyIt	full _ [3]	left _ [0]	center _ [1]	right _ [2]page{Go to another page} _ yourself	forward{Go to next page} _ gotoNextPage	back{Go to previous page} _ gotoPreviousPage	random{Select any composed page to go to} _ gotoRandomPagefonts{Move to right to select font to apply to selected text} _ fontIt	[PreviewPageController fontSubMenu]utilities{Move to right for more commands} _ yourself	[PreviewPageController initUtilityMenu]'.	"PreviewMainMenu resultBlock: TreeMenu usefulResultBlock"!initSelectedMenu	"PreviewPageController initialize"	| pictureMenu |	(PreviewYellowButtonSelectedMenu isKindOf: TreeMenu)		ifTrue: [PreviewYellowButtonSelectedMenu letGo].	PreviewPixScaleMenu _ (TreeMenu labels:'proportion scalingfit scalingunscale')				answers: #(2 1 3).	pictureMenu _ (TreeMenu labels:'editupdatecentermoveshow realscale' lines: #(2 4)) children: ((Array new: 6) at: 6 put: PreviewPixScaleMenu; yourself);		answers: #(editForm updateForm centerPicture movePicture showReal scaleIt).	PreviewYellowButtonSelectedMenu _ (TreeMenu labels:'pictureframe fit pictureremoveproperties')	children: ((Array new: 4)				at: 1 put: pictureMenu;				yourself);	answers: #(yourself fitPicture removeRectangle properties)!initUtilityMenu	"PreviewPageController initialize"	". . . initializes the yellow button Tree menu and corresponding messages."	^ TreeMenu createMenuFrom: '-picture access _ yourself	select transparent{select a picture on this page} _ selectPix	-copy from my list{make another copy of one of the pictures in this preview} _ getListPicture	add blank space{make blank pix frame to block out text} _ getRectangle	frame from screen{copy some of the screen into a pix} _ getScreenPicture-text utilities _ yourself	strip CRs _ stripCarraigeReturns	-generate table{Make table from selected text and put it in copy buffer} _ makeTable	search _ findIt	-add as keyword{Add the selected word as a keyword on this item} _ addKeyWord	time stamp _ timeStamp	compute it _ printItredisplay{refresh the display of this page} _ redisplay-compose document{compose entire doc automatically} _ composeEndPages-document looks{change margins, columns, line height, etc.} _ setOptionrestore{go back to the last saved version} _ restorefile text away{make text file(s) containing all the text in this preview} _ fileText'!programmerMenu	"PreviewPageController initialize"	^(TreeMenu labels:'inspectshow justifyshow tabsreset tabsredisplaykill picture')		answers: #(inspect showJustify showTabs resetTabs displayPageText killPictures)! !!ContainerListController class methodsFor: 'class initialization'!initialize	"ContainerListController initialize"	AllTheMenus _ Array new: 7.	self initializeFolderList.	self initializeInBasket.	self initializeMainMenu.	self initializeItem.	self initializeTrashList.	self initializeKeyword.	self initializeScavengerMenu!initializeAddSubmenu	" Initialize the add branch of the folder TreeMenu. " "ContainerListController initializeAddSubmenu"	| anArray theItems controlArray size messageArray theLabel |	theItems _ DataMaster createItemArray.	size _ theItems size + 3.	controlArray _ Array new: size withAll: #createNewSelection:.	controlArray at: size put: #mustHaveASelection:.	controlArray at: size - 1 put: #justDoIt:.	messageArray _ Array new: size.	1 to: theItems size do: [:each| messageArray at: each put: (theItems at: each)]. 	messageArray at: size put: #connectSelection.	messageArray at: size - 1 put: #makeNewCenter.	messageArray at: size - 2 put: #addContainer.	anArray _ Array new: 2.	anArray at: 1 put: controlArray.	anArray at: 2 put: messageArray.	theLabel _ String new.	theItems do: [:each| theLabel _ theLabel,each,''].	theLabel _ theLabel,'folderinfo center from selectionadd map/database links'.	^(TreeMenu labels: theLabel)			answers: anArray;			resultBlock: [:first :last | last selection]!initializeDisplaySubmenu	" Initialize the display branch of the folder TreeMenu.""ContainerListController initializeDisplaySubmenu"	| anArray |	anArray _ Array new: 2.	anArray at: 1 put: #(justDoIt: justDoIt: mustHaveASelection:  justDoIt:).	anArray at: 2 put: #(showGraphicTree showStructure showOtherPointers connectionsForThisSelection).	^(TreeMenu labels:'structure tree{Display a graphic filing structure.}structure list{Display a filing structure outline.}cross references{Display other labels for this selection}connections{Display all connection to the selection}')			answers: anArray;			resultBlock: [:first :last | last selection]!initializeFolderList	"Initialize the yellow button pop-up menu for the folder list pane.""   This menu is found in AllTheMenus at index 6"	AllTheMenus at: 6 put: (Array with: ((TreeMenu labels: 'file in this folder{Add the item to this folder}') answers: (Array with: #(mustHaveASelection: ) with: #(inThisFolder))) with: TreeMenu).	"ContainerListController initializeFolderList"!initializeInBasket	"ContainerListController initializeInBasket" "This menu is found in AllTheMenus at index 2"	| anArray theMenu |	anArray _ Array new: 2.	anArray at: 1 put: #(mustHaveASelection: mustHaveASelection: mustHaveASelection: cutSelection: cutSelection: editSelection: editSelection: mustHaveASelection: checkAndUpdate:).	anArray at: 2 put: #(viewSelection duplicateSelection putInTheCopyBuffer cutSelection destroySelection  renameSelection reclassifySelection hardcopySelection dumpFolder).	theMenu _ TreeMenu labels:'open{Display the selection.}duplicate{Duplicate this selection and put the new copy in the transfer buffer.}copy{Put a reference in the transfer buffer.}cut{Cut this selection and put it in the transfer buffer.}destroy{Remove this item from the disk}rename {Change the label or keywords of the selection.}reclassify {Change the classification of the selection.}hardcopy{Hardcopy this selection.}cut all{dump everything into the trash}' lines: #(1 5 8).	theMenu 		children:			((Array new: 9) yourself);			answers:  anArray;			resultBlock: [:first :last | last selection].	AllTheMenus at: 2 put: (Array with: theMenu with: TreeMenu)!initializeItem	"ContainerListController initializeItem"	"   This menu is found in AllTheMenus at index 5"	| anArray theMenu |	anArray _ Array new: 2.	anArray at: 1 put: #(mustHaveASelection: mustHaveASelection: mustHaveASelection: justDoIt: justDoIt: justDoIt: justDoIt:).	anArray at: 2 put: #(viewSelection duplicateSelection putInTheCopyBuffer showItemListKey showKeyWordList makeInToAFolder connectionsForThisSelection).	theMenu _ AllTheMenus at: 5.	theMenu == nil ifFalse: [((theMenu at: 1) isKindOf: TreeMenu)		ifTrue: [(theMenu at: 1) letGo]].	theMenu _ TreeMenu labels: 'open{Display the selection.}duplicate{Duplicate this selection and put the new copy in the transfer buffer.}copy{Put a reference in the transfer buffer.}search{Returns a folder with all items matching the specified search pattern.}key words{Returns a list of all the key words in the selection.}make folderconnections{Display all connection to the selection}' lines: #(3).	theMenu children:			((Array new: 7) yourself);			answers:  anArray;			resultBlock: [:first :last | last selection].	AllTheMenus  at: 5 put: (Array with: theMenu with: TreeMenu)!initializeKeyword	"ContainerListController initializeKeyword" "   This menu is found in AllTheMenus at index 4"	| anArray theMenu |		anArray _ Array new: 2.	anArray at: 1 put: #(mustHaveASelection: cutSelection: renameKeyword:).	anArray at: 2 put: #(viewSelection cutKeyword renameKeyword).	theMenu _ TreeMenu labels:'connections{Display the all items connected to this keyword.}remove{Remove this keyword from this Information Center.}rename{Rename this keyword in this Information Center.}'.	theMenu 		children:			((Array new: 3) yourself);			answers:  anArray;			resultBlock: [:first :last | last selection].	AllTheMenus at: 4 put: (Array with: theMenu with: TreeMenu).!initializeMainMenu	"ContainerListController initializeMainMenu"	"   This menu is found in AllTheMenus at index 1"	| anArray theMenu |	theMenu _ AllTheMenus at: 1.	anArray _ Array new: 2.	anArray at: 1 put: #(mustHaveASelection: nil nil mustHaveASelection: mustHaveASelection: cutSelection: addSelection:  editSelection: editSelection: mustHaveASelection: nil  nil).	anArray at: 2 put: #(viewSelection nil nil duplicateSelection putInTheCopyBuffer cutSelection addFromBuffer renameSelection reclassifySelection hardcopySelection nil nil).	theMenu == nil ifFalse: [((theMenu at: 1) isKindOf: TreeMenu)		ifTrue: [(theMenu at: 1) letGo]].	theMenu _ TreeMenu labels: 'open{Display the selection.}displayretrieve byduplicate{Duplicate this selection and put the new copy in the transfer buffer.}copy{Put a reference in the transfer buffer.}cut{Cut this selection and put it in the transfer buffer.}paste{Add the reference from the transfer buffer to this folder.}rename {Change the label or keywords of the selection.}reclassify {Change the classification of the selection.}hardcopy{Hardcopy this selection.}createmaintenance' lines: #(3 7 10).	theMenu children:			((Array new: 12)				at: 2 put: self initializeDisplaySubmenu;				at: 3 put: self initializeRetrieveBySubmenu;				at: 11 put: self initializeAddSubmenu;				at: 12 put: self initializeMaintenanceSubmenu;				yourself);		answers: anArray; resultBlock: [:first :last | last selection].	AllTheMenus  at: 1 put: (Array with: theMenu with: TreeMenu)!initializeMaintenanceSubmenu	" Initialize the  'maintenance' branch of the Information center TreeMenu."	| anArray |	anArray _ Array new: 2.	anArray at: 1 put: #(justDoIt: justDoIt: justDoIt: justDoIt: justDoIt: justDoIt: justDoIt: justDoIt: justDoIt: checkAndUpdateSelection: checkAndUpdateSelection: justDoIt: justDoIt:).	anArray at: 2 put: #(save restore shutDown renameInfoCenter removeUser changePassword verify showFileNames editLinkTypes lockSelection unlockSelection backup sendFilesToServer).	^(TreeMenu labels:'save info center{Save this Information Center to disk.}restore info center{Restore this Information Center from disk.}close info center{Save and close this Information Center.}rename info center{Rename this Information Center.}destroy info center{Destroy this Information Center, and remove all references to center.}change password{Change password of this Information center.}verify structure{Confirm that all items contained in this Information center are referenced.}file name list{List file names associated with current selection.}edit link types{Add or delete an Information Center link type.}lock{Lock selected item so only owner of this center may see it}unlock{Unlock selected item so anyone with access to this Information Center may see it}backup selection{Backup files associated with current selection to a file server}send selection{Send files associated with current selection to another user by way of a file server}' lines: #(5 9 11))children: ((Array new: 13)				yourself);				answers: anArray;			resultBlock: [:first :last | last selection]!initializeRetrieveBySubmenu	" Initialize the retrieve by--> branch of the folder TreeMenu."	| anArray |	anArray _ Array new: 2.	anArray at: 1 put: #(justDoIt: justDoIt: justDoIt: justDoIt: justDoIt:).	anArray at: 2 put: #(showKeyWordList showFolderList showItemList showItemListKey retrieveByDataItem ).	^(TreeMenu labels: 'key words{Display the list of key words.}folders{Display a list of folders.}items{Display a list of items.}search{Returns a folder with all items matching the specified search pattern.}data type{Display a list of items matching the specified data types.}')			answers: anArray;			resultBlock: [:first :last | last selection]!initializeScavengerMenu	"ContainerListController initializeScavengerMenu""   This menu is found in AllTheMenus at index 7"	| anArray theMenu |	theMenu _ AllTheMenus at: 7.	anArray _ Array new: 2.	anArray at: 1 put: #(mustHaveASelection: cutSelection: cutSelection: closeAfter: cutSelection: closeAfter: checkAndUpdate: justDoIt: justDoIt:).	anArray at: 2 put: #(viewSelection refileSelection destroySelection destroyAll releaseSelection releaseAll scavengeThese getFilesFromServer getSelectionFromServer).	theMenu == nil ifFalse: [((theMenu at: 1) isKindOf: TreeMenu)		ifTrue: [(theMenu at: 1) letGo]].	theMenu _ TreeMenu labels: 'open{Display the selection.}refile{Refile this selection.}destroy{Destroy this selection on the disk.}destroy all{Destroy all of these selections on the disk.}release{Drop this selection from the folder.}release all{Drop all of these selections from the folder.}recover{Find all of the unreferenced items of the specified types.}fetch new files{get the data files retrieved from the file server}fetch copy selection{get the data files from the file server for the selection in the copy buffer}' lines: #(2 4 6 7).	theMenu 	children:			((Array new: 9) yourself);			answers:  anArray;			resultBlock: [:first :last | last selection].	AllTheMenus  at: 7 put: (Array with: theMenu with: TreeMenu)!initializeTrashList	"ContainerListController initializeTrashList"	"  This menu is found in AllTheMenus at index 3"	| anArray theMenu |	theMenu _ AllTheMenus at: 3.	anArray _ Array new: 2.	anArray at: 1 put: #(mustHaveASelection: mustHaveASelection: checkAndUpdateSelection: editSelection: editSelection: mustHaveASelection: cutSelection: checkAndUpdate: cutSelection:).	anArray at: 2 put: #(viewSelection putInTheCopyBuffer refileTrashSelection renameSelection reclassifySelection hardcopySelection dumpSelection dumpTrashBin destroyTrashSelection).	theMenu _ TreeMenu labels:'open{Display the selection.}copy{Pick this item back out of the trash.}refile{File this item back into a info center.}rename {Change the label or keywords of the selection.}reclassify {Change the classification of the selection.}hardcopy{Hardcopy this selection.}dump selection{Remove this selection from the Trash.}dump all trash{Remove everything in the Trash.}destroy selection{Remove this selection from the disk.}' lines: #(1 6).	theMenu 		children:			((Array new: 9) yourself);			answers:  anArray;			resultBlock: [:first :last | last selection].	AllTheMenus  at: 3 put: (Array with: theMenu with: TreeMenu)! !!ContainerListController class methodsFor: 'instance creation'!new	^self error:' ContainerListControllers are created using new: '!new: aMenuNumber	^super new initMenu: aMenuNumber! !OutlineController class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!OutlineController class methodsFor: 'initialization'!initialize	"Initialize the yellow  button pop-up menu the auto book list."	"OutlineController initialize"	OutlineYellowButtonMenus _ TreeMenu createMenuFrom:'-add{add a new entry} _ addEntrycopy{copy this entry} _ copycut{cut this entry} _ cut-paste{paste entry from copy buffer} _ yourself	before{paste before present entry} _ pasteBefore	after{paste after present entry} _ pasteAfter	under{paste under present entry} _ pasteUnderhide{hide entries under entry selected} _ hideSubs-show{restore entries under entry selected} _ showSubsinput/edit{turn edit on or off} _ editParagraph-change entry{rename or change classification of this entry} _ changeSelectionsave{accept changes to entries} _ accept-restore{forget changes made to entries} _ cancelhardcopy{hardcopy of outline} _ hardcopyDocumentutilities _ yourself	produce text item{text of outline for pasting} _ composeDocument	produce structure text{headings only of outline for pasting} _ composeStructure	concat another{concatenate with a user specified outline} _ concat	compress{clean up the file} _ compress	repair _ repair'! !ChapterController class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ChapterController class methodsFor: 'initialization'!initialize	"Initialize the yellow  button pop-up menu the auto book list."	ChapterYellowButtonMenu _ TreeMenu labels:'view selectionhide{hide entries under entry selected}show subsections{restore subsection entries under entry selected}show all{restore all entries under entry selected}reset{start fresh}hardcopylook for...next reference' lines: #(1 5 6).	ChapterYellowButtonMessages _ #(editParagraph hideSubs showTopSubs showSubs reset hardcopyDocument lookFor nextReference)	"ChapterController initialize"! !!FunctionKeyEditor class methodsFor: 'instance creation'!initialize		"FunctionKeyEditor initialize"	". . . initializes the yellow button pop-up menu and corresponding messages."	FuncKeySectionBuffer _ Array new: 2.	FKEYellowButtonMenu _ Array new: 2.	FKEYellowButtonMessages _ Array new: 2.	FKEYellowButtonMenu at: 1 put: (PopUpMenu labels: 'edit keyscopy' lines: #()).	FKEYellowButtonMessages at: 1 put: #(editKeys copySection).	FKEYellowButtonMenu at: 2 put: (PopUpMenu labels: 'edit keysedit auto logincreate emptycopycutpaste' lines: #(2)).	FKEYellowButtonMessages at: 2 put: #(editKeys editAutoLogin createSection copySection cutSection pasteSection).!openOnUser: aUserName	"FunctionKeyEditor openOnUser: 'ellersieck'"	self new openOnUser: aUserName! !DQueryListController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DQueryListController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button pop-up menu."	DQueryYellowButtonMenu _ TreeMenu labels:'show all records{Show all records in the file}sort hitsreverse hitsadd{Enter a new query from a Querier pop-up}deletedelete allquery{Show all records in the file which match the selected query}query hits{Show all records in the hit list which match the selected query}undo query{Display the previous hit list}'		lines: #(3 6).	DQueryYellowButtonMessages _ #(showAll sortList invertList addQuery deleteQuery smashQueries query queryVsPresent lastQuery)	"DQueryListController initialize"! !!AutoBookListController class methodsFor: 'initialize'!initialize	"Initialize the yellow  button pop-up menu the auto book list."	ABListYellowButtonMenu _ PopUpMenu labels: 'copy entrycut entrypaste entryadd new entryedit entrydisplay entry' 			lines: #(3 4).	ABListYellowButtonMessages _ #(copyEntry cutEntry pasteEntry addEntry editEntry showAll)	"AutoBookListController initialize"! !DataListController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DataListController class methodsFor: 'initialize'!initialize	"Initialize the yellow button pop-up menu the field list."	DataMenu _ PopUpMenu labels:'copycutpasteenter dataedit datachart data'lines: #(3 5).	DataMenuMessages _ #(copy cut paste enterData edit chartIt)	"DataListController initialize"! !StackListController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!StackListController class methodsFor: 'As yet unclassified'!initialize	"Initialize the yellow button pop-up menu the field list."	StackMenu _ PopUpMenu labels:'copycutpasteenter dataedit datachart data'lines: #(3 5).	StackMenuMessages _ #(copy cut paste enterStack editStack drawChart)	"StackListController initialize"! !!FunctionKeyEditorController class methodsFor: 'initialize'!initialize		"FunctionKeyEditorController initialize"	". . . initializes the yellow button pop-up menu and corresponding messages."	FuncKeysYellowButtonMenu _ Array new: 2.	FuncKeysYellowButtonMessages _ Array new: 2.	FuncKeysYellowButtonMenu at: 1 put: (PopUpMenu labels: 'copy').	FuncKeysYellowButtonMessages at: 1 put: #(copyFunctionKey).	FuncKeysYellowButtonMenu at: 2 put: (PopUpMenu labels: 'acceptcancelcopycutpastecreatechange' lines: #(2 5)).	FuncKeysYellowButtonMessages at: 2 put: #(putLabelDefs getLabelDefs copyFunctionKey removeFunctionKey pasteFunctionKey createFunctionKey editFunctionKey)! !!FunctionKeyEditorController class methodsFor: 'instance creation'!newOnModel: functionKeysModel withStatusView: statusView	"create the view of available function keys"	| functionKeysView |	functionKeysView _ RS232FunctionKeysView new.	functionKeysView		model: functionKeysModel controller: self new;		selection: (functionKeysModel viewListIndex);		statusView: statusView.	^functionKeysView!newWithStatusView: statusView forUser: aUser onSection: sectionName	"create the view of available function keys"	| functionKeysModel |	functionKeysModel _ RS232FunctionKeys new initForUser: aUser onSection: sectionName.	^self newOnModel: functionKeysModel withStatusView: statusView! !!RS232FunctionKeysController class methodsFor: 'initialize'!initialize		"RS232FunctionKeysController initialize"	". . . initializes the yellow button pop-up menu and corresponding messages."	RS232FuncKeysYellowButtonMenu _ Array new: 2.	RS232FuncKeysYellowButtonMessages _ Array new: 2.	RS232FuncKeysYellowButtonMenu at: 1 put:		(PopUpMenu labels: 'editscroll upscroll down' lines: #(1)).	RS232FuncKeysYellowButtonMessages at: 1 put: #(initEditMode scrollUpSome scrollDownSome).	RS232FuncKeysYellowButtonMenu at: 2 put:		(PopUpMenu labels: 'end editacceptcancelcopycutpastecreatechange' lines: #(1 3 6)).	RS232FuncKeysYellowButtonMessages at: 2 put: #(endEditMode putLabelDefs getLabelDefs copyFunctionKey removeFunctionKey pasteFunctionKey createFunctionKey editFunctionKey)! !DReportListController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DReportListController class methodsFor: 'class initialization'!initialize	"Initialize the yellow  button pop-up menu."	DReportYellowButtonMenu _ TreeMenu labels:'show all recordssort hitsreverse hitsadd{Specify the fields for this report}deletedelete allmake report{Generate a report of the hit list using the selected format}'		lines: #(3 6).	DReportYellowButtonMessages _ #(showAll sortList invertList addReport deleteReport smashReports report)	"DReportListController initialize"! !DHitListController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DHitListController class methodsFor: 'class initialization'!initialize	"Initialize the yellow  button pop-up menu."	"DHitListController initialize"	DHitYellowButtonMenu _ TreeMenu createMenuFrom:'show all records{show every record in database} _ showAllsort hits{sort a <= b}  _ sortListreverse hits{show list in the reverse order} _ invertList-clear hits{clear this list} _ clearListdelete record{delete selected record} _ deleteRecord-undelete record{undelete selected record} _ undeleteRecordspawn record{create separate entry form for this database on selected record} _ spawnRecordutilities _ yourself	show deleted records{Show deleted records in hit list} _ deletedRecords	make new database{Create a new database containing the items in the hit list} _ cloneDataBase	chart data{Draw a chart based on the data in the hit list} _ chartDatabase	compress database{Remove all deleted records from this database} _ compressDatabase	delete entry form{Get rid of currently saved version of spawn record entry form} _ dumpEntryForm'! !DFieldListController class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DFieldListController class methodsFor: 'class initialization'!initialize	"Initialize the yellow button pop-up menu the field list."	DFieldYellowButtonMenu _ TreeMenu labels:'add{Add a new field}delete{Remove this field}rename{Alter the name of the field}change length{Alter the length of the field}definition{Show the name, length, and type of a field.}all definitions{Show the name, length, and type of all fields.}'.	DFieldYellowButtonMessages _ #(addNewField deleteField renameField changeFieldLength fieldStat allFieldStat)	"DFieldListController initialize"! !!ChangeListController class methodsFor: 'class initialization'!initialize	"ChangeListController initialize"	ChangeListYellowButtonMenu _		PopUpMenu			labels:'file in{Add contents of a changes file to the browser menu.}file out{Store unremoved items into a changes file.}recover last changes{Add references to changes since last snapshot.}display system changes{Add references to methods in the internal change set.}do all{Evaluate all unremoved expressions in the browser menu.}remove all{Mark all items for removal.}restore all{Unremove all items.}spawn all{Create a new, identical change-management browser.}forget{Delete all items marked for removal.}do it{Evaluate the selected item.}remove it{Mark the selected item for removal.}restore it{Unremove the selected item.}spawn it{Create a message-selector browser for the selected item.}check conflicts{Check for conflicts with another changes file.}check with system{Check for conflicts with current system.}'			lines: #( 4 8 9 13 ).	ChangeListYellowButtonMessages _		#(fileIn fileOut recover getChanges doAll removeAll restoreAll copyView forget doThis removeItem restoreItem browse check checkWithSystem)! !!BioController class methodsFor: 'initialize'!initialize		"BioController initialize"	" . . . creates the tree menu"	(BioYellowButtonMenu isKindOf: TreeMenu)		ifTrue: [BioYellowButtonMenu letGo].	(BioYellowButtonMenu _ TreeMenu labels: 'paste imagerename selectiondelete selectionhardcopy selectionhardcopy reporthardcopy images' lines: #(4))		answers: #(pasteImage rename deleteImage hardcopyOne hardcopyReport hardcopyAll)! !!ScreenController class methodsFor: 'class initialization'!initialize	"ScreenController initialize"	". . . initializes the System Menu."	self initializeYellowButtonMenu.	self initializeBlueButtonMenu.	self allInstancesDo: [:eachInstance | eachInstance initialize]!initializeBlueButtonMenu 	"ScreenController initialize"	". . . initializes the System Menu."	(ScreenBlueButtonMenu isKindOf: TreeMenu)		ifTrue: [ScreenBlueButtonMenu letGo].	ScreenBlueButtonMenu _ TreeMenu createMenuFrom:'select & close{Select window(s) to be closed} _ selectAndClose-find{Activate a window of your choice} _ findOnedate & time{Display the current date and time} _ yourself	display{Display the current date and time} _ showDateAndTime	analog clock{Open an analog clock for one of the time zones in the clock list} _ openClock	digital clock{Open a digital clock for one of the time zones in the clock list} _ openDigitalClock	edit clock list{Edit the list of clock labels and time zones} _ editTimeZonesMenuversion info{show version information about this particular Analyst image} _ analystVersionInforesources{Display the amount of core, oops, and disk space remaining} _ showResourcesgarbage collect{Reclaim unused objects} _ garbageCollect-idle start{Go to normal Idle state immediately} _ idleStart	force login{Start Idle, force user to re-Login afterwards} _ [$F]	normal{Go to normal Idle state immediately} _ [$N]collapse display{Collapse all windows to their label} _ collapseDisplayrestore display{Refresh all windows} _ restoreDisplay'.	ScreenBlueButtonMessages _ FakeCollection withAll: #performBlueSelections!initializeOITMenu	| label labelString labelStream readStream tempArray counter centerString |	centerString _ ConfigFile currentUserConfig getSection: #OIT.	(centerString == nil or: [centerString isEmpty])		ifFalse:			[readStream _ ReadStream on: centerString from: 1 to: centerString size.			labelStream _ReadWriteStream on: (String with: Character space).			tempArray _ OrderedCollection new.			readStream upTo: $*.			counter _ 1.			[readStream atEnd] whileFalse:				[labelStream nextPutAll: (label _ readStream upTo: $,).				labelStream cr.				tempArray add: (Array with: label with: ((readStream upTo: $,) at: 1) with: (readStream upTo: Character cr)).				counter _ counter + 1.				readStream upTo: $*].			labelString _ labelStream contents copyFrom: 1 to: labelStream size - 1]		ifTrue:			[labelString _ 'Default Delta DataDefault Tektronix'.			tempArray _ Array					with: (Array with: 'Default Delta Data Label' with: $D with: String new)					with: (Array with: 'Default Tektronix Label' with: $T with: String new)].	^ (TreeMenu labels: labelString lines: #()) answers: tempArray asArray!initializeSmalltalkSubmenu	"Initialize the Smalltalk branch of the System TreeMenu."	^TreeMenu createMenuFrom:'Windows _ yourself	Browser{Open a class-hierarchy browser} _ openBrowser	Workspaces _ yourself		system{The system workspace contains useful expressions to evaluate} _ openSystemWorkspace		empty{Create an empty workspace} _ openWorkspace		on a file{Open a workspace on the contents of a file} _ openWorkspaceOnFile		XDE{Open an XDE communication center} _ openXDECenter	File List{Open a file-list window} _ openFileList	Change List{Open a change-management browser} _ openChangeList	Command Bar{The command bar window is for quick access to system commands} _ openCommandBar	Transcript{Open a system transcript} _ openTranscriptRemote Disk _ yourself	file server{Change name of default file server} _ fileServer	login{Change user-name and password} _ remoteLogin	directory{Change file-server directory} _ connect	release{Disconnect from file server} _ releaseExternalViewsSession _ yourself	just quit{Exit to the underlying operating system (without saving the current state of Smalltalk)} _ quit	just save{"Snapshot" the current state of Smalltalk onto a disk file, (but don''t exit from Smalltalk)} _ save	-save, then quit{"Snapshot" the current state of Smalltalk onto a disk file, then exit to the underlying operating system} _ saveThenQuit	suspend{Exit to the underlying operating system, but do so in such a way that the user can return to the current state at a later time} _ defer	changes _ yourself		reset changes{Forget previous changes} _ noChanges		file out changes{File out previous changes} _ fileOutChanges		inspect changes{Create a change-management browser} _ inspectChanges	crash recovery _ yourself		recent text{Recover last 5000 characters in the changes file} _ crashRecover		browse{Create a browser to recover changes} _ browseRecoverPrinting _ yourself	print entire screen{Print an image of the entire screen} _ printEntireScreen	print framed area{Frame an area of screen to print} _ printFramedArea'!initializeSystemControlsSubmenu	"Initialize the system controls branch of the System TreeMenu."	^TreeMenu createMenuFrom:'-audit controls _ yourself	-set up{Select users to be audited} _ auditOn	-clean up{Reset audit trail} _ wipeOut	hardcopy{Print audit trail} _ printAuditoredit user list{Edit list of users who may login} _ editUsersFile'!initializeUserProfileSubmenu	" Initialize the User Profile branch of the System TreeMenu"	^TreeMenu createMenuFrom:'screen color{Move to the right to see available colors} _ screenColor:	black{Make screen background black} _ [#black]	dark gray{Make screen background 75% gray} _ [#darkGray]	gray{Make screen background 50% gray} _ [#gray]	light gray{Make screen background 25% gray} _ [#lightGray]	white{Make screen background white} _ [#white]set system font{Move to the right to see available fonts} _ setSystemFont:	[ParagraphEditor fontSubMenu]clipboard{Open clipboard button window} _ clipboardFunction:	show{Display entries at the top left corner of the screen} _ [#show]	-hide{Do not display entries} _ [#doNotShow]	LIFO{Multiple entry: Last in first out} _ [#lastInFirstOut]	FIFO{Multiple entry: First in first out} _ [#firstInFirstOut]	-single{Single entry} _ [#noStacking]	drop one{Remove the item ready to be pasted} _ [#retrieve]	clear{Remove everything} _ [#clear]menu display _ yourself	auto sub-menus{Automatic display of tree menu branches?} _ autoMenuShow:		enable{Display a tree menu branch without the user having to move to the right} _ [true]		disable{Only display a tree menu branch when the user moves to the right} _ [false]	accelerate cursor{Accelerate movement of the cursor across menu items?} _ accelerateCursorPlace:		enable{Accelerate movement of the cursor across menu items} _ [true]		disable{Do not accelerate movement of the cursor across menu items} _ [false]	scroll speed{Set the minimum speed of scrolling in scroll menus} _ scrollMenuSpeed-idle image{Set idle image to the current buffer contents} _ idleFormprinter name{Specify name of desired printer} _ printerNamenetwork login{Specify login id and password for remote host} _ remoteLoginbackup user{Send user configuration info to file server} _ backupUserMenuChoicerestore user{Retrieve user configuration info from file server} _ restoreUserMenuChoice'!initializeYellowButtonMenu	"ScreenController initialize"	". . . initializes the System Menu."	| fullMenu restrictedMenu newFirst |	((ScreenYellowButtonMenu isKindOf: NonprogrammerMenu) or: [ScreenYellowButtonMenu isKindOf: TreeMenu])		ifTrue: [ScreenYellowButtonMenu letGo].	self changeOITMenu.	fullMenu _ TreeMenu createMenuFrom:'Information Centers{Open an information center} _ openInfoCenterGraphics Pad{Open a graphics or chart editor} _ makeNewChartOrGraphicPadScratch Pad{Open a scratch pad for text} _ openTextWindow-World Atlas{Open the World Atlas} _ openAutoBookUser Guide{Open the user guide} _ openUserGuide-User Profile _ yourself	[ScreenController initializeUserProfileSubmenu]System Control _ yourself	[ScreenController initializeSystemControlsSubmenu]Smalltalk _ yourself	[ScreenController initializeSmalltalkSubmenu]Log out{Quit Analyst and return to the executive} _ logOut'.	fullMenu resultBlock: TreeMenu usefulResultBlock.	restrictedMenu _ TreeMenu createMenuFrom:'Information Centers{Open an information center} _ openInfoCenterGraphics Pad{Open a graphics or chart editor} _ makeNewChartOrGraphicPadScratch Pad{Open a scratch pad for text} _ openTextWindow-World Atlas{Open the World Atlas} _ openAutoBookUser Guide{Open the user guide} _ openUserGuide-User Profile _ yourself	[ScreenController initializeUserProfileSubmenu]Log out{Quit Analyst and return to the executive} _ logOut'.	restrictedMenu resultBlock: TreeMenu usefulResultBlock.	ScreenYellowButtonMenu _ NonprogrammerMenu new fullMenu: fullMenu; restrictedMenu: restrictedMenu.	ScreenYellowButtonMessages _ TreeMenu! !!ScreenController class methodsFor: 'user initialization'!changeOITMenu	| newMenu |	newMenu _ self initializeOITMenu.	OITMenu == nil		ifTrue: [OITMenu _ newMenu]		ifFalse: [OITMenu become: newMenu]!makeScreenColor: aSymbolOfColor logChange: aBoolean	Form screen == (Form perform: aSymbolOfColor) ifFalse:		[Form setScreenMask: (Form perform: aSymbolOfColor).		ScreenController allInstancesDo: [:each | each view model: (InfiniteForm with: Form screen)].		ScheduledControllers restore.		(aBoolean and: [Smalltalk includesKey: #ConfigFile])			ifTrue: [ConfigFile currentUserConfig writeSection: #ScreenColor with: aSymbolOfColor asString]]!oitMenu	^OITMenu! !!BoxController class methodsFor: 'class initialization'!initialize	"BoxController initialize"	". . . initializes the yellow button pop-up menu."	BoxYellowButtonMenu  _		PopUpMenu			labels: 'change boxchange contentsadd Boxadd Matrix'			lines: #(2).	BoxYellowButtonMessages _ #(boxChange selectionChange addBox addMatrix)! !!DBoxController class methodsFor: 'initialization'!initialize	"DBoxController initialize."	Type _ #(#execute #fill #password #keyword #select #multipleSelect #multiple #paragraph).	TypeActivity _#(#startExecuteAt: #startFillControllerAt: #startFillControllerAt:#startFillControllerAt: #startSelectAt: #startMultipleSelectAt: #startQuerierControllerAt: #startFillControllerAt:)! !!GrapherController class methodsFor: 'class initialization'!initialize	"GrapherController initialize"	". . . initializes the yellow button pop-up menu."	GrapherControllerYellowButtonMenu  _		PopUpMenu			labels: 'BrowseBrowse MessagesMoveGraph SubclassesAdd ConnectionRemove ConnectionScroll'			lines: #(2 3 4 6).	GrapherControllerYellowButtonMessages _ #(browseClass browseMessages boxMove browseSubclasses  addConnection removeConnection scroll)! !!InfoCenterGraphController class methodsFor: 'class initialization'!initialize	"InfoCenterGraphController initialize"	". . . initializes the yellow button pop-up menu."	ICGCYellowButtonMenu  _		PopUpMenu			labels: 'openadd connectionremove connectiongraphedit link typesredisplayorganizemovescrollhardcopy'			lines: #(1 3 5 8).	ICGCYellowButtonMessages _ #(viewIt addConnection removeConnection graphElement editLinkTypes redisplay cleanItUp boxMove scroll hardcopy)! !!ABFormController class methodsFor: 'As yet unclassified'!initialize	"Initialize the yellow  button pop-up menu the auto book list."	ABFormYellowButtonMenu _ PopUpMenu labels: 'compress changes rewrite sources '.	ABFormYellowButtonMessages _ #(compressChanges rewriteSources)	"ABFormController initialize"! !PreviewTabController class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!RectForm class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!RectForm class methodsFor: 'utility'!pointIn: aFile	^Point x: ((aFile upTo: Delimiter) asNumber)		y: ((aFile upTo: Delimiter) asNumber)!pointIn: aFile delimiter: del	^Point x: ((aFile upTo: del) asNumber)		y: ((aFile upTo: del) asNumber)! !!RectForm class methodsFor: 'instance creation'!readFrom: aFile delimiter: del	"rectangle form fileName pBorder rBorder offset scale"	| newSelf |	newSelf	_ self rectangle: ((self pointIn: aFile delimiter: del)							extent: (self pointIn: aFile delimiter: del)).	aFile upTo: del.	newSelf fileName: (aFile upTo: del).	newSelf pBorder: (aFile peek = $t).	aFile upTo: del.	newSelf rBorder: (aFile peek = $t).	aFile upTo: del.	newSelf offset: (self pointIn: aFile delimiter: del).	aFile peek = $n		ifFalse: [newSelf scale: (Point x: (Compiler evaluate: (aFile upTo: del)) y: (Compiler evaluate: (aFile upTo: del)))]		ifTrue: [aFile upTo: del].	aFile peek = $f		ifTrue: [newSelf opaque: false.				aFile upTo: del].	^newSelf!rectangle: aRect	^self new initialize rectangle: aRect; offset: aRect origin!rectangle: aRect form: aForm fileName: aName	^self new initialize rectangle: aRect;		form: aForm;		fileName: aName;		offset: aRect origin!rectangle: aRect form: aForm fileName: aName scale: aScale	^self new initialize rectangle: aRect;		form: aForm;		fileName: aName;		offset: aRect origin;		scale: aScale! !OutlineList class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!OutlineList class methodsFor: 'instance creation'!new	"create a new OutlineList"	| theOutlineList |	theOutlineList _ self basicNew.	theOutlineList		collection: OrderedCollection new;		toggleListIndex: 0;		theCutBuffer: 0;		hasChanged: false.	^theOutlineList!on: aFileName withKey: aString	| aOutlineList | 	aOutlineList _ self new.	aOutlineList fileName: aFileName;		key: aString.	^aOutlineList! !!OutlineList class methodsFor: 'initialization'!initialize	"OutlineList initialize"	TextPtr _ 2.	LinkPtr _ 1! !!OutlineList class methodsFor: 'private'!getRunsAndTextEnd: aFileStream 	| size pos |	aFileStream position: (size _ aFileStream size) - 1.	aFileStream next = $) ifFalse: [^Array with: (RunArray new: size withAll: 1) with: size].	aFileStream position: (size _ aFileStream size) - 1.	pos _ size - 1.	[pos <= 1 | (aFileStream next asciiValue = 255)]		whileFalse: 			[pos _ pos - 1.			aFileStream position: pos].	aFileStream position: pos + 1.	^ Array with: (Compiler evaluate: (aFileStream next: size - pos - 1)) with: pos!hardcopyUsingBP: theBP	"theBP applicData contains the temporary filename to pull the text from and the heading to be used"	| inputTextFile runsAndTextEnd start textLeft string text appendToLineEndString | 	theBP pressPrinter useHeadings: (theBP applicData at: 2).	inputTextFile _ (HeaderFileStream fileNamed: (theBP applicData at: 1)) readOnly.	PressOrInterpress == #Interpress		ifTrue: [theBP pressPrinter printFromFile: inputTextFile]		ifFalse: [runsAndTextEnd _ self getRunsAndTextEnd: inputTextFile.				inputTextFile reset.				[start _ inputTextFile position.				 textLeft _ (runsAndTextEnd at: 2) - start.				 textLeft > 0] whileTrue:					[string _ inputTextFile next: (5000 min: textLeft).					 (appendToLineEndString _ inputTextFile through: Character cr) isEmpty 						ifFalse: [string _ string, appendToLineEndString].					 text _ Text string: string runs: ((runsAndTextEnd at: 1) copyFrom: start + 1 to: inputTextFile position).					 theBP pressPrinter putText: text].				inputTextFile close].	Disk removeKey: (theBP applicData at: 1).	theBP pressFileCreated: true!makeSimpleTextFileFromSuitcase: aSuitcase	| aOutlineList fname | 	aOutlineList _ self on: aSuitcase dataItem filename withKey: String new.	aSuitcase changeClassification: aOutlineList root.	aSuitcase dataItem label: aOutlineList root label.	aSuitcase accept.	fname _ aOutlineList makeSimpleTextFile.	aOutlineList release.	^fname! !Auditor class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!Auditor class methodsFor: 'utilities'!hardcopy	| theFileText | 	AuditTrail == nil ifTrue: [AuditTrail _ (FileStream fileNamed: AuditFileName) readWrite].	AuditTrail close.	(Smalltalk includesKey: #PrintFrom1108)		ifTrue: [PrintFrom1108 sendAndWaitPrintFile: AuditTrail name printer: UserProfile current printerName copies: 1]		ifFalse: [(DataMaster backgroundPrintingAvailable: true) ifTrue:					[theFileText _ AuditTrail contentsOfEntireFile.					BackgroundPrinter putText: (Text fromString: theFileText)]].	AuditOn ifTrue: [AuditTrail readWrite; setToEnd]!save	| timeNow | 	timeNow _ LargePositiveInteger new: 4.	Time secondClockInto: timeNow.	timeNow - LastSaved > 180		ifTrue:			[AuditTrail nextPutAll: 'Close Audit Trail File at ',Time dateAndTimeNow printString; cr. 			AuditTrail close.			Time secondClockInto: LastSaved]!wipeOut	(self confirm: 'Destroy the current audit record?') ifFalse: [^self].	AuditTrail == nil ifFalse: [AuditTrail close].	Disk removeKey: AuditFileName ifAbsent: [].	AuditTrail _ AuditOn ifTrue: [(FileStream fileNamed: AuditFileName) readWrite] ifFalse: [nil]! !!Auditor class methodsFor: 'initialization'!initialize	"Auditor initialize."	AuditFileName _ 'AuditTails'.	LastSaved _ LargePositiveInteger new: 4.	AuditOn _ false! !!Auditor class methodsFor: 'public access'!absoluteAdd: aString	AuditTrail nextPutAll: aString; cr!add: aString	AuditOn ifTrue: [AuditTrail nextPutAll: aString; cr]!audit	^AuditOn!auditOn	| users labels defaults one ans newAnalystUsers found thisUser | 	"Auditor auditOn"	(users _ LogInOut usersFileStream) == nil ifTrue: [^self booboo: 'Users file missing'].	labels _ OrderedCollection new.	defaults _ OrderedCollection new.	labels add: 'Users monitored:'.	[users atEnd]	whileFalse: [labels add: (one _ users upTo: $\).				users skipTo: Character cr; skip: -3.				(users next: 2) = '20' ifFalse: [defaults add: one].				users next].	ans _ DBoxView		openFor: #(multipleSelect)		title: 'Audit Trail Set Up'		labels: (Array with: labels)		defaults: (Array with: defaults)		commands: #(accept cancel bailOut)		autoAccept: false		links: Array new.	(ans ~~ nil and: [ans isEmpty not])	ifTrue: [newAnalystUsers _ WriteStream on: String new.			users reset; readWrite.			ans first == nil ifTrue: [ans at: 1 put: (Array with: 'Ghost')].			ans first do: [:one |				found _ false.				[users atEnd or: [found]]				whileFalse: [thisUser _ users upTo: Character cr.							newAnalystUsers nextPutAll: (thisUser copyFrom: 1 to: thisUser size - 2).							(thisUser copyUpTo: $\) = one								ifTrue: [found _ true. newAnalystUsers nextPutAll: '66']								ifFalse: [newAnalystUsers nextPutAll: '20'].							newAnalystUsers cr]].			[users atEnd]			whileFalse: [thisUser _ users upTo: Character cr.						newAnalystUsers nextPutAll: (thisUser copyFrom: 1 to: thisUser size - 2).						newAnalystUsers nextPutAll: '20'.						newAnalystUsers cr].		users reset; nextPutAll: newAnalystUsers contents].	users close!shutDown	self add: Time dateAndTimeNow printString.	AuditOn _ false.	AuditTrail == nil ifFalse: [AuditTrail close].	AuditTrail _ nil!turnMeOn: aBoolean	AuditOn _ aBoolean.	AuditOn ifTrue:		[AuditTrail == nil ifTrue: [AuditTrail _ (FileStream fileNamed: AuditFileName) readWrite].		AuditTrail setToEnd]! !Stats class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Stats class methodsFor: 'instance creation'!on: aCollection	| newStats | 	newStats _ super new.	newStats collection: aCollection.	^newStats! !!BackgroundPrinter class methodsFor: 'printing'!askQuestions: questionArray	"defaults, types, labels (optionally followed by the classification and info center to file at) go in questionArray"	^ self new askQuestions: questionArray!askQuestions: questionArray queueData: applicData callOnTurn: applicClass	| theBP | 	theBP _ self new askQuestions: questionArray.	theBP == nil ifFalse: [theBP queueData: applicData callOnTurn: applicClass]!hardcopyWithSuitcase: aSuitcase	self printPressFileName: aSuitcase dataItem filename!printForm: aForm	self printForm: aForm withTitle: String new alignMark: false suitcase: nil!printForm: aForm suitcase: aSuitcase	self printForm: aForm withTitle: String new alignMark: false suitcase: aSuitcase!printForm: aForm withTitle: titleString	self printForm: aForm withTitle: titleString alignMark: false suitcase: nil!printForm: aForm withTitle: titleString alignMark: putAlignMark suitcase: aSuitcase	| default types labels size orientation answers fullPressExtent maxPressExtent questionArray theBP applicData arr theClass infoCenterName |	default _ OrderedCollection new.	types _ OrderedCollection new.	labels _ OrderedCollection new.	size _ #full.	orientation _ #normal.	arr _ self fittingOf: aForm extent boundedBy: self defaultDoverRectangle fullSize: true.	(arr at: 1) ifFalse: [size _ #half].	(arr at: 2) ifTrue: [orientation _ #landscape].	default add: orientation;		add: size;		add: #yes;		add: titleString.	types addAllLast: #(select select select fill).	labels addAllLast: #(#(Mode normal landscape)				  #(Size full half)				  #(Border yes no)				  #(Title)).	aSuitcase == nil		ifFalse: [theClass _ aSuitcase classification. infoCenterName _ aSuitcase centerName]		ifTrue: [theClass _ Classification array: (Array with: nil)].	(questionArray _ Array new: 5)		at: 1 put: default; at: 2 put: types; at: 3 put: labels; at: 4 put: theClass; at: 5 put: infoCenterName.	theBP _ self askQuestions: questionArray.	theBP == nil ifTrue: [^self]. "bailout"	applicData _ Array new: 11. "see createPressFile for definition of contents"	applicData		at: 1 put: #createPressFile;		at: 2 put: (Array with: (aForm deepCopy));		at: 3 put: (Array with: (theBP applicAnswers at: 4)); "caption - may be nil"		at: 4 put: ((theBP applicAnswers at: 2) = #full); "full size"		at: 5 put: ((theBP applicAnswers at: 1) = #landscape); "landscape"		at: 6 put: ((theBP applicAnswers at: 3) = #yes); "border"		at: 7 put: putAlignMark.	theClass == nil ifFalse: [applicData at: 11 put: (Array with: theClass hardcopyString asText with: nil with: nil)].	(((theBP applicAnswers at: 1) ~= orientation) and: [(orientation = #landscape) and: [applicData at: 4]])		ifTrue: [self booboo: 'This WILL be landscape mode - it will not fit any other way'].	(((theBP applicAnswers at: 2) ~= size) and: [size = #half])		ifTrue: [self booboo: 'This WILL be half sized - it will not fit any other way'].	theBP queueData: applicData callOnTurn: BackgroundPrinter!printPressFileName: aFileName	| fileStream theReturn bkgrndInst goAhead typeFile |	typeFile _ DataMaster giveMe: #englishString for: aFileName.	typeFile = PressOrInterpress asLowercase			ifFalse: [^self booboo: 'Not currently set to handle this type of Printer file'].	[theReturn _ DBoxView		openFor: #(fill fill)		title: 'Send ', typeFile, ' file to printer'		labels: #(#('Printer Name:') #('No. Copies:'))		defaults: (Array with: UserProfile current printerName with: (String with: $1)).	 theReturn == nil ifTrue: [^self].	 ((theReturn at: 1) = nil or: [(theReturn at: 2) = nil or: [(theReturn at: 2) asString isNumeric not]])]		whileTrue: [self booboo: 'Try again'].	bkgrndInst _ BackgroundPrinter new sendPressFile: aFileName toPrinter: (theReturn at: 1) numCopies: (theReturn at: 2) asNumber asInteger.	RunAsForeground		ifTrue: [bkgrndInst runAsForeground]		ifFalse: [self putInBackground: bkgrndInst]!printReportText: theText annoDict: annoDict forms: formsList titles: titleList suitcase: aSuitcase	| default types labels questionArray theBP applicData theClass infoCenterName | 	default _ OrderedCollection new.	types _ OrderedCollection new.	labels _ OrderedCollection new.	default add: #normal.	types addLast: #select.	labels addLast: #('Mode (all images)' normal landscape).	theText == nil ifFalse:		[default add: #yes.		 types add: #select.		 labels add: #('Print Annotations' yes no)].	aSuitcase == nil		ifFalse: [theClass _ aSuitcase classification. infoCenterName _ aSuitcase centerName]		ifTrue: [theClass _ Classification array: (Array with: nil)].	(questionArray _ Array new: 5)		at: 1 put: default; at: 2 put: types; at: 3 put: labels; at: 4 put: theClass; at: 5 put: infoCenterName.	theBP _ self askQuestions: questionArray.	theBP == nil ifTrue: [^self]. "bailout"	applicData _ Array new: 11. "see createPressFile for definition of contents"	applicData		at: 1 put: #createPressFile;		at: 2 put: formsList asArray;		at: 3 put: titleList asArray;		at: 4 put: true; "full size"		at: 5 put: ((theBP applicAnswers at: 1) = #landscape); "landscape"		at: 6 put: true; "border"		at: 7 put: false. "align mark"	theText == nil ifFalse:			[applicData at: 8 put: theText copy.			 applicData at: 9 put: annoDict copy.			 applicData at: 10 put: ((theBP applicAnswers at: 2) = #yes)].	theClass == nil ifFalse: [applicData at: 11 put: (Array with: theClass hardcopyString asText with: nil with: nil)].	theBP queueData: applicData callOnTurn: BackgroundPrinter!putText: theText	self putText: theText annoDict: nil suitcase: nil!putText: theText annoDict: annoDict suitcase: aSuitcase	| default labels types answers theBP questionArray applicData theClass infoCenterName |	default _ OrderedCollection new.	types _ OrderedCollection new.	labels _ OrderedCollection new.	(annoDict == nil or: [annoDict isEmpty]) ifFalse:		[default add: #yes. labels add: #('Print Annotations' yes no). types add: #select].	aSuitcase == nil		ifFalse: [theClass _ aSuitcase classification. infoCenterName _ aSuitcase centerName]		ifTrue: [theClass _ Classification array: (Array with: nil)].	(questionArray _ Array new: 5)		at: 1 put: default; at: 2 put: types; at: 3 put: labels; at: 4 put: theClass; at: 5 put: infoCenterName.	theBP _ self askQuestions: questionArray.	theBP == nil ifTrue: [^self]. "bailout"	applicData _ Array new: 11. "see createPressFile for definition of contents"	applicData at: 1 put: #createPressFile.	applicData at: 8 put: theText copy.	theClass == nil ifFalse: [applicData at: 11 put: (Array with: theClass hardcopyString asText with: nil with: nil)].	(annoDict == nil or: [annoDict isEmpty])		ifFalse:			[applicData at: 9 put: annoDict copy.			 applicData at: 10 put: ((theBP applicAnswers at: 1) = #yes)]		ifTrue: [applicData at: 10 put: true].	theBP queueData: applicData callOnTurn: BackgroundPrinter!snapForm	| cursorLoc mouseButtons cursor defaults theForm answers formRect yes no |	cursorLoc _ Sensor cursorPoint.	mouseButtons _ Sensor buttons.	cursor _ Cursor currentCursor.	theForm _ Form fromDisplay: (formRect _ Rectangle fromUser).	answers _ DBoxView		openFor: #(select select select)		labels: #(('Show Cursor' yes no)				  ('Show Mouse' yes no)				  ('Align Mark' yes no))		defaults: (Array with: #yes with: #yes with: #no).	answers == nil ifTrue: [^self].	((answers at: 1) = #yes) ifTrue: [cursor displayOn: theForm at: cursorLoc - formRect origin rule: Form under].	((answers at: 2) = #no)		ifTrue: [mouseButtons _ 0]		ifFalse: [theForm _ self putMouseButtons: mouseButtons on: theForm].	Clipboard clip: theForm.	self printForm: theForm withTitle: String new alignMark: ((answers at: 3) = #yes) suitcase: nil! !!BackgroundPrinter class methodsFor: 'access'!abortCurrent	self installBackgroundProcess.	BackgroundDelay _ 200.	CurrentInstance == nil ifFalse: [CurrentInstance checkRemovalOfSending].	self cleanUpAfter!accessQueue	| wasProtected | 	(wasProtected _ DequeProtect at: 1) ifFalse: [DequeProtect at: 1 put: true].	^wasProtected!deAccessQueue	"BackgroundPrinter deAccessQueue"	| wasProtected | 	wasProtected _ DequeProtect at: 1.	DequeProtect at: 1 put: false.	[(DequeProtect at: 2) isEmpty] whileFalse: [(DequeProtect at: 2) signal].	^wasProtected!defaultDoverRectangle	^ 317@635 corner: 20954@26987"(0.125*2540) asInteger@(0.25*2540) asInteger extent: (8.125*2540) asInteger@(10.375*2540) asInteger "!dequeProtected	^ DequeProtect at: 1!emptyBackground	"BackgroundPrinter emptyBackground"	self protectQueueWhileDo:		[1 to: BackgroundDeque size do: [:i | BackgroundDeque removeFirst checkRemovalOfSending]]!fittingOf: anExtent boundedBy: aRect fullSize: fSize	"Check a given extent to see if it would fit in a given rectangle for either full size or half size. Passing back an array of two, the first element indicating either full or half size and the second element is true if it should be landscaped."	| defaultRect pressScale landscape maxExtent testExtent fullSize | 	landscape _ false.	fullSize _ fSize.	defaultRect _ aRect.	PressOrInterpress == #Interpress		ifTrue: [defaultRect _ defaultRect origin extent: (defaultRect extent // 2).				pressScale _ fullSize ifTrue: [16] ifFalse: [8]]		ifFalse: [pressScale _ fullSize ifTrue: [32] ifFalse: [16]].	maxExtent _ defaultRect extent - (ImagePressRect center - defaultRect center).	testExtent _ anExtent * pressScale.	"theForm's current press extent"	(testExtent y > maxExtent y or: [testExtent x > maxExtent y])		ifTrue: [fullSize _ false]		ifFalse:			[(testExtent x > maxExtent x) ifTrue:				[(testExtent y > maxExtent x)					ifTrue: [fullSize _ false]					ifFalse: [landscape _ true]]].	^Array with: fullSize with: landscape!getCurrent	^ CurrentInstance!getEntry: entryNum	| entryNumObject |	self protectQueueWhileDo:		[entryNumObject _ BackgroundDeque at: entryNum].	^ entryNumObject!givePriorityTo: entryNum	| entryNumObject |	self protectQueueWhileDo:		[entryNumObject _ BackgroundDeque removeObjectAt: entryNum.		 BackgroundDeque addFirst: entryNumObject]!messenger	| bc | 	^(bc _ BackgroundController unprotectedBackgroundAccess) == nil		ifTrue: [BackgroundController backgroundAccess]		ifFalse: [bc]!numWaiting	^ BackgroundDeque size!protectQueueWhileDo: aBlock	| wasProtected |	wasProtected _ self accessQueue.	aBlock value.	wasProtected ifFalse: [self deAccessQueue]!putInBackground: anObject	BackgroundDeque addLast: anObject.	BackgroundDelay _ 200.	BackgroundController backgroundAccess!removeEntry: entryNum	self protectQueueWhileDo:		[(BackgroundDeque removeObjectAt: entryNum) checkRemovalOfSending]!runAsForeground: aBoolean	RunAsForeground _ aBoolean!setToPress: aBoolean	(aBoolean and: [Smalltalk includesKey: #PressFile])		ifTrue: [Smalltalk at: #PressOrInterpress put:#Press]		ifFalse: [Smalltalk at: #PressOrInterpress put:#Interpress].	ImagePressRect _ PressOrInterpress == #Press						ifTrue: [2540@2540 extent: 16672@22784 "(521@712)*32"]						ifFalse: [1270@1270 extent:  8336@11392 "(521@712)*16"]. "inch x margin of 1@.7" "PressPrinter DefaultPageRectangle"	"for use in centering images, comments, align marks"	(Smalltalk includesKey: #PreviewCompositionScanner)		ifTrue: [PreviewCompositionScanner setMinimumSpacing]!waitForDeque	self dequeProtected		ifTrue: [self messenger show: 'Waiting for queue restart'. (DequeProtect at: 2) wait]		ifFalse: [(DequeProtect at: 2) isEmpty ifFalse: [(DequeProtect at: 2) signal]]! !!BackgroundPrinter class methodsFor: 'initialization'!cleanUpAfter	CurrentInstance _ nil.	BackgroundDeque ifEmptyDo: [BackgroundDelay _ 0. BackgroundController closeBackgroundAccess]!initialize	"BackgroundPrinter initialize"	| offButtonForm |	Smalltalk at: #BackgroundDelay put: 0.	RunAsForeground _ false.	BackgroundDeque _ SharedDeque new: 10.	(DequeProtect _ Array new: 2) at: 1 put: false; at: 2 put: Semaphore new.	self installBackgroundProcess.	ImagePressRect _ PressOrInterpress == #Press						ifTrue: [2540@2540 extent: 16672@22784 "(521@712)*32"]						ifFalse: [1270@1270 extent:  8336@11392 "(521@712)*16"].  "inch x margin of 1@.7" "PressPrinter DefaultPageRectangle"	"for use in centering images, comments, align marks" 	OnButtonForm _  Form extent: 10@27					   fromArray: #( 7680 16128 32640 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 65472 32640 16128 7680)					   offset: 0@0.	offButtonForm _ Form extent: 10@27					  fromArray: #( 7680 8448 16512 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 32832 16512 8448 7680)					  offset: 0@0.	MouseForm _ (Form extent: 46@39) borderWidth: 4.	1 to: 3 do: [ :button | MouseForm copy: (self buttonRect: button)									from: 0@0									in: offButtonForm									rule: Form over]!installBackgroundProcess	"BackgroundPrinter installBackgroundProcess"	BackgroundProcess == nil ifFalse: [self terminateBackgroundProcess].	BackgroundProcess _		[[true] whileTrue:			[self waitForDeque.			 (CurrentInstance _ BackgroundDeque removeFirst) heresYourChance.			 self cleanUpAfter]] newProcess.	BackgroundProcess priority: Processor userBackgroundPriority.	BackgroundProcess resume!terminateBackgroundProcess	"BackgroundPrinter terminateBackgroundProcess"	BackgroundProcess == nil ifFalse:		[BackgroundProcess terminate. BackgroundProcess _ nil. CurrentInstance _ nil. BackgroundDelay _ 0]! !!BackgroundPrinter class methodsFor: 'private'!buttonRect: buttonNumber	^((buttonNumber-1)*12 + 6) @ 6 extent: 10@27!hardcopyUsingBP: theBP	"in this case, applicData at: 1 is expected to be the message for theBP to perform"	theBP perform: (theBP applicData at: 1)!putMouseButtons: mouseButtons on: aForm	"return a form consisting of aForm with a representation of the mouse (with its buttons pressed according to mouseButtons) off the lower right hand corner"	| newForm mouseOrigin |	aForm borderWidth: 2.	newForm _ Form new extent: (aForm extent x max: MouseForm extent x) @ (aForm extent y + MouseForm extent y - 1).	aForm displayOn: newForm at: 0@0.	mouseOrigin _ newForm extent - MouseForm extent.	mouseOrigin y: mouseOrigin y - 1.	"inset mouse into border of form"	MouseForm displayOn: newForm at: mouseOrigin.	1 to: 3 do: [:i |		0 = (mouseButtons bitAnd: (#(1 2 4) at: i))			ifFalse:	[OnButtonForm displayOn: newForm at: (mouseOrigin + (self buttonRect: i) origin)]].	^newForm! !!RS232MemoryBuffer class methodsFor: 'instance creation'!ofSize: theSize	"Answer a new instance of me theSize long"	^self basicNew on: (String new: theSize)! !!BinaryChoice class methodsFor: 'instance creation'!myMessage: messageString displayAt: aPoint centered: centered ifTrue: trueAlternative ifFalse: falseAlternative	"Answer an instance of me whose question is messageString.  The usermust respond before continuning If centered, a Boolean, is false, display the view of the	instance at aPoint; otherwise display it with its center at aPoint."	| newChoice |	newChoice _ self new initialize.	newChoice trueAction: trueAlternative.	newChoice falseAction: falseAlternative.	BinaryChoiceView openBooBooOn: newChoice message: messageString displayAt: aPoint centered: centered!myMessage: messageString displayAt: aPoint centered: centered yesLabel: yesString noLabel:noString ifTrue: trueAlternative ifFalse: falseAlternative	"Answer an instance of me whose question is messageString.  The usermust respond before continuning If centered, a Boolean, is false, display the view of the	instance at aPoint; otherwise display it with its center at aPoint."	| newChoice |	newChoice _ self new initialize.	newChoice trueAction: trueAlternative.	newChoice falseAction: falseAlternative.	BinaryChoiceView openBooBooOn: newChoice message: messageString displayAt: aPoint centered: centered yesLabel: yesString noLabel:noString! !!BoxView class methodsFor: 'examples'!openClassView: aClass 	"BoxView openClassView: View""open a test view of the BoxView"	| aBoxView  aBoxModel topView topY|	aBoxView _ BoxView new.	aBoxModel _ OrderedCollection new.	topY _ 10.	topY _ self setUpViewForClass: aClass with: 10 and: topY in: aBoxView on: aBoxModel.	aBoxView model: aBoxModel.	aBoxView controller: GrapherController new.	aBoxView insideColor: Form white.	aBoxView setBorders.	aBoxView borderWidth: 2.	topView _ StandardSystemView new.	topView controller: StandardSystemController new.	topView model: aBoxView model.	topView addSubView: aBoxView.	topView label: 'BoxView Test'.	topView minimumSize: 400 @ topY + 40.	topView controller open!openTest 	"BoxView openTest""open a test view of the BoxView"	| aBoxView  aBoxModel topView topY|	aBoxView _ BoxView new.	aBoxModel _ OrderedCollection new.	aBoxView addBox: (Rectangle new origin:40@50 corner:620@210).	aBoxModel add: ((Matrix new: 4 by: 4) setAsScalar: 8).	topY _ 220.	1 to: 5 do:		[:i | aBoxView addBox:(Rectangle new origin: 50@topY corner: 550@(topY+20)).		topY _ topY + 30.		aBoxModel add: 'position ',(i printString)].	aBoxView model: aBoxModel.	aBoxView controller: BoxController new.	aBoxView insideColor: Form darkGray.	aBoxView borderWidth: 2.	aBoxView setBorders.	topView _ StandardSystemView new.	topView controller: StandardSystemController new.	topView model: aBoxView model.	topView addSubView: aBoxView.	topView label: 'BoxView Test'.	topView minimumSize: 400 @ 350.	topView controller open!setUpViewForClass: aClass with: topX and: topY in: aBoxView on: aBoxModel	| aTopX aTopY |	aTopY _ topY.	aTopX _ topX.	aBoxView addBox: (Rectangle new origin: aTopX@aTopY corner: aTopX+(aClass printString asParagraph width + 5)@(aTopY + 20)).	aBoxModel add: (aClass).	aTopX _ aTopX + 40.	aClass subclasses do:		[:subclass | aTopY _ aTopY + 21.			aTopY _ self setUpViewForClass: subclass with: aTopX and: aTopY in: aBoxView on: aBoxModel.].	^aTopY! !!BoxView class methodsFor: 'instance creation'!new	"create a new BoxView"	| theNewBoxView |	theNewBoxView _ super new.	theNewBoxView boxList: OrderedCollection new.	theNewBoxView cancelBorders.	theNewBoxView oldElement: 0.	theNewBoxView xSize: 0.	theNewBoxView ySize: 0.	theNewBoxView labelList: OrderedCollection new.	theNewBoxView offsetPoint: 0@0.	theNewBoxView mapChanged: true.	^ theNewBoxView! !!DBoxView class methodsFor: 'utilities'!emphasisFontNum	^EmphasisFontNum!individualSelectionWidth: aStringCollection 	"Answer the width of all elements' total widths (excluding the first string) 	in aStringCollections."	| width sz |	aStringCollection == nil ifTrue: [^(MyCharacterScanner widthOfString: 'nil' emphasis: EmphasisFontNum)+10].	width _ 0.	(aStringCollection isKindOf: String)		ifTrue: [width _ (MyCharacterScanner widthOfString: aStringCollection emphasis: EmphasisFontNum)+10]		ifFalse: [(sz _ aStringCollection size) > 2					ifTrue: [width _ 0.							2 to: sz do:								[:i | width _ width max: (self individualSelectionWidth: (aStringCollection at: i))].							width _ width * (sz - 1)]					ifFalse: [width _ 200]].	^width!messageWidth: stringCollections 	"Answer the maximum width of the first strings of all the  	elements in stringCollections."	| max aString |	max _ 0.	stringCollections do: 		[:aCol | 		aString _ aCol at: 1.		max _ max max: (MyCharacterScanner widthOfString: aString emphasis: EmphasisFontNum)].	^(max + 15)!selectionWidth: stringCollections 	"Answer the nominal of all elements' total widths (excluding the first string) 	in stringCollections."	| width max min new |	stringCollections isEmpty ifTrue: [^0].	width _ self individualSelectionWidth: (stringCollections at: 1).	max _ min _ width.	2 to: stringCollections size do: 		[:i | width _ width + (new _ self individualSelectionWidth: (stringCollections at: i)).			max _ max max: new.			min _ min min: new].	^400 min: (max > ((width // stringCollections size) + 125) ifTrue: ["max + min // 2"((width // stringCollections size) + 1)] ifFalse: [max])! !!DBoxView class methodsFor: 'initialization'!initialize	"DBoxView initialize"	MyCharacterScanner _ FastTextDisplayScanner new.	EmphasisFontNum _ TextStyle getNumForStrikeFont: 'TimesRoman10B'! !!DBoxView class methodsFor: 'instance creation'!openFor: aTypeCollection labels: stringCollections defaults: defaultCollection	"Create a new DBoxView without title."	^self openFor: aTypeCollection title: String new labels: stringCollections defaults: defaultCollection!openFor: aTypeCollection title: titleString labels: stringCollections defaults: defaultCollection	"Create a new DBoxView."	^self openFor: aTypeCollection		title: titleString		labels: stringCollections		defaults: defaultCollection		autoAccept: false!openFor: aTypeCollection title: titleString labels: stringCollections defaults: defaultCollection autoAccept: aBoolean	"Create a new DBoxView."	^self openFor: aTypeCollection		title: titleString		labels: stringCollections		defaults: defaultCollection		commands: #(accept cancel bailOut)		autoAccept: aBoolean		links: #()!openFor: aTypeCollection title: titleString labels: stringCollections defaults: defaultCollection commands: commandCollection autoAccept: aBoolean	^self openFor: aTypeCollection		title: titleString		labels: stringCollections		defaults: defaultCollection		commands: commandCollection		autoAccept: aBoolean		links: #()!openFor: aTypeCollection title: titleString labels: stringCollections defaults: defaultCollection commands: commandCollection autoAccept: aBoolean links: linkCollection	^self openFor: aTypeCollection title: titleString labels: stringCollections defaults: defaultCollection commands: commandCollection autoAccept: aBoolean links: linkCollection linksBy: #()!openFor: aTypeCollection title: titleString labels: stringCollections defaults: defaultCollection commands: commandCollection autoAccept: aBoolean links: linkCollection linksBy: linkByCollection	"Create a new DBoxView."	| aDBoxView messageWidth selectionWidth origin answer aString titleWidth w hasFill clue |	hasFill _ false.	aTypeCollection do: [:type |		hasFill _ hasFill or: [#(fill password 'fill' 'password') includes: type]].	messageWidth _ self messageWidth: stringCollections.	selectionWidth _ self selectionWidth: stringCollections.	hasFill ifTrue: [selectionWidth _ selectionWidth max: 200]. 	titleWidth _ MyCharacterScanner widthOfString: titleString emphasis: EmphasisFontNum.	(aDBoxView _ self openView) title: titleString.	origin _ ((titleString == nil) or: [titleString isEmpty]) ifTrue: [20@40] ifFalse: [20@60].	w _ aDBoxView addExecute: commandCollection				at: 20@(origin y - 30) autoAccept: aBoolean.	selectionWidth _ selectionWidth max: (w - messageWidth).	1 to: aTypeCollection size do: 	[:i | aString _ (aTypeCollection at: i) asSymbol.		(aString == #select or: [aString == #multipleSelect])			ifTrue: [aDBoxView addSelect: (stringCollections at: i) 					default: (defaultCollection at: i)					at: origin 					from: (aDBoxView model size+2) 					messageWidth: messageWidth 					selectionWidth: selectionWidth 					height: 25					type: aString].		aString == #multiple			ifTrue: [aDBoxView addMultiple: (stringCollections at: i)					default: (defaultCollection at: i)					at: origin					from: (aDBoxView model size+2) 					messageWidth: messageWidth 					selectionWidth: selectionWidth 					height: 25].		aString == #fill | (aString == #password) | (aString == #keyword) | (aString == #paragraph)			ifTrue: [aDBoxView addFill: (stringCollections at: i)					type: aString 					default: (defaultCollection at: i)					at: origin 					from: (aDBoxView model size+2) 					messageWidth: messageWidth 					selectionWidth: selectionWidth 					height: 30].		origin y: ((aDBoxView boxList last) corner) y.].	SmalltalkSignal do:	[linkCollection isEmpty ifFalse: [aDBoxView linkTo: linkCollection].	linkByCollection isEmpty ifFalse: [aDBoxView linkBy: linkByCollection].	aDBoxView displayWidth: ((messageWidth+selectionWidth+40) max: (titleWidth + 20)) height: (origin y +20).	aDBoxView controller startUp.	answer _ aDBoxView answerArray.	aDBoxView release.	aDBoxView form displayOn: Display at: (aDBoxView displayBox topLeft).	aDBoxView _ nil.	^answer]	handle: [(clue _ SmalltalkSignal clue) = #recursive				ifTrue: [self booboo: 'recursive links detected !!!! Check your setups.'] ifFalse: [SmalltalkSignal noHandler].			SmalltalkSignal handleReturn: nil].!openView	"create a new DBoxView."		| aDBoxView |	aDBoxView _ super new.	aDBoxView model: (OrderedCollection new)		controller: DBoxController new;		insideColor: Form white;		answerArray: nil;		borderWidth: 2;		setBorders.	^aDBoxView! !!ConnectedBoxView class methodsFor: 'instance creation'!new	"create a new BoxView"	| theNewBoxView aNewElement |	theNewBoxView _ super new.	theNewBoxView boxList: OrderedCollection new.	theNewBoxView connections: AdjacencyMatrix new.	theNewBoxView cancelBorders.	theNewBoxView oldElement: 0.	^ theNewBoxView! !!ConnectedBoxView class methodsFor: 'new views - examples'!openClassView: aClass 	"ConnectedBoxView openClassView: Controller""open a test view of the BoxView"	| aBoxView  aBoxModel topView topY|	aBoxView _ ConnectedBoxView new.	aBoxModel _ OrderedCollection new.	topY _ 10.	topY _ self setUpViewForClass: aClass with: 10 and: topY in: aBoxView on: aBoxModel connectTo: 0.	aBoxView model: aBoxModel.	aBoxView controller: GrapherController new.	aBoxView insideColor: Form white.	aBoxView setBorders.	aBoxView borderWidth: 2.	topView _ StandardSystemView new.	topView controller: StandardSystemController new.	topView model: aBoxView model.	topView addSubView: aBoxView.	topView label: 'BoxView Test'.	topView minimumSize: 300 @ 10.	topView controller open!openOneLevelClassView: aClass 	"ConnectedBoxView openOneLevelClassView: Controller""open a test view of the BoxView"	| aBoxView  aBoxModel topView topY|	aBoxView _ ConnectedBoxView new.	aBoxModel _ OrderedCollection new.	topY _ 10.	topY _ self setUpOneLevelViewForClass: aClass with: 10 and: topY in: aBoxView on: aBoxModel.	aBoxView model: aBoxModel.	aBoxView controller: GrapherController new.	aBoxView insideColor: Form white.	aBoxView setBorders.	aBoxView borderWidth: 2.	topView _ StandardSystemView new.	topView controller: StandardSystemController new.	topView model: aBoxView model.	topView addSubView: aBoxView.	topView label: aClass printString,' Subclasses'.	topView minimumSize: 400 @ topY + 40.	topView controller open! !!ConnectedBoxView class methodsFor: 'private'!setUpOneLevelViewForClass: aClass with: topX and: topY in: aBoxView on: aBoxModel	| aTopX aTopY theConnections boxAddr|	aTopY _ topY.	aTopX _ topX.	aBoxView addBox: (Rectangle new origin: aTopX@aTopY corner: aTopX+(aClass printString asParagraph width + 5)@(aTopY + 20)).	aBoxModel add: (aClass).	boxAddr _ aBoxView boxList size.	aTopX _ aTopX + 200.	aClass subclasses do:		[:subclass |aTopY _ aTopY + 21.				aBoxView addBox: (Rectangle new origin: aTopX@aTopY corner: aTopX+(subclass printString asParagraph width + 5)@(aTopY + 20)).				aBoxView addConnectionFrom: boxAddr to: (aBoxView boxList size).				aBoxModel add: (subclass)].	^aTopY!setUpViewForClass: aClass with: topX and: topY in: aBoxView on: aBoxModel connectTo: boxAddr 	| aTopX aTopY aboxAddr theCount theName theNameForm theLabelForm |	"save copies of the x/y position"	aTopY _ topY.	aTopX _ topX.	"produce the box and label for this node"	theName _ aClass printString asParagraph.	theNameForm _ theName asForm.	theLabelForm _ Form extent: theName width + 5 @ 20.	theNameForm displayOn: theLabelForm at: 2 @ 2.	aBoxView labelList add: (theLabelForm borderWidth: 1).	aBoxModel add: aClass.	aBoxView addBox: (aTopX @ aTopY extent: theLabelForm extent).	"add a connection if appropriate"	boxAddr ~= 0 		ifTrue: [aBoxView addConnectionFrom: aBoxView boxList size to: boxAddr].	"set up for recursive call for sub-elements"	aboxAddr _ aBoxView boxList size.	theCount _ 0.	aTopX _ aTopX + (theName width + 30).	"call self once for each sub-element, to give tree structure"	aClass subclasses do: 		[:subclass | 		aTopY _ self					setUpViewForClass: subclass					with: aTopX					and: aTopY					in: aBoxView					on: aBoxModel					connectTo: aboxAddr.		theCount _ theCount + 1.		theCount < aClass subclasses size ifTrue: [aTopY _ aTopY + 21]].	"balance the tree"	aTopY ~= topY 		ifTrue: [aBoxView 			changeBoxAt: aboxAddr 			to: (topX @ (topY + (aTopY - topY // 2)) extent: theLabelForm extent)].	"remember the highest x and y positions"	aTopX > aBoxView xSize ifTrue: [aBoxView xSize: aTopX].	aTopY > aBoxView ySize ifTrue: [aBoxView ySize: aTopY].	^aTopY! !!InfoCenterGraphView class methodsFor: 'instance creation'!new	"create a new BoxView"	| theNewBoxView |	theNewBoxView _ super new.	theNewBoxView connections: AdjacencyMatrix new.	theNewBoxView infoCentLabelList: OrderedCollection new.	theNewBoxView hasChanged: false.	^ theNewBoxView! !!InfoCenterGraphView class methodsFor: 'new views'!viewStructureFollowingForward: fType backward: bType in: center startingAt: anElement label: theLabel orient: aSymbol 	"ConnectedBoxView openClassView: Stream"	"open a test view of the BoxView"	| aBoxView aBoxModel topView topY brokenKey |	center clearFlags.	aBoxView _ InfoCenterGraphView new.	aBoxView linkType: (Array with: fType with: bType).	aBoxView center: center.	aBoxModel _ OrderedCollection new.	aBoxView orientation: aSymbol.	topY _ 10.	Level _ 10.	Cursor wait showWhile: [aSymbol == #vertical			ifTrue: [topY _ self							setUpViewForElement: anElement							followingForward: fType							backward: bType							inCenter: center							with: 10							and: topY							in: aBoxView							on: aBoxModel							connectTo: 0]			ifFalse: [topY _ self							setAcrossViewForElement: anElement							followingForward: fType							backward: bType							inCenter: center							with: 10							and: topY							in: aBoxView							on: aBoxModel							connectTo: 0]].	aBoxView model: aBoxModel; controller: InfoCenterGraphController new; insideColor: Form white; setBorders; borderWidth: 1.	ContainerModel addDependent: aBoxView.	(topView _ StandardSystemView new) controller: ICGStandardSystemController new; model: aBoxView model; helpIndex: #GraphicFolder; addSubView: aBoxView; label: theLabel; minimumSize: 200 @ 200; classifyLabel: anElement; borderWidth: 1.	Cursor normal show.	topView controller open!viewTwoWayGraphFor: anElement in: center	| theReturn theLabel links fLinks bLinks | 	theReturn _ center chooseTheLinks: 'Show any of these connection types' default: #( (vertical) (contains) (none)).	theReturn == nil ifTrue: [^nil].	theLabel _ anElement label, ' connections'.	fLinks _ Array new: (theReturn at: 2) size.	bLinks _ Array new: (theReturn at: 3) size.	1 to: (theReturn at: 2) size do: [:i | fLinks at: i put: (center linkTypeFor: ((theReturn at: 2) at: i))].	1 to: (theReturn at: 3) size do: [:i | bLinks at: i put: (center linkTypeFor: ((theReturn at: 3) at: i))].	DataMaster findTheOneByEvaluating:		[:each | ((each isKindOf: StandardSystemController)				and: [each view label = theLabel])				and: [(each view subViews at: 1) linkType = (Array with: fLinks with: bLinks)]].	self		viewStructureFollowingForward: fLinks		backward: bLinks		in: center		startingAt: anElement		label: theLabel		orient: (theReturn at: 1)! !!InfoCenterGraphView class methodsFor: 'private'!formFor: anElement	| theNameForm theLabelForm | 	theNameForm _ anElement iconDisplayString asForm.	theLabelForm _ Form extent: theNameForm width + 10 @ (theNameForm height + 2).	theNameForm displayOn: theLabelForm at: 5 @ -2.	theLabelForm borderWidth: 1.	^theLabelForm!paragraphForLabel: aLabel 	"convert the string aLabel into a paragraph with the text having special emphasis"	^(Text string: aLabel emphasis: 1) asParagraph!setAcrossViewForBackElement: anElement followingForward: fType backward: bType inCenter: center with: topX and: topY in: aBoxView on: aBoxModel connectTo: boxAddr	| newTopX newTopY aBoxAddr theCount theLabelForm fLinks bLinks presentElement |	newTopY _ topY.	newTopX _ topX.	anElement setFlag.	1 to: aBoxModel size do: [:each | anElement == (aBoxModel at: each)			ifTrue: 				[boxAddr = 0 ifFalse: [aBoxView addConnectionFrom: boxAddr to: each].				anElement clearFlag.				^newTopY]].	aBoxModel add: anElement.	fType class == Array 		ifTrue:[fLinks_ OrderedCollection new. 			fType do: [:each | fLinks addAll: (anElement fPointersOfType: each)]] 		ifFalse: [fLinks _ anElement fPointersOfType: fType].	bType class == Array 		ifTrue:[bLinks_ OrderedCollection new. 			bType do: [:each | bLinks addAll: (anElement bPointersOfType: each)]] 		ifFalse: [bLinks _ anElement bPointersOfType: bType].	"produce the box and label for this node"	aBoxView infoCentLabelList add: anElement iconDisplayString.	theLabelForm _ self formFor: anElement.	aBoxView labelList add: theLabelForm.	aBoxView addBox: (newTopX @ newTopY extent: theLabelForm extent).	boxAddr ~= 0 ifTrue: [aBoxView addConnectionFrom: boxAddr to: aBoxView boxList size].	aBoxAddr _ aBoxView boxList size.	newTopY _ newTopY + (theLabelForm height + 30).	fLinks size > 0		ifTrue: 			[theCount _ 0.			fLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopX _ self											setAcrossViewForElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: eachElem to: aBoxAddr]]]].						theCount _ theCount + 1.						theCount < fLinks size ifTrue: [newTopX _ newTopX + theLabelForm width + 28]]]].	bLinks size > 0		ifTrue: 			[theCount _ 0.			bLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopX _ self											setAcrossViewForBackElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: aBoxAddr  to: eachElem]]]].						theCount _ theCount + 1.						theCount < bLinks size ifTrue: [newTopX _ newTopX + theLabelForm width + 28]]]].	newTopX ~= topX ifTrue: [aBoxView changeBoxAt: aBoxAddr to: ((topX + (newTopX - topX // 2)) @ topY extent: theLabelForm extent)].	"remember the highest x and y positions"	Level < newTopX ifTrue: [Level _ newTopX].	anElement clearFlag.	newTopX > aBoxView xSize ifTrue: [aBoxView xSize: newTopX].	newTopY > aBoxView ySize ifTrue: [aBoxView ySize: newTopY].	^newTopX!setAcrossViewForElement: anElement followingForward: fType backward: bType inCenter: center with: topX and: topY in: aBoxView on: aBoxModel connectTo: boxAddr 	| newTopX newTopY aBoxAddr theCount theLabelForm fLinks bLinks presentElement |	newTopY _ topY.	newTopX _ topX.	anElement setFlag.	1 to: aBoxModel size do: [:each | anElement == (aBoxModel at: each)			ifTrue: 				[boxAddr = 0 ifFalse: [aBoxView addConnectionFrom: each to: boxAddr].				anElement clearFlag.				^newTopX]].	aBoxModel add: anElement.	fType class == Array 		ifTrue:[fLinks_ OrderedCollection new. 			fType do: [:each | fLinks addAll: (anElement fPointersOfType: each)]] 		ifFalse: [fLinks _ anElement fPointersOfType: fType].	bType class == Array 		ifTrue:[bLinks_ OrderedCollection new. 			bType do: [:each | bLinks addAll: (anElement bPointersOfType: each)]] 		ifFalse: [bLinks _ anElement bPointersOfType: bType].	"produce the box and label for this node"	aBoxView infoCentLabelList add: anElement iconDisplayString.	theLabelForm _ self formFor: anElement.	aBoxView labelList add: theLabelForm.	aBoxView addBox: (newTopX @ newTopY extent: theLabelForm extent).	boxAddr ~= 0 ifTrue: [aBoxView addConnectionFrom: aBoxView boxList size to: boxAddr].	aBoxAddr _ aBoxView boxList size.	newTopY _ newTopY + (theLabelForm height + 70).	fLinks size > 0		ifTrue: 			[theCount _ 0.			fLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopX _ self											setAcrossViewForElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: eachElem to: aBoxAddr]]]].						theCount _ theCount + 1.						theCount < fLinks size ifTrue: [newTopX _ newTopX + 28]]]].	bLinks size > 0		ifTrue: 			[theCount _ 0.			bLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopX _ self											setAcrossViewForBackElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: aBoxAddr  to: eachElem]]]].						theCount _ theCount + 1.						theCount < bLinks size ifTrue: [newTopX _ newTopX + 28]]]].	fLinks size > 0 | (bLinks size > 0) ifTrue:[newTopX ~= topX ifTrue: [aBoxView changeBoxAt: aBoxAddr to: ((topX + (newTopX - topX // 2)) @ topY extent: theLabelForm extent)]].	newTopX _ newTopX + theLabelForm width.	"remember the highest x and y positions"	anElement clearFlag.	newTopX > aBoxView xSize ifTrue: [aBoxView xSize: newTopX].	newTopY > aBoxView ySize ifTrue: [aBoxView ySize: newTopY].	^newTopX!setUpViewForBackElement: anElement followingForward: fType backward: bType inCenter: center with: topX and: topY in: aBoxView on: aBoxModel connectTo: boxAddr	| newTopX newTopY aBoxAddr theCount theLabelForm fLinks bLinks presentElement |	newTopY _ topY.	newTopX _ topX.	anElement setFlag.	1 to: aBoxModel size do: [:each | anElement == (aBoxModel at: each)			ifTrue: 				[boxAddr = 0 ifFalse: [aBoxView addConnectionFrom: boxAddr to: each].				anElement clearFlag.				^newTopY]].	aBoxModel add: anElement.	fType class == Array 		ifTrue:[fLinks_ OrderedCollection new. 			fType do: [:each | fLinks addAll: (anElement fPointersOfType: each)]] 		ifFalse: [fLinks _ anElement fPointersOfType: fType].	bType class == Array 		ifTrue:[bLinks_ OrderedCollection new. 			bType do: [:each | bLinks addAll: (anElement bPointersOfType: each)]] 		ifFalse: [bLinks _ anElement bPointersOfType: bType].	"produce the box and label for this node"	aBoxView infoCentLabelList add: anElement iconDisplayString.	theLabelForm _ self formFor: anElement.	aBoxView labelList add: theLabelForm.	aBoxView addBox: (newTopX @ newTopY extent: theLabelForm extent).	boxAddr ~= 0 ifTrue: [aBoxView addConnectionFrom: boxAddr to: aBoxView boxList size].	aBoxAddr _ aBoxView boxList size.	newTopX _ newTopX + (theLabelForm width + 70).	Level < newTopX ifTrue: [Level _ newTopX].	fLinks size > 0		ifTrue: 			[theCount _ 0.			fLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopY _ self											setUpViewForElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: eachElem to: aBoxAddr]]]].						theCount _ theCount + 1.						theCount < fLinks size ifTrue: [newTopY _ newTopY + 28]]]].	bLinks size > 0		ifTrue: 			[theCount _ 0.			bLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopY _ self											setUpViewForBackElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: aBoxAddr  to: eachElem]]]].						theCount _ theCount + 1.						theCount < bLinks size ifTrue: [newTopY _ newTopY + 28]]]].	newTopY ~= topY ifTrue: [aBoxView changeBoxAt: aBoxAddr to: (topX @ (topY + (newTopY - topY // 2)) extent: theLabelForm extent)].	"remember the highest x and y positions"	anElement clearFlag.	newTopX > aBoxView xSize ifTrue: [aBoxView xSize: newTopX].	newTopY > aBoxView ySize ifTrue: [aBoxView ySize: newTopY].	^newTopY!setUpViewForElement: anElement followingForward: fType backward: bType inCenter: center with: topX and: topY in: aBoxView on: aBoxModel connectTo: boxAddr 	| newTopX newTopY aBoxAddr theCount theLabelForm fLinks bLinks presentElement |	newTopY _ topY.	newTopX _ topX.	anElement setFlag.	1 to: aBoxModel size do: [:each | anElement == (aBoxModel at: each)			ifTrue: 				[boxAddr = 0 ifFalse: [aBoxView addConnectionFrom: each to: boxAddr].				anElement clearFlag.				^newTopY]].	aBoxModel add: anElement.	fType class == Array 		ifTrue:[fLinks_ OrderedCollection new. 			fType do: [:each | fLinks addAll: (anElement fPointersOfType: each)]] 		ifFalse: [fLinks _ anElement fPointersOfType: fType].	bType class == Array 		ifTrue:[bLinks_ OrderedCollection new. 			bType do: [:each | bLinks addAll: (anElement bPointersOfType: each)]] 		ifFalse: [bLinks _ anElement bPointersOfType: bType].	"produce the box and label for this node"	aBoxView infoCentLabelList add: anElement iconDisplayString.	theLabelForm _ self formFor: anElement.	aBoxView labelList add: theLabelForm.	aBoxView addBox: (newTopX @ newTopY extent: theLabelForm extent).	boxAddr ~= 0 ifTrue: [aBoxView addConnectionFrom: aBoxView boxList size to: boxAddr].	aBoxAddr _ aBoxView boxList size.	newTopX _ newTopX + (theLabelForm width + 70).	Level < newTopX ifTrue: [Level _ newTopX].	fLinks size > 0		ifTrue: 			[theCount _ 0.			fLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopY _ self											setUpViewForElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: eachElem to: aBoxAddr]]]].						theCount _ theCount + 1.						theCount < fLinks size ifTrue: [newTopY _ newTopY + 28]]]].	bLinks size > 0		ifTrue: 			[theCount _ 0.			bLinks do: [:key | (center okToFoolWith: (center fileCabinet at: (key at: 3)))					ifTrue: 						[(presentElement _ center fileCabinet at: (key at: 3)) isFlagSet not							ifTrue: [newTopY _ self											setUpViewForBackElement: presentElement											followingForward: fType											backward: bType											inCenter: center											with: newTopX											and: newTopY											in: aBoxView											on: aBoxModel											connectTo: aBoxAddr]							ifFalse: [1 to: aBoxModel size do: [:eachElem |									 presentElement == (aBoxModel at: eachElem) 										ifTrue: [boxAddr = 0 											ifFalse: [aBoxView addConnectionFrom: aBoxAddr  to: eachElem]]]].						theCount _ theCount + 1.						theCount < bLinks size ifTrue: [newTopY _ newTopY + 28]]]].	newTopY ~= topY ifTrue: [aBoxView changeBoxAt: aBoxAddr to: (topX @ (topY + (newTopY - topY // 2)) extent: theLabelForm extent)].	"remember the highest x and y positions"	anElement clearFlag.	newTopX > aBoxView xSize ifTrue: [aBoxView xSize: newTopX].	newTopY > aBoxView ySize ifTrue: [aBoxView ySize: newTopY].	^newTopY! !!StandardSystemView class methodsFor: 'instance creation'!model: aModel label: labelText minimumSize: minimumSize helpIndex: symbol	| view |	view _ self new.	view model: aModel.	view label: labelText.	view minimumSize: minimumSize.	view borderWidth: 1.	view helpIndex: symbol.	^view! !!StandardSystemView class methodsFor: 'label access'!labelTag	^LabelTag!labelTag: aString	LabelTag _ aString! !!NotifierView class methodsFor: 'instance creation'!reportContext: haltContext	| ans f | 	"Getting ready to report error. Prompt user for input and append user input, the stack to a file."	(self confirm: 'Do you want to generate error report?')		ifTrue: [f _ (FileStream fileNamed: 'AnalystError.log') readWrite.				f setToEnd.				ans _ FillInTheBlank request: 'Please describe your actions before this error occured. Thank you.' initialAnswer: String new.				Cursor write showWhile: [				f nextPutAll: 'user: ', UserProfile current userName, (String with: Character tab), Time dateAndTimeNow printString, (String with: Character cr), 'comments: ', ans, (String with: Character cr), 'Stack: '.				haltContext stack do:					[:i | f nextPutAll: (String with: Character cr), i printString].				f nextPutAll: '-------------------------------------'.				f close]].	ScheduledControllers searchForActiveController! !!ClockView class methodsFor: 'initialize'!initialize	"ClockView initialize"	| text |	NumberForms _ Array new: 12.	1 to: 12 do:		[:number |		text _ number printString asText.		text emphasizeFrom: 1 to: text size with: 35.		NumberForms at: number put: text asParagraph asForm].	QuickScanner _ FastTextDisplayScanner new.	FontNum _ TextStyle getNumForStrikeFont: 'TimesRoman12B'.	self timeZonePopUpFromConfigFile!open	"ClockView open"		ClockView open: 160.!open: aSize	"ClockView open"	| clockView holder choice labelSize labelX labelExtent |	clockView _ self new.	clockView borderWidth: 2.	clockView insideColor: Form white.	((TimeZones at: 1) isEmpty) | (((TimeZones at: 1) size) ~= ((TimeZones at: 2) size))		ifTrue: [^ self booboo:'I have no timezone information.  Please edit the timezone list.']		ifFalse:[choice _ ((ScrollMenu new: 8 on: (TimeZones at: 1)) startUp: #anyButton).				choice isNil ifFalse:						[labelSize _ QuickScanner widthOfString: ((TimeZones at: 1) at: choice) asString emphasis: FontNum.						labelX _ 175 max: (labelSize + 10).						labelExtent _ Point x: labelX y: 28.						clockView minimumSize: labelX @ aSize.						clockView maximumSize: labelX @ aSize.						clockView clockLabel: ((TimeZones at: 1) at: choice).						clockView timeZone: ((TimeZones at: 2) at: choice).						clockView labelFrame: (Quadrangle origin: 0@0 corner: labelExtent).						clockView controller open]]! !!ClockView class methodsFor: 'private'!timeZonePopUpFromConfigFile	"get the time zones from config file. If are none, then add the default ones"	| labelCollection timeZoneCollection aString readStream timeZoneString |	labelCollection _ OrderedCollection new.	timeZoneCollection _ OrderedCollection new.	timeZoneString _ ConfigFile currentUserConfig getSection: #TimeZones.	timeZoneString == nil ifFalse:		[readStream _ ReadStream on: timeZoneString from: 1 to: timeZoneString size.		aString _ (readStream upTo: $*).		[readStream atEnd] whileFalse:			[labelCollection add: ((readStream upTo: $,) asSymbol).			 timeZoneCollection add: ((readStream upTo: (Character cr)) asNumber).			 aString _ (readStream upTo: $*)]].	TimeZones _ Array with: labelCollection with: timeZoneCollection! !!DigitalClockView class methodsFor: 'open'!open	"DigitalClockView open"	DigitalClockView open: 56! !!ContainerListView class methodsFor: 'instance creation'!new	| aView |	aView _ super new.	aView hasChanged: false.	^aView! !DReportListView class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DReportListView class methodsFor: 'instance creation'!new	^super new listTitle: 'REPORTS'! !OutlineView class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!OutlineView class methodsFor: 'instance creation'!createAnalystDataItem: tempItem	"Create a new Analyst data item file. This differs from the default in order to not allow setting of class" 	| return filename | 	return _ InformationCenter getNewKeyFor: tempItem withKeywords: String new dBoxTitle: 'Create new ', tempItem label askClass: false.	return == nil ifTrue: [^nil].	Cursor wait showWhile: 		[filename _ Disk makeNewFileName: (return at: 1) withSuffix: (DataMaster giveMe: #suffixString for: tempItem label).		(HeaderFileStream fileNamed: filename) readWrite; writeHeaderLabel: (return at: 1) class: (return at: 3) mods: (return at: 4) dataType: (DataMaster giveMe: #iconIndex for: filename)].	^Array with: return with: filename!hardcopyWithSuitcase: aSuitcase	| aOutlineList answers maxItem newSuitcase pvFileName | 	aOutlineList _ OutlineList on: aSuitcase dataItem filename withKey: String new.	(answers _ aOutlineList getQBoxOptions: 'Print Options' printing: true) == nil		ifTrue: [aOutlineList release. ^nil].	maxItem _ aOutlineList isUserGuide		ifTrue: [aSuitcase dataItem copy]		ifFalse: [aSuitcase dataItem copy changeClassAndModifier: (Array with: (answers at: (answers size - 1)) with: (answers at: answers size))].	(answers size > 1 and: [(answers at: 2) == #Preview])		ifTrue: [maxItem _ (DataItem locked: maxItem isLocked classification: maxItem classification modifiers: maxItem modifiers type: (DataItem typeIndexFor: #Item) label: aOutlineList thisLabel filename: nil bPointers: nil fPointers: nil atIndex: 0).				pvFileName _ aOutlineList previewTextUnder: maxItem heading: (answers at: 1) landscape: ((answers at: 3) == #Landscape).				pvFileName == nil					ifFalse: [maxItem filename: pvFileName.							newSuitcase _ Suitcase new packTheSuitcaseFrom: aSuitcase centerName forItem: maxItem.							aOutlineList release.							PreviewPageView openWithSuitcase: newSuitcase]]		ifFalse: [newSuitcase _ Suitcase new packTheSuitcaseFrom: aSuitcase centerName forItem: maxItem.				aOutlineList directHardcopyUnder: maxItem heading: (answers at: 1) class: maxItem hardcopyString withSuitcase: newSuitcase.				aOutlineList release]!openUserGuideWithKey: searchString	"if searchString is nil, just open it; otherwise, look for searchString and only open it if find it"	Cursor execute show.	ScheduledControllers scheduledControllers do: [:each |	((each isKindOf: StandardSystemController) and: [each view label = 'User Reference Manual'])		ifTrue: [searchString == nil ifFalse:					[each model key: searchString; selectKey.					each model listIndex = 0						ifTrue: [^self booboo: 'The reference manual shows no references to: ', searchString]].				each centerCursorInView.				ScheduledControllers unschedule: each.				ScheduledControllers scheduleActive: each]].	self openWithSuitcase: ((Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem type: #Item label: 'User Reference Manual' filename: self userGuideName atIndex: 0)) searchString: searchString)!openWithSuitcase: aSuitcase 	| theModel anOutlineListView topView |	theModel _ OutlineList on: aSuitcase dataItem filename withKey: aSuitcase searchString.	(anOutlineListView _ self new) model: theModel;		setupList: theModel treeList;		borderWidth: 1.	(topView _ StandardSystemView new)		model: theModel;		addSubView: anOutlineListView;		borderWidth: 1;		minimumSize: 300 @ 150;		helpIndex: #Outline.	theModel isUserGuide		ifTrue: [anOutlineListView controller: ChapterController new]		ifFalse: [aSuitcase changeClassification: theModel root.				aSuitcase dataItem label: theModel root label.				aSuitcase accept.				topView controller: StandardSystemController new].	topView label: aSuitcase dataItem label;		classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.	topView controller open!userGuideName	^'ReferenceManual.manual'! !DFieldListView class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DFieldListView class methodsFor: 'instance creation'!new	^super new listTitle: 'FIELDS'! !DataListView class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!DHitListView class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DHitListView class methodsFor: 'instance creation'!new	^super new listTitle: 'HITS'! !DQueryListView class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DQueryListView class methodsFor: 'instance creation'!new	^super new listTitle: 'QUERIES'! !PreviewTabView class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewTabView class methodsFor: 'initialization'!initialize	"PreviewTabView initialize"	MyCharacterScanner _ FastTextDisplayScanner new.	Rulers _ Array new: 4.	1 to: Rulers size do: [:i | Rulers at: i put: (self initializeRulerIndexed: i)].	self initializeTabForms!initializeRulerIndexed: unitIndex	"tabs is in micas units. rulerUnit is either inch or centimeters or picas."	| origin pos marginRect rulerRect basicUnit accumTotal noOfRepeats unitsPerLong longUnit mediumsPerLong mediumUnit numIndex medTotal shortTotal numPara aWidth longBar mediumBar shortBar aForm |  	aWidth _ 754.	aForm _ Form extent: (aWidth@52).	longBar _ Quadrangle new				region: (0@0 extent: (1@10))				borderWidth: 0				borderColor: Form black				insideColor: Form black.	mediumBar _ Quadrangle new				region: (0@0 extent: (1@7))				borderWidth: 0				borderColor: Form black				insideColor: Form black.	shortBar _ Quadrangle new				region: (0@0 extent: (1@4))				borderWidth: 0				borderColor: Form black				insideColor: Form black.	marginRect	_ Quadrangle new		region: (6@0 extent: aWidth @ 20)		borderWidth: 0		borderColor: Form black		insideColor: Form darkGray.	rulerRect	_ Quadrangle new		region: (marginRect bottomLeft + (0@30) extent: aWidth@2)		borderWidth: 0		borderColor: Form black		insideColor: Form black.	marginRect displayOn: aForm.	rulerRect displayOn: aForm.	basicUnit _ #(72 28 12 1) at: unitIndex.	unitsPerLong _ #(1 5 6 50) at: unitIndex.	longUnit _ basicUnit * unitsPerLong.	mediumsPerLong _ #(4 5 6 5) at: unitIndex.	mediumUnit _ longUnit/mediumsPerLong.	accumTotal _ 0.	numIndex _ 0.	noOfRepeats _ aWidth//longUnit.	origin _ rulerRect origin.	0 to: noOfRepeats - 1 do: [:i |		numPara _ numIndex printString asParagraph.		numPara displayOn: aForm at: (marginRect bottomLeft + (accumTotal@1) - ((numPara compositionRectangle width // 2) @ 0)).		pos _ origin + (accumTotal@0).		(longBar align: longBar bottomLeft with: pos) displayOn: aForm.		medTotal _ mediumUnit.		shortTotal _ medTotal/2.		1 to: mediumsPerLong - 1 do: [:j |			(mediumBar align: mediumBar bottomLeft with: (pos + (medTotal@0))) displayOn: aForm.			(shortBar align: shortBar bottomLeft with: (pos + (shortTotal@0))) displayOn: aForm.			medTotal _ medTotal + mediumUnit.			shortTotal _ shortTotal + mediumUnit.].		(shortBar align: shortBar bottomLeft with: (pos + (shortTotal@0))) displayOn: aForm.		accumTotal _ accumTotal + longUnit.		numIndex _ numIndex + unitsPerLong].	numPara _ numIndex printString asParagraph.	numPara displayOn: aForm at: (marginRect bottomLeft + (accumTotal@1) - ((numPara compositionRectangle width // 2) @ 0)).	pos _ origin + (accumTotal@0).	(longBar align: longBar bottomLeft with: pos) displayOn: aForm.	medTotal _ mediumUnit.	shortTotal _ medTotal/2.	mediumsPerLong _ mediumsPerLong min: ((rulerRect right - pos x + mediumUnit)//mediumUnit).	1 to: mediumsPerLong - 1 do: [:j |		(mediumBar align: mediumBar bottomLeft with: (pos + (medTotal@0))) displayOn: aForm.		(shortBar align: shortBar bottomLeft with: (pos + (shortTotal@0))) displayOn: aForm.		medTotal _ medTotal + mediumUnit.		shortTotal _ shortTotal + mediumUnit.].	pos x + shortTotal <= rulerRect right		ifTrue: [(shortBar align: shortBar bottomLeft with: (pos + (shortTotal@0))) displayOn: aForm].	^BitBlt new		destForm: Display;		combinationRule: Form over;		sourceX: 0; sourceY: 0;		clipX: 0; clipY: 0;		clipWidth: 10000; clipHeight: 10000;		sourceForm: aForm;		width: aForm width; height: aForm height;		yourself!initializeTabForms	| i | 	"PreviewTabView initializeTabForms"	i _ 0.	TabCursorArray _ Array new: 4.	TabBarArray _ Array new: 4.	#(#leftTabCursor #centerTabCursor #rightTabCursor #decimalTabCursor) do: [:msg |		i _ i + 1.		TabCursorArray at: i put: (self perform: msg).		TabBarArray at: i			put: (BitBlt new				destForm: Display;				sourceForm: (TabCursorArray at: i);				combinationRule: Form under;				sourceX: 0; sourceY: 0;				clipX: 0; clipY: 0;				clipWidth: 10000; clipHeight: 10000;				width: 16; height: 12)].	TabIndex _ 1.	TabBar _ TabBarArray at: TabIndex.	TabCursor _ TabCursorArray at: TabIndex! !!PreviewTabView class methodsFor: 'cursors'!centerTabCursor	"PreviewTabView centerTabCursor showWhile: [Sensor waitButton]"	^Cursor extent: 16@16 fromArray: #(2r00000001000000002r00000011100000002r00000011100000002r00000111110000002r00000111110000002r00001101011000002r00000001000000002r00000001000000002r00000001000000002r00000001000000002r00000001000000002r00001111111000002r00000000000000002r00000000000000002r00000000000000002r0000000000000000) offset: -7@0!decimalTabCursor	"PreviewTabView decimalTabCursor showWhile: [Sensor waitButton]"	^Cursor extent: 16@16 fromArray: #(2r00000001000000002r00000011100000002r00000011100000002r00000111110000002r00000111110000002r00001101011000002r00000001000000002r00000001000000002r00000001000000002r00000011100000112r00000011100000112r00000011100000002r00000000000000002r00000000000000002r00000000000000002r0000000000000000) offset: -7@0!leftTabCursor	"PreviewTabView leftTabCursor showWhile: [Sensor waitButton]"	^Cursor extent: 16@16 fromArray: #(2r00000001000000002r00000011100000002r00000011100000002r00000111110000002r00000111110000002r00001101011000002r00000001000000002r00000001000000002r00000001000000002r00000001000000002r00000001000000002r00000001111100002r00000000000000002r00000000000000002r00000000000000002r0000000000000000) offset: -7@0!rightTabCursor	"PreviewTabView rightTabCursor showWhile: [Sensor waitButton]"	^Cursor extent: 16@16 fromArray: #(2r00000001000000002r00000011100000002r00000011100000002r00000111110000002r00000111110000002r00001101011000002r00000001000000002r00000001000000002r00000001000000002r00000001000000002r00000001000000002r00011111000000002r00000000000000002r00000000000000002r00000000000000002r0000000000000000) offset: -7@0! !!PreviewTabView class methodsFor: 'instance creation'!createFormOn: tabsArray at: aPoint width: aWidth rulerUnit: rulerUnit tabConversion: s	| aTabView | 	"tabsArray is an array of two elements, the first - an array of integers in micas units, the second - an array of integers ranging from 1 to 4 representing left, center, right and decimal tab. rulerUnit is either inch or centimeters or picas."	aTabView _ self new.	aTabView borderWidth: 0.	aTabView window: (0@0 extent: aWidth@144)		viewport: (aPoint extent: aWidth@144).	aTabView model: nil;		returnTabs: tabsArray;		tabs: tabsArray first copy;		tabTypes: tabsArray last copy;		scale: s;		unitIndex: (#(inch cm picas points) indexOf: rulerUnit).	^aTabView createTabs!openOn: tabsArray at: aPoint width: aWidth rulerUnit: rulerUnit tabConversion: s	| aTabView | 	"tabsArray is an array of two elements, the first - an array of integers in micas units, the second - an array of integers ranging from 1 to 4 representing left, center, right and decimal tab. rulerUnit is either inch or centimeters or picas."	aTabView _ self new.	aTabView borderWidth: 0.	aTabView window: (0@0 extent: aWidth@144)		viewport: (aPoint extent: aWidth@144).	aTabView model: nil;		returnTabs: tabsArray;		tabs: tabsArray first copy;		tabTypes: tabsArray last copy;		scale: s;		unitIndex: (#(inch cm picas points) indexOf: rulerUnit).	^aTabView! !!PreviewTabView class methodsFor: 'accessing'!rulers	^Rulers!tabBarArray	^TabBarArray! !!BinaryChoiceView class methodsFor: 'instance creation'!openBooBooOn: aBinaryChoice message: messageString displayAt: originPoint centered: centered	"Answer an instance of me that displays aSingleChoice asking the question	messageString.  If the argument centered, a Boolean, is false, display the instance	with top left corner at originPoint;  otherwise, display it with its center at	originPoint.  If necessary, translate so the view is completely on the screen.	Do not schedule, rather take control immediately and insist that the user respond."	| topView messageView switchView savedArea |	messageView _ DisplayTextView new model: messageString asDisplayText.	messageView insideColor: Form white.	messageView controller: NoController new.	messageView centered.	switchView _ 		self buildSingleSwitchFor: aBinaryChoice width: messageView window width.	topView _ self new model: aBinaryChoice.	topView addSubView: messageView.	topView addSubView: switchView below: messageView.	topView		align: (centered				ifTrue: [switchView viewport center]				ifFalse: [topView viewport topLeft])		with: originPoint.	topView borderWidth: 2.	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	topView insideColor: Form white.	savedArea _ Form fromDisplay: topView displayBox.	topView display.	topView controller startUp.	topView release.	savedArea displayOn: Display at: topView viewport topLeft!openBooBooOn: aBinaryChoice message: messageString displayAt: originPoint centered: centered yesLabel:yesString noLabel:noString	"Answer an instance of me that displays aBinaryChoice asking the question	messageString.  If the argument centered, a Boolean, is false, display the instance	with top left corner at originPoint;  otherwise, display it with its center at	originPoint.  If necessary, translate so the view is completely on the screen.	Do not schedule, rather take control immediately and insist that the user respond."	| topView messageView switchView savedArea |	messageView _ DisplayTextView new model: messageString asDisplayText.	messageView insideColor: Form white.	messageView controller: NoController new.	messageView centered.	switchView _ 		self buildSwitchesFor: aBinaryChoice width: messageView window width yesLabel:yesString noLabel:noString.	topView _ self new model: aBinaryChoice.	topView addSubView: messageView.	topView addSubView: switchView below: messageView.	topView		align: (centered				ifTrue: [switchView viewport center]				ifFalse: [topView viewport topLeft])		with: originPoint.	topView borderWidth: 2.	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	topView insideColor: Form white.	savedArea _ Form fromDisplay: topView displayBox.	topView display.	topView controller startUp.	topView release.	savedArea displayOn: Display at: topView viewport topLeft! !!BinaryChoiceView class methodsFor: 'private'!buildSingleSwitchFor: aBinaryChoice	width: anInteger	|switchView yesSwitchView|	switchView _ View new model: aBinaryChoice.	switchView controller: BinaryChoiceController new.	yesSwitchView _ SwitchView new model: aBinaryChoice.	yesSwitchView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.	yesSwitchView selector: #active.	yesSwitchView controller selector: #selectTrue.	yesSwitchView label: 'click mouse here please' asParagraph.	yesSwitchView window: (0@0 extent: anInteger @ yesSwitchView window height).	switchView addSubView: yesSwitchView.	switchView borderWidthLeft: 0 right: 0 top: 0 bottom: 0.	^switchView!buildSwitchesFor: aBinaryChoice	width: anInteger yesLabel:yesString noLabel:noString	|switchView yesSwitchView noSwitchView|	switchView _ View new model: aBinaryChoice.	switchView controller: BinaryChoiceController new.	yesSwitchView _ SwitchView new model: aBinaryChoice.	yesSwitchView borderWidthLeft: 0 right: 2 top: 0 bottom: 0.	yesSwitchView selector: #active.	yesSwitchView controller selector: #selectTrue.	yesSwitchView label: yesString asParagraph.	yesSwitchView window: (0@0 extent: anInteger//2 @ yesSwitchView window height).	noSwitchView _ SwitchView new model: aBinaryChoice.	noSwitchView selector: #active.	noSwitchView controller selector: #selectFalse.	noSwitchView label: noString asParagraph.	noSwitchView window: (0@0 extent: anInteger//2 @ noSwitchView window height).	switchView addSubView: yesSwitchView.	switchView addSubView: noSwitchView toRightOf: yesSwitchView.	switchView borderWidthLeft: 0 right: 0 top: 2 bottom: 0.	^switchView! !SpreadsheetView class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SpreadsheetView class methodsFor: 'class initialization'!initialize	"this method produces the Arrow form for generating the window""	SpreadsheetView initialize.	"	| arrow bits clip |	bits _ Array new: 14.	bits at:  1 put: 2r00000100000.	bits at:  2 put: 2r00001110000.	bits at:  3 put: 2r00011111000.	bits at:  4 put: 2r00111111100.	bits at:  5 put: 2r01111111110.	bits at:  6 put: 2r11111111111.	bits at:  7 put: 2r00011111000.	bits at:  8 put: 2r00011111000.	bits at:  9 put: 2r00011111000.	bits at: 10 put: 2r00011111000.	bits at: 11 put: 2r00011111000.	bits at: 12 put: 2r00011111000.	bits at: 13 put: 2r00011111000.	bits at: 14 put: 2r00011111000.	arrow _ Form extent: 16 @ 14 fromArray: bits offset: 0 @ 0.	ArrowForm _ Form extent: 30 @ 30.	clip _ ArrowForm boundingBox.	arrow		displayOn: ArrowForm		at: 5 @ 2		clippingBox: clip		rule: Form under		mask: nil.	(arrow rotateBy: 1)		displayOn: ArrowForm		at: 15 @ 5		clippingBox: clip		rule: Form under		mask: nil.	(arrow rotateBy: 2)		displayOn: ArrowForm		at: 10 @ 15		clippingBox: clip		rule: Form under		mask: nil.	(arrow rotateBy: 3)		displayOn: ArrowForm		at: 2 @ 10		clippingBox: clip		rule: Form under		mask: nil.	ArrowForm borderWidth: 1.! !!SpreadsheetView class methodsFor: 'instance creation'!createAnalystDataItem: tempItem	"Create a new Analyst data item file for a Spreadsheet" 	| return suffixString ssLabel | 	return _ InformationCenter getNewKeyFor: tempItem withKeywords: String new dBoxTitle: 'Create new ', tempItem label askClass: true.	return == nil ifTrue: [^nil].	suffixString _ DataMaster giveMe: #suffixString for: tempItem label.	return at: 1 put: (ssLabel _ (return at: 1) asFileName).	(self getOldFileName: ssLabel, suffixString) == nil		ifFalse: [self booboo: ssLabel, ' already exists'. ^ nil].	Cursor wait showWhile: 		[(HeaderFileStream fileNamed: ssLabel, suffixString) readWrite; writeHeaderLabel: ssLabel class: (return at: 3) mods: (return at: 4) dataType: (DataMaster giveMe: #iconIndex for: #ss)].	^Array with: return with: ssLabel, suffixString!open: rows by: columns 	"Open a SpreadsheetView on a new holder." 	SpreadsheetView open: rows by: columns on: nil	"SpreadsheetView open: 20 by: 6"!open: rows by: columns label: labelString	"Open a SpreadsheetView on a stored holder." 	self open: rows by: columns on: nil label: labelString!open: rows by: columns on: holder	"Open a SpreadsheetView on a stored holder." 	self open: rows by: columns on: holder label: String new!open: rows by: columns on: holder label: labelString	"Open a SpreadsheetView on a stored holder." 	self open: rows by: columns on: holder label: labelString default: 'SSFile.ss'!open: rows by: columns on: holder label: labelString default: aFileName	"Open a SpreadsheetView on a stored holder." 	self open: rows by: columns on: holder label: labelString default: aFileName suitcase: nil!open: rows by: columns on: holder label: labelString default: aFileName suitcase: aSuitcase	"Open a SpreadsheetView on a stored holder." 	| aSpreadsheetView aDisplayModeView aPointModeView aInputView topView viewRect spreadsheetModel anUpdateModeView |	"create the spreadsheet model on the stored holder"	spreadsheetModel _ holder == nil		ifTrue: [SpreadsheetHolder new: rows by: columns]		ifFalse: [holder].	spreadsheetModel allHolders at: (aFileName copyFrom: 1 to: aFileName size - 3) asUppercase put: spreadsheetModel.	spreadsheetModel fileName: (aFileName copyFrom: 1 to: aFileName size - 3).	"create the view"	viewRect _ 0@0 			corner: (spreadsheetModel xGrid at: spreadsheetModel xGrid size)					@ (spreadsheetModel yGrid at: spreadsheetModel yGrid size) + 30.	(aSpreadsheetView _ self new)		offsetPoint: 1@1;		controller: (SpreadsheetController new saveFile: aFileName);		model: spreadsheetModel;		insideColor: Form white;		borderWidth: 1;		window: (0@0 corner: 600 @ 218).	spreadsheetModel view: aSpreadsheetView; controller: aSpreadsheetView controller.		aDisplayModeView _ self createDisplayModeView.	anUpdateModeView _ self createUpdateModeView.	aPointModeView _ self createPointModeView.	(aInputView _ StringHolderView new)		model: (StringHolder new contents: String new);		controller: CellStringHolderController new;		insideColor: Form white;		borderWidth: 1;		window: (0@0 corner: 600 @ 22).	(aSpreadsheetView controller)		checkCopyBuffer;		displayModeView: aDisplayModeView;		updateModeView: anUpdateModeView;		pointModeView: aPointModeView;		inputView: aInputView.	(aInputView controller)		spreadsheetView: aSpreadsheetView;		updateModeView: anUpdateModeView;		displayModeView: aDisplayModeView;		pointModeView: aPointModeView.	aDisplayModeView model addDependent: aInputView controller.	(topView _ StandardSystemView new)		controller: StandardSystemSpreadsheetController new;		model: aSpreadsheetView model;		label: 'Spreadsheet ', labelString;		insideColor: Form black;		borderWidth: 1;		addSubView: aSpreadsheetView;		addSubView: aDisplayModeView below: aSpreadsheetView;		addSubView: aPointModeView toRightOf: aDisplayModeView;		addSubView: anUpdateModeView toRightOf: aPointModeView;		addSubView: aInputView below: aDisplayModeView;		minimumSize: 400@200;		helpIndex: #Spreadsheet.	aSuitcase == nil ifFalse:		[topView classifyLabel: aSuitcase classification.		topView addDependent: aSuitcase].	topView controller open!openOnFile: aFileName 	"open a spreadsheet on stored data" 	"SpreadsheetView openOnFile: 'Spam.Sheet'"	self openOnFile: aFileName label: aFileName!openOnFile: aFileName label: aString 	"open a spreadsheet on stored data"	"SpreadsheetView openOnFile: 'Spam.Sheet' label: 'Spam'"	self openOnFile: aFileName label: aString suitcase: nil!openOnFile: aFileName label: aString suitcase: aSuitcase	"open a spreadsheet on stored data"	"SpreadsheetView openOnFile: 'Spam.Sheet' label: 'Spam'"	| holder size label theRightOne theFileStream |	((Disk includesKey: aFileName) and:			[theFileStream _ (MixedFileStream fileNamed: aFileName) readOnly.			size _ theFileStream size.			theFileStream close.			size > 0])		ifTrue: 			[((SpreadsheetHolder allSheets includesKey: aString asUppercase) and: [(SpreadsheetHolder allSheets at: aString asUppercase) class ~= Dictionary])				ifTrue: 					[Project top projectWindows scheduledControllers do: [:each | (each isKindOf: StandardSystemSpreadsheetController)							ifTrue: [each view label = ('Spreadsheet ' , aString)ifTrue: [theRightOne _ each]]].					theRightOne centerCursorInView.					ScheduledControllers activeController under.					ScheduledControllers unschedule: theRightOne.					ScheduledControllers scheduleActive: theRightOne].			theFileStream _ MixedFileStream fileNamed: aFileName.			aSuitcase == nil ifFalse: [aSuitcase updateFromHeaderIn: theFileStream].			theFileStream reset.			holder _ SpreadsheetHolder readFrom: theFileStream.			self				open: holder rows				by: holder columns				on: holder				label: aString				default: aFileName				suitcase: aSuitcase]		ifFalse: 			[size _ DBoxView						openFor: #(fill fill )						title: 'Enter Spreadsheet Dimensions'						labels: #((rows ) (columns ) )						defaults: #('20' '20' )						autoAccept: true.			size == nil ifFalse: [self					open: (size at: 1) asNumber					by: (size at: 2) asNumber					on: nil					label: aString					default: aFileName					suitcase: aSuitcase]]!openWithSuitcase: aSuitcase 	"open a spreadsheet on stored data"	self openOnFile: aSuitcase dataItem filename label: aSuitcase dataItem label suitcase: aSuitcase! !!SpreadsheetView class methodsFor: 'private'!createDisplayModeView	| aDisplayModeView |	(aDisplayModeView _ LabelSwitchView new)		model: (LabelSwitch new			labels: #('value' 'rule' 'label')			selectors: #(value rule label));		borderWidth: 1;		window: (0@0 corner: 200@10).	^aDisplayModeView!createPointModeView	| aPointModeView |	(aPointModeView _ LabelSwitchView new)		model: (LabelSwitch new			labels: #('absolute' 'relative')			selectors: #(absolute relative));		borderWidth: 1;		window: (0@0 corner: 200@10).	^aPointModeView!createUpdateModeView	| anUpdateModeView |	(anUpdateModeView _ LabelSwitchView new)		model: (LabelSwitch new			labels: #('auto update' 'no updates')			selectors: #(update noUpdate));		borderWidth: 1;		window: (0@0 corner: 200@10).	^anUpdateModeView! !!FormsView class methodsFor: 'instance creation'!openControlPanel	"FormsView openControlPanel."	self openPanelOn: FormsModel controlPanel backgroundColor: Form lightGray!openOn: anArray	self		openOn: anArray		backgroundColor: Form white!openOn: formsModel backgroundColor: backgroundColor	"Open an instance of me with the model and controller specified in anArray,	and with the specified background color."	| formsController formsView topView borderWidth boundingBox size |	formsController _ FormsController new.	formsModel resetState.	formsModel updateControllers: formsController.	borderWidth _ 2.	boundingBox _ formsModel boundingBox.	size _ boundingBox extent + (boundingBox origin * 2) + (borderWidth * 2).	formsView _ FormsView new.	formsView model: formsModel.	formsView controller: formsController.	formsView insideColor: backgroundColor.	formsView borderWidth: borderWidth.	topView _ StandardSystemView new.	topView label: formsModel name.	topView model: formsModel.	topView minimumSize: size.	topView maximumSize: size.	topView addSubView: formsView.	topView controller open!openOn: formsModel label: label suitcase: aSuitcase	"Open an instance of me with the model and controller specified in anArray,	and with the specified label and suitcase."	| formsController formsView topView borderWidth boundingBox size |	formsController _ FormsController new.	formsModel resetState.	formsModel updateControllers: formsController.	borderWidth _ 2.	boundingBox _ formsModel boundingBox.	size _ boundingBox extent + (boundingBox origin * 2) + (borderWidth * 2) + 5.	formsView _ FormsView new.	formsView model: formsModel.	formsView controller: formsController.	formsView insideColor: Form white.	formsView borderWidth: borderWidth.	topView _ StandardSystemView new.	topView label: label.	topView controller: ClassifiedStandardSystemController new.	topView model: formsModel.	topView minimumSize: size.	size x > 600 ifTrue:[topView maximumSize: size x @ 750] ifFalse:[	topView maximumSize: 600@750].	topView addSubView: formsView.	aSuitcase == nil ifFalse:		[topView classifyLabel: aSuitcase classification.		topView addDependent: aSuitcase].	topView controller open!openPanelOn: formsModel backgroundColor: backgroundColor	"Open an instance of me with the model and controller specified in anArray,	and with the specified background color."	| formsController formsView topView borderWidth boundingBox size |	formsController _ FormsController new.	formsModel resetState.	formsModel updateControllers: formsController.	borderWidth _ 2.	boundingBox _ formsModel boundingBox.	size _ boundingBox extent + (boundingBox origin * 2) + (borderWidth * 2).	formsView _ FormsView new.	formsView model: formsModel.	formsView controller: formsController.	formsView insideColor: backgroundColor.	formsView borderWidth: borderWidth.	topView _ StandardSystemView new.	topView label: nil.	topView model: formsModel.	topView minimumSize: size.	topView maximumSize: size.	topView addSubView: formsView.	topView controller open!openWithSuitcase: aSuitcase 	"Open an instance of me with data stored in the InformationCenter."	self		openOn: (FormsModel fromSuitcase: aSuitcase)		label: aSuitcase dataItem label		suitcase: aSuitcase! !!FormsView class methodsFor: 'editor creation'!openEditOn: formsModel backgroundColor: backgroundColor	"Open an instance of me with the model and controller specified in anArray,	and with the specified background color."	| formsController formsView topView borderWidth boundingBox size |	formsController _ FormsEditController new.	formsModel resetState.	formsModel updateControllers: formsController.	borderWidth _ 2.	boundingBox _ formsModel boundingBox.	size _ boundingBox extent + (boundingBox origin * 2) + (borderWidth * 2).	formsView _ FormsView new.	formsView model: formsModel.	formsView controller: formsController.	formsView insideColor: backgroundColor.	formsView borderWidth: borderWidth.	topView _ StandardSystemView new.	topView label: formsModel name.	topView model: formsModel.	topView minimumSize: size.	topView maximumSize: 600@750.	topView addSubView: formsView.	topView controller open!openEditor	"Open an instance of me with the model and controller specified in anArray,	and with the specified background color."	| formsController formsView topView borderWidth size formsModel |	formsController _ FormsEditController new.	formsModel _ FormsModel named: 'NewForm'.	formsModel updateControllers: formsController.	size _ 600@750.	formsView _ FormsView new.	formsView model: formsModel.	formsView controller: formsController.	formsView insideColor: Form white.	formsView borderWidth: 2.	topView _ StandardSystemView new.	topView label: formsModel name.	topView model: formsModel.	topView minimumSize: size.	topView maximumSize: size.	topView addSubView: formsView.	topView controller open!openEditorOn: aSuitcase	"Open an instance of me with the model and controller specified in anArray,	and with the specified background color."	| formsController formsView topView borderWidth size formsModel |	formsController _ FormsEditController new.	formsModel _ FormsModel named: 'NewForm'.	formsModel updateControllers: formsController.	size _ 600@750.	formsView _ FormsView new.	formsView model: formsModel.	formsView controller: formsController.	formsView insideColor: Form white.	formsView borderWidth: 2.	topView _ StandardSystemView new.	topView controller: ClassifiedStandardSystemController new.	topView label: aSuitcase dataItem label.	topView model: formsModel.	topView minimumSize: size.	topView maximumSize: size.	topView addSubView: formsView.	aSuitcase == nil ifFalse:		[topView classifyLabel: aSuitcase classification.		topView addDependent: aSuitcase].	topView controller open! !!FormsView class methodsFor: 'examples'!example	"FormsView example." 	self openOn: FormsModel example!openChangesPanel	"FormsView openChangesPanel."	self openPanelOn: FormsModel changesPanel backgroundColor: Form lightGray! !LabelSwitchView class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!PreviewPageView class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewPageView class methodsFor: 'instance creation'!createAnalystDataItem: tempItem	"Create the necessary files for a new empty Preview" 	| lkcm filename | 	lkcm _ InformationCenter getNewKeyFor: tempItem withKeywords: String new dBoxTitle: 'Create new ', tempItem label askClass: true.	lkcm == nil ifTrue: [^nil].	Cursor wait showWhile: 		[filename _ PreviewPage makeFileWithText: Text new annoDict: nil lkcm: lkcm portrait: (self confirm: 'Preview Orientation?' yesLabel: 'Portrait' noLabel: 'Landscape')].	^Array with: lkcm with: filename!hardcopyWithSuitcase: aSuitcase	| aPreview extent ans |  	aPreview _ PreviewPage newFrom: aSuitcase.	ans _ aPreview hardcopyOptions.	ans == nil		ifFalse: [aPreview retrieve; initializeFirstPage.				extent _ self pageSizeFrom: aSuitcase.				aPreview setRect: (0@0 extent: (extent - (4@4))).				aPreview recomposeAll.				aPreview hardcopy: ans].	aPreview release!openWithSuitcase: aSuitcase 	| topView aPreviewView size |	aPreviewView _ self new.	aPreviewView setPreview: aSuitcase.	aPreviewView borderWidth: 1.	topView _ StandardSystemView new.	topView model: aSuitcase controller: ClassifiedStandardSystemController new.	topView classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.	topView borderWidth: 1.	topView addSubView: aPreviewView.	topView label: aSuitcase dataItem label.	topView helpIndex: #Preview.	size _ self pageSizeFrom: aSuitcase.	topView maximumSize: size.	topView minimumSize: size.	topView controller open!pageSizeFrom: aSuitcase 	"2540/32.0*8 =8 inches screen printer unit"	^(aSuitcase dataItem filename findString: (DataMaster previewSuffixFor: #landscape) startingAt: 1) = 0		ifTrue: [635 @ 754] "8 x 9.5"	"for bigger window, try: 650@833"		ifFalse: [833 @ 556] "10.5 x 7"! !!QuerierView class methodsFor: 'private'!buildAnswerView: aQuerier frameWidth: widthInteger	| answerView |	answerView _ self new model: aQuerier.	answerView window: (0@0 extent: widthInteger @ 40).	answerView borderWidth: 2.	^answerView!buildMessageView: messageString	|  messageView  |	messageView _ DisplayTextView new model: messageString asDisplayText.	messageView borderWidthLeft: 2 right: 2 top: 2 bottom: 0.	messageView insideColor: Form white.	messageView controller: NoController new.	messageView window: (0@0 extent: (messageView window extent max: 200@30)).	messageView centered.	^messageView! !!QuerierView class methodsFor: 'instance creation'!openOn: aQuerier message: messageString	"Create and start up an instance of myself."	| topView messageView answerView savedArea |	messageView _ self buildMessageView: messageString.	answerView _ 		self buildAnswerView: aQuerier 			frameWidth: messageView window width.	topView _ View new model: aQuerier.	topView controller: BinaryChoiceController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: Sensor cursorPoint.	topView window: 		(0 @ 0 extent: 			messageView window width @ 			(messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	savedArea _ Form fromDisplay: topView displayBox.	topView display.	topView controller startUp.	topView release.	savedArea displayOn: Display at: topView viewport topLeft.	topView _ nil.! !FieldStringView class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!SharedObject class methodsFor: 'instance creation'!on: anObject	^self new setSharedObject: anObject! !!DBox class methodsFor: 'instance creation'!new	^super new initialize!type: aType description: string1 variable:string2 group: anInterval	"Answers a new instance of DBox whose variable is aVariable, type aType and description aString."	| aDBox |	(aDBox _ self new) type: aType; description: string1; variable: string2; initial: string2; group: anInterval.	^aDBox!type: aType description: string1 variable:string2 group: anInterval query: aQuery	"Answers a new instance of DBox whose variable is aVariable, type aType and description aString."	| aDBox |	(aDBox _ self new) type: aType; description: string1; variable: string2; initial: string2; group: anInterval; query: aQuery.	^aDBox! !!PrintFrom1108 class methodsFor: 'access control'!sendAndWaitPrintFile: file printer: printer copies: copies 	| printPacket result |	printPacket _ self new				sendPrintFile: file				printer: printer				copies: copies				doneSemaphore: nil.	XDEInterfaceModel addToQueue: [printPacket heresYourChance].	Cursor wait showWhile:		[[(Delay forSeconds: 5) wait.		(result _ printPacket checkProgressAndShowOn: Transcript) class == self] whileTrue].	^result!sendPrintFile: file printer: printer copies: copies	"ask it to send the file, and return the packet so it can be checked later for status. If TajoInterfaceModel is in the image, share the queue with it!!"	| printPacket | 	printPacket _ self new sendPrintFile: file printer: printer copies: copies doneSemaphore: nil.	XDEInterfaceModel addToQueue: [printPacket heresYourChance].	^printPacket! !SpreadsheetCell class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SpreadsheetCell class methodsFor: 'class initialization'!initialize"	 SpreadsheetCell initialize.	"	| pt |	CellDisplayBitBlt _ BitBlt new.	CellRuleBitBlt _ BitBlt		destForm: nil		sourceForm: nil		halftoneForm: nil		combinationRule: Form over		destOrigin: (CellZeroPoint _ 0 @ 0)		sourceOrigin: CellZeroPoint		extent: (pt _ 3 @ 3)		clipRect: (CellZeroPoint corner: pt).	CellFastTextDisplayScanner _ FastTextDisplayScanner new.	CellText _ Text new: 1.	CellTextStyle _ TextStyle default.	CellTextStyle firstIndent: 5.	CellTextStyle restIndent: 5.! !!SpreadsheetCell class methodsFor: 'instance creation'!in: anObject	"create a new cell with a reference to the object it will be held in"	| cell |	cell _  SpreadsheetCell new holder: anObject.	cell contents: nil.	cell rule: nil.	cell updateFlag: false.	cell form: nil.	^cell! !Tables class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!Tables class methodsFor: 'instance creation'!example	"Tables example"	| temp |	temp _ Tables new.	temp widthArray: (Array new: 3); delimiter: $~.	^temp format: 'Name~Address~Telephone~Irwin King~Somewhere, USA~123-4567'!format: aText update: aSuitcase	| aTable return | 	aTable _ self new.	(return _ aTable format: aText) == nil ifTrue: [^nil].	aSuitcase == nil ifFalse: [aSuitcase spare: aTable tabsArray].	^return!initialize	"Tables initialize"	MinWidth _ 0.5.	FontIndex _ TextStyle getNumForStrikeFont: 'Gacha10'!style	(Style == nil or: [(Style at: 1) ~~ PressOrInterpress])		ifTrue:			[Style _ Array				with: PressOrInterpress				with: (PressOrInterpress == #Press							ifTrue: [TextStyle default]							ifFalse: [PrintStyle default]).			 (Style at: 2) outputMedium: #DisplayPrinterWidths].	^(Style at: 2)! !!FakeCollection class methodsFor: 'class initialization'!initialize	Echo release.	Echo _ self new actionBlock: [:aKeyOrIndex | aKeyOrIndex]! !!FakeCollection class methodsFor: 'examples'!echo	^Echo!withAll: anObject	^self new value: anObject! !!Rectangle class methodsFor: 'instance creation'!fromUser: gridPoint	"Answer an instance of me that is determined by having the	user designate the top left and bottom right corners.  The gridding for	user selection is gridPoint."	| originPoint newSelf |	Cursor origin showWhile: [		[Sensor redButtonPressed] whileFalse.		originPoint _ Sensor cursorPoint grid: gridPoint].	newSelf _ self new origin: originPoint corner: originPoint + gridPoint.	Sensor cursorPoint: newSelf corner.	^newSelf		userChangeCornerMinExtent: gridPoint		maxExtent: Display extent		grid: gridPoint		gridOrigin: 0@0		outlineColor: Form gray	"Rectangle fromUser: 100@100."!fromUser: gridPoint gridOrigin: fixPoint	"Answer an instance of me that is determined by having the	user designate the top left and bottom right corners.  The gridding for	user selection is gridPoint."	| originPoint newSelf |	Cursor origin showWhile: [		[Sensor redButtonPressed] whileFalse.		originPoint _ (Sensor cursorPoint - fixPoint grid: gridPoint) + fixPoint].	newSelf _ self new origin: originPoint corner: originPoint + gridPoint.	Sensor cursorPoint: newSelf corner.	^newSelf		userChangeCornerMinExtent: gridPoint		maxExtent: Display extent		grid: gridPoint		gridOrigin: fixPoint		outlineColor: Form gray	"Rectangle fromUser: 100@100."!fromUser: gridPoint gridOrigin: fixPoint withExtent: extentPoint 	"Answer a Rectangle by having the user designate the location of one of the four corners. The width and height 	are determined by extentPoint."	| downYet offsetFromOrigin |	downYet _ false.	^Cursor origin		showWhile: [Display				outline: [(Sensor cursorPoint - fixPoint grid: gridPoint) + fixPoint extent: extentPoint]				while: [Processor yield.					     Sensor anyButtonPressed						ifTrue: [downYet _ true]						ifFalse: [downYet not]]				width: 2				halftone: Form gray]!fromUserAspectRatio: aspectPoint 	"Answer an instance of Rectangle that is determined by having the user 	designate the top left and bottom right corners, constrained so the aspect 	ratio is determined by aspectPoint."	| rectangle extent ratio |	Cursor origin showWhile: [rectangle _ Sensor waitButton extent: 1 @ 1].	ratio _ aspectPoint y / aspectPoint x.	Cursor corner		showWhile: 			[Sensor cursorPoint: rectangle corner.			Display				outline: 					[extent _ Sensor cursorPoint - rectangle origin max: 1 @ 1.					extent y * aspectPoint x > (aspectPoint y * extent x)						ifTrue: [extent x: (extent y / ratio) rounded]	"constrain width"						ifFalse: [extent y: (extent x * ratio) rounded].	"constrain height"					rectangle extent: extent]				while: [Sensor anyButtonPressed]				width: 2				halftone: Form gray].	^rectangle	"Rectangle fromUserAspectRatio: Sensor waitButton"!fromUserAtVertex: vertexName withExtent: extentPoint 	"Answer a Rectangle by having the user designate the location of one of the four corners. The width and height 	are determined by extentPoint."	| downYet offsetFromOrigin |	downYet _ false.	offsetFromOrigin _ (vertexName == #origin				ifTrue: [0 @ 0]				ifFalse: [vertexName == #bottomLeft						ifTrue: [0 @ extentPoint y]						ifFalse: [vertexName == #topRight								ifTrue: [extentPoint x @ 0]								ifFalse: [extentPoint copy]]]).	^(Cursor perform: vertexName)		showWhile: [Display				outline: [Sensor cursorPoint - offsetFromOrigin extent: extentPoint]				while: [Processor yield.					     Sensor anyButtonPressed						ifTrue: [downYet _ true]						ifFalse: [downYet not]]				width: 2				halftone: Form gray]!fromUserMinExtent: minExt maxExtent: maxExt outlineColor: halftoneForm 	"Answer with a Rectangle that is determined by having the 	user press redButton at the top left(origin) and release at 	the buttom right(corner)."	| originPoint newSelf |	minExt = maxExt ifTrue: [^self fromUserWithExtent: minExt].	Cursor origin showWhile: [originPoint _ Sensor waitButton].	newSelf _ Rectangle origin: originPoint corner: originPoint + minExt.	Sensor cursorPoint: newSelf corner.	^newSelf		userChangeCornerMinExtent: minExt		maxExtent: maxExt		grid: 1 @ 1		gridOrigin: 0@0		outlineColor: halftoneForm!fromUserWithExtent: extentPoint 	"Answer a Rectangle by having the user designate the top  	left corner.  The width and height are determined by 	extentPoint. "	^Cursor origin showWhile: [Display			outline: [Rectangle origin: Sensor cursorPoint extent: extentPoint]			while: 				[Processor yield.				Sensor noButtonPressed]			width: 2			halftone: Form gray]!fromUserWithReduceFromMax: maxExtent	"show the user the maxExtent rectangle. Once they have placed its origin,	allow them to move the corner in to reduce the rectangle's size"	^ (Rectangle fromUserWithExtent: maxExtent)		userChangeCornerMinExtent: nil		maxExtent: maxExtent		grid: nil		gridOrigin: 0@0		outlineColor: Form gray!numbersReverseInit: aBlock	^Rectangle new numbersReverseInit: aBlock!pointsInit: aBlock	^Rectangle new pointsInit: aBlock! !DataControl class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!DataControl class methodsFor: 'initialize'!initialize	"DataControl initialize"	| aDataControl | 	aDataControl _ self new.	aDataControl setup.	Smalltalk at: #DataMaster put: aDataControl.	(Smalltalk includesKey: #ContainerListController) ifTrue:[ContainerListController initializeMainMenu]! !Pool named: #TextConstants includes: #DefaultTextStyle!!TextStyle class methodsFor: 'access'!getNumForStrikeFont: nameOfFont	"find nameOfFont StrikeFont in the fontArray of DefaultTextStyle and return its index,		if not there put a message in Transcript and return the default, 1"	| fontNum fontName |	fontName _ nameOfFont asLowercase.	fontNum _ DefaultTextStyle fontArray		findFirst: [:f | (f isKindOf: StrikeFont)						and: [f name asLowercase = fontName]].	fontNum = 0		ifFalse: [^fontNum]		ifTrue: [Transcript cr; show: 'Could not find ', nameOfFont, ' font'. ^1]! !PrintStyle class comment:'Copyright (c) Xerox Corporation, 1987. All rights reserved.class variables: DefaultLeftMargin, DefaultRightMargin, DefaultTopMargin, DefaultBottomMargin<Integers> currently 1250, 9250, 1250, 12720 for each. Measurement unit is 2 micas(2/100 mm). These values are determined by intersection of A4 and US letter size. DefaultLineGrid<Integer> currently 212 (*2 micas).  This value calculated such as 				10(font size of DefaultPrintFont) * ((635/36) -- micas/point) * 1.2''10*(635/36)'' means how many micas are corresponding to 10 point. This is also the minimal size for lineGrid by which printing image for a text is readable(not overridden every where). So the scaling facter 1.2 is for easiness for reading.  DefaultTabsArray<Array> currently #(424 848 1272 1696 2120 2544 2968 3392 3816 4240 4664 5088 5512 5936 6360 6784 7208 7632 8056 8480 8904 9328 9752 10176 10600 11024 11448 11872 12296 12720 13144 13568 )A difference of each contiguous elements is 424, which is 2 times as large as DefaultLineGrid. DefaultFormScale<Integer> currently 4 DefaultFontName<String> currently ''Modern10'' DefaultPaperSize<String> currently 10500 @ 13970, which represents the width and height of the intersectional area of A4 and US letter size. DefaultPrintStyle<PrintStyle> an Instance of PrintStyle with default values above for each instance variables. For reference, execute next expression.					PrintStyle default inspectEach class variable is initialized in a class method "initialize".'!!PrintStyle class methodsFor: 'instance creation'!default	"Answer the system default print style."	^DefaultPrintStyle copy! !!PrintStyle class methodsFor: 'class initialize'!defaultFontsConversionArray	^ Interpress defaultFontsConversionArray!initialize	"PrintStyle initialize"	"initialize class variables"	| fontArray |	fontArray _ Array new: 28.  #('Classic10'	"1"	'Modern10'	"4"	'Classic12'	"7"	'Modern12'	"10"	'Classic14'	"13"	'Modern14'	"16"	'Classic18'	"19"	'Modern8'	"22"	'Titan-printwheel10'	"25")		with: (Interval from: 1 to: 27 by: 3)		do: [:face :j|			fontArray at: j put: (DisplayPrintFont fromWidth: (self getOldFileName: (face, '.width'))).			fontArray at: j+1 put: (DisplayPrintFont fromWidth: (self getOldFileName: (face, (String with: $B), '.width'))).			fontArray at: j+2 put: (DisplayPrintFont fromWidth: (self getOldFileName: (face, (String with: $I), '.width')))].	fontArray at: 28 put: (DisplayPrintFont fromWidth: (self getOldFileName: 'Gacha10.width')).	self		setDefaultPaper: 10500 @ 13970		topMargin: 1250		bottomMargin: 1250		leftMargin: 1250		rightMargin: 1250		lineGrid: 212		tab: 424		fontArray: fontArray		formScale: 4!setDefaultPaper: paper topMargin: topmargin bottomMargin: bottommargin leftMargin: leftmargin rightMargin: rightmargin lineGrid: linegrid tab: tab fontArray: fontArray formScale: scale 	| tabs |	DefaultPaperSize _ paper.	DefaultTopMargin _ topmargin.	DefaultBottomMargin _ paper y - bottommargin.	DefaultLeftMargin _ leftmargin.	DefaultRightMargin _ paper x - rightmargin.	DefaultPrinterLineGrid _ linegrid.	tabs _ Array new: (paper x max: paper y)					// tab + 1.	tabs at: 1 put: tab.	1 to: tabs size - 1 do: [:i | tabs at: i + 1 put: (tabs at: i)				+ tab].	DefaultPrinterTabsArray _ tabs.	DefaultFormScale _ scale.	DefaultPrintStyle _ self fontArray: fontArray! !!PrintStyle class methodsFor: 'As yet unclassified'!pressScale	^ 16 "17.6389"	"1270.0/72"! !!Project class methodsFor: 'class initialization'!initialize	"This is the Top Project."   	CurrentProject _ TopProject _ super new initialProject	"Project initialize."! !!Project class methodsFor: 'constants'!top	"Answer the top-level project."	^TopProject! !!ContainerModel class methodsFor: 'private'!fixName: aString	| temp |	aString size > 1 	ifTrue:		[temp _ aString copy.		temp at: 1 put: (temp at: 1) asUppercase.		^temp]! !!ContainerModel class methodsFor: 'access'!message	^UserMessage!message:aMessage	UserMessage _ aMessage! !!ContainerModel class methodsFor: 'open items'!createForIndexOrItem: theIndex inCenter: aCenter	^self basicNew initialize: theIndex in: aCenter!openThisFolder: theFolder inCenter: aCenter searchString: aString 	"open view on selected container"	Cursor execute show.	(self createForIndexOrItem: theFolder inCenter: aCenter) searchString: aString;		scheduleTheFolder: (theFolder centerIndex = 1				ifTrue: [aCenter name , '''s Info Center']				ifFalse: [aCenter name , '''s ' , theFolder label , '  Folder'])		usingMenu: 1		width: 1		helpMessage: #Folder! !!FileStringHolder class methodsFor: 'instance creation'!fileStream: aFileStream 	"Answer an instance of me on the argument, aFileStream."	^self new setFileStream: aFileStream! !!AnnotationModel class methodsFor: 'open windows'!fileStream: aFileStream withSuitcase: theSuitcase	"Answer an instance of me on the argument, aFileStream."	^self new setFileStream: aFileStream withSuitcase: theSuitcase!hardcopyDirect	"return true to hardcopy directly, false to preview it, nil to abort."	| answer |	(Smalltalk includesKey: #PreviewPageView)		ifTrue: 			[answer _ DBoxView						openFor: #(select select )						title: 'Select Hardcopy Method'						labels: #(('Choose either:' Direct Preview) ('  if preview:' Portrait Landscape ) )						defaults: #((Direct ) (Portrait ) )						commands: #(accept cancel bailOut )						autoAccept: false						links: (Array with: (Array with: 1@2 with: 2@1 with: 2@2)).			answer == nil ifTrue: [^nil].			^answer].	^#(Direct nil )!hardcopyReportWithSuitcase: suitcase	| annoModel formList titleList aStream fileName | 	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].	annoModel _ AnnotationModel fileStream: (HeaderFileStream fileNamed: (fileName _ suitcase dataItem filename)).	aStream _ (self openFile: fileName, (DataMaster giveMe: #specialSuffixString for: #report asString)) readOnly.	formList _ OrderedCollection new.	titleList _ OrderedCollection new.	[aStream atEnd] whileFalse:		[titleList add: (aStream upTo: $*).		formList add: (aStream upTo: Character cr)].	aStream close.	BackgroundPrinter printReportText: annoModel contents annoDict: annoModel annoDictionary forms: formList titles: titleList suitcase: suitcase!hardcopyWithSuitcase: suitcase 	| annoModel direct |	(direct _ self hardcopyDirect) == nil ifTrue: [^self].	annoModel _ AnnotationModel fileStream: (HeaderFileStream fileNamed: suitcase dataItem filename).	(direct at: 1) == #Direct		ifTrue: [	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].				BackgroundPrinter				putText: annoModel contents				annoDict: annoModel annoDictionary				suitcase: suitcase]		ifFalse: [ComposeTextController					previewText: annoModel contents					annoDict: annoModel annoDictionary					withStartSuitcase: suitcase					portrait: ((direct at: 2) == #Portrait)]!openOnText: text suitcaseToUpdate: suitcase	"create a file using the filename in suitcase as the kernal name; update the filename in the suitcase, open an annotation text view on it"	| theNewFileName fs annoModel |	Cursor execute show.	theNewFileName _ Disk makeNewFileName: suitcase dataItem filename withSuffix: (DataMaster giveMe: #suffixString for: #text asString).	suitcase dataItem filename: theNewFileName.	fs _ (HeaderFileStream fileNamed: theNewFileName) readWrite.	fs writeHeaderFor: suitcase dataItem.	ComposeTextController putText: text inStream: fs usingAnnoDict: nil.	fs close.	Cursor read show.	annoModel _ AnnotationModel fileStream: (HeaderFileStream fileNamed: theNewFileName) withSuitcase: suitcase.	suitcase dataItem centerIndex = 0 ifTrue: [annoModel lock].	annoModel withSuitcase: suitcase defaultSize: 486@550!openReportWithSuitcase: aSuitcase	"Create a big window that will allow the viewing of images and related text."	| formView listView aFileView topView keyList whichSide |	whichSide _ (self confirm: 'Select image position' yesLabel: 'left' noLabel: 'right').	Cursor execute showWhile: [	(topView _ StandardSystemView new)		label: aSuitcase dataItem label;		borderWidth: 1;		addDependent: aSuitcase.	(formView _ FormView new)		model: (Form new extent: 512@512);		controller: NoController new;		borderWidth: 1.	keyList _ KeyFileList new.	keyList newListAndPattern: aSuitcase dataItem filename, (DataMaster giveMe: #specialSuffixString for: 'report').	keyList whereToPutIt: formView.	(listView _ ListView new)		model: keyList;		controller: BioController new;		list: keyList list;		borderWidth: 1;		window: (0@0 extent: 514@100).	aFileView _ StringHolderView new.	aFileView model: (AnnotationModel fileStream: (HeaderFileStream fileNamed: aSuitcase dataItem filename) withSuitcase: aSuitcase);			controller: ComposeTextController new;			window: (0@0 extent: 484@614);			borderWidth: 1.	whichSide		ifTrue: [topView addSubView: formView.				topView addSubView: aFileView					align: aFileView viewport topLeft					with: formView viewport topRight]		ifFalse: [topView addSubView: aFileView.				topView addSubView: formView					align: formView viewport topLeft					with: aFileView viewport topRight].	topView addSubView: listView		align: listView viewport topLeft		with: formView viewport bottomLeft.	topView classifyLabel: aSuitcase classification.	topView		model: aFileView model;		controller: ComposeSystemController new;		minimumSize: topView viewport extent;		maximumSize: topView viewport extent;		helpIndex: #Report].	topView controller open!openTextWorkspace	"open a blank annotation text view"	| aSuitcase |	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: AnnotationModel) and: [each view label = (UserName,'''s Scratch pad')]].aSuitcase _ Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem type: #Item label: UserName,'''s Scratch pad' filename: UserName, '.notepad' atIndex: 0).		(AnnotationModel fileStream: (HeaderFileStream fileNamed: aSuitcase dataItem filename) withSuitcase: aSuitcase) withSuitcase: aSuitcase defaultSize: 200@200!openWithSuitcase: aSuitcase	"open a annotation text view on the specifed file " 	(Disk includesKey: aSuitcase dataItem filename)			ifFalse: [(self confirm: 'There is no data for this item. Should I create a new file.') ifFalse:[Cursor normal show. ^nil]].	Cursor read show.	(AnnotationModel fileStream: (HeaderFileStream fileNamed: aSuitcase dataItem filename) withSuitcase: aSuitcase) withSuitcase: aSuitcase defaultSize: 486@550! !!AnnotationModel class methodsFor: 'annotations'!cleanDict: outputDict fromString: string fromDict: annoDict 	"clean up this annotation dictionary"	| theIndex theParen theKey theAnno |	theIndex _ 1.		[theIndex _ string findString: '::' startingAt: theIndex.	theIndex = 0]		whileFalse: 			[theParen _ string findString: '::' startingAt: theIndex + 1.			theParen = 0				ifTrue: [theIndex _ theIndex + 1]				ifFalse: [theParen - theIndex = 5						ifTrue: 							[theKey _ string copyFrom: theIndex to: theParen + 1.							theAnno _ annoDict at: theKey ifAbsent: [theAnno _ nil].							theAnno == nil								ifFalse: 									[outputDict at: theKey put: theAnno.									self										cleanDict: outputDict										fromString: theAnno asString										fromDict: annoDict].							theIndex _ theIndex + 6]						ifFalse: [theIndex _ theIndex + 1]]].	^outputDict!convert: goodFileName toStupidText: stupidFileName	"goodFileName is the name of a valid AnnotationModel type text file.  This will create a file named stupidFileName which will consist of the simple ascii characters in lines of length <= 80, essentially what might be sent to a tty terminal"	| stupidFileStream goodTextStream maxChars lineEnd lineStart emptyLine lastSpace charCnt lineDone chr theLine cr annoModel | 	annoModel _ (AnnotationModel fileStream: (HeaderFileStream fileNamed: goodFileName) withSuitcase: (Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem type: #Item label: goodFileName filename: goodFileName atIndex: 0))).	cr _ Character cr.	stupidFileStream _ (FileStream fileNamed: stupidFileName) writeShorten.	goodTextStream _ ReadStream on: annoModel getIntegratedAnnotationText string.	Cursor execute showWhile: [	maxChars _ 80.	"doesn't include CR on end of line"	lineEnd _ goodTextStream position.	[goodTextStream atEnd] whileFalse:		[lineStart _ lineEnd.		 emptyLine _ false.		 lastSpace _ 0.		 charCnt _ 0.		 lineDone _ false.		 [lineDone or: [charCnt = maxChars or: [goodTextStream atEnd]]]			whileFalse:				[(chr _ goodTextStream next) = cr					ifTrue:						[lineDone _ true.						 charCnt = 0 ifTrue: [emptyLine _ true]]					ifFalse:						[charCnt _ charCnt + 1.						 chr = $ "space" ifTrue: [lastSpace _ goodTextStream position]]].		 lineEnd _ goodTextStream position.		 (lineDone or: [lastSpace = 0 or: [goodTextStream atEnd]])			ifFalse:				[lineEnd _ lastSpace.				 charCnt _ lineEnd - lineStart - 1 "need to back up to last space"].		 goodTextStream position: lineStart.		 theLine _ (emptyLine			ifTrue: [String with: $ "space" with: cr]			ifFalse: [(goodTextStream next: charCnt), (String with: cr)]).		 stupidFileStream nextPutAll: theLine.		 goodTextStream position: lineEnd].	stupidFileStream close]!findAnyAnnosIn: aText usingDict: annoDict	"Returns a dictionary of any annotations in aText"	| outputDict |	outputDict _ OopConservingDictionary new.	self cleanDict: outputDict fromString: (aText asString) fromDict: annoDict.	^outputDict! !ConfigFileModel class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ConfigFileModel class methodsFor: 'accessing'!clearCurrentUserFile	CurrentUserFileStream == nil ifFalse: [CurrentUserFileStream close].	CurrentUserFileStream _ nil!currentUserFileName	"update currentUserFileStream if necessary, and return the base name of the file currently in CurrentUserFileStream"	| currentName gtr wantName | 	wantName _ (UserName, '-configFile') asFileName.	CurrentUserFileStream == nil ifFalse:		[currentName _ ((FileDirectory decomposeName: CurrentUserFileStream name) at: 'Name-Body').		wantName = currentName ifTrue: [^currentName]].	CurrentUserFileStream _ (FileStream fileNamed: wantName) readOnly.	^wantName!getConfigSection: sectionName	^ self getConfigSection: sectionName forUser: UserName!getConfigSection: sectionName forUser: userName	"return the text of section sectionName in config file of current user,		or if not there - from default config file, or if not there return empty string"	| fileStream results resetUserName user userFileName |	Cursor read showWhile: [	userName == nil		ifTrue: [results _ String new]		ifFalse:			[userFileName _ (userName, '-configFile') asFileName.			fileStream _ (userFileName = self currentUserFileName					ifTrue: [CurrentUserFileStream readOnly; reset]					ifFalse: [(FileStream fileNamed: userFileName) readOnly]).			 results _ self getSection: sectionName inStream: fileStream.			 fileStream close].	results isEmpty		ifTrue:			[fileStream _ (FileStream fileNamed: 'Default-configFile' asFileName) readOnly.			 results _ self getSection: sectionName inStream: fileStream.			 fileStream close.			 (results isEmpty or: [userName == nil])				ifFalse: [self replaceSection: sectionName inFile: userFileName with: results inSectionName: nil]]].	^ results!getSection: sectionName inStream: fileStream	"return the text of section sectionName"	^fileStream next: (self findSection: sectionName inStream: fileStream)!replaceConfigSection: sectionName with: aString	"add or replace contents of sectionName in current users configFile with aString"	self replaceSection: sectionName inFile: UserName, '-configFile' with: aString inSectionName: nil!replaceSection: sectionName inFile: fileName with: aString inSectionName: newSectionName	"add or replace contents of sectionName with aString in file named fileName. If aString is nil, remove the section"	| oldSectionLength oldFileStream newFileStream resetCurrent tempName |	Cursor write showWhile: [	resetCurrent _ false.	oldFileStream _ (fileName asFileName = self currentUserFileName			ifTrue: [CurrentUserFileStream readOnly; reset]			ifFalse: [(FileStream fileNamed: fileName asFileName) readOnly]).	oldSectionLength _ self findSection: sectionName inStream: oldFileStream.	oldSectionLength = 0		ifTrue: [newFileStream _ oldFileStream readWrite"adding new section"]		ifFalse:			["copy old sections to new file stream"			 oldFileStream close.			 fileName asFileName = CurrentUserFileStream name ifTrue: [resetCurrent _ true].			 Disk renameKey: fileName asFileName newName: (tempName _ 'Analyst-oldDefsFile').			 oldFileStream _ (FileStream fileNamed: tempName) readOnly.			 newFileStream _ (FileStream fileNamed: fileName asFileName) writeShorten.			 self copyAllExceptSection: sectionName from: oldFileStream to: newFileStream. "copy all but sectionName"			 oldFileStream close.			 Disk removeKey: tempName].	(aString == nil or: [aString isEmpty]) ifFalse:		[newFileStream			nextPut: ${;			nextPutAll: (newSectionName == nil ifTrue: [sectionName] ifFalse: [newSectionName]) asString;			nextPutAll: '||';			nextPutAll: (aString size printStringRadix: 10);			nextPut: Character cr;			nextPutAll: aString].	newFileStream close.	resetCurrent ifTrue: [CurrentUserFileStream _ newFileStream]]!sectionsOnFileNamed: fileName	"returns ordered collection of names of sections in the configuration file fileName"	"ConfigFileModel sectionsOnFileNamed: UserName, '-configFile' asFileName"	| fileStream defsLength sectionNames |	sectionNames _ OrderedCollection new.	fileStream _ (fileName asFileName = self currentUserFileName			ifTrue: [CurrentUserFileStream readOnly; reset]			ifFalse: [(FileStream fileNamed: fileName asFileName) readOnly]).	[fileStream atEnd] whileFalse:		[fileStream next = ${			ifTrue:				[sectionNames add: (self parseStringFrom: fileStream).				 defsLength _ Integer readFrom: fileStream.				 fileStream skipTo: Character cr.				 fileStream skip: defsLength]			ifFalse: [fileStream skipTo: Character cr]].	fileStream close.	^sectionNames! !!ConfigFileModel class methodsFor: 'private'!copyAllExceptSection: sectionName from: oldFileStream to: newFileStream	"copy oldFileStream to newFileStream skipping the section for sectionName"	"the checking for ${ is redundant unless someone has directly messed with the file"	| chr thisSection defsLength sectionNameAsLowercase |	Cursor read showWhile: [	sectionNameAsLowercase _ sectionName asString asLowercase.	[oldFileStream atEnd] whileFalse:		[chr _ oldFileStream next.		 newFileStream nextPut: chr.		 chr = ${			ifTrue:				[sectionNameAsLowercase = (thisSection _ (self parseStringFrom: oldFileStream) asLowercase)					ifTrue:						[newFileStream skip: -1.						 defsLength _ Integer readFrom: oldFileStream.						 oldFileStream skipTo: Character cr.						 oldFileStream skip: defsLength]					ifFalse:						[defsLength _ Integer readFrom: oldFileStream.						 newFileStream nextPutAll: thisSection;							nextPutAll: '||';							nextPutAll: (defsLength printStringRadix: 10);							nextPutAll: (oldFileStream through: Character cr);							nextPutAll: (oldFileStream next: defsLength)]]			ifFalse:				[newFileStream nextPutAll: (oldFileStream through: Character cr).				 "because through: doesn't work at end of file - in later version use upThrough:"				 oldFileStream atEnd ifTrue: [newFileStream nextPut: Character cr]]]]!findSection: sectionName inStream: fileStream	"position fileStream to start of text of sectionName. Return length of section, 0 if not found"	"the checking for ${ is redundant unless someone has directly messed with the file"	| defsLength thisSection soughtSection |	soughtSection _ sectionName asString asLowercase.	[fileStream atEnd] whileFalse:		[fileStream next = ${			ifTrue:				[thisSection _ self parseStringFrom: fileStream.				 defsLength _ Integer readFrom: fileStream.				 fileStream skipTo: Character cr.				 soughtSection = thisSection asLowercase					ifTrue: [^defsLength]					ifFalse: [fileStream skip: defsLength]]			ifFalse: [fileStream skipTo: Character cr]]. 	^ 0!parseStringFrom: fileStream	"read in characters up to (but not including) the next double-|		and return that as a string"	| bufferStream chr |	bufferStream _ WriteStream on: (String new: 200).	[fileStream atEnd] whileFalse:		[chr _ fileStream next.		 (chr = $| and: [fileStream peek = $|])			ifTrue:				[fileStream next.	"gobble |"				 ^ bufferStream contents].		 bufferStream nextPut: chr		].	^ bufferStream contents! !!FillInTheBlank class methodsFor: 'futuristic instance creation'!request: messageString default: aString	^User request: messageString default: aString	"^self request: messageString initialAnswer: aString"! !!AutoBook class methodsFor: 'instance creation'!new: theBook	^ super new initialize: theBook!open: theLabel onData: theBook	"Schedule Auto book" "AutoBook open:'The Fact Book' onData:'FactBook'"	|x aForm formView bookView firstListView secondListView thirdListView textView theModel|	Cursor wait show.	theModel _ AutoBook new: theBook.	bookView _ StandardSystemView new model: theModel.	bookView controller: AutoBookStandardSystemController new.	bookView label: theLabel.	aForm _ (Form readFrom: theBook, (self suffixFor: #map)).	(formView _ FormView new)		model: aForm controller: (ABFormController new);		window: (0 @ 0 extent: aForm extent);		insideColor: Form white;		borderWidthLeft: 2 right: 1 top: 2 bottom: 1.	(firstListView _ FirstABListView new)		model: theModel controller: FirstABListController new;		selection: (theModel firstListIndex);		window: (0 @ 0 extent: 200 @ (aForm extent y));		borderWidthLeft: 1 right: 2 top: 2 bottom: 1.	x _ (((aForm extent x) +200) /2) rounded.	(secondListView _ SecondABListView new)		model: theModel controller: SecondABListController new;		window: (0 @ 0 extent: x @ 150);		borderWidthLeft:  2 right: 1 top: 1 bottom: 1.	(thirdListView _ ThirdABListView new)		model: theModel controller: ThirdABListController new;		window: (0 @ 0 extent: x @ 150);		borderWidthLeft: 1 right: 2 top: 1 bottom: 1.	(textView _ AutoBookTextView new)		model: (theModel contents: (String with: Character space));		controller: AutoBookTextController new;		window: (0@0 extent: aForm extent x +200@300);		borderWidthLeft: 2 right: 2 top: 1 bottom: 2.	bookView		addSubView: formView;		addSubView: firstListView toRightOf: formView;		addSubView: secondListView below: formView;		addSubView: thirdListView toRightOf: secondListView;		addSubView: textView below: secondListView;		minimumSize: aForm extent x +200 @ (aForm extent y +450);		maximumSize: aForm extent x +200 @ (aForm extent y +450);		helpIndex: #Factbook.	Cursor normal show.	bookView controller open.!suffixFor: aSymbol	"this is just to centralize getting suffixes for the files, since some file systems require modification of this"	aSymbol == #changes ifTrue: [^'.changes'].	aSymbol == #sources ifTrue: [^'.sources'].	aSymbol == #map ifTrue: [^'.picture'].	aSymbol == #picture ifTrue: [^'.picture'].	aSymbol == #index ifTrue: [^'.index'].	^String new! !DataListModel class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DataListModel class methodsFor: 'As yet unclassified'!dataSpace	^DataSpace!initialize	"DataListModel initialize"	LabelSpace _ 15. "The spacing for the label"	DataSpace _ 10. "The spacing for the data"	CopyBuffer _ Array new: 5!labelSpace	^LabelSpace!new	^ super new initialize! !!RS232Model class methodsFor: 'class initialization'!checkRS232Connections	(RS232Collector = nil)	ifTrue: [^true].	^(RS232Collector rs232Window superView controller closeAndUnschedule)!initialize	Smalltalk at: #RS232Collector put: nil.	DefaultFont _ TextStyle getNumForStrikeFont: 'Gacha10'.  "font to be used for browsing text"	NoData _ AsyncSerialPort NoData.	"RS232Model initialize."! !!RS232Model class methodsFor: 'instance creation'!rs232Open	"Schedule a View for a RS232 connection"	RS232Collector _ self new.	RS232Collector openRS232View! !!RS232Model class methodsFor: 'example'!example	"How to open a RS232 connection. "	RS232Model rs232Open! !!TekModel class methodsFor: 'instance creation'!rs232OpenTek	"Schedule a View for a RS232 connection"	self rs232OpenTekWithLabel: 'Tek' logIn: ''	"TekModel rs232OpenTek"!rs232OpenTekWithLabel: aLabel logIn: aString	"Schedule a View for a RS232 connection"	| typeWindow answers |	answers _ DBoxView		openFor: #(select select)		labels: #(#('Display Full Sized?' yes no) 				  #('Tack text style?' yes no))		defaults: #(no no).	answers == nil ifTrue: [^self].	RS232Collector _ self new.	typeWindow _ ((answers at: 2) = #yes) "tack text style"		ifTrue: [2] ifFalse: [0].	typeWindow _ typeWindow bitOr: (((answers at: 1) = #yes) ifTrue: [1] ifFalse: [0]).	"full size"	RS232Collector openTekViewType: typeWindow withLabel: aLabel autoSendString: aString	"TekModel rs232OpenTekWithLabel: 'Tek' logIn: ''"! !Sum class comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Sum class methodsFor: 'As yet unclassified'!of: aMatrix	| newSum | 	newSum _ super new.	newSum collection: aMatrix.	^newSum! !HeaderFileStream class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!HeaderFileStream class methodsFor: 'instance creation'!fileNamed: fileName	^self new initialize: (FileStream fileNamed: fileName)!headerStreamOn: aFileStream	(aFileStream isKindOf: HeaderFileStream) ifTrue: [^aFileStream].	aFileStream close.	^self new initialize: aFileStream!newFileNamed: fileName	^self new initialize: (FileStream newFileNamed: fileName)!oldFileNamed: fileName	^self new initialize: (FileStream oldFileNamed: fileName)! !!HeaderFileStream class methodsFor: 'default behavior'!doesNotUnderstand: aMessage	| result | 	result _ FileStream perform: aMessage selector withArguments: aMessage arguments.	(result isKindOf: FileStream) ifTrue: [^self new initialize: result].	^result! !!HeaderFileStream class methodsFor: 'initialize'!initialize	"HeaderFileStream initialize"	HeaderID _ '..Header'! !MixedFileStream class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!EncryptedFileStream class comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!EncryptedFileStream class methodsFor: 'private'!checkKey: keyString	"the only checking that can be done is to be sure it is a string with at least one character"	((keyString isKindOf: String) and: [keyString size > 0])		ifFalse: [self booboo: 'Invalid key'. ^false].	^true! !!EncryptedFileStream class methodsFor: 'instance creation'!encryptedStreamOn: aFileStream withKey: keyString	| useFileStream | 	(aFileStream isKindOf: EncryptedFileStream) ifTrue: [^aFileStream].	aFileStream close.	(self checkKey: keyString) ifFalse: [^nil].	useFileStream _ (aFileStream isKindOf: HeaderFileStream) ifTrue: [aFileStream fileStream] ifFalse: [aFileStream].	^self new initialize: useFileStream key: keyString!fileNamed: fileName	| keyString | 	keyString _ self requestKey.	keyString == nil ifTrue: [^nil].	^self new initialize: (FileStream fileNamed: fileName) key: keyString!fileNamed: fileName withKey: keyString	(self checkKey: keyString) ifFalse: [^nil].	^self new initialize: (FileStream fileNamed: fileName) key: keyString!newFileNamed: fileName	| keyString | 	keyString _ self requestKey.	keyString == nil ifTrue: [^nil].	^self new initialize: (FileStream newFileNamed: fileName) key: keyString!oldFileNamed: fileName	| keyString | 	keyString _ self requestKey.	keyString == nil ifTrue: [^nil].	^self new initialize: (FileStream oldFileNamed: fileName) key: keyString!requestKey	FillInTheBlank		requestPassword: 'Please enter encryption key'		displayAt: Sensor cursorPoint		centered: true		action: [:keyString] 		initialAnswer: String new.	^(self checkKey: keyString) ifTrue: [keyString] ifFalse: [nil]! !!EncryptedFileStream class methodsFor: 'conversion'!decryptFile: encFileName toFile: newFileName withKey: theKey	"decrypt encFileName into newFileName using theKey.  If newFileName is nil, then replace encFileName with the decrypted file.  If theKey is nil, ask for the key"	| theRealKey encfs outFileStream regularFile | 	theRealKey _ theKey.	theRealKey == nil ifTrue: [(theRealKey _ self requestKey) == nil ifTrue: [^false]].	regularFile _ newFileName.	regularFile == nil ifTrue: [regularFile _ #CNVRTXXX asString].	encfs _ (EncryptedFileStream fileNamed: encFileName withKey: theRealKey) readOnly; binary.	Disk removeKey: regularFile ifAbsent: []. "if exists and open header stream on it, could be left with old header"	outFileStream _ (HeaderFileStream fileNamed: regularFile) readWriteShorten; binary.	encfs hasHeader ifTrue:		[outFileStream header: encfs readHeader.		outFileStream reset].	encfs reset.	encfs decryptInto: outFileStream maxBytes: nil.	encfs close.	outFileStream close.	newFileName == nil ifTrue: "got to replace encFileName"		[Disk removeKey: encFileName.		Disk renameKey: regularFile newName: encFileName].	^true!decryptFile: aFileName withKey: keyString intoStream: outStream	"it is assumed that outStream is a stream type object and it's current position is where the user wishes to start putting the data decrypted from aFileName"	| totalLeft inStream |	(self checkKey: keyString) ifFalse: [^false].	Cursor wait showWhile: [	inStream _ self new initialize: (FileStream fileNamed: aFileName) key: keyString.	inStream readOnly.	inStream decryptInto: outStream maxBytes: nil.	inStream close].	^true!encryptFile: regularFile toFile: newFileName withKey: theKey	"encrypt regularFile into newFileName using theKey.  If newFileName is nil, then replace regularFile with the encrypted file.  If theKey is nil, ask for the key"	| theRealKey encFileName encfs inFileStream | 	theRealKey _ theKey.	theRealKey == nil ifTrue: [(theRealKey _ self requestKey) == nil ifTrue: [^false]].	encFileName _ newFileName.	encFileName == nil ifTrue: [encFileName _ #CNVRTXXX asString].	Disk removeKey: encFileName ifAbsent: []. "if exists and open header stream on it, could be left with old header"	encfs _ (EncryptedFileStream fileNamed: encFileName withKey: theRealKey) readWriteShorten; binary.	inFileStream _ (HeaderFileStream fileNamed: regularFile) readOnly; binary.	inFileStream hasHeader ifTrue:		[encfs header: inFileStream readHeader.		encfs reset].	inFileStream reset.	encfs encryptStream: inFileStream.	encfs close.	inFileStream close.	newFileName == nil ifTrue: "got to replace regularFile"		[Disk removeKey: regularFile.		Disk renameKey: encFileName newName: regularFile].	^true!encryptStream: inStream withKey: keyString intoFile: aFileName	"it is assumed that inStream is a stream type object and it's current position is where the user wishes to start getting the data to encrypt and put into the file aFileName"	| outStream totalLeft |	(self checkKey: keyString) ifFalse: [^false].	Cursor wait showWhile: [	outStream _ self new initialize: (FileStream fileNamed: aFileName) key: keyString.	outStream readWriteShorten.	outStream encryptStream: inStream.	outStream close].	^true! !FixedFileStream class comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986. All rights reserved.'!!FixedFileStream class methodsFor: 'instance creation'!fileNamed: fileDesignator 	"Answer a FileStream on an old or new File designated by the string 	fileDesignator. "	"(FixedFileStream fileNamed: 'current') compress"	^self new initialize: (FileStream fileNamed: fileDesignator)! !!FixedFileStream class methodsFor: 'examples'!example	"FixedFileStream example"	| theDicts theStream names lengths types finalCollection |	"create a new file for use"	names _ OrderedCollection new.	lengths _ OrderedCollection new.	types _ OrderedCollection new.	names add: 'name'.	lengths add: 20.	types add: 'string'.	names add: 'rank'.	lengths add: 20.	types add: 'string'.	names add: 'serialNumber'.	lengths add: 30.	types add: 'number'.	FixedFileStream newOn: 'gamma' withFieldNames: names fieldLengths: lengths fieldTypes: types.	"open the file and populate it with data"	theStream  _ FixedFileStream fileNamed: 'gamma'.	theDicts _ OrderedCollection new.	theDicts add: OopConservingDictionary new.	(theDicts at: 1) at: #name put: 'Kurt'. 	(theDicts at: 1) at: #rank put: 'Slave'.	(theDicts at: 1) at: #serialNumber put: '1357'.	theDicts add: Dictionary new.	(theDicts at: 2) at: #name put: 'Leslee'. 	(theDicts at: 2) at: #rank put: 'Wench'.	(theDicts at: 2) at: #serialNumber put: '2468'.	theDicts add: Dictionary new.	(theDicts at: 3) at: #name put: 'Rae'. 	(theDicts at: 3) at: #rank put: 'Toady'.	(theDicts at: 3) at: #serialNumber put: '36912'.	theDicts add: Dictionary new.	(theDicts at: 4) at: #name put: 'Pete'. 	(theDicts at: 4) at: #rank put: 'Honcho'.	(theDicts at: 4) at: #serialNumber put: '481632'.	1 to: 30 do: [:each | theStream constructRecordFrom: (theDicts at: each \\ 4 + 1)].	theStream close.	"alter record number 20 to have name = 'Napoleon'"	theStream  _ FixedFileStream fileNamed: 'gamma'.	theStream replaceRecord: 20 field: #name with: 'Napoleon'.	finalCollection _ theStream allRecordNumbersFitting:(FixedFileFilter on: 'name contains ''Napoleon''').	theStream close.	finalCollection inspect!example2	"to be performed after example 1.  This will alter a record and then delete an old one"	"FixedFileStream example2"	| theDicts theStream names lengths types finalCollection |	theStream _ FixedFileStream fileNamed: 'gamma'.	"alter record number 21 to have name = 'Napoleon'"	theStream replaceRecord: 21 field: #name with: 'Napoleon'.	"delete record 20"	theStream deleteRecord: 20.	finalCollection _ theStream allRecordsFitting:(FixedFileFilter on: 'name contains ''Napoleon''').	theStream close.	finalCollection inspect! !!FixedFileStream class methodsFor: 'file creation'!newOn: aFileName withFieldNames: nameCollection fieldLengths: lengthCollection fieldTypes: typeCollection 	"create a new fixed record file using the information 	contained in the three passed collections. nameCollection is expected to be an OrderedCollection of strings, as is typeCollection.  lengthCollection should be an OrderedCollection of numbers.  "	| theNewFixedFile |	nameCollection size = lengthCollection size & (nameCollection size = typeCollection size)		ifTrue: [Cursor write				showWhile: 					[theNewFixedFile _ FileStream newFileNamed: aFileName.					theNewFixedFile nextPutAll: nameCollection size printString.					theNewFixedFile nextPut: Character cr.					1 to: nameCollection size do: 						[:i | 						theNewFixedFile nextPutAll: (nameCollection at: i).						theNewFixedFile nextPut: $,.						theNewFixedFile nextPutAll: (lengthCollection at: i) printString.						theNewFixedFile nextPut: $,.						theNewFixedFile nextPutAll: (typeCollection at: i).						theNewFixedFile nextPut: Character cr].					theNewFixedFile close]]		ifFalse: [^self booboo: 'Inconsistent information']! !ClassifiedFixedFileStream class comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!ClassifiedFixedFileStream class methodsFor: 'examples'!example2	"to be performed after 'FixedFileStream example'.  This will convert the 	database to a classified one, classify a record and then delete an old one"	"ClassifiedFixedFileStream example2"	| theStream class finalCollection |	theStream _ ClassifiedFixedFileStream fileNamed: 'gamma'.	"alter record number 21 to have name = 'Napoleon'"	class _ Classification array: #(XPers ).	theStream classifyRecord: 21 with: class.	"delete record 20"	theStream deleteRecord: 20.	finalCollection _ theStream allRecordNumbersFitting: (FixedFileFilter on: 'classification = ''#(XPers)''').	theStream close.	finalCollection inspect! !!ClassifiedFixedFileStream class methodsFor: 'file creation'!newOn: aFileName withFieldNames: nameCollection fieldLengths: lengthCollection fieldTypes: typeCollection 	"create a new fixed record file using the information 	contained in the three passed collections. nameCollection is expected to be an OrderedCollection of strings, as is typeCollection.  lengthCollection should be an OrderedCollection of numbers.  "	| theNewFixedFile |	nameCollection size = lengthCollection size & (nameCollection size = typeCollection size)		ifTrue: [Cursor write				showWhile: 					[theNewFixedFile _ FileStream newFileNamed: aFileName.					theNewFixedFile nextPutAll: '* '; nextPut: Character cr.					DCM writeClassification: theNewFixedFile.					Classification new storeOn: theNewFixedFile.					theNewFixedFile nextPutAll: nameCollection size printString.					theNewFixedFile nextPut: Character cr.					1 to: nameCollection size do: 						[:i | 						theNewFixedFile nextPutAll: (nameCollection at: i).						theNewFixedFile nextPut: $,.						theNewFixedFile nextPutAll: (lengthCollection at: i) printString.						theNewFixedFile nextPut: $,.						theNewFixedFile nextPutAll: (typeCollection at: i).						theNewFixedFile nextPut: Character cr].					theNewFixedFile close]]		ifFalse: [^self booboo: 'Inconsistent information']!newOn: aFileName withHeaderFor: aDataItem withFieldNames: nameCollection fieldLengths: lengthCollection fieldTypes: typeCollection 	"create a new fixed record file using the information 	contained in the three passed collections. nameCollection is expected to be an OrderedCollection of strings, as is typeCollection.  lengthCollection should be an OrderedCollection of numbers.  If aDataItem is nil, then no header"	| theNewFixedFile |	nameCollection size = lengthCollection size & (nameCollection size = typeCollection size)		ifTrue: [Cursor write				showWhile: 					[theNewFixedFile _ (HeaderFileStream fileNamed: aFileName) writeShorten.					aDataItem == nil ifFalse: [theNewFixedFile writeHeaderFor: aDataItem].					theNewFixedFile nextPutAll: '* '; nextPut: Character cr.					DCM writeClassification: theNewFixedFile.					Classification new storeOn: theNewFixedFile.					theNewFixedFile nextPutAll: nameCollection size printString.					theNewFixedFile nextPut: Character cr.					1 to: nameCollection size do: 						[:i | 						theNewFixedFile nextPutAll: (nameCollection at: i).						theNewFixedFile nextPut: $,.						theNewFixedFile nextPutAll: (lengthCollection at: i) printString.						theNewFixedFile nextPut: $,.						theNewFixedFile nextPutAll: (typeCollection at: i).						theNewFixedFile nextPut: Character cr].					theNewFixedFile close]]		ifFalse: [^self booboo: 'Inconsistent information']! !LabelSwitch comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!LabelSwitch methodsFor: 'initialize-release'!release	self dependents do: [:each | self removeDependent: each].	self nilFields.	super release! !!LabelSwitch methodsFor: 'accessing'!label	^labels at: active!labels	^labels!labels: labelArray selectors: selectorArray	"Initialize my instance variables."	active _ 1.	labels _ Array new: labelArray size.	1 to: labels size do: [:label |		labels at: label put: (labelArray at: label) asDisplayText].	selectors _ selectorArray asArray!selector	^selectors at: active!selectors	^selectors!size	^labels size! !!LabelSwitch methodsFor: 'state'!switch	active _ active \\ labels size + 1.	self changed!switchToLabel: aLabel	active _ labels indexOf: aLabel asDisplayText ifAbsent: [active].	self changed!switchToSelector: aSelector	active _ selectors indexOf: aSelector ifAbsent: [active].	self changed! !!LabelSwitch methodsFor: 'updating'!changed	self changed: self selector! !!SyntaxError methodsFor: 'text'!textMenu	"SyntaxError flushMenus"	TextMenu == nil ifTrue:		[TextMenu _ ActionMenu			labels: 'again\undo\copy\cut\paste\do it\print itaccept{Accept and compile the method.}cancelproceed{Continue execution.}' withCRs			lines: #(2 5 7 9)			selectors: #(again undo copySelection cut paste doIt printIt accept cancel proceed)].	^ TextMenu! !!BitBlt methodsFor: 'line drawing'!drawFrom: startPoint to: stopPoint segmentLength: segLen	"draw a line with segments of length segLen"	| offset point1 point2 totLen whiteLen deltaX deltaY |	"Always draw down, or at least left-to-right"	((startPoint y = stopPoint y and: [startPoint x < stopPoint x])		or: [startPoint y < stopPoint y])		ifTrue: [point1 _ startPoint. point2 _ stopPoint]		ifFalse: [point1 _ stopPoint. point2 _ startPoint].	width _ sourceForm width.	height _ sourceForm height.	offset _ sourceForm offset.	destX _ (point1 x + offset x) rounded.	destY _ (point1 y + offset y) rounded.	deltaX _ (point2 x - point1 x) rounded.	deltaY _ (point2 y - point1 y) rounded.	totLen _ (deltaX squared + deltaY squared) sqrt.	whiteLen _ 3.	"let this be min space between segments"	whiteLen _ whiteLen		+ ((totLen \\ (segLen + whiteLen))	"space remaining to be spread over line"		// ((totLen // (segLen + whiteLen)) - 1)).  "num segments - 1 = num spaces"	self drawSegLoopX: deltaX Y: deltaY segLen: segLen spaceLen: whiteLen!drawSegLoopX: xDelta Y: yDelta segLen: segLen spaceLen: spaceLen	"The basics of this are copied from drawLoopX:Y:"	| dx dy px py P i thetaConst draw switchPos soFar originLoc |	dx _ xDelta sign.	dy _ yDelta sign.	px _ yDelta abs.	py _ xDelta abs.	self copyBits.	draw _ true.	soFar _ segLen.	py > px		ifTrue: 			["more horizontal"			thetaConst _ (yDelta abs // xDelta abs) arcTan cos.	"cos theta"			originLoc _ destX.			switchPos _ originLoc + (soFar * thetaConst).			P _ py // 2.			i _ 0.			[(i _ i + 1) <= py]				whileTrue: 					[destX _ destX + dx.					destX > switchPos						ifTrue:							[draw _ draw not.							 switchPos _ originLoc + (thetaConst *								(soFar _ soFar + (draw ifTrue: [segLen] ifFalse: [spaceLen])))].					(P _ P - px) < 0						ifTrue: 							[destY _ destY + dy.							P _ P + py].					draw ifTrue: [self copyBits]]]		ifFalse: 			["more vertical"			thetaConst _ xDelta abs = 0 ifFalse: [(yDelta abs // xDelta abs) arcTan sin "sin theta"] ifTrue: [1].			originLoc _ destY.			switchPos _ originLoc + (soFar * thetaConst).			P _ px // 2.			i _ 0.			[(i _ i + 1) <= px]				whileTrue: 					[destY _ destY + dy.					destY > switchPos						ifTrue:							[draw _ draw not.							 switchPos _ originLoc + (thetaConst *								(soFar _ soFar + (draw ifTrue: [segLen] ifFalse: [spaceLen])))].					(P _ P - py) < 0						ifTrue: 							[destX _ destX + dx.							P _ P + px].					draw ifTrue: [self copyBits]]]! !Pool named: #TextConstants includes: #EndOfRun!Pool named: #TextConstants includes: #CrossedX!!CharacterScanner methodsFor: 'scanning'!characterNotInFont	"All fonts have an illegal character to be used when a character is not within the font's legal range. When characters out of ranged are encountered in scanning text, then this special character indicates the appropriate behavior. The character is usually treated as a unary message understood by a subclass of CharacterScanner."	| illegalAsciiString saveIndex stopCondition ascii | 	saveIndex _ lastIndex.	ascii _ (font strikeFont) maxAscii + 1.	illegalAsciiString	_ (stopConditions at: ascii + 1) == #characterNotInFont		ifTrue: [String with: Character space]		ifFalse: [String with: ascii asCharacter].	outputMedium == #Display		ifTrue:	[stopCondition _ 					self scanCharactersFrom: 1 to: 1						in: illegalAsciiString						rightX: rightMargin						stopConditions: stopConditions						displaying: self doesDisplaying]		ifFalse: [((self isKindOf: CompositionScanner) not					and: [outputMedium == #DisplayPrinterWidths])					ifTrue:	[stopCondition _ 								self scanPrinterWidthsCharactersFrom: 1									to: 1									in: illegalAsciiString									rightX: rightMargin									stopConditions: stopConditions									displaying: self doesDisplaying]					ifFalse:	["#PressPrinter"							stopCondition _ 								self scanPrinterCharactersFrom: 1									to: 1									in: illegalAsciiString									rightX: rightMargin									stopConditions: stopConditions]].	lastIndex _ saveIndex + 1.	stopCondition ~= (stopConditions at: EndOfRun)		ifTrue:	[^self perform: stopCondition]		ifFalse: [lastIndex = runStopIndex					ifTrue:	[^self perform: (stopConditions at: EndOfRun)].				^false]!scanPrinterCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops	| ascii nextDestX |	lastIndex _ startIndex.	[stopIndex >= lastIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			(stops at: ascii + 1) == nil ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ font widthFor: ascii).			rightX < nextDestX ifTrue: [^stops at: CrossedX].			destX _ nextDestX.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun!scanPrinterWidthsCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops displaying: display	"This is a variation of the scanning primitive to allow displaying using printing fonts' widths.  When the fonts are not coordinated, the place they fall on the display may not be the same as where they fall on the printed page.  This allows for a preview of where the characters will actually fall on the printed page and where the line breaks and tabs will actually fall. March through source String from startIndex to stopIndex. If any character is flagged with a non-nil entry in stops, then return the corresponding value. Determine width of each character from xTable. If dextX would exceed rightX, then return stops at: 258. If displaying is true, then display the character. Advance destX by the width of the character. If stopIndex has been reached, then return stops at: 257."	| ascii nextDestX scanningXTable scale |	scale _ textStyle pressScale.	scanningXTable _ (font strikeFont) xTable.		"BitBlt will want Display widths"	lastIndex _ startIndex.	[stopIndex >= lastIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			(stops at: ascii + 1) == nil ifFalse: [^stops at: ascii + 1].			sourceX _ scanningXTable at: ascii + 1.	"use Alto glyphs"			width _ ((scanningXTable at: ascii + 2) - sourceX).	"Display width"			nextDestX _ destX + (font widthFor: ascii). 		"Printer width"			rightX < nextDestX ifTrue: [^stops at: CrossedX].			display				ifTrue:	[destX _ destX // scale.						self copyBits].			destX _ nextDestX.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CompositionScanner methodsFor: 'accessing'!rightX	"Meaningful only when a line has just been composed -- refers to the line most recently composed.  This is a subtrefuge to allow for easy resizing of a composition rectangle to the width of the maximum line.  Useful only when there is only one line in the form or when each line is terminated by a carriage return.  Handy for sizing menus and lists."	outputMedium = #DisplayPrinterWidths		ifTrue:	[^spaceX + textStyle pressScale // textStyle pressScale]		ifFalse:	[^spaceX].! !!CompositionScanner methodsFor: 'scanning'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	lastIndex _ startIndex.		"scanning sets last index"	line _ 		TextLineInterval			start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0.	self setStopConditions.		"also sets font and height on line"	spaceX _ destX _ leftMargin _		(aParagraph leftMarginForCompositionForStartIndex: startIndex). "changed for database indenting"	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue:		[self error: 'No room between margins to compose'].	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[outputMedium = #Display				ifTrue:					[stopCondition _ 						self 							scanCharactersFrom: lastIndex							to: runStopIndex							in: text string							rightX: rightMargin							stopConditions: stopConditions							displaying: false]				ifFalse: [stopCondition _ 							self scanPrinterCharactersFrom: lastIndex									to: runStopIndex									in: text string									rightX: rightMargin									stopConditions: stopConditions].			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition) ifTrue: [^line]]! !Pool named: #TextConstants includes: #Space!!CompositionScanner methodsFor: 'stop conditions'!crossedX	"There is a word that has fallen across the right edge of the composition rectangle.  This signals the need for wrapping which is done to the last space that was encountered, as recorded by the space stop condition."	spaceCount > 0 ifTrue: [line stop: spaceIndex].	spaceCount > 1			ifTrue:	["The common case. First back off the space at which we wrap."				spaceCount _ spaceCount - 1.				spaceIndex _ spaceIndex - 1.				["Check to see if any spaces preceding the one at which we wrap.					Double space after a period, most likely."				(spaceCount > 0 and: [(text at: spaceIndex) = Space])]					whileTrue:						[spaceCount _ spaceCount - 1.						spaceIndex _ spaceIndex - 1.						"Account for backing over a run which might							change width of space."						font _ self resetFont.						spaceX _ spaceX - (font widthOf: Space)].						line paddingWidth: rightMargin - spaceX.						line internalSpaces: spaceCount]		ifFalse:	[spaceCount = 1					ifTrue:	["wrap at space, but no internal spaces"							line internalSpaces: 0.							line paddingWidth: rightMargin - spaceX]					ifFalse:	["Neither internal nor trailing spaces, almost never happen,								she says confidently."							lastIndex _ lastIndex - 1.							[destX <= rightMargin]							whileFalse:								[destX _ destX - (font widthOf:													(text at: lastIndex)).										"bug --doesn't account for backing over										 run and changing actual width of										characters. Also doesn't account for										backing over a tab.  Happens only										when no spaces in line, presumably rare."								lastIndex _ lastIndex - 1].							spaceX _ destX.							line paddingWidth: rightMargin - destX.							lastIndex < line first								ifTrue:	[line stop: line first]								ifFalse:	[line stop: lastIndex]]].	^true!onePixelBackspace	"Decrement destX by 1. "	destX _ (destX - textStyle pressScale) max: leftMargin.	lastIndex _ lastIndex + 1.	^false!onePixelSpace	"Increment destX by 1. "	destX _ destX + textStyle pressScale.	lastIndex _ lastIndex + 1.	destX > rightMargin ifTrue: 	[^self crossedX].	^false!setStopConditions	"Set the font and the stop conditions for the current run."	(outputMedium = #PressPrinter or: [outputMedium = #DisplayPrinterWidths])		ifTrue:	[font _ (textStyle fontAt: (text emphasisAt: lastIndex)) asPrinterWidthsFont]		ifFalse:	[font _ textStyle fontAt: (text emphasisAt: lastIndex)].	super setStopConditions! !!CompositionScanner methodsFor: 'private'!resetFont	"Mainly to allow the stop condition crossedX to be shared by display and printer media."	(outputMedium = #PressPrinter or: [outputMedium = #DisplayPrinterWidths])		ifTrue:[^(textStyle fontAt: (text emphasisAt: spaceIndex)) asPrinterWidthsFont]		ifFalse:	[^ textStyle fontAt: (text emphasisAt: spaceIndex)]! !TablesCompositionScanner comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!TablesCompositionScanner methodsFor: 'scanning'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph width: aWidth	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	lastIndex _ startIndex.		"scanning sets last index"	line _ 		TextLineInterval			start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0.	self setStopConditions.		"also sets font and height on line"	spaceX _ destX _ leftMargin _ 0.	rightMargin _ aWidth.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			["outputMedium = #Display				ifTrue:					[stopCondition _ 						self 							scanCharactersFrom: lastIndex							to: runStopIndex							in: text string							rightX: rightMargin							stopConditions: stopConditions							displaying: false]				ifFalse: ["stopCondition _ 							self scanPrinterCharactersFrom: lastIndex									to: runStopIndex									in: text string									rightX: rightMargin									stopConditions: stopConditions"]".			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition) ifTrue: [^line]]! !PreviewCompositionScanner comment:'Copyright (c) Xerox Corporation, 1986, 1987. All rights reserved.Class Variable[MinimumSpacing]		this is the spacing where you may tell the program so that it will not compose any text for a line if the space between the right and left margins is less than MinimumSpacing. '!!PreviewCompositionScanner methodsFor: 'scanning'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph with: rect	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition scale |	lastIndex _ startIndex.		"scanning sets last index"	line _ PreviewTextLineInterval			start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0 margins: aParagraph margins alignment: 3.	self setStopConditions.		"also sets font and height on line".	spaceX _ destX _ leftMargin _ line lMargin.		outputMedium == #DisplayPrinterWidths		ifTrue:	[scale _ textStyle pressScale]		ifFalse:	[scale _ 1].	rightMargin _ ((rect width		- (aParagraph textStyle rightMarginTabAt: aParagraph marginTabsLevel) - aParagraph rightIndent) * scale) -  line rMargin.	leftMargin >= (rightMargin - MinimumSpacing) ifTrue:		[line stop: lastIndex - 1. ^ line]. "this signifies that there is no room to compose therefore shift down a line - Irwin 12/84"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	tabWidth _ 0.	currentTab _ 0.	spaceCount _ 0.	[tabWidth > 0		ifTrue:			[stopCondition _ 				self 					scanPrinterCharactersFrom: lastIndex					to: runStopIndex					in: text string					rightMargin: rightMargin					stopConditions: stopConditions]		ifFalse:			[stopCondition _ 				self					scanPrinterCharactersFrom: lastIndex					to: runStopIndex					in: text string					rightX: rightMargin					stopConditions: stopConditions].	 "See setStopConditions for stopping conditions for composing."	 (self perform: stopCondition)] whileFalse: [].	^line!nextTabXFrom: anX	"Tab stops are distances from the leftMargin. Set the distance into anX normalized for the paragraph's left margin. Scale makes the routine usable for printing. On the display the scale is 1."	| tabX newTabX |	1 to: tabsArray size do: 		[:i | (tabX _ (tabsArray at: i) asInteger) > anX				ifTrue: [newTabX _ tabX min: rightMargin.						currentTab _ tabTypesArray at: i.						currentTab > 1 ifTrue: [tabWidth _ newTabX - anX] ifFalse: [0].						^newTabX]].	currentTab _ tabWidth _ 0."	tabWidth _ rightMargin - anX."	^rightMargin!scanPrinterCharactersFrom: startIndex to: stopIndex in: sourceString rightMargin: rightX stopConditions: stops	| ascii nextDestX aStop totalTabWidth |	stops at: 33 put: nil.	lastIndex _ startIndex.	totalTabWidth _ tabWidth.	[stopIndex >= lastIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			(aStop _ stops at: ascii + 1) == nil				ifFalse: [stops at: 33 put: #space.						(#(cr ff tab) includes: aStop)							ifTrue: [destX _ destX + totalTabWidth].						^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			width _ font widthFor: ascii.			(currentTab = 4				ifTrue: [tabWidth > width and: [ascii ~= 46]]				ifFalse: [currentTab = 2							ifTrue: [width _ width // 2. tabWidth > width]							ifFalse: [tabWidth > width]])				ifTrue: [ascii = 32							ifTrue: [spaceIndex _ lastIndex.									spaceCount _ spaceCount + 1.									spaceX _ destX + totalTabWidth - tabWidth.].						currentTab = 2							ifTrue: [nextDestX _ destX + width.									nextDestX + totalTabWidth > rightX										ifTrue: [destX _ destX + totalTabWidth.												stops at: 33 put: #space.												^stops at: CrossedX].									destX _ nextDestX].						tabWidth _ tabWidth - width]				ifFalse: [destX _ destX + totalTabWidth.						self adjustTabPosition.						lastIndex > startIndex ifTrue: [lastIndex _ lastIndex - 1].						stops at: 33 put: #space.						^#continueCompose].			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	destX _ destX + (totalTabWidth - tabWidth).	^stops at: EndOfRun! !!PreviewCompositionScanner methodsFor: 'stop conditions'!adjustTabPosition	"Adjust tab position to compensate right and center tabs."	tabWidth > 0		ifTrue: [line reverseAdjustBy: tabWidth untilTypeIs: #(#tab #runTab).				tabWidth _ 0].!characterNotInFont	text _ text copyReplaceFrom: lastIndex				to: lastIndex				with: (Text string: ' ' emphasis: (text emphasisAt: lastIndex)).	^super characterNotInFont!continueCompose	^false!cr	"Answer true.  Sets up values for the text line interval currently being composed."	lastIndex = runStopIndex		ifTrue: [line updateInterpressVarPos: destX type: #run.				line updateInterpressVarCharIndex: lastIndex.				line rememberSpaceCount: spaceCount].	line stop: lastIndex.	spaceX _ destX.	line paddingWidth: rightMargin - destX.	self adjustTabPosition.	^true!crossedX	| return | 	return _ super crossedX.	self adjustTabPosition.	^return!endOfRun	"Answer true if scanning has reached the end of the paragraph.  Otherwise set stop conditions (mostly install potential new font) and answer false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			destX _ destX + tabWidth.			spaceX _ destX.			line paddingWidth: rightMargin - destX.			self adjustTabPosition.			^true]	ifFalse:	[(line hasDelimitors and: [lastIndex = line lastDelimitorIndex])				ifTrue: [line delimitorType: #runTab]				ifFalse: [line updateInterpressVarPos: destX type: #run.						line updateInterpressVarCharIndex: lastIndex.						line rememberSpaceCount: spaceCount].			runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).			runStopIndex _ lastIndex + (runLength - 1).			self setStopConditions.			^false]!ff"'ff'(form feed) needs page alternation. So line breakes here."	line stop: lastIndex.	line paddingWidth: rightMargin - destX.	self adjustTabPosition.	^true!initSpecialStops	"Set the font and the stop conditions for the current run."	super initSpecialStops.	stopConditions at: 13 put: #ff.!space	"Record left x and character index of the space character just encounted.  Used for wrap-around.  Answer whether the character has crossed the right edge of the composition rectangle of the paragraph."	spaceX _ destX.	destX _ spaceX + spaceWidth.	lastIndex _ (spaceIndex _ lastIndex) + 1.	spaceCount _ spaceCount + 1.	rightMargin < destX		ifTrue: [spaceIndex = runStopIndex					ifTrue: [line updateInterpressVarPos: destX type: #run.							line updateInterpressVarCharIndex: spaceIndex.							line rememberSpaceCount: spaceCount].				^self crossedX].	^false!tab	| nextDestX | 	"Advance destination x according to tab settings in the paragraph's textStyle.  Answer whether the character has crossed the right edge of the composition rectangle of the paragraph.  Scale allows use of same code for display and printing composition"	self adjustTabPosition.	nextDestX _ self nextTabXFrom: destX.	rightMargin <"=" nextDestX		ifTrue: [lastIndex = runStopIndex					ifTrue: [line updateInterpressVarPos: nextDestX type: #runTab.							line updateInterpressVarCharIndex: lastIndex.							line rememberSpaceCount: spaceCount].				destX _ nextDestX. ^self crossedX].	currentTab "<"= 1 ifTrue: [destX _ nextDestX].	line updateInterpressVarPos: destX type: #tab.	line updateInterpressVarCharIndex: lastIndex.	line rememberSpaceCount: spaceCount.	lastIndex _ lastIndex + 1.	^false! !!PreviewCompositionScanner methodsFor: 'initialize-release'!in: aParagraph	"Initialize the paragraph to be scanned as the argument, aParagraph.  Set the composition frame for the paragraph."	super initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	tabWidth _ 0.	currentTab _ 0.	self setTabs: aParagraph tabs!setTabs: aTabsArray	tabsArray _ aTabsArray first.	tabTypesArray _ aTabsArray last.	marginTabsArray _ Array new: tabsArray size.	1 to: tabsArray size		do: [:i | marginTabsArray at: i put: (Array with: (tabsArray at: i) with: (tabsArray at: i))].! !FastTextDisplayScanner comment:'Copyright (c) Xerox Corporation, 1987.  All rights reserved.'!!FastTextDisplayScanner methodsFor: 'initialize-release'!infoSize: anInteger1 cacheSize: anInteger2	| r |	myFalse _ false.	myText _ Text new: 1.	startIndices _ Array new: (infoSize _ anInteger1).	stopIndices _ Array new: anInteger1.	lineWidths _ Array new: anInteger1.	stopsCache _ LRUCacheDictionary new: anInteger2.	sourceY _ 0.	font _ nil.! !!FastTextDisplayScanner methodsFor: 'accessing'!infoSize	^infoSize! !!FastTextDisplayScanner methodsFor: 'displaying'!displayString: aString emphasis: anInteger on: aForm at: aPoint clippingBox: aRectangle	| cx cy p1 p2 ra |	(ra _ myText runs) runs at: 1 put: aString size.	ra values at: 1 put: anInteger.	self		displayText:			(myText setString: aString setRuns: ra)		textStyle: DefaultTextStyle		destForm: aForm		leftMargin: aPoint x		rightMargin: 8000		destY: aPoint y		halftoneForm: nil		combinationRule: "Form over" 3		clipX: (cx _ (p1 _ aRectangle origin) x)		clipY: (cy _ p1 y)		clipWidth: (p2 _ aRectangle corner) x - cx		clipHeight: p2 y - cy.!displayString: aString emphasis: anInteger1 on: aForm1 at: aPoint clippingBox: aRectangle rule: anInteger2 mask: aForm2	| cx cy p1 p2 ra |	(ra _ myText runs) runs at: 1 put: aString size.	ra values at: 1 put: anInteger1.	self		displayText:			(myText setString: aString setRuns: ra)		textStyle: DefaultTextStyle		destForm: aForm1		leftMargin: aPoint x		rightMargin: 8000		destY: aPoint y		halftoneForm: aForm2		combinationRule: anInteger2		clipX: (cx _ (p1 _ aRectangle origin) x)		clipY: (cy _ p1 y)		clipWidth: (p2 _ aRectangle corner) x - cx		clipHeight: p2 y - cy.!displayText: aText on: aForm at: aPoint clippingBox: aRectangle	| cx cy p1 p2 ra |	self		displayText: aText		textStyle: DefaultTextStyle		destForm: aForm		leftMargin: aPoint x		rightMargin: 8000		destY: aPoint y		halftoneForm: nil		combinationRule: "Form over" 3		clipX: (cx _ (p1 _ aRectangle origin) x)		clipY: (cy _ p1 y)		clipWidth: (p2 _ aRectangle corner) x - cx		clipHeight: p2 y - cy.!displayText: aText textStyle: aTextStyle destForm: aForm leftMargin: aLeftMargin rightMargin: aRightMargin destY: aDestY halftoneForm: aHalftoneForm combinationRule: aCombinationRule clipX: aClipX clipY: aClipY clipWidth: aClipWidth clipHeight: aClipHeight	| al fa i ri rn rv st temp1 temp2 temp3 "spare1 spare2" |	text _ aText.	leftMargin _ aLeftMargin +		(textStyle _ aTextStyle) restIndent.	rightMargin _ aRightMargin - aTextStyle rightIndent.	destY _ aDestY.	halftoneForm _ aHalftoneForm.	combinationRule _ aCombinationRule.	clipX _ aClipX.	clipY _ aClipY.	clipWidth _ aClipWidth.	clipHeight _ aClipHeight.	(	(destForm _ aForm) class == DisplayScreen		or: [aForm class == Form.]	) ifFalse: [^self puntDisplay].	(temp3 _ (st _ aText string) size) = 0 ifTrue: [^self].	(temp2 _ (rn _ (temp1 _ aText runs) runs) size) +		temp3 >= infoSize ifTrue: [^self puntDisplay].	rv _ temp1 values.	(al _ aTextStyle alignment) > 2 ifTrue: [^self puntDisplay].	fa _ aTextStyle fontArray.	destX _ temp3 _ aLeftMargin + aTextStyle firstIndent.	maxLineWidth _ spaceIndex _ lastIndex _ i _ ri _ runCount _ 0.	lineCount _ 1.	[startIndices at: (runCount _ runCount + 1) put: i + 1.	i _ i + (rn at: (ri _ ri + 1)).	font == (font _ fa at: (rv at: ri)) ifFalse:		[font emphasis = 0 ifFalse:			[font _ nil.			^self puntDisplay			].		self setStopConditions.		].			[	(temp1 _ self					scanCharactersFrom: (lastIndex _ lastIndex + 1)					to: i in: st rightX: rightMargin					stopConditions: stopConditions displaying: false				) == #space					ifTrue:						[spaceIndex _ lastIndex.						(destX _ (spaceX _ destX) + spaceWidth)							> rightMargin								ifTrue: [self crossedX.]								ifFalse: [true.].						]					ifFalse: [self perform: temp1.].			] whileTrue: [].	temp1 == #abort ifTrue: [^self puntDisplay].	lineWidths at: lineCount put: destX.	stopIndices at: runCount put: i.	ri < temp2.	] whileTrue: [].	lastIndex _ i _ ri _ 0.	destX _ al = 0		ifTrue: [temp3.]		ifFalse: [rightMargin - (lineWidths at: 1) // al + temp3.].	destY _ destY + aTextStyle baseline - (temp3 _ font ascent).	temp1 _ 1.	temp2 _ aTextStyle lineGrid.	[lastIndex < i		ifTrue:			[destX _ al = 0				ifTrue: [leftMargin.]				ifFalse:					[rightMargin - (lineWidths at: temp1)						// al + leftMargin.					].			destY _ destY + temp2.			]		ifFalse:			[i _ i + (rn at: (ri _ ri + 1)).			font == (font _ fa at: (rv at: ri)) ifFalse:				[destY _ destY + temp3.				sourceForm _ font glyphs.				xTable _ font xTable.				height _ font height.				destY _ destY - (temp3 _ font ascent).				].			].		self			scanCharactersFrom: (startIndices at: temp1)			to: (stopIndices at: temp1) in: st			rightX: 8000 stopConditions: NoStops			displaying: true.	(temp1 _ temp1 + 1) <= runCount.	] whileTrue: [].! !!FastTextDisplayScanner methodsFor: 'stop conditions'!abort	^myFalse!cr	spaceIndex _ 0.	stopIndices at: runCount put: lastIndex - 1.	lineWidths at: lineCount put: destX.	maxLineWidth < destX ifTrue: [maxLineWidth _ destX.].	startIndices at: (lineCount _ runCount _ runCount + 1)		put: lastIndex + 1.	destX _ leftMargin.	^true!crossedX	| i |	spaceIndex > 0		ifTrue:			[stopIndices at: runCount put:				(lastIndex _ spaceIndex) - 1.			lineWidths at: lineCount put: spaceX.			maxLineWidth < spaceX ifTrue:				[maxLineWidth _ spaceX.].			startIndices				at: (lineCount _ runCount _ runCount + 1)				put: spaceIndex + 1.			destX _ leftMargin.			spaceIndex _ 0.			]		ifFalse:			[stopIndices at: runCount put: lastIndex - 1.			lineWidths at: lineCount put: destX.			maxLineWidth < destX ifTrue:				[maxLineWidth _ destX.].			startIndices				at: (lineCount _ runCount _ runCount + 1)				put: lastIndex.			i _ (text string at: lastIndex) asciiValue.			destX _ leftMargin + (xTable at: i + 2)				- (xTable at: i + 1).			].	^true!endOfRun	^myFalse!setStopConditions	| i sc |	sourceForm _ font glyphs.	xTable _ font xTable.	height _ font height.	spaceWidth _ (xTable at: 34) - (xTable at: 33).	stopConditions _ stopsCache find: font ifAbsentUseResultOf:		[StopsCache find: font ifAbsentUseResultOf:			[sc _ font stopConditions.			stopConditions _ Array new: 258.			i _ 1.				[(sc at: i) == nil ifFalse:					[stopConditions at: i put: #abort.].				(i _ i + 1) < 258.				] whileTrue: [].			stopConditions				at: "CR asciiValue + 1" 14 put: #cr;				at: "Space asciiValue + 1" 33 put: #space;				at: "EndOfRun" 257 put: #endOfRun;				at: "CrossedX" 258 put: #crossedX.			stopConditions.			].		].! !!FastTextDisplayScanner methodsFor: 'converting'!formFromString: aString emphasis: anInteger	| ra |	(ra _ myText runs) runs at: 1 put: aString size.	ra values at: 1 put: anInteger.	^self		formFromText:			(myText setString: aString setRuns: ra)		textStyle: DefaultTextStyle		maxWidth: 8000!formFromText: aText textStyle: aTextStyle maxWidth: anInteger	| al as fa fx i j lg lx ra ri rn rs rv rx sc st sz "spare1 spare2 spare3 spare4" |	(sz _ (st _ aText string) size) = 0		ifTrue: [^Form new extent: 0@0].	leftMargin _ (lx _ (textStyle _ aTextStyle) restIndent).	rightMargin _ anInteger - (rx _ aTextStyle rightIndent).	destY _ 0.	halftoneForm _ nil.	combinationRule _ "Form over" 3.	clipX _ clipY _ 0.	clipWidth _ clipHeight _ 8000.	(rs _ (rn _ (ra _ (text _ aText) runs) runs) size) +		sz >= infoSize ifTrue: [^self punt asForm].	rv _ ra values.	(al _ aTextStyle alignment) > 2 ifTrue: [^self punt asForm].	fa _ aTextStyle fontArray.	destX _ fx _ aTextStyle firstIndent.	maxLineWidth _ spaceIndex _		lastIndex _ i _ ri _ runCount _ 0.	lineCount _ 1.	[startIndices at: (runCount _ runCount + 1) put: i + 1.	i _ i + (rn at: (ri _ ri + 1)).	font == (font _ fa at: (rv at: ri)) ifFalse:		[font emphasis = 0 ifFalse:			[font _ nil.			^self punt asForm			].		self setStopConditions.		].			[	(sc _ self					scanCharactersFrom: (lastIndex _ lastIndex + 1)					to: i in: st rightX: rightMargin					stopConditions: stopConditions displaying: false				) == #space					ifTrue:						[spaceIndex _ lastIndex.						(destX _ (spaceX _ destX) + spaceWidth)							> rightMargin								ifTrue: [self crossedX.]								ifFalse: [true.].						]					ifFalse: [self perform: sc.].			] whileTrue: [].	sc == #abort ifTrue: [^self punt asForm].	lineWidths at: lineCount put: destX.	destX > maxLineWidth ifTrue: [maxLineWidth _ destX.].	stopIndices at: runCount put: i.	ri < rs.	] whileTrue: [].	lastIndex _ i _ ri _ 0.	destForm _ Form new		extent:			(rightMargin _ maxLineWidth + rx) @				((runCount - rs + 1) * (lg _ aTextStyle lineGrid)).	destX _ al = 0		ifTrue: [fx.]		ifFalse: [rightMargin - (lineWidths at: 1) // al + fx.].	destY _ aTextStyle baseline - (as _ font ascent).	j _ 1.	[lastIndex < i		ifTrue:			[destX _ al = 0				ifTrue: [lx.]				ifFalse:					[rightMargin - (lineWidths at: j) // al + lx.].			destY _ destY + lg.			]		ifFalse:			[i _ i + (rn at: (ri _ ri + 1)).			font == (font _ fa at: (rv at: ri)) ifFalse:				[destY _ destY + as.				sourceForm _ font glyphs.				xTable _ font xTable.				height _ font height.				destY _ destY - (as _ font ascent).				].			].		self			scanCharactersFrom: (startIndices at: j)			to: (stopIndices at: j) in: st			rightX: 8000 stopConditions: NoStops			displaying: true.	(j _ j + 1) <= runCount.	] whileTrue: [].	^destForm! !!FastTextDisplayScanner methodsFor: 'widths'!widthOfString: aString emphasis: anInteger	| ra |	(ra _ myText runs) runs at: 1 put: aString size.	ra values at: 1 put: anInteger.	^self		widthOfText:			(myText setString: aString setRuns: ra)		textStyle: DefaultTextStyle		maxWidth: 8000!widthOfText: aText textStyle: aTextStyle maxWidth: anInteger	| fa fx i lx ra ri rn rs rv rx sc st sz |	(sz _ (st _ aText string) size) = 0 ifTrue: [^0].	leftMargin _ (lx _ (textStyle _ aTextStyle) restIndent).	rightMargin _ anInteger - (rx _ aTextStyle rightIndent).	destY _ 0.	halftoneForm _ nil.	combinationRule _ "Form over" 3.	clipX _ clipY _ 0.	clipWidth _ clipHeight _ 8000.	(rs _ (rn _ (ra _ (text _ aText) runs) runs) size) +		sz >= infoSize ifTrue: [^self punt width].	rv _ ra values.	fa _ aTextStyle fontArray.	destX _ fx _ aTextStyle firstIndent.	maxLineWidth _ spaceIndex _		lastIndex _ i _ ri _ runCount _ 0.	lineCount _ 1.	[startIndices at: (runCount _ runCount + 1) put: i + 1.	i _ i + (rn at: (ri _ ri + 1)).	font == (font _ fa at: (rv at: ri)) ifFalse:		[font emphasis = 0 ifFalse:			[font _ nil.			^self punt width			].		self setStopConditions.		].			[	(sc _ self					scanCharactersFrom: (lastIndex _ lastIndex + 1)					to: i in: st rightX: rightMargin					stopConditions: stopConditions displaying: false				) == #space					ifTrue:						[spaceIndex _ lastIndex.						(destX _ (spaceX _ destX) + spaceWidth)							> rightMargin								ifTrue: [self crossedX.]								ifFalse: [true.].						]					ifFalse: [self perform: sc.].			] whileTrue: [].	sc == #abort ifTrue: [^self punt width].	lineWidths at: lineCount put: destX.	destX > maxLineWidth ifTrue: [maxLineWidth _ destX.].	stopIndices at: runCount put: i.	ri < rs.	] whileTrue: [].	^maxLineWidth + rx! !!FastTextDisplayScanner methodsFor: 'private'!punt	^Paragraph new		compositionRectangle:			(0@0 corner: rightMargin +				textStyle rightIndent @ 8000			)		text: text		style: textStyle		offset: 0@0		outputMedium: #Display		fitWidth: true!puntDisplay	| r |	(Paragraph		withText: text		style: textStyle		compositionRectangle:			((leftMargin _ leftMargin - textStyle restIndent) @ 0				corner: rightMargin + textStyle rightIndent @ 8000			)		clippingRectangle:			(r _ clipX @ clipY extent: clipWidth @ clipHeight)	)		displayOn: destForm		at: leftMargin + 1 @ destY		clippingBox: r		rule: combinationRule		mask: halftoneForm! !!CharacterBlockScanner methodsFor: 'scanning'!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It is assumed that aPoint has been transformed into coordinates appropriate to the text's destinationForm rectangle and the compositionRectangle."	super initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint _ aPoint.	outputMedium = #DisplayPrinterWidths		ifTrue:	[characterPoint x: (characterPoint x * textStyle pressScale)].	^self buildCharacterBlockIn: aParagraph!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The coordinates in the CharacterBlock will be appropriate to the intersection of the destinationForm rectangle and the compositionRectangle."	super 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex _ targetIndex.	characterPoint _ 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !Pool named: #TextConstants includes: #Justified!Pool named: #TextConstants includes: #Space!!CharacterBlockScanner methodsFor: 'stop conditions'!onePixelBackspace	"Decrement destX by 1 pixel size."	| characterWidth |	characterWidth _ textStyle pressScale.	lastCharacterExtent x: characterWidth.	lastIndex _ lastIndex + 1.	destX _ (destX - characterWidth) max: leftMargin.	^ false!onePixelSpace	"Increment destX by 1 pixel size."	| characterWidth |	characterWidth _ textStyle pressScale.	lastCharacterExtent x: characterWidth.	(destX + characterWidth)  >= characterPoint x		ifTrue: [^self crossedX].	lastIndex _ lastIndex + 1.	destX _ destX + characterWidth.	^ false!setStopConditions	"Set the font and the stop conditions for the current run."	outputMedium = #PressPrinter		ifTrue:	[font _ PressFont fontName:							(textStyle fontAt: (text emphasisAt: lastIndex)) name]		ifFalse:	[outputMedium = #DisplayPrinterWidths					ifTrue:	[font _ (textStyle fontAt: (text emphasisAt: lastIndex)) asPrinterWidthsFont]					ifFalse:	[font _ textStyle fontAt: (text emphasisAt: lastIndex)]].	super setStopConditions.	stopConditions 		at: Space asInteger + 1 		put: (textStyle alignment = Justified				ifTrue: [#paddedSpace]				ifFalse: [nil])! !!CharacterBlockScanner methodsFor: 'private'!buildCharacterBlockIn: aParagraph	| lineIndex runLength lineStop characterBlock done stopCondition |	"handle nullText"	(aParagraph numberOfLines = 0 or: [text size = 0])		ifTrue:	[leftMargin _ (aParagraph leftMarginForDisplayForLine: 1) //								textStyle pressScale.				^CharacterBlock					stringIndex: 1	"like being off end of string"					character: nil					topLeft: (leftMargin @								(aParagraph compositionRectangle) top)					extent: (0 @ textStyle lineGrid)].	"find the line"	lineIndex _ aParagraph lineIndexOfTop: characterPoint y.	destY _ (aParagraph topAtLineIndex: lineIndex).	line _ aParagraph lineAt: lineIndex.	text _ aParagraph textAt: lineIndex.	rightMargin _ aParagraph rightMarginForDisplay.	(lineIndex = aParagraph numberOfLines and:		[(destY + textStyle lineGrid) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					characterPoint x: rightMargin]			ifFalse:	[characterPoint y < (aParagraph compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _								(aParagraph compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[characterPoint x: rightMargin]].	destX _ leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.	nextLeftMargin_ aParagraph leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex	"scanning for index"]		ifFalse:	[lineStop _ line last].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ textStyle lineGrid.	spaceCount _ 0. done  _ false.	[done]	whileFalse:	[outputMedium = #DisplayPrinterWidths		ifTrue:	[stopCondition _ 					self scanPrinterWidthsCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: characterPoint x						stopConditions: stopConditions						displaying: false]		ifFalse:	["#Display or #PressPrinter"				stopCondition _ 					self scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: characterPoint x						stopConditions: stopConditions						displaying: false].		"see setStopConditions for stopping conditions for character block 	operations."	lastCharacterExtent x: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition)		ifTrue:	[outputMedium = #DisplayPrinterWidths					ifTrue:	[characterPoint x:  (characterPoint x // textStyle pressScale).							lastCharacterExtent x:								(lastCharacterExtent x // textStyle pressScale)].				^CharacterBlock					stringIndex: lastIndex					character: lastCharacter					topLeft: characterPoint					extent: lastCharacterExtent]]! !PreviewCharacterBlockScanner comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewCharacterBlockScanner methodsFor: 'initialize-release'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	lineLead _ (aParagraph var at: #grid) y! !!PreviewCharacterBlockScanner methodsFor: 'private'!buildCharacterBlockIn: aParagraph within: aColRect	| lineIndex runLength lineStop characterBlock done stopCondition s offset |	"handle nullText"	s _ textStyle pressScale.	(aParagraph numberOfLines = 0 or: [text size = 0])		ifTrue:	[leftMargin _ (aParagraph leftMarginForDisplayForLine: 1) //s.				^CharacterBlock					stringIndex: 1	"like being off end of string"					character: nil					topLeft: (leftMargin @aColRect top)					extent: (0 @ lineLead)].	"find the line"	lineIndex _ aParagraph lineIndexOfPoint: (characterPoint x//s)@characterPoint y.	line _ aParagraph lineAt: lineIndex.	line first > line last		ifTrue: [^CharacterBlock					stringIndex: line first					character: (text at: line first)					topLeft: (characterPoint x//s)@characterPoint y					extent: (0 @ lineLead)].	text _ aParagraph textAt: lineIndex.	rightMargin _ (aColRect right - aParagraph rightIndent - (textStyle rightMarginTabAt: aParagraph marginTabsLevel)) * s."	rightMargin _ aParagraph rightMarginForDisplay."	offset _ aColRect left - aParagraph clippingRectangle left * s.	destX _ leftMargin _ (aParagraph leftMarginForDisplayForLine: lineIndex) + offset.	nextLeftMargin_ (aParagraph leftMarginForDisplayForLine: (lineIndex+1 min: aParagraph lastLine)) + offset.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex	"scanning for index"]		ifFalse:	[lineStop _ line last].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	destY _ (aParagraph topAtLineIndex: lineIndex) + font strikeFont height - font strikeFont ascent.	lastCharacterExtent _ 0 @ lineLead.	spaceCount _ 0. done  _ false.	[done]	whileFalse:	[stopCondition _ 			self scanPrinterWidthsCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: characterPoint x						stopConditions: stopConditions.	"see setStopConditions for stopping conditions for character block operations."	lastCharacterExtent x: ((text at: lastIndex) = $ 				ifTrue: [spaceWidth] ifFalse: [font widthOf: (text at: lastIndex)]).	(self perform: stopCondition)		ifTrue:	[characterPoint x: (characterPoint x // s).				lastCharacterExtent x: (lastCharacterExtent x // s).				^CharacterBlock					stringIndex: lastIndex					character: lastCharacter					topLeft: characterPoint					extent: lastCharacterExtent]]!characterBlockAtPoint: aPoint in: aParagraph within: aColRect	"Answer a CharacterBlock for character in aParagraph at point aPoint. It is assumed that aPoint has been transformed into coordinates appropriate to the text's destinationForm rectangle and the compositionRectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint _ aPoint.	characterPoint x: (characterPoint x * textStyle pressScale).	^self buildCharacterBlockIn: aParagraph within: aColRect!characterBlockForIndex: targetIndex in: aParagraph	| lineIndex aColRect |  	"Answer a CharacterBlock for character in aParagraph at targetIndex. The coordinates in the CharacterBlock will be appropriate to the intersection of the destinationForm rectangle and the compositionRectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex _ targetIndex.	lineIndex _ (aParagraph lineIndexOfCharacterIndex: characterIndex).	aColRect _ aParagraph colContainsLine: lineIndex.	characterPoint _ 		(aColRect right - aParagraph rightIndent - (textStyle rightMarginTabAt: aParagraph marginTabsLevel)) * textStyle pressScale @ (aParagraph topAtLineIndex: lineIndex).	^self buildCharacterBlockIn: aParagraph within: aColRect!scanPrinterWidthsCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops	"This is a variation of the scanning primitive to allow displaying using printing fonts' widths.  When the fonts are not coordinated, the place they fall on the display may not be the same as where they fall on the printed page.  This allows for a preview of where the characters will actually fall on the printed page and where the line breaks and tabs will actually fall. March through source String from startIndex to stopIndex. If any character is flagged with a non-nil entry in stops, then return the corresponding value. Determine width of each character from xTable. If dextX would exceed rightX, then return stops at: 258. If displaying is true, then display the character. Advance destX by the width of the character. If stopIndex has been reached, then return stops at: 257."	| ascii nextDestX scanningXTable |	scanningXTable _ (font strikeFont) xTable.		"BitBlt will want Display widths"	lastIndex _ startIndex.	[stopIndex >= lastIndex]	whileTrue: 		[ascii _ (sourceString at: lastIndex) asciiValue.		ascii = 32			ifTrue: [nextDestX _ destX + spaceWidth]			ifFalse: [(stops at: ascii + 1) == nil ifFalse: [^stops at: ascii + 1].					sourceX _ scanningXTable at: ascii + 1.	"use Alto glyphs"					width _ ((scanningXTable at: ascii + 2) - sourceX).	"Display width"					nextDestX _ destX + (font widthFor: ascii)]. 		"Printer width"		rightX < nextDestX ifTrue: [^stops at: CrossedX].		destX _ nextDestX.		lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!PreviewCharacterBlockScanner methodsFor: 'stop conditions'!crossedX	"Text display has wrapping.  The scanner just found a character past the x location of the cursor.  We know that the cursor is pointing at a character or before one."	| leadingTab currentX |	((characterPoint x <= (destX + ((lastCharacterExtent x) // 2)))		or: [line last = lastIndex])		ifTrue:	[lastCharacter _ text at: lastIndex.							((lastCharacter = Space and: [line alignment = Justified])					and: [destX + lastCharacterExtent x > rightMargin])					ifTrue:	[characterPoint _ nextLeftMargin @ (destY + lineLead).							characterIndex notNil								ifTrue:	[lastIndex _ (characterIndex min: (line last + 1))]								ifFalse:	[lastIndex _ (lastIndex + 1) min: (line last + 1)]]					ifFalse:	[((lastCharacter = Tab) and: [line last = lastIndex])								ifTrue:	[(characterPoint x <= (destX + ((lastCharacterExtent x) // 2)))											ifFalse:												[destX _ (destX + lastCharacterExtent x).												characterPoint _ destX @ destY.												^ self endOfRun]].								characterPoint _ destX @ destY].				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x.	lastCharacterExtent x: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	"Yukky if next character is space or tab."	(lastCharacter = Space and: [line alignment = Justified])		ifTrue:	[lastCharacterExtent x:					(lastCharacterExtent x + (line justifiedPadFor: (spaceCount + 1))).				^true].	lastCharacter = Tab		ifTrue:			["See tabForDisplay for illumination on the following awfulness."			leadingTab _ true.			(line first to: lastIndex - 1) do:			[:index |			(text at: index) = Space				ifTrue: [leadingTab _ false]].			(line alignment ~= Justified or: [leadingTab])				ifTrue:	[lastCharacterExtent x: (textStyle nextTabXFrom: currentX							leftMargin: leftMargin rightMargin: rightMargin) -								currentX]				ifFalse:	[lastCharacterExtent x:  (((currentX + (textStyle tabWidth -								(line justifiedTabDeltaFor: spaceCount))) -									currentX) max: 0)]].	^ true!endOfRun	"Before arriving at the cursor location, the selection has encountered an end of run.  Answer false if the selection continues, true otherwise.  Set up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]])		ifTrue:	["We're really at the end of a real run."				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop _ characterIndex	"scanning for index"]					ifFalse:	[lineStop _ line last			"scanning for point"].				(runStopIndex _ lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex _ lineStop].				self setStopConditions.				^false].	lastCharacter _ text at: lastIndex.	characterPoint _ destX @ destY.	((lastCharacter = Space and: [textStyle alignment = Justified])		or: [lastCharacter = Tab])		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[characterPoint x: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				lastCharacterExtent x: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				lastCharacterExtent x: 0.				^true].	"just off end of line without crossing x"	lastIndex _ lastIndex + 1.	^true!setJustifiedSpaceWidth	spaceWidth _ line justifiedPad + (font widthOf: Space)!setStopConditions	super setStopConditions.	"also sets the font"	(line alignment = 3 and: [line startJustify: lastIndex])		ifTrue: [self setJustifiedSpaceWidth].!tab	| currentX |	currentX _ destX.	currentX _ leftMargin - line lMargin + (line positionAt: lastIndex).	(line alignment = 3 and: [line startJustify: lastIndex + 1])		ifTrue: [self setJustifiedSpaceWidth].	lastSpaceOrTabExtent _ lastCharacterExtent copy.	lastSpaceOrTabExtent x: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent _ lastSpaceOrTabExtent copy.			^self crossedX].	destX _ currentX.	lastIndex _ lastIndex + 1.	^false! !!DisplayScanner methodsFor: 'scanning'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine.  The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to the StopConditions array passed to the primitive at which time the code to handle the stopCondition is run and the call on the primitive continued until a stopCondition returns true which means the line has terminated."	| runLength done lineGrid lineIndex stopCondition displaying moveDown |	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	rightMargin _ aParagraph rightMarginForDisplay.	lineGrid _ textStyle lineGrid.	outputMedium = #PressPrinter		ifTrue:	[lineY _ destY _ aParagraph destinationForm bottom - (lineGrid * (linesInterval first - 1)). "Y origin lower left -- decreases as moving down page."				 pressFile _ aParagraph pressFile.				 lineIndex _ 0	"so empty paragraph works on printing"]		ifFalse:	["assume outputMedium Display if not PressPrinter for now"				 lineY _ destY _ aParagraph topAtLineIndex: linesInterval first].	displaying _ self doesDisplaying.	linesInterval do: 		[:lineIndex | 		line _ aParagraph lineAt: lineIndex.		outputMedium = #Display ifFalse: "move down to the baseline"			[outputMedium = #PressPrinter				ifTrue:					[lineY _ lineY - lineGrid.					 lineY < aParagraph destinationForm top "bottom for Press"						ifTrue:	[^ lineIndex	"paragraph off end of page"]]				ifFalse: [lineY _ lineY + lineGrid "#DisplayPrinterWidths"]].		runX _ destX _ leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		text _ aParagraph textAt: lineIndex.		lastIndex _ line first.		self setStopConditions.	"also sets the font"		outputMedium = #PressPrinter			ifTrue:	[pressFile setX: leftMargin.					 pressFile setY: (destY _ lineY + self fontAscentDelta). "fontAscent delta??"					 runStartIndex _ lastIndex]			ifFalse:	[destY _ lineY + self fontAscentDelta].		runLength _ text runLengthFor: line first.		(runStopIndex _ lastIndex + (runLength - 1)) > line last 			ifTrue: [runStopIndex _ line last].		spaceCount _ 0.		done _ false.		[done]			whileFalse: 				[outputMedium = #Display					ifTrue: [stopCondition _ 								self scanCharactersFrom: lastIndex									to: runStopIndex									in: text string									rightX: rightMargin									stopConditions: stopConditions									displaying: displaying]					ifFalse:						[outputMedium = #PressPrinter							ifTrue:								[stopCondition _ 									self scanPrinterCharactersFrom: lastIndex										to: runStopIndex										in: text string										rightX: rightMargin										stopConditions: stopConditions]							ifFalse: "#DisplayPrinterWidths"								[stopCondition _ 									self scanPrinterWidthsCharactersFrom: lastIndex										to: runStopIndex										in: text string										rightX: rightMargin										stopConditions: stopConditions										displaying: displaying]].				"see setStopConditions for stopping conditions for displaying."				done _ self perform: stopCondition].		outputMedium = #Display			ifTrue: ["Y origin upper left -- increases as moving down page. Move to top of next line"					lineY _ lineY + lineGrid]].		outputMedium = #PressPrinter			ifTrue:	[^lineIndex+1]			ifFalse: [^lineIndex]!lineY	"this is for access by printing to see where it really got to on the page"	^lineY! !Pool named: #TextConstants includes: #Justified!Pool named: #TextConstants includes: #NonFaceEmphasisMask!Pool named: #TextConstants includes: #Space!Pool named: #TextConstants includes: #Tab!!DisplayScanner methodsFor: 'stop conditions'!cr	"When a carriage return is encountered, simply increment the pointer into the paragraph."	outputMedium = #PressPrinter		ifTrue:	[lastIndex = runStartIndex	"if cr only character since											last showChars don't print it"				ifTrue:	[pressFile nextPutAll:							(text string copyFrom: runStartIndex to: lastIndex)]				ifFalse:	[pressFile showCharacters: lastIndex - runStartIndex.						pressFile nextPutAll:							(text string								copyFrom: runStartIndex to: lastIndex)].				pressFile skipCharacters: 1.				runStartIndex _ runStopIndex.	"indicates characters have already been												sent to pressFile"				self checkEmphasis.				^ true]		ifFalse:	["When displaying line stopped in endOfRun, primitive hasn't incremented				lastIndex when cr stop occurs, hence, "				lastIndex_ lastIndex + 1.				^false]!crossedX	"This condition will sometimes be reached 'legally' during printing, when, for instance the space that caused the line to wrap actually extends over the right  boundary.  This character is allowed to print, even though it is technically outside or straddling the clippingRectangle since it is in the normal case not visible and is in any case appropriately clipped by the scanner.  **Note that clipping is not entirely managed for the printer as yet.**"	outputMedium = #PressPrinter		ifTrue:	[pressFile showCharacters: runStopIndex - runStartIndex + 1.				pressFile nextPutAll:					(text string copyFrom: runStartIndex to: runStopIndex).				destX _ rightMargin.		"In case emphasizing to do.  Width of last											character has not been added in when stop											condition occurs."				self checkEmphasis]		ifFalse:	[self checkEmphasis].	^true!endOfRun	"The end of a run in the display case either means that there is actually a change in the style (run code) to be associated with the string or the end of this line has been reached.  A check for any emphasis (underlining, for example) that may run the length of the run is done here before returning to displayLines: to do the next line"	| runLength lastCharacter|	lastIndex = line last		ifTrue: [ outputMedium = #PressPrinter				ifTrue:	["tab or padded space may have been last						 character in line"						lastCharacter _ text at: lastIndex.						((textStyle alignment = Justified							and: [lastCharacter = Space])								or:	[lastCharacter = Tab])							ifTrue:	["characters already sent to pressFile"]							ifFalse:	[pressFile showCharacters:										runStopIndex - runStartIndex + 1.									pressFile nextPutAll:										(text string copyFrom:											runStartIndex to: runStopIndex)]]				ifFalse:	["just displaying and at end of line"].				self checkEmphasis. ^true].	outputMedium = #PressPrinter		ifTrue:	[pressFile showCharacters: runStopIndex - runStartIndex + 1.				pressFile nextPutAll:					(text string copyFrom: runStartIndex to: runStopIndex).				self checkEmphasis.				runLength _ text runLengthFor:					(lastIndex _ runStartIndex _ lastIndex + 1).				self setStopConditions.				runX _ destX.				destY _ lineY + self fontAscentDelta.		"fontAscent delta"				pressFile setX: destX.				pressFile setY: destY]		ifFalse:	[self checkEmphasis.				runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).				self setStopConditions.				runX _ destX.				destY _ lineY + self fontAscentDelta.		"fontAscent delta"].	(runStopIndex _ lastIndex + (runLength - 1)) > line last 		ifTrue: [runStopIndex _ line last].	^false!onePixelBackspace	"Increment destX by 1."	destX _ (destX - textStyle pressScale) max: runX.	outputMedium = #PressPrinter		ifTrue:	[self pressTabOrSpace].	lastIndex _ lastIndex + 1.	^false!onePixelSpace	"Increment destX by 1."	destX _ destX + textStyle pressScale.	outputMedium = #PressPrinter		ifTrue:	[self pressTabOrSpace].	lastIndex _ lastIndex + 1.	^false!paddedSpace	"Each space is a stop condition when the alignment = justified.  Padding must be added to the base width of the space according to which space in the line this space is and according to the amount of space that remained at the end of the line when it was composed."	spaceCount _ spaceCount + 1.	destX _ destX + spaceWidth + (line justifiedPadFor: spaceCount).	outputMedium = #PressPrinter		ifTrue:	[self pressTabOrSpace].	lastIndex _ lastIndex + 1.	^false!setStopConditions	"Set the font and the stop conditions for the current run."	| fontIndex displayFont |	outputMedium = #PressPrinter		ifTrue:	[displayFont _ textStyle fontAt: (fontIndex _ text emphasisAt: lastIndex).				font _ PressFont fontName: displayFont name.					"Cut off face emphasis -- ."				font emphasis: (displayFont emphasis bitAnd: NonFaceEmphasisMask).				pressFile selectFontCode: fontIndex style: textStyle rotation: 0 "in minutes of arc"]		ifFalse:	[font _ textStyle fontAt: (text emphasisAt: lastIndex).				outputMedium = #DisplayPrinterWidths					ifTrue: [font _ font asPrinterWidthsFont]].	super setStopConditions.	stopConditions 		at: Space asInteger + 1 		put: (textStyle alignment = Justified				ifTrue: [#paddedSpace]				ifFalse: [nil])!tab	"This awfulness attempts to handle leading and internal tabs in a justified line.  Leading tabs are considered legal and should be reflected on the display gracefully.  Internal tabs (when the line is justified) are considered at the very best a misguided use of the character, and are reflected on the display the best we can."	| leadingTab |	(textStyle alignment ~= Justified or: [leadingTab _ true.		(line first to: lastIndex) do: 			[:index | (text at: index) = Space ifTrue: [leadingTab _ false]].		leadingTab])		ifTrue: 	["if a leading tab, just like a tab on a non-jusitified line"				destX _ textStyle						nextTabXFrom: destX						leftMargin: leftMargin						rightMargin: rightMargin]		ifFalse:	["otherwise"				destX _ destX +						(textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount))							max: destX].	outputMedium = #PressPrinter		ifTrue:	[self pressTabOrSpace].	lastIndex _ lastIndex + 1.	^false! !Pool named: #TextConstants includes: #SuperscriptedBit!Pool named: #TextConstants includes: #SubscriptedBit!!DisplayScanner methodsFor: 'private'!checkEmphasis	| emphasis sourceRect italicY lineSegment displayDestX displayRunX clipRect |	(emphasis _ (font emphasis bitAnd: 7)) = 0		ifTrue: [^self].	clipRect _ self clipRect.	outputMedium = #DisplayPrinterWidths			ifTrue:	[displayDestX _ destX // textStyle pressScale.					displayRunX _ runX // textStyle pressScale]			ifFalse:	[displayDestX _ destX.					displayRunX _ runX].	emphasis >= 8	"overstrike"		ifTrue:	[outputMedium = #PressPrinter					ifTrue:	[self error: 'overstrike not implemented for Press Printing']					ifFalse:						[destForm							fill: (((displayRunX @ (lineY + textStyle baseline-3))							extent: (displayDestX - displayRunX) @ 1) intersect: clipRect)							rule: combinationRule mask: halftoneForm].				emphasis _ emphasis - 8].	emphasis >= 4	"underlined"		ifTrue:	[outputMedium = #PressPrinter					ifTrue:	["It appears that for Press baseline is y orgin for character.							A press character's y orgin is about it's baseline, I think.							pressScale added to get a smidgeon under baseline"							lineSegment  _ (runX @ (lineY - (2 * textStyle pressScale)))								extent: (destX - runX) @ (1 * textStyle pressScale).							pressFile showRectangle: lineSegment]					ifFalse:	[lineSegment _								((displayRunX @ (lineY + textStyle baseline + 1))									extent: (displayDestX - displayRunX) @ 1).							lineSegment bottom <= (clipY+clipHeight) ifTrue:								[destForm fill: lineSegment									rule: combinationRule									mask: halftoneForm]].					emphasis _ emphasis - 4].	emphasis >= 2	"italic"		ifTrue:	[outputMedium = #PressPrinter					ifTrue:	[self error: 'no synthetic fonts for Press Printing']					ifFalse:	[italicY _ destY + textStyle lineGrid - 4.							[italicY > destY]							whileTrue:							[sourceRect _								displayRunX @ destY									extent: (displayDestX - displayRunX + 2)												@ (italicY - destY).							destForm							copyBits: sourceRect							from: destForm							at: (displayRunX+1) @ destY							clippingBox: (sourceRect intersect: clipRect)							rule: Form over mask: nil.							italicY _ italicY - 4]].					emphasis _ emphasis - 2].	emphasis >= 1	"bold face"		ifTrue:	[outputMedium = #PressPrinter					ifTrue:	[self error: 'no synthetic fonts for Press Printing']					ifFalse:	[sourceRect _ displayRunX @ destY								extent: (displayDestX - displayRunX - 1)											@ textStyle lineGrid.							destForm							copyBits: sourceRect							from: destForm							at: (displayRunX+1) @ destY							clippingBox: (sourceRect intersect: clipRect) rule: Form under mask: nil]]!doesDisplaying	outputMedium = #PressPrinter		ifTrue:	[^false]		ifFalse:	[^true]!fontAscentDelta	"return the distance ro move from lineY for the current font, for		#Display:  lineY is at top of lineGrid, so is from top of line to top of characters in current font		#PressPrinter:  lineY is at bottom of lineGrid, so is from bottom of characters in current font to bottom of line		#DisplayPrinterWidths: lineY is at bottom of lineGrid, so is from bottom of line to top of characters in current font"	| currentFont previousFont actualAscent scriptFudge |	scriptFudge _ 2.	outputMedium = #DisplayPrinterWidths		ifTrue:	[currentFont _ font strikeFont.				previousFont					_ (textStyle fontAt: (text emphasisAt: ((lastIndex - 1) max: 1))) strikeFont]		ifFalse:	["#PressPrinter or #Display"				outputMedium = #PressPrinter					ifTrue:	[previousFont _								(textStyle fontAt: (text emphasisAt: ((lastIndex - 1) max: 1))).							previousFont _ PressFont fontName: previousFont name]					ifFalse:	[previousFont _								(textStyle fontAt: (text emphasisAt: ((lastIndex - 1) max: 1)))].				currentFont _ font].	((currentFont emphasis bitAt: SubscriptedBit) = 1)		ifTrue:			[outputMedium = #Display				ifTrue: [^ textStyle baseline - scriptFudge]				ifFalse:					[outputMedium = #PressPrinter						ifTrue:	[^ (currentFont ascent - (scriptFudge * textStyle pressScale)) negated]						ifFalse:	[^ scriptFudge - currentFont ascent]]]		ifFalse:			[((currentFont emphasis bitAt: SuperscriptedBit) = 1)				ifTrue:					[outputMedium = #Display						ifTrue: [^ textStyle baseline - previousFont ascent - currentFont ascent + scriptFudge]						ifFalse:							[outputMedium = #PressPrinter								ifTrue:	[^ previousFont ascent - (scriptFudge * textStyle pressScale)]								ifFalse:	[^ scriptFudge - currentFont ascent - previousFont ascent]]]				ifFalse: "not a sub or super script font"					[outputMedium = #Display						ifTrue: [^ textStyle baseline - currentFont ascent]						ifFalse:							[outputMedium = #PressPrinter								ifTrue:	[^ 0] "ascent delta only for display and scripting"								ifFalse:	[^ 0 - currentFont ascent]]]]!pressTabOrSpace	"For press, put the space onto the file and set runStartIndex."	lastIndex = runStartIndex			"if only tab or paddedSpace since last showChars, don't print it"		ifTrue:	[pressFile nextPutAll:					(text string copyFrom: runStartIndex to: lastIndex)]		ifFalse:	[pressFile showCharacters: lastIndex - runStartIndex.				pressFile nextPutAll:					(text string copyFrom: runStartIndex to: lastIndex)].	pressFile skipCharacters: 1.	pressFile setX: destX.	runStartIndex _ lastIndex + 1! !PreviewDisplayScanner comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewDisplayScanner methodsFor: 'stop conditions'!endOfRun	"The end of a run in the display case either means that there is actually a change in the style (run code) to be associated with the string or the end of this line has been reached.  A check for any emphasis (underlining, for example) that may run the length of the run is done here before returning to displayLines: to do the next line"	| runLength |	self checkEmphasis.	self setStopConditions.	runX _ destX.	destY _ lineY + self fontAscentDelta.		"fontAscent delta""	(runStopIndex _ lastIndex + (runLength - 1)) > line last 		ifTrue: [runStopIndex _ line last]."	^false!setStopConditions	super setStopConditions.	"also sets the font"	(line alignment = 3 and: [line startJustify: lastIndex])		ifTrue: [self setJustifiedSpaceWidth].!tab	destX _ leftMargin - line lMargin + (line positionAt: lastIndex).	lastIndex _ lastIndex + 1.	(line alignment = 3 and: [line startJustify: lastIndex])		ifTrue: [self setJustifiedSpaceWidth].! !Pool named: #TextConstants includes: #Ctrlf!Pool named: #TextConstants includes: #CR!Pool named: #TextConstants includes: #Space!!PreviewDisplayScanner methodsFor: 'new display'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle at: aPoint 	"The central display routine.  The call on the primitive  	(scanCharactersFrom:to:in:rightX:) will be interrupted according to the  	StopConditions array passed to the primitive at which time the code to  	handle the stopCondition is run and the call on the primitive continued until 	 a stopCondition returns true which means the line has terminated."	| runLength done lineGrid lineIndex stopCondition offset |	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	rightMargin _ aParagraph rightMarginForDisplay.	lineGrid _ (aParagraph var at: #grid) y.	lineY _ destY _ aPoint y.	offset _ aPoint x - aParagraph clippingRectangle left * textStyle pressScale.	linesInterval do: 		[:lineIndex | 		line _ aParagraph lineAt: lineIndex.		lineY _ lineY + lineGrid.		runX _ destX _ leftMargin _ (aParagraph leftMarginForDisplayForLine: lineIndex) + offset.		text _ aParagraph textAt: lineIndex.		lastIndex _ line first.		self setStopConditions.		destY _ lineY + self fontAscentDelta.		self displaySingleLine].	^lineIndex!displaySingleLine	| delimitorCount delimitorIndices delimitorPositions countsBetweenDelimitors delimitorTypes changeFlag tabIndex nextTabIndex stop sz ignorLast checkEmp | 	(line == nil or: [line first > line last]) ifTrue: [^self].	delimitorCount _ line delimitorCount.	delimitorIndices _ line delimitorIndices.	delimitorPositions _ line delimitorPositions.	countsBetweenDelimitors _ line countsBetweenDelimitors.	stop _ line last.	ignorLast _ 0.	[(stop >= line first)	and: [(text at: stop) == Space or: [(text at: stop) == CR or: [(text at: stop) == Ctrlf]]]]	whileTrue: [stop _ stop - 1.				ignorLast _ ignorLast + 1].	(delimitorCount >= 1	and: [(delimitorIndices at: delimitorCount) = line last			and: [ignorLast > 0]])		ifTrue: [countsBetweenDelimitors at: delimitorCount put: ((countsBetweenDelimitors at: delimitorCount) - ignorLast)].	delimitorTypes _ line delimitorTypes.	changeFlag _ #normal.	tabIndex _ 0.	checkEmp _ (font emphasis bitAnd: 7) > 0.	[nextTabIndex _ line nextTabIndexFrom: tabIndex.	nextTabIndex > tabIndex] whileTrue:	[tabIndex + 1 to: nextTabIndex do: [:count |		self scanPrinterWidthsCharactersFrom: lastIndex				size: (countsBetweenDelimitors at: count)				in: text string.		lastIndex _ (delimitorIndices at: count) + 1.		((changeFlag _ delimitorTypes at: count) == #run or: [changeFlag == #runTab])			ifTrue: [	self endOfRun.					checkEmp _ (font emphasis bitAnd: 7) > 0]			ifFalse: [checkEmp ifTrue: [destX _ leftMargin - line lMargin + (delimitorPositions at: count)]]].	checkEmp ifTrue: [self checkEmphasis].	destX _ runX _ leftMargin - line lMargin + (delimitorPositions at: nextTabIndex).	tabIndex _ nextTabIndex].	(line alignment = 3 and: [line startJustify: lastIndex])		ifTrue: [self setJustifiedSpaceWidth].	tabIndex + 1 to: delimitorCount do: [:count |		(sz _ countsBetweenDelimitors at: count) > 0			ifTrue: [self scanPrinterWidthsCharactersFrom: lastIndex						size: sz						in: text string].		lastIndex _ (delimitorIndices at: count) + 1.		((changeFlag _ delimitorTypes at: count) == #run or: [changeFlag == #runTab])			ifTrue: [	self endOfRun]].	sz _ line last - ignorLast - lastIndex + 1.	sz > 0		ifTrue: [self scanPrinterWidthsCharactersFrom: lastIndex					size: sz					in: text string.				self endOfRun].!scanPrinterWidthsCharactersFrom: startIndex size: stringSize in: sourceString	"This is a variation of the scanning primitive to allow displaying using printing fonts' widths.  When the fonts are not coordinated, the place they fall on the display may not be the same as where they fall on the printed page.  This allows for a preview of where the characters will actually fall on the printed page and where the line breaks and tabs will actually fall. March through source String from startIndex to stopIndex. This lobotomized version doesn't know anything about stops - it assumes the caller is taking care of that"	| ascii scanningXTable scale nextDestX maxAscii notInFontAscii |	scale _ textStyle pressScale.	scanningXTable _ font strikeFont xTable.		"BitBlt will want Display widths"	maxAscii _ font strikeFont maxAscii.	lastIndex _ startIndex.	stringSize = 0 ifTrue: [^self tab].	1 to: stringSize do: 		[:i | ascii _ (sourceString at: lastIndex) asciiValue.			ascii = 32				ifTrue: [destX _ destX + spaceWidth]				ifFalse:					[ascii > maxAscii						ifTrue:							[notInFontAscii _ maxAscii + 1.							sourceX _ scanningXTable at: maxAscii + 2.	"use Alto glyphs"							width _ ((scanningXTable at: maxAscii + 3) - sourceX).	"Display width"							nextDestX _ destX + (font widthFor: font maxAscii + 1)]						ifFalse:							[sourceX _ scanningXTable at: ascii + 1.	"use Alto glyphs"							width _ ((scanningXTable at: ascii + 2) - sourceX).	"Display width"							nextDestX _ destX + (font widthFor: ascii)].					destX _ destX // scale.					self copyBits.					destX _ nextDestX].			lastIndex _ lastIndex + 1].! !Pool named: #TextConstants includes: #SuperscriptedBit!Pool named: #TextConstants includes: #Space!Pool named: #TextConstants includes: #SubscriptedBit!!PreviewDisplayScanner methodsFor: 'private'!fontAscentDelta	"return the distance to move from lineY for the current font, for		#Display:  lineY is at top of lineGrid, so is from top of line to top of characters in current font		#PressPrinter:  lineY is at bottom of lineGrid, so is from bottom of characters in current font to bottom of line		#DisplayPrinterWidths: lineY is at bottom of lineGrid, so is from bottom of line to top of characters in current font"	| currentFont previousFont scriptFudge |	scriptFudge _ 2.	currentFont _ font strikeFont.	previousFont _ (textStyle fontAt: (text emphasisAt: ((lastIndex - 1) max: 1))) strikeFont.	((currentFont emphasis bitAt: SubscriptedBit) = 1)		ifTrue:			[^ scriptFudge - currentFont ascent]		ifFalse:			[((currentFont emphasis bitAt: SuperscriptedBit) = 1)				ifTrue:					[^ scriptFudge - currentFont ascent - previousFont ascent]				ifFalse: "not a sub or super script font"					[^ 0 - currentFont ascent]]!setJustifiedSpaceWidth	spaceWidth _ line justifiedPad + (font widthOf: Space)! !FastTextList comment:'I am a list of strings, for use in ListViews.  I implement all messages to TextListwhich are sent by ListView, but no others.  I am about 1.5 to 2 times as fast asa TextList because I am not a Paragraph -- I use a primitive method in CharacterScannerto blit the text up as fast as possible.INSTANCE VARIABLES:list	<OrderedCollection> of Strings representing the lines.numberOfLines	<Integer> The number of lines in the list -- equal to ''list size.''origin	<Point> The position at which to display the first visible line of text.topLine	<Integer> The line number of the first visible line.linesShown	<Integer> The number of lines currently displayed.'!!FastTextList methodsFor: 'initialization'!setList: aList font: aFont	list _ aList.	numberOfLines _ list size.	font _ aFont.	sourceForm _ aFont glyphs.	destForm _ Display.	halftoneForm _ Form black.	combinationRule _ Form over.	height _ font height.	sourceY _ 0.	clipX _ 0.	clipY _ 0.	xTable _ font xTable.	stopConditions _ Stops.	topLine _ 1! !!FastTextList methodsFor: 'displaying'!displayLines: first to: last	"Display lines of text."	| fontHeight leftX rightX |	fontHeight _ ListStyle lineGrid.	self destOrigin: origin + (0@(first-topLine*fontHeight)).	leftX _ destX.	rightX _ clipX+clipWidth+10.	first to: last do:		[:eachLine |		self			scanCharactersFrom: 1 to: (list at: eachLine) size			in: (list at: eachLine)			rightX: rightX			stopConditions: stopConditions			displaying: true.		destX _ leftX.		destY _ destY+fontHeight]!displayOn: whoCares	"Display lines of text."	| fontHeight rightX leftX |	fontHeight _ ListStyle lineGrid.	rightX _ clipX+clipWidth+10.	self destOrigin: origin.	leftX _ destX.	topLine to: topLine + linesShown -1 do:		[:eachLine |		self			scanCharactersFrom: 1 to: (list at: eachLine) size			in: (list at: eachLine)			rightX: rightX			stopConditions: stopConditions			displaying: true.		destX _ leftX.		destY _ destY+fontHeight]!displayString: aString font: aFont height: charHeight on: aForm at: aPoint	"OLD METHOD  Display lines of text."	"| length index start leftX str bob |	self		setDestForm: aForm		sourceForm: aFont glyphs		halftoneForm: Form black		combinationRule: Form over		destOrigin: aPoint		sourceOrigin: 0@0		extent: 0@0		clipRect: aForm boundingBox.	font _ aFont.	xTable _ font xTable.	height _ font height.	stopConditions _ font stopConditions shallowCopy.	length _ aString size.	str _ aString, (String with: Character cr).	leftX _ destX.	CRs _ OrderedCollection new.	index _ 1.	[index < length] whileTrue:		[[(str at: index) ~= Character cr] whileTrue:			[index _ index+1].		CRs add: index.		index _ index+1 ].	start _ 1.	CRs do:		[:pos |		bob _ self			scanCharactersFrom: start to: pos-1 in: str			rightX: 15000			stopConditions: stopConditions			displaying: true.		bob ~= #endOfRun ifTrue: [self error: 'Weird return from scan: ', bob].		start _ pos+1.		destX _ leftX.		destY _ destY+charHeight]"! !!FastTextList methodsFor: 'accessing'!boundingBox	"Supposed to be 'offset extent: compositionRectangle extent'"	^ Rectangle		origin: 0@0		extent: 10000@(ListStyle lineGrid * list size)!clippingRectangle	"Answer what my clippingRectangle would be if I were a Paragraph."	^ self clipRect!compositionRectangle	"Answer what my compositionRectangle would be if I were a Paragraph."	^ Rectangle		origin: clipX @ (clipY - (topLine-1 * ListStyle lineGrid))		extent: 10000@(ListStyle lineGrid * numberOfLines)!gainedALine	"How many lines do I have now?"	| linesPossible | 	linesPossible _ ( self clippingBox height // self lineGrid).	numberOfLines _ numberOfLines + 1.	linesShown <= linesPossible ifTrue:[linesShown _ linesShown  + 1]!gainedALine: clippingBox	"How many lines do I have now?"	| linesPossible | 	linesPossible _ (clippingBox height // self lineGrid).	numberOfLines _ numberOfLines + 1.	linesShown < linesPossible ifTrue:[linesShown _ linesShown  + 1]!height	"Answer my total height (the height of my compositionRectangle)."	^ ListStyle lineGrid * numberOfLines!lineGrid	"Answer the lineGrid of my TextStyle."	^ ListStyle lineGrid!list	^list!lostALine	"How many lines do I have now?"	numberOfLines _ numberOfLines - 1.	linesShown _ linesShown min: numberOfLines.	(numberOfLines - topLine + 1) < linesShown ifTrue:[topLine _ (topLine - 1) max: 1. ^true].	^false!numberOfLines	"How many lines do I have?"	^numberOfLines!topLine	^topLine! !!FastTextList methodsFor: 'positioning'!repositionAt: aPoint clippingBox: clippingBox	"A fake of the message to Paragraph."	origin _ aPoint x @ clippingBox top.	topLine _ (clippingBox top - aPoint y) // self lineGrid +1.	linesShown _ (clippingBox height // self lineGrid)			min: (numberOfLines-topLine+1).	self clipRect: clippingBox! !!FastTextList methodsFor: 'scrolling'!scrollBy: amount	"Scroll myself.	This method assumes that the list is scrollable; i.e. that it is	displaying as many lines as possible."	| grid lines aForm |	grid _ self lineGrid."figure out how many lines to scroll:"	(amount abs between: 0 and: grid)		ifTrue: [lines _ amount sign]		ifFalse: [lines _ amount quo: grid]."don't scroll off the ends!!"	lines _ (lines max: 1-topLine)		min: (numberOfLines - (topLine + linesShown -1) ).	lines = 0 ifTrue: [^self]."if no old text will be left, just redisplay:"	lines abs >= linesShown ifTrue:		[Display white: self clipRect.		topLine _ topLine + lines.		self displayOn: Display.		^self]."blit the text that will remain:"	Display		copyBits: self clipRect		from: Display		at: clipX @ (clipY - (grid*lines))		clippingBox: self clipRect		rule: Form over		mask: Form black."display the new text:"	topLine _ topLine + lines.	lines > 0		ifTrue:			[Display white:				( (clipX @ (origin y + (linesShown-lines *grid)))					corner: self clipRect corner ).			self displayLines: topLine-lines+linesShown				to: topLine+linesShown-1 ]		ifFalse:			[Display white:				( clipX@clipY					extent: clipWidth @ (grid*lines negated) ).			self displayLines: topLine				to: topLine-lines-1 ].! !PrintScanner comment:'Copyright (c) 1984, 1985 Xerox Corporation.  All rights reserved.	I am a Scanner for Interpressing text. My instances hold the state of CharacterScanner in addition to the following required only for Interpressing text.  I am used to determine where to break a line. The process of cutting out one line continues until the result from performing stopconditions is true.	The word ''delimitor'' (appears in the comments below) means a tab or a font-change.Instance Variables: spaceIndex<Integer> Character index of the last space scanned in line. tabIndex<Integer> Not used in single-font version. Character index of the last tab scanned in line.  delimitorCount<Integer> Number of tabs and font-changes scanned in line. delimitorIndex<Integer> Character index of the last delimitor scanned in line. delimitorIndices<Array> Each element represents delimitor index in order scanned in line. The initial size of this array is 32 for multi-font version and same as the tabsArray(which is one of the PrintStyle''s instance variables) size for single-font version, and the default value for each element is 0.		example:	Consider a line below whose first character''''s index is 100(* means a character. - for a tab, # for a font-change,  % for both a tab and a font-change).			*****%****--#*****				In this case, delimitorIndices = (106 111 112 1130 --- 0)	 delimitorPositions<Array> Each element represents absolute x-cordinate of next delimitor position in printing image. The size of this array and the default value for each element are same as of delimitorIndices. The measurement unit used is 2 micas(2/100 mm).		example:	Inthe case above, delimitorPositions = (2120 3002 3355 3410 0 --- 0) countBetweenDelimitors<Array> I-th element represents number of characters  between (i-1)-th and i-th delimitor.  The size of this array and the default value for each element are same as of delimitorIndices. In the case that tabs are contiguous(like the case above), corresponding values are to be 0.		example:	Inthe case above, countsBetweenDelimitorsArray = (5 4 0 1 --- 0) delimitorTypes<Array> In single-font version,  each element of this array represents a constant symbol #single.  In multi-font version, each element of this array represents delimitors type: tab, font-change or both tab and font-change, each case is represented as symbol #tab, #run and #runTab respectively.example:		If cosidered for multi-font version, In the case above,delimitorTypes = (#runTab #tab #tab #run nil nil  - - nil)	The size of this array is same as of delimitorIndicesArray. Element''s default value is nil. printStyle<PrintStyle> Just a printing style, required from interpressing text onto a printing image. See PrintStyle comments.'!!PrintScanner methodsFor: 'initialize-release'!in: anInterpress"Passing Information from Interpress to PrintScanner for initialization."	text _ anInterpress text.	textStyle _ anInterpress printStyle! !!PrintScanner methodsFor: 'accessing'!countsBetweenDelimitors	^countsBetweenDelimitors!delimitorCount	^delimitorCount!delimitorIndices	^delimitorIndices!delimitorPositions	^delimitorPositions!delimitorTypes	^delimitorTypes! !!PrintScanner methodsFor: 'scanning'!characterNotInFont	text _ text copyReplaceFrom: lastIndex				to: lastIndex				with: (Text string: ' ' emphasis: (text emphasisAt: lastIndex)).	^self space	"self perform:#space"!composeLineFrom: startIndex"Return a line cut out by startIndex and stopConditions. The former half of this method( ~ 'done _ false') is for initialization of instance variables. Values for line, spaceCount, spaceIndex, lastIndex, tabIndex, delimitorIndex, delimitorCount, delimitorIndices, delimitorPositions and countsBetweenDelimitors are modified in methods of message-category named stopCondition."	| runLength done stopCondition |	lastIndex _ startIndex.	self setStopConditions.		"also sets font"	spaceX _ destX _ leftMargin _ textStyle leftMargin.	rightMargin _ textStyle rightMargin.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ 		TextLineInterval			start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0.	spaceCount _ 0.	spaceIndex _ 0.	tabIndex _ 0.	delimitorIndex _ lastIndex - 1.	delimitorCount _ 0.	delimitorIndices _ Array new: 16 withAll: 0.	delimitorPositions _ Array new: 16 withAll: 0.	countsBetweenDelimitors _ Array new: 16 withAll: 0.	delimitorTypes _ Array new: 16.	done _ false.	[done]		whileFalse: 			[stopCondition _ 				super					scanCharactersFrom: lastIndex					to: runStopIndex					in: text string					rightX: rightMargin					stopConditions: stopConditions					displaying: false.			(self perform: stopCondition) ifTrue: [^line]]!composeLineFrom: startIndex left: leftInteger right: rightInteger"Return a line cut out by startIndex and stopConditions. The former half of this method( ~ 'done _ false') is for initialization of instance variables. Values for line, spaceCount, spaceIndex, lastIndex, tabIndex, delimitorIndex, delimitorCount, delimitorIndices, delimitorPositions and countsBetweenDelimitors are modified in methods of message-category named stopCondition."	| runLength done stopCondition |	lastIndex _ startIndex.	self setStopConditions.		"also sets font"	spaceX _ destX _ leftMargin _ leftInteger.	rightMargin _ rightInteger.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ 		TextLineInterval			start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0.	spaceCount _ 0.	spaceIndex _ 0.	tabIndex _ 0.	delimitorIndex _ lastIndex - 1.	delimitorCount _ 0.	delimitorIndices _ Array new: 16 withAll: 0.	delimitorPositions _ Array new: 16 withAll: 0.	countsBetweenDelimitors _ Array new: 16 withAll: 0.	delimitorTypes _ Array new: 16.	done _ false.	[done]		whileFalse: 			[stopCondition _ 				super					scanCharactersFrom: lastIndex					to: runStopIndex					in: text string					rightX: rightMargin					stopConditions: stopConditions					displaying: false.			(self perform: stopCondition) ifTrue: [^line]]! !!PrintScanner methodsFor: 'stop conditions'!cr	"CR breakes a line at the very index."	lastIndex = runStopIndex		ifTrue: [self updateVarPos: destX					type: #run					index: lastIndex.				"self updateCountsInBetweenUpTo: (lastIndex - 1)"].	line stop: lastIndex.	spaceX _ destX.	line paddingWidth: rightMargin - destX.	^true!crossedX"Line breakes at stopIndex(only one temporary variable in this method). If stopIndex is less than first index of line, line breakes just before the lastIndex. In both cace, new line is determined."	| stopIndex |	spaceCount > 0 ifTrue: [line stop: (stopIndex _ spaceIndex max: tabIndex)].	spaceCount > 1		ifTrue: [spaceCount _ spaceCount - 1.				spaceIndex _ spaceIndex - 1.				[(spaceCount > 0 and: [(text at: spaceIndex) = Space])]				whileTrue: [spaceCount _ spaceCount - 1.							spaceIndex _ spaceIndex - 1.							font _ self resetFont.							spaceX _ spaceX - (font widthOf: Space)].				line paddingWidth: rightMargin - spaceX.				line internalSpaces: spaceCount]		ifFalse:	[spaceCount = 1					ifTrue:	["wrap at space, but no internal spaces"							line internalSpaces: 0.							line paddingWidth: rightMargin - spaceX]					ifFalse:	["Neither internal nor trailing spaces, almost never happen,								she says confidently."							lastIndex _ lastIndex - 1.							[destX <= rightMargin]							whileFalse:								[destX _ destX - (font widthOf:													(text at: lastIndex)).										"bug --doesn't account for backing over										 run and changing actual width of										characters. Also doesn't account for										backing over a tab.  Happens only										when no spaces in line, presumably rare."								lastIndex _ lastIndex - 1].							spaceX _ destX.							line paddingWidth: rightMargin - destX.							(stopIndex _ lastIndex) < line first								ifTrue:	[line stop: line first]								ifFalse:	[line stop: lastIndex]]].	stopIndex < line first		ifTrue: [line stop: (lastIndex - 1).				delimitorIndex = lastIndex					ifTrue: [delimitorCount _ delimitorCount - 1].				^true].	(stopIndex < delimitorIndex and: [delimitorCount > 0])		ifTrue: [[delimitorCount > 0 and: [(delimitorIndices at: delimitorCount) > stopIndex]]					whileTrue: [delimitorCount _ delimitorCount - 1]].	^true!endOfRun"As current run came to the end, runLength, runStopIndex and font must be reset.  If current scanning index is same as the text size, line breakes here."	| runLength |	lastIndex >= text size		ifTrue: [line stop: text size.				spaceX _ destX.				line paddingWidth: rightMargin - destX.				^true]		ifFalse:	[(delimitorCount > 0 and: [lastIndex = (delimitorIndices at: delimitorCount)])					ifTrue: [delimitorTypes at: delimitorCount put:#runTab]					ifFalse: [self updateVarPos: destX type: #run index: lastIndex.							delimitorIndex _ lastIndex].				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				runStopIndex _ lastIndex + (runLength - 1).				self setStopConditions.				^false]!ff"'ff'(form feed) needs page alternation. So line breakes here."	line stop: lastIndex.	line paddingWidth: rightMargin - destX.	^true!setStopConditions"Set stopConditions for line breaking and also set font and xTable(,which is for calculating line width)."	font _ textStyle fontAt: (text emphasisAt: lastIndex).	spaceWidth _ font widthOf: Space.	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at:33 put:#space.	stopConditions at:10 put:#tab.	stopConditions at:14 put:#cr.	stopConditions at:258 put:#crossedX.	stopConditions at:257 put:#endOfRun.	stopConditions at:13 put:#ff!space	"There needs to know last space index scanned in a line for word wrap-arround. If destX becomes larger than rightMargin, line breakes here."	spaceX _ destX.	destX _ spaceX + spaceWidth.	lastIndex _ (spaceIndex _ lastIndex) + 1.	spaceCount _ spaceCount + 1.	destX > rightMargin		ifTrue: [spaceIndex = runStopIndex					ifTrue: [self updateVarPos: destX								type: #run								index: spaceIndex.							self updateCountsInBetweenUpTo: spaceIndex].				^self crossedX].	^false!tab	| savedDestX | "There needs to know precisely where to print the character following a tab, if encountering with a tab. To achieve this, collecting information about tab(delimitorCount, tabIndex, --- ) is inevitable. If destX becomes larger than rightMargin, line breakes here."	savedDestX _ destX.	destX _ textStyle				nextTabXFrom: destX 				leftMargin: leftMargin 				rightMargin: rightMargin.	self updateVarPos: destX type: #tab index: lastIndex.	(((lastIndex - 1) = delimitorIndex) or: [lastIndex = (line first)])		ifTrue: [self updateCountsInBetweenUpTo: 0]		ifFalse: [self updateCountsInBetweenUpTo: (lastIndex - 1)].	tabIndex _ lastIndex.	delimitorIndex _ lastIndex.	destX > rightMargin		ifTrue: [lastIndex = runStopIndex					ifTrue: [delimitorTypes at: delimitorCount put: #runTab].				line stop: lastIndex.				line paddingWidth: rightMargin - savedDestX.				line internalSpaces: spaceCount.				^true].	lastIndex _ lastIndex + 1.	^false! !!PrintScanner methodsFor: 'private'!endLineAt: stopInteger	| old next newCount | 	"Set the stopping point in the string of the line to be stopInteger."	line stop: stopInteger.	[delimitorCount > 0 and: [(delimitorIndices at: delimitorCount) > stopInteger]]		whileTrue: [delimitorIndices at: delimitorCount put: 0.					delimitorPositions at: delimitorCount put: 0.					delimitorTypes at: delimitorCount put: nil.					delimitorCount _ delimitorCount - 1].	old _ line start - 1.	1 to: delimitorCount do: [:i |		countsBetweenDelimitors at: i put: (newCount _ (next _ delimitorIndices at: i) - old max: 0).		((delimitorTypes at: i) == #tab or: [(delimitorTypes at: i)  == #runTab])			ifTrue: [countsBetweenDelimitors at: i put: (newCount - 1 max: 0)].		old _ next ]!growDelimitors	"Ordinally 32 as delimitors size is considered quite enough. If the current size is not enough unfortunately, sizes grow by 32."	| newDelimitorIndices newDelimitorPositions newDelimitorTypes newCountsBetweenDelimitors newSize |	newSize _ delimitorIndices size + 32.	newDelimitorIndices _ Array new: newSize withAll: 0.	newDelimitorPositions _ Array new: newSize withAll: 0.	newDelimitorTypes _ Array new: newSize.	newCountsBetweenDelimitors _ Array new: newSize withAll: 0.	1 to: delimitorIndices size do: [:i | 		newDelimitorIndices at: i put: (delimitorIndices at: i).		newDelimitorPositions at: i put: (delimitorPositions at: i).		newDelimitorTypes at: i put: (delimitorTypes at: i).		newCountsBetweenDelimitors at: i put: (countsBetweenDelimitors at: i)].	delimitorIndices _ newDelimitorIndices.	delimitorPositions _ newDelimitorPositions.	delimitorTypes _ newDelimitorTypes.	countsBetweenDelimitors _ newCountsBetweenDelimitors!nextTabIndexFrom: startIndex	| type | 	startIndex + 1 to: delimitorCount do: [:i |		type _ delimitorTypes at: i.		(type == #tab or: [type == #runTab])			ifTrue: [^i]].	^startIndex!resetFont	"Mainly to allow the stop condition crossedX to be shared by display and printer media."	^textStyle fontAt: (text emphasisAt: spaceIndex)!updateCountsInBetweenUpTo: anInteger	countsBetweenDelimitors at: delimitorCount put: ((anInteger - delimitorIndex) max: 0).!updateVarPos: newPos type: newType index: anInteger	"Various instance variables are updated here."	delimitorCount _ delimitorCount + 1.	delimitorIndices size < delimitorCount		ifTrue: [self growDelimitors].	delimitorPositions at: delimitorCount put: newPos.	delimitorTypes at: delimitorCount put: newType.	delimitorIndices at: delimitorCount put: anInteger.	countsBetweenDelimitors at: delimitorCount put: (anInteger - delimitorIndex).! !PrintFrom1108 comment:'Copyright (c) 1985, 1986 Xerox Corporation.  All Rights Reserved.This class contains two primitives and supporting messages which are meant as a temporary device for sending press and interpress files directly from Smalltalk on the 1108'!!PrintFrom1108 methodsFor: 'access'!checkProgressAndShowOn: anObject	| timeNow | 	Processor yield.	(done or: [timeNow _ LargePositiveInteger new: 4. Time secondClockInto: timeNow. timeNow - lastCheckedTime > 10])		ifTrue:			[Disk includesKey: 'dummy'.			anObject show: 'Sending ', fileName, (String with: $ ), self lastStatus.			Time secondClockInto: lastCheckedTime].	^ (done ifTrue: [self lastStatus] ifFalse: [self])!commitSuicide	"terminate this print packet, taking whatever steps are necessary depending on its progress so far. This is somewhat hit and miss code - things could slip through the cracks if the timing is just right"	(sent and: [done not])		ifTrue: [XDEInterfaceModel new abort; addDummy]		ifFalse: [done _ true]!heresYourChance	"send to the primitive and wait for it to finish, set the instance variables accordingly"	| sem printerType |	printerType _		((fileName findString: '.interpress' startingAt: 1) == 0 ifFalse: [1]			ifTrue: [(fileName findString: '.press' startingAt: 1) == 0 ifFalse: [2]				ifTrue: [(PressOrInterpress = #Interpress ifTrue: [1] ifFalse: [2])]]).	done ifFalse: "could be true if aborted before got here" 		[sent _ true.		sem _ Semaphore new.		self sendPrintFile: fileName printerType: printerType printer: printerName copies: numCopies signal: sem.		sem wait.		lastStatus _ self printStatus].	done _ true.	doneSemaphore == nil ifFalse: [doneSemaphore signal]!lastStatus	"update the lastStatus (if not already done) and return it"	lastStatus _ 		(sent ifFalse: [#waitingTurn]			ifTrue: [done ifFalse: [self printStatus] ifTrue: [lastStatus]]).	^lastStatus!printerName	^printerName!printerName: printer numCopies: copies	printerName _ printer.	numCopies _ copies!printStatus	"returns a symbol corresponding to a human readable string about the status of the last call on sendInterpress:printer:copies:signal:"	^self printStatusList at: self printResult!printStatusList	"symbols corresponding to human readable strings about the status of the last call on sendInterpress:printer:copies:signal:"	^#(done warning abort error notStarted pending)!sendPrintFile: file printer: printer copies: copies doneSemaphore: aSemaphore	"initialization message"	fileName _ file.	printerName _ printer.	numCopies _ copies.	doneSemaphore _ aSemaphore.	sent _ false.	done _ false.	lastStatus _ #waitingTurn.	lastCheckedTime _ LargePositiveInteger new: 4.	Time secondClockInto: lastCheckedTime.	lastCheckedTime _ lastCheckedTime - 60! !!PrintFrom1108 methodsFor: 'primitives'!printResult	"returns an integer indicating the status of the last call on the primitive sendInterpress:printer:copies:signal:	 the integer correspondence is: 1 = success; 2 = warning; 3 = abort; 4 = error; 5 = notStarted; 5 = pending"	<primitive: 179>	^self primitiveFailed!sendPrintFile: file printerType: typeInteger printer: printer copies: copies signal: aSemaphore	"starts a process to send numCopies of the filename to the printer printerName.  typeInteger = 1 is an interpress printer (will use Print tool), typeInteger = 2 is press (will use OPrint tool). When it finishes (for whatever reason), doneSemaphore will be signaled"	<primitive: 178>	^self primitiveFailed! !Signal comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!Signal methodsFor: 'using'!do: doBlock handle: handleBlock	"evaluate doBlock; if all goes well, return its value.	if I am signalled while evaluating doBlock,		the signal: method will try to handle the problem		by evaluating the handleBlock which is stored in thisContext.	handling is done by sending me one of		signalReturn signalReturn: signalReturnDoing: [return a result for the signal: message]		handleReturn handleReturn: handleReturnDoing: [which return a result for a do:handle: ], or		doRetry [which restarts evaluation of the doBlock in a do:handle: ].	unwinding, done in all the above, invokes every unwindBlock		stored in Signal class>>do:onUnwindDo: contexts		found up to where the stack will be trimmed and resumed.	if handleBlock returns, having done none of the above,	or if the reject message is sent during evaluation of handleBlock		the signal: method will try for another handler earlier in the stack."	[^ doBlock value] whileTrue: []  "yes, this is strange; for retry: "!signal	"signal with no extra info"	^ self signal: nil!signal: clue	"generate and propagate a signal until a handler handles it.	examine the stack to find and invoke handleBlocks		that were set up for me or the CatchAllSignal.	clue supplies info for identifying the problem.	this context stores clue and the active doHandleContext for use on recovery."	| doHandleContext receiver |  "doHandleContext must be the first temp"	doHandleContext _ thisContext.	[(doHandleContext _ doHandleContext sender) == nil] whileFalse: [		(doHandleContext method == DoHandleMethod		and: [(receiver _ doHandleContext receiver)				== self or: [receiver == CatchAllSignal] ] )		 ifTrue: [ "activate the handleBlock, which returns only if it fails to handle"			(doHandleContext at: 2) shallowCopy value ] ].	^ self noHandler!signalNoReturn	"raise a signal that prevents handling by signalReturn* messages.	 presumably this is because the local state is too messed up to continue"	self signalNoReturn: nil!signalNoReturn: clue	"raise a signal that prevents handling by signalReturn* messages.	 presumably this is because the local state is too messed up to continue"	self signal: clue.	self error: 'unable to resume from this signal'! !!Signal methodsFor: 'handling'!doRetry	"unwind the stack to the do:handle: context with the currently executing handleBlock.	restart do:handle:, so evaluating the doBlock gets restarted"	self retry: (Signal unwindTo: self doHandleContext)!handleReturn	"unwind the stack to the do:handle: context with the current handleBlock,	 then return nil as the result of the do:handle: message."	self handleReturnDoing: []!handleReturn: aValue	"unwind the stack to the do:handle: context with the current handleBlock,	 then return aValue as the result of the do:handle: message."	self handleReturnDoing: [aValue].!handleReturnDoing: aBlock	"run all unwind blocks from here to the do:handle: context		which has my currently executing handle block.	resume the sender of do:handle: with (aBlock value) as the result of the do:handle: message.	aBlock is not evaluated until after unwinding."		| sender value |	sender _ Signal unwindTo: self doHandleContext sender.	value _ aBlock value.	thisContext sender releaseTo: sender.	thisContext swapSender: sender.	^ value!reject	"explicitly fail to handle by returning from the current handle block,		back to the signal method that is evaluating it.	this signifies that handling failed here;		give another handle block farther back in the stack a chance."	thisContext swapSender: self signalContext!signalReturn	"return nil to the signalling context, as the result of the signal message.	execute any unwind blocks for partial computations that are dropped		(between here and the signalling context)"		self signalReturnDoing:  []!signalReturn: aValue	"return aValue to the signalling context, as the result of the signal message.	execute any unwind blocks for partial computations that are dropped		(between here and the signalling context)"		self signalReturnDoing:  [aValue]!signalReturnDoing: aBlock	"return (aBlock value) to the signalling context, as the result of the signal message.	execute any unwind blocks for partial computations that are dropped		(between here and the signalling context).	aBlock is executed after unwinding"		| sender value |	sender _ Signal unwindTo: self signalContext sender.	value _ aBlock value.	thisContext sender releaseTo: sender.	thisContext swapSender: sender.	^ value! !!Signal methodsFor: 'reason'!clue	"return the argument to signal: "	^ self signalContext at: 1!clueString	"return the argument to signal: as a string"	| string |	string _ self clue.	^ (string isKindOf: String)		ifTrue: [string]		ifFalse: [string printString]! !!Signal methodsFor: 'contexts'!doHandleContext	"return my [or CatchAllSignal's] do:handle: context whose handleBlock is active.	 it can be found in the signal context, which is currently evaluating it"	^ self signalContext at: 2!isSignalNoReturn	"return whether I was raised using the signalNoReturn: method"	^ self signalContext sender method == SignalNoReturnMethod!signalContext	"return the context where I am doing the signal: method.	 if I am not active, notify the user."	| signalContext |	signalContext _ thisContext.	[(signalContext _ signalContext sender) == nil] whileFalse: [		(	signalContext method == SignalMethod		and: [signalContext receiver == self] )		 ifTrue: [^ signalContext] ].	^ self noSignal! !!Signal methodsFor: 'private--notification'!noHandler"no available handler block has succeeded"	(self confirm: self clueString, 'Do you want to debug?')		ifTrue: [self notify: 'signal has not been handled: ', self clueString.				"Try the message again if the programmer decides to proceed."]		ifFalse: [NotifierView reportContext: thisContext]!noSignal	"an attempt has been made to recover when no signal is being handled"	self notify: 'no signal in force'!notify: aString	"schedule a notifier"	NotifierView openContext: thisContext sender		label: aString		contents: thisContext sender shortStack! !!Signal methodsFor: 'private--recovering'!retry: aContext	"release stack up to aContext.	 restart aContext"	"This version depends on	 method do:handle: being	 '[^ doBlock value] whileTrue: []'	 and aContext being the doHandleContext"	thisContext sender releaseTo: aContext.	"clean up stack and release doBlock"	aContext jump: 1.	"skip return instruction"		"for Sun type implementations use restart instead"	thisContext swapSender: aContext.	"return to those thrilling..."	^ true	"and make whileTrue: test succeed (if necessary)"! !!Signal methodsFor: 'obsolete recovering'!resumeWith: aValue	^self signalReturn: aValue!unwindAndDo: aBlock	^self handleReturnDoing: aBlock!unwindAndRetry	^self doRetry!unwindWith: aValue	^self handleReturn: aValue! !RectForm comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.RectForm is a new data type to keep track of the picture, rectangles in the PreviewPage.InstanceVariable========[rectangle]		this is the outer box which surrounds a form if there is a form.  Its origin is a relative screen distant from the clipping rectangle origin of the PreviewPage.[form]			this is usually nil and it is a form only when there is a picture associated with the rectangle and you are on the same page.  This is to keep the memory usage low. [fileName] 		this is the file name which associates with the form.  When you go to a new page, a form is read in with the file named fileName.[pBorder]		a boolean toggle to indicate whether there is a border around the picture.[rBorder] 		a boolean toggle to indicate whether there is a border around the rectangle.[offset]			this is the offset similar to the origin in the rectangle which is a relative screen distant from the clippint rectangle origin to the form origin.[scale]			it is a point which indicates the state of the picture if there is any.  nil = normal, x equals y  = proportion scaling, x not equal to y = fit scaling'!!RectForm methodsFor: 'accessing'!fileName	^fileName!fileName: aName	fileName _ aName!form	^form!form: aForm	form _ aForm!getForm	| aForm | 	aForm _ form.	(aForm == nil and: [fileName isEmpty not])		ifTrue: [aForm _ Form readFrom: fileName].	^aForm!offset	^offset!offset: aPoint	offset _ aPoint!opaque	^opaque!opaque: showOpaque	opaque _ showOpaque!pBorder	^pBorder!pBorder: aBoolean	pBorder _ aBoolean!rBorder	^rBorder!rBorder: aBoolean	rBorder _ aBoolean!rectangle	^rectangle!rectangle: aRect	rectangle _ aRect!scale	^scale!scale: aPoint	scale _ aPoint! !!RectForm methodsFor: 'initialize-release'!initialize	scale _ 1@1.	fileName _ String new.	rBorder _ false.	pBorder _ true.	opaque _ true! !!RectForm methodsFor: 'private'!contains: another	^rectangle contains: another!containsPoint: aPoint	^rectangle containsPoint: aPoint!extent	^rectangle extent!formExtentScaled: scaledIfTrue	^form == nil		ifTrue: [rectangle extent]		ifFalse: [scaledIfTrue ifTrue: [form extent * scale] ifFalse: [form extent]]!insetBy: delta	^rectangle insetBy: delta!moveTo: newOrigin	^rectangle moveTo: newOrigin!pixRectangleScaled: scaledIfTrue	^scaledIfTrue		ifTrue: [0@0 extent: form extent * scale]		ifFalse: [0@0 extent: form extent]!properties	^Array with: (Array with: (rBorder ifTrue: [#on] ifFalse: [#off]))			with: (Array with: (pBorder ifTrue: [#on] ifFalse: [#off]))			with: (Array with: (opaque ifTrue: [#on] ifFalse: [#off]))!translateBy: delta	^rectangle translateBy: delta! !!RectForm methodsFor: 'file out'!point: aPoint out: aFile delimiter: del	aFile 		nextPutAll: aPoint x printString; nextPut: del; 		nextPutAll: aPoint y printString; nextPut: del!rect: aRect out: aFile delimiter: del	self point: aRect origin out: aFile delimiter: del.	self point: aRect extent out: aFile delimiter: del!writeTo: aFile delimiter: del 	"rectangle form fileName pBorder rBorder offset scale"	self rect: rectangle out: aFile delimiter: del.	aFile 		nextPutAll: nil printString; nextPut: del; 		nextPutAll: fileName; nextPut: del;		nextPutAll: pBorder printString; nextPut: del; 		nextPutAll: rBorder printString; nextPut: del.	self point: offset out: aFile delimiter: del.	self point: scale out: aFile delimiter: del.	opaque ifFalse: [aFile nextPut: $f; nextPut: del]! !Sum comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!Sum methodsFor: 'As yet unclassified'!collection: aCollection	collection _ aCollection!printOn: aStream	collection sum printOn: aStream! !SpreadsheetCell comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!SpreadsheetCell methodsFor: 'initialize-release'!release"	contents release."	rule = nil ifFalse: [self breakOldRuleDependencies.].	contents _ nil.	rule _ nil.	holder _ nil."	xcell release.	ycell release.	self nilFields.	super release"! !!SpreadsheetCell methodsFor: 'accessing'!box	"answer border box for cell"	^holder boxAt: xcell @ ycell!boxAt: boxPoint 	"answer border box for cell at boxPoint"	^holder boxAt: boxPoint!changeContents: newContents	"change contents to newContents, display new contents and notify dependents"	contents _ newContents.	form _ nil.	self display.	self changed!changeRule: aString	"Change my rule and parse to code, then evaluate."	| newRule |	aString = ''		ifTrue:			[newRule _ nil]		ifFalse:			[newRule _ SpreadsheetRule new string: aString.			newRule codeNotifying: holder controller inputView controller "generate a signal to acceptSignal in InputController if illegal rule"].	self removeOldRule.	rule _ newRule.	self setRuleDependencies.	self evaluate!contents	^contents!contents: newContents	"change contents to newContents without notifying dependents"	contents _ newContents!form	^form!form: aForm	form _ aForm!holder	^holder!holder: anObject	holder _ anObject!removeOldRule	"remove and release old rule before installing a new one"	rule == nil		ifFalse:			[self breakOldRuleDependencies.			rule _ nil]!reset	"Clear my rule and value." 	updateFlag ifFalse: [^nil].	self breakOldRuleDependencies.	rule _ nil.	self dependents isEmpty 		ifFalse: [self dependents do: [:eachDep | eachDep reset]].	holder view clearMapCell: xcell @ ycell.	holder atPoint: xcell @ ycell put: holder nilCell.	holder view blacken: xcell @ ycell.	self nilFields.	updateFlag _ false!rule	"access the rule of the cell"	^rule!rule: aRule	"access the rule of the cell"	rule _ aRule!updateFlag	^updateFlag!updateFlag: aBoolean	updateFlag _ aBoolean!userUpdate	rule == nil		ifFalse: "update by rule"			[self addUpdate]		ifTrue: "no rule - but update dependents"			[self display; addUpdate]!userUpdate: aPoint	rule == nil		ifFalse: "update by rule"			[self addUpdate]		ifTrue: "no rule - but update dependents"			[self displayAt: aPoint; addUpdate]!xcell	^xcell!xcell: aSmallInteger	xcell _ aSmallInteger!ycell	^ycell!ycell: aSmallInteger	ycell _ aSmallInteger! !!SpreadsheetCell methodsFor: 'copying'!deepCopy	| theNewCell |	theNewCell _ SpreadsheetCell in: holder.	theNewCell contents: contents deepCopy.	theNewCell rule: rule.	^theNewCell! !!SpreadsheetCell methodsFor: 'displaying'!display	"display cell and its contents"	self = holder nilCell		ifFalse: [self displayAt: xcell @ ycell]		ifTrue: [self displayAt: holder controller selectionPoint]!displayAt: displayPoint 	"display cell and its contents at displayPoint"	"if I am a nil cell, just return"	| cellContents fe fh fw r1 r2 r3 ra |	contents == nil ifTrue: [^nil].	"find my box"	r1 _ holder view insetDisplayBox.	r1 _ Rectangle new		origin: r1 origin x + 30 @ (r1 origin y + 30) 		corner: r1 corner.	r2 _ self boxAt: displayPoint.	r2 _ Rectangle new		origin: r2 origin x + 1 @ (r2 origin y + 1) 		corner: r2 corner x - 1 @ (r2 corner y - 1).	(r2 intersects: r1) ifFalse: [^nil].	fe _ (fw _ r2 corner x - r2 origin x) @ (fh _ r2 corner y - r2 origin y).	"if the form is already generated, display it at once and return"	form == nil ifTrue:		[form _ Form basicNew			extent: fe			offset: CellZeroPoint			bits: (WordArray new: fw + 15 // 16 * fh).		rule == nil ifFalse: "place the rule mark"			[CellRuleBitBlt destForm: form; copyBits.].		"update scroll map"		holder view fillMapCell: displayPoint.		"get display object to display as cell contents"		(contents isLiteral or: [((contents isKindOf: DisplayObject)				| (contents isKindOf: Chart)) not])			ifTrue:				[cellContents _ contents printString.				"CellCharacterScanner destForm: form; destX: 5; destY: CellDestY; clipWidth: fw; clipHeight: fh;					scanCharactersFrom: 1					to: cellContents size					in: cellContents					rightX: fw					stopConditions: CellCharacterScanner stopConditions					displaying: true."				(ra _ CellText runs) runs at: 1 put: cellContents size.				CellFastTextDisplayScanner					displayText:						(CellText setString: cellContents setRuns: ra)					textStyle: CellTextStyle					destForm: form					leftMargin: 0					rightMargin: fw					destY: 0					halftoneForm: nil					combinationRule: "Form over" 3					clipX: 0					clipY: 0					clipWidth: fw					clipHeight: fh.				]			ifFalse:				[cellContents _ contents.				"display the contents"				SmalltalkSignal do:					[(cellContents isKindOf: Chart)						ifTrue:							[r3 _ r2 intersect: r1.							Display								fill: r3								rule: Form over								mask: Form white.							cellContents								displayOn: Display								at: r2 origin								clippingBox: r3								rule: Form over								mask: Form black.							form _ r3 = r2								ifTrue: [Form fromDisplay: r3.]								ifFalse: [nil.].							^nil							]						ifFalse:							[cellContents								displayOn: form								at: 5 @ 5								clippingBox: (2 @ 2 corner: fw - 2 @ (fh - 2))								rule: Form over								mask: Form black.							].						]					handle: 						[cellContents _ '#Undisplayable#' asForm.						SmalltalkSignal doRetry.						].				].		].	CellDisplayBitBlt		setDestForm: Display		sourceForm: form		halftoneForm: nil		combinationRule: 3		destOrigin: r2 origin		sourceOrigin: CellZeroPoint		extent: fe		clipRect: r1; copyBits.!displayDependents	"draw links between cells"	| dotSetter deps point box otherBox |	deps _ self dependents.	deps size = 0 ifTrue: [^nil].	dotSetter _ BitBlt				destForm: Display				sourceForm: (Form extent: 1 @ 1) black				halftoneForm: Form black				combinationRule: Form reverse				destOrigin: 0 @ 0				sourceOrigin: 0 @ 0				extent: 1 @ 1				clipRect: holder view insetDisplayBox.	point _ 0.	box _ self boxAt: xcell @ ycell.	deps do: 		[:each | 		(holder controller selectionPoint class == Rectangle 			and: [holder controller selectionPoint origin <= (each xcell @ each ycell) and: [(each xcell @ each ycell) <= holder controller selectionPoint corner]])			ifFalse: [otherBox _ (self boxAt: each xcell @ each ycell) insetBy: 5.					dotSetter 						drawFrom: (self bound: box center + point within: box)						to: (self bound: otherBox center + point within: otherBox)].		point < 0 ifTrue:[point _ point * -1] ifFalse:[point _ point + 2 * -1]]!displayReferences	"draw links between cells"	| dotSetter refs point box otherBox |	rule == nil ifTrue: [^nil].	refs _ rule referencesForCellAt: xcell @ ycell in: holder.	refs size = 0 ifTrue: [^nil].	dotSetter _ BitBlt				destForm: Display				sourceForm: (Form extent: 1 @ 1) black				halftoneForm: Form black				combinationRule: Form reverse				destOrigin: 0 @ 0				sourceOrigin: 0 @ 0				extent: 1 @ 1				clipRect: holder view insetDisplayBox.	point _ 0.	box _ self boxAt: xcell @ ycell.	refs do: 		[:each | 		each class == Array			ifFalse: 				[otherBox _ (self boxAt: each)							insetBy: 5.				dotSetter drawFrom: (self bound: (self boxAt: xcell @ ycell) center + point within: box)					to: (self bound: (self boxAt: each) center + point within: (self boxAt: each))].		point < 0			ifTrue: [point _ point * -1]			ifFalse: [point _ point + 2 * -1]]! !!SpreadsheetCell methodsFor: 'menu message support'!details	rule isNil 		ifFalse: [			(rule referencesForCellAt: xcell @ ycell in: holder)				do: [:ref | 					ref class == Array ifTrue: [InformationCenter openFromFileName: (ref at: 1) , '.ss']]]! !!SpreadsheetCell methodsFor: 'updating'!addUpdate	updateFlag		ifFalse: 			[updateFlag _ true.			holder addUpdate: self.			self dependents do: [:each | each addUpdate]]!evaluate	| superCell |	updateFlag		ifTrue: [updateFlag _ false.				rule == nil				ifFalse: 					[(rule referencesForCellAt: xcell @ ycell in: holder) do: 						[:ref | ref class == Array ifFalse:[superCell _ holder atPoint: ref.							superCell updateFlag ifTrue: [superCell evaluate]]].					contents _ SmalltalkSignal do: [rule code value: holder value: xcell value: ycell]								handle: [SmalltalkSignal handleReturn:  'ERROR: ', SmalltalkSignal clueString "holder badRef"].					form _ nil.					self display]]!update: sender	self addUpdate! !!SpreadsheetCell methodsFor: 'private'!bound: aPoint within: aRectangle	"return the closest point to aPoint within aRectangle"	^((aPoint x max: aRectangle origin x) min: aRectangle corner x) @  ((aPoint y max: aRectangle origin y) min: aRectangle corner y)!breakOldRuleDependencies	rule == nil ifFalse: [(rule referencesForCellAt: xcell @ ycell in: holder)			do: [:refPoint | (refPoint isKindOf: Array)					ifTrue: [refPoint size = 3							ifTrue: [holder allHolders									atSheet: (refPoint at: 1)									point: (refPoint at: 2) @ (refPoint at: 3)									for: holder									removeDependent: self]							ifFalse: [holder allHolders									atSheet: (refPoint at: 1)									rectangle: (Rectangle new origin: (refPoint at: 2) @ (refPoint at: 3) 											corner: (refPoint at: 4) @ (refPoint at: 5))									for: holder									removeDependent: self]]					ifFalse: [(holder atPoint: refPoint) removeDependent: self]]]!compile: aString	"compile in context of cell to use instance variables"	^Compiler new		evaluate: aString		in: nil		to: self		notifying: nil		ifFail: [nil]!dependOn: cellPoint	"Add self to the dependents list of cell at cellPoint.  Make sure I do not depend on the nilCell."	(holder atPoint: cellPoint) = holder nilCell		ifTrue: [holder initCellAt: cellPoint].				"need to turn nilCell into unique cell"	(holder atPoint: cellPoint) removeDependent: self.		"prevent redundant updates"	(holder atPoint: cellPoint) addDependent: self			"set dependency for automatic updating"!setRuleDependencies	rule == nil ifFalse: [(rule referencesForCellAt: xcell @ ycell in: holder)			do: [:refPoint | (refPoint isKindOf: Array)					ifTrue: [refPoint size = 3							ifTrue: [holder allHolders									atSheet: (refPoint at: 1)									point: (refPoint at: 2) @ (refPoint at: 3)									for: holder									addDependent: self]							ifFalse: [holder allHolders									atSheet: (refPoint at: 1)									rectangle: (Rectangle new origin: (refPoint at: 2) @ (refPoint at: 3) 											corner: (refPoint at: 4) @ (refPoint at: 5))									for: holder									addDependent: self]]					ifFalse: [self dependOn: refPoint]]]! !Chart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!Chart methodsFor: 'accessing'!areYouAutoScaled	"queries the flag which turns on scaling for the chart."	^isAutoScaled!areYouFilled 	"queries the flag which turns on filling for the chart."	^isFilled!areYouLabeled 	"queries the flag which turns on labelling for the chart."	^isLabeled!areYouLabeledByPercent 	"queries the flag which turns on labeledByPercent for the chart."	^labeledByPercent!areYouLegended 	"queries the flag which turns on legending for the chart."	^isLegended!dataArray	"return the array of data."	^ dataArray!dataArray: anArray	"set the array of data points."	dataArray _ anArray!emphasis	"return the emphasis for labels."	^ emphasis!emphasis: anInteger	"set the emphasis."	emphasis _ anInteger!gutter	^gutter!gutter: aNumber	gutter _ aNumber!isAutoScaled: aBoolean 	"sets the flag which turns on scaling for the chart."	isAutoScaled _ aBoolean!isFilled 	"sets the flag which turns on filling for the chart."	isFilled _ true!isFilled: aBoolean 	"sets the flag which turns on filling for the chart."	isFilled _ aBoolean!isLabeled 	"sets the flag which turns on labelling for the chart."	isLabeled _ true!isLabeled: aBoolean 	"sets the flag which turns on labelling for the chart."	isLabeled _ aBoolean!isLegended 	"sets the flag which turns on legending for the chart."	isLegended _ true!isLegended: aBoolean 	"sets the flag which turns on legending for the chart."	isLegended _ aBoolean!labelArray	"return the array of labels."	^ labelArray!labelArray: anArray	"set the array of labels."	labelArray _ anArray!labeledByPercent	"returns the flag which turns on percent labelling for the chart."	^labeledByPercent!labeledByPercent: aBoolean 	"sets the flag which turns on percent labelling for the chart."	labeledByPercent _ aBoolean!mask: i	"get the mask for the user"	^MaskArray at: (maskArray at: i \\ maskArray size + 1)!maskArray	"return the array of masks."	^ maskArray!maskArray: anOrderedCollection	"set the array of masks."	maskArray _ anOrderedCollection!storeOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: ' new title: '.	title storeOn: aStream.	aStream nextPutAll: '; isFilled: ', isFilled printString.	aStream nextPutAll: '; isLabeled: ', isLabeled printString.	aStream nextPutAll: '; isLegended: ', isLegended printString.	aStream nextPutAll: '; labeledByPercent: ', labeledByPercent printString.	aStream nextPutAll: '; dataArray: ('.	dataArray storeOn: aStream.	aStream nextPutAll: '); labelArray: ('.	labelArray storeOn: aStream.	aStream nextPut: $)!title	"returns the title for the chart."	^title!title: aString	"set the title for the chart."	title _ aString! !!Chart methodsFor: 'displaying'!displayOn: form	self displayOn: form at: 0@0 clippingBox: form computeBoundingBox!displayOn: aForm at: aPoint clippingBox: aRectangle rule: anInteger mask: anotherInteger	self displayOn: aForm at: aPoint clippingBox: aRectangle.! !!Chart methodsFor: 'legend'!legendOn: targetForm 	self legendOn: targetForm at: 0@0 clippingBox: targetForm computeBoundingBox!legendOn: targetForm at: aPoint clippingBox: aRectangle	self legendOn: targetForm at: aPoint clippingBox: aRectangle with:labelArray!legendOn: targetForm at: aPoint clippingBox: aRectangle with:anArray	"display a legend for a chart on the target form"	| rect norm spacing labeling top dispRect displayRect theLabel mask |	anArray = nil ifTrue: [^self].	rect _ aRectangle corner x - (aRectangle width // 12) @ (aRectangle origin y + 3) corner: aRectangle corner - 3.	displayRect _ rect copy.	(spacing _ (aRectangle height - 6 / anArray size) asInteger) > 30 ifTrue: [spacing _ 30].	"calculate max value on array"	1 to: anArray size do: 		[:i | 		theLabel _ self formFrom: (anArray at: i).		theLabel displayOn: targetForm at: rect origin x - theLabel extent x - 5 @ (rect origin y + (spacing * (i - 1) + 1)).		top _ rect origin y + (spacing * (i - 1)) asInteger.		dispRect _ rect origin x @ top corner: rect right @ (rect origin y + (spacing * i)).		isFilled ifTrue: [ mask _ self mask: i]				ifFalse: [ mask _ Form white].		targetForm			fill: dispRect			rule: Form over			mask: Form black;			fill: (dispRect insetBy: 1 @ 1)			rule: Form over			mask: mask]! !!Chart methodsFor: 'title'!titleOn: targetForm 	"Place a title on the targetForm"	self titleOn: targetForm at: 0@0 clippingBox: targetForm computeBoundingBox!titleOn: targetForm at: aPoint clippingBox: aRectangle	"Place a title on the targetForm"	title isNil ifTrue:[title _ String new].	((Paragraph withText: (title asText			emphasizeFrom: 1			to: title size			with: 25)		style: (TextConstants at: #DefaultTextStyle))		gridWithLead: ((TextConstants at: #DefaultTextStyle)				fontAt: 25) height) asForm		displayOn: targetForm		at: aRectangle origin + (5 @ 10)		clippingBox: aRectangle		rule: Form under		mask: Form black.	(TextConstants at: #DefaultTextStyle)		gridForFont: 7 withLead: 0! !!Chart methodsFor: 'private'!computeAppropriateMax: aNumber 	"compute a power of ten based max which will include the max passed in."	| theOrder theBase theMax |	aNumber = 0 ifTrue:[^0].	theOrder _ 10 raisedTo: (self orderOf: aNumber abs) +1.	theBase _ aNumber abs // theOrder.	aNumber > 0		ifTrue: 			[theMax _(theOrder * (theBase + 1)) asFloat.			[theMax / 2 > aNumber] whileTrue:[theMax _ theMax / 2]]		ifFalse: 			[theMax _ -1 * (theOrder * (theBase + 1)) asFloat.			[theMax / 2 < aNumber] whileTrue:[theMax _ theMax / 2]].	^theMax!formFrom: aString	^FastTextDisplayScanner new formFromString: aString emphasis: emphasis!orderOf: aNumber	"find the order of magnitude for a given number."	| nextOrder power |	power _ 0.	nextOrder _ (10 raisedTo: power).	[aNumber < nextOrder]		whileFalse:[ power _ power + 1.			nextOrder _ (10 raisedTo: power).			nextOrder].	^ (power - 1)! !PieChart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!PieChart methodsFor: 'displaying'!displayOn: targetForm at: aPoint clippingBox: aRectangle	"Creates a labeled PieChart on the Form targetForm.  The    	dataArray provides a list of values to use in partitioning a    	PieChart, while labelArray tells the system how to label the  	  slices."	| totalSum thePie thePieCenter thisSlice circumferencePoint angle aForm interiorPoint fillAngle oldAngle |	fillAngle _ oldAngle _ angle _ totalSum _ 0.	"if legended, legend with the elements of the labelArray"	isLegended ifTrue: [self legendOn: targetForm at: aPoint clippingBox: aRectangle].	1 to: dataArray size do: [:key | totalSum _ totalSum + (dataArray at: key)].	"create a circle sized to fit the new form"	(aForm _ Form new extent: 2 @ 2) black.	thePieCenter _ aRectangle center.	isLegended ifTrue:[thePieCenter x: thePieCenter x - (aRectangle width // 12)].	(thePie _ NewCircle new) form: aForm; center: thePieCenter.	targetForm extent x > targetForm extent y		ifTrue: [thePie radius: aRectangle extent y * 3 // 16]		ifFalse: [thePie radius: aRectangle extent x * 3 // 16]. 	thePie		displayOn: targetForm		at: 0 @ 0		clippingBox: aRectangle		rule: Form under		mask: Form black.	"now begin to draw the slices in the pie"	(thisSlice _ Line new) form: aForm.	center _ thePie.	circumferencePoint _ Point x: 0 y: 0.	interiorPoint _ Point x: 0 y: 0.	circumferencePoint x: thePie center x + (thePie radius * angle cos); y: thePie center y + (thePie radius * angle sin).	thisSlice beginPoint: thePie center; endPoint: circumferencePoint.	thisSlice		displayOn: targetForm		at: 0 @ 0		clippingBox: aRectangle		rule: Form over		mask: Form black.	"self displayTarget:targetForm."	1 to: dataArray size do: 		[:key | 		oldAngle _ angle.		angle _ angle + (2 * Float pi * (dataArray at: key) / totalSum).		"if filled, then fill with elements from the mask array."		isFilled ifTrue: [thePie				fillSegmentFrom: oldAngle				to: angle				onForm: targetForm				withColor: (self mask: key)].		circumferencePoint x: thePie center x + (thePie radius * angle cos); y: thePie center y + (thePie radius * angle sin).		interiorPoint x: thePie center x + (thePie radius / 2 * fillAngle cos); y: thePie center y + (thePie radius / 2 * fillAngle sin).		thisSlice beginPoint: thePie center; endPoint: circumferencePoint.		thisSlice			displayOn: targetForm			at: 0 @ 0			clippingBox: aRectangle			rule: Form over			mask: Form black].	"if labeled, label with elements from the label array"	isLabeled ifTrue: [self labelOn: targetForm onCircle: thePie clippingBox: aRectangle].	"if titled place a title on the form"	title = nil ifFalse: [self titleOn: targetForm at: aPoint clippingBox: aRectangle]! !!PieChart methodsFor: 'labeling'!labelOn: targetForm at: aPoint clippingBox: aRectangle 	self labelOn: targetForm onCircle: center clippingBox: aRectangle!labelOn: targetForm onCircle: thePie 	"Creates a labeled PieChart on the Form targetForm.  The 	dataArray provides a list of values to use in partitioning a 	PieChart, while labelArray tells the system how to label the 	slices. "	| totalSum displayAngle oldAngle circumferencePoint exteriorPoint angle aLine interiorLabel exteriorLabel offsetNum |	"total the data in this drawing"	totalSum _ 0.	1 to: dataArray size do: [:key | totalSum _ totalSum + (dataArray at: key)].	"now begin to label the slices in the pie"	angle _ 0.	exteriorPoint _ Point new.	circumferencePoint _ Point new.	1 to: dataArray size do: 		[:key | 		oldAngle _ angle.		angle _ angle + ("2 * Float pi" 6.28318 * (dataArray at: key) / totalSum).		displayAngle _ oldAngle + angle / 2.		"create both the interior and exterior labels"		labeledByPercent		ifTrue:[interiorLabel _ (((dataArray at: key)					/ totalSum * 100) asFloat rounded) printString , '%']		ifFalse:[interiorLabel _ (dataArray at: key) printString].		isLegended			ifTrue:[exteriorLabel _ interiorLabel.					 exteriorLabel _ (exteriorLabel asText) emphasizeFrom:1 to: exteriorLabel size with: 13]			ifFalse:[exteriorLabel _ (labelArray at: key),':  ',interiorLabel.					exteriorLabel _ (exteriorLabel asText) emphasizeFrom:1 to: exteriorLabel size with: 13].		"use the offsets and calculated angles to  create label points."		exteriorPoint x: thePie center x + (thePie radius * 1.5 * displayAngle cos).		exteriorPoint y: thePie center y + (thePie radius * 1.5 * displayAngle sin). 		circumferencePoint x: thePie center x + (thePie radius * 1.0 * displayAngle cos).		circumferencePoint y: thePie center y + (thePie radius * 1.0 * displayAngle sin).		(aLine _ Line new) beginPoint: circumferencePoint; endPoint: exteriorPoint; displayOn: targetForm at: 0@0 rule: Form under.		"label the points on the targetForm"		exteriorLabel _ exteriorLabel asDisplayText. 		(displayAngle > ("0.5 * Float pi" 1.5708)) & (displayAngle < ("1.5 * Float pi" 4.71239))			ifTrue: [exteriorPoint x: (exteriorPoint x - (exteriorLabel form extent x) - 5)]			ifFalse: [exteriorPoint x: (exteriorPoint x + 8)].		(displayAngle > 0.0) & (displayAngle < ("Float pi" 3.14159))			ifTrue: [exteriorPoint y: exteriorPoint y - (exteriorLabel form extent y * 2 / 3)]			ifFalse: [exteriorPoint y: exteriorPoint y - (exteriorLabel form extent y *5 / 6)].		exteriorLabel displayOn: targetForm at: exteriorPoint rule: Form under].!labelOn: targetForm onCircle: thePie clippingBox: aRectangle	"Creates a labeled PieChart on the Form targetForm.  The 	dataArray provides a list of values to use in partitioning a 	PieChart, while labelArray tells the system how to label the 	slices. "	| totalSum displayAngle oldAngle circumferencePoint exteriorPoint angle aLine interiorLabel exteriorLabel offsetNum |	"total the data in this drawing"	totalSum _ 0.	1 to: dataArray size do: [:key | totalSum _ totalSum + (dataArray at: key)].	"now begin to label the slices in the pie"	angle _ 0.	exteriorPoint _ Point new.	circumferencePoint _ Point new.	1 to: dataArray size do: 		[:key | 		oldAngle _ angle.		angle _ angle + ("2 * Float pi" 6.28318 * (dataArray at: key) / totalSum).		displayAngle _ oldAngle + angle / 2.		"create both the interior and exterior labels"		labeledByPercent		ifTrue:[interiorLabel _ (((dataArray at: key)					/ totalSum * 100) asFloat rounded) printString , '%']		ifFalse:[interiorLabel _ (dataArray at: key) printString].		isLegended			ifTrue:[exteriorLabel _ self formFrom: interiorLabel]			ifFalse:[exteriorLabel _ self formFrom: ((labelArray at: key),':  ',interiorLabel)].		"use the offsets and calculated angles to  create label points."		exteriorPoint x: thePie center x + (thePie radius * 1.5 * displayAngle cos).		exteriorPoint y: thePie center y + (thePie radius * 1.5 * displayAngle sin). 		circumferencePoint x: thePie center x + (thePie radius * 1.0 * displayAngle cos).		circumferencePoint y: thePie center y + (thePie radius * 1.0 * displayAngle sin).		(aLine _ Line new) beginPoint: circumferencePoint; endPoint: exteriorPoint; displayOn: targetForm at: 0@0 rule: Form under.		"label the points on the targetForm"		(displayAngle > ("0.5 * Float pi" 1.5708)) & (displayAngle < ("1.5 * Float pi" 4.71239))			ifTrue: [exteriorPoint x: (exteriorPoint x - (exteriorLabel extent x) - 5)]			ifFalse: [exteriorPoint x: (exteriorPoint x + 8)].		(displayAngle > 0.0) & (displayAngle < ("Float pi" 3.14159))			ifTrue: [exteriorPoint y: exteriorPoint y - (exteriorLabel extent y * 2 / 3)]			ifFalse: [exteriorPoint y: exteriorPoint y - (exteriorLabel extent y *5 / 6)].		exteriorLabel displayOn: targetForm at: exteriorPoint clippingBox: aRectangle rule: Form under mask: Form black].! !!PieChart methodsFor: 'spreadsheet accessing'!title: aString labels: aMatrix data: anotherMatrix	self title: aString.	self isLabeled:true.	self labeledByPercent:true.	self isFilled:true.	labelArray _ OrderedCollection new.	dataArray _ OrderedCollection new.	aMatrix do: [:each | labelArray add: each].	anotherMatrix do: [:each | dataArray add: each].	^self! !BarChart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!BarChart methodsFor: 'area calculation'!calculateAreaForBars: targetForm within: aRectangle	"calculate the space available on the form for the bars to be displayed"	| originPoint cornerPoint |	cornerPoint _ aRectangle corner - (0@15).	originPoint _ aRectangle  origin + ((aRectangle width // 8) @ ((aRectangle height // 8) + 10)).	originPoint x < (aRectangle origin x + 40) ifTrue:[originPoint x: aRectangle origin x + 40].	isLegended		ifTrue:[cornerPoint x: cornerPoint x - (aRectangle width // 4)].	^originPoint corner: cornerPoint! !!BarChart methodsFor: 'displaying'!displayOn: targetForm at: aPoint clippingBox: aRectangle	"display a bar chart on the target form"	| rect norm spacing labeling top  bottom dispRect displayRect theMaxPoint theMinPoint mask |	rect _ self calculateAreaForBars: targetForm within: aRectangle.	(displayRect _ rect copy) corner: displayRect corner x @ (displayRect corner y - 30).	spacing _ (rect width / dataArray size) asInteger.	"calculate max value on array"	theMaximum _ theMinimum _ 0.	dataArray do: 		[:i | 		i > theMaximum ifTrue: [theMaximum _ i].		i < theMinimum ifTrue: [theMinimum _ i]].	(self writeAxisOn: targetForm beside: displayRect clippingBox: aRectangle)		ifFalse: [^false].	norm _ rect height - 30 / (theMaximum - theMinimum).	self titleOn: targetForm at: aPoint clippingBox: aRectangle.	"display the bars on the target form"	theMaxPoint _ displayRect origin x - 10 @ displayRect origin y.	theMinPoint _ displayRect origin x - 10 @ displayRect corner y.	"bring x axis up"	1 to: dataArray size do: 		[:i | 		(dataArray at: i)			>= 0			ifTrue: 				[top _ rect top + rect height - 30 - ((dataArray at: i)								* norm) asInteger + zeroOffset.				bottom _ (rect bottom - 29 + zeroOffset).				top _ (theMaxPoint y max: top) min: (theMinPoint y).				bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).				dispRect _ rect left + (spacing * (i - 1)) @ top corner: rect left + (spacing * i) - gutter @ bottom]			ifFalse: 				[top _ rect top + rect height - 30 + zeroOffset.				bottom _ (rect bottom - 30 - ((dataArray at: i)										* norm) asInteger + zeroOffset).				top _ (theMaxPoint y max: top) min: (theMinPoint y).				bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).				dispRect _ rect left + (spacing * (i - 1)) @ top corner: rect left + (spacing * i) - gutter @ bottom].		isFilled			ifTrue: [mask _ self mask: (((i - 1) \\ maskArray size) + 1)]			ifFalse: [mask _ Form white].		targetForm			fill: dispRect			rule: Form over			mask: Form black;			fill: (dispRect insetBy: 1 @ 1)			rule: Form over			mask: mask].	isLabeled ifTrue: [self labelOn: targetForm at: aPoint clippingBox: aRectangle].	isLegended ifTrue: [self legendOn: targetForm at: aPoint clippingBox: aRectangle]! !!BarChart methodsFor: 'labeling'!calculateInterval	| theABSMax theOrder temp1 temp | 	theABSMax _ theMaximum abs max:  theMinimum abs.	theOrder _ 10.0 raisedTo: (self orderOf: theABSMax).	[theABSMax / theOrder <= 4] whileTrue: [theOrder _ theOrder / 2].	[theABSMax / theOrder > 4] whileTrue: [theOrder _ theOrder * 2].	^theInterval _ theOrder!computeNewAppropriateMax: aNumber	| topValue | 	"compute a power of ten based max which will include the max passed in."	topValue _ 0.	aNumber > 0		ifTrue:[[aNumber > topValue] whileTrue: [topValue _ topValue + theInterval]]		ifFalse:[[aNumber < topValue] whileTrue: [topValue _ topValue - theInterval]].	^topValue!gcd: x and: y 	| temp x1 y1 |	x1 _ x.	y1 _ y.	y1 > x1		ifTrue: 			[temp _ self gcd: y1 and: x1.			^temp]		ifFalse: [[y1 < 0.1]				whileFalse: [x1 >= y1						ifTrue: [x1 _ x1 - y1]						ifFalse: 							[temp _ x1.							x1 _ y1.							y1 _ temp]].				^x1]!labelOn: targetForm 	"display the labels for a bar chart on the target form"	self labelOn: targetForm at: 0@0 clippingBox: targetForm computeBoundingBox!labelOn: targetForm at: aPoint clippingBox: aRectangle 	"display the labels for a bar chart on the target form"	| rect norm spacing labeling top dispRect displayRect form |	dataArray = nil ifTrue: [^self].	rect _ self calculateAreaForBars: targetForm within: aRectangle.	displayRect _ rect copy.	displayRect corner: displayRect corner x @ (displayRect corner y - 30).	spacing _ (rect width / dataArray size) asInteger.	1 to: labelArray size do: 		[:i | 		form _ self formFrom: (labelArray at: i).		form			displayOn: targetForm			at: rect bottomLeft - (0 @ 20) + (spacing * (i - 1) + (spacing - form width / 2) @ 0)			clippingBox: aRectangle]!writeAxisOn: aForm beside: aRectangle clippingBox: clipRectangle	"create a scale by which data can be interpreted."	| scaleLine theMidPoint theMaxPoint theMinPoint theABSMax theOrder theMidText theMidTextPoint theMax theMin theInter labelString defaultString answers label1 label2 label3 aLine temp temp1 |	aLine _ Line new.	theMidPoint _ Point new.	theMax _ theMaximum.	theMin _ theMinimum.	theMaximum _ self computeAppropriateMax: theMaximum.	theMinimum _ self computeAppropriateMax: theMinimum.	self calculateInterval.	theMaximum _ self computeNewAppropriateMax: theMax.	theMinimum _ self computeNewAppropriateMax: theMin.	theMaxPoint _ aRectangle origin x - 10 @ aRectangle origin y.	theMinPoint _ aRectangle origin x - 10 @ aRectangle corner y.	(scaleLine _ Line new) beginPoint: theMaxPoint; endPoint: theMinPoint; displayOn: aForm.	[theMaximum - theInterval > theMax] whileTrue: [theMaximum _ theMaximum - theInterval].	[theMinimum + theInterval < theMin] whileTrue: [theMinimum _ theMinimum + theInterval].	gutter == nil ifTrue: [gutter _ 5].	self areYouAutoScaled		ifFalse: 			[(label1 _ OrderedCollection new) add: 'Maximum <' , theMax printString , '>,<' , theMaximum printString , '> :'.			(label2 _ OrderedCollection new) add: 'Minimum <' , theMin printString , '>,<' , theMinimum printString , '> :'.			(defaultString _ OrderedCollection new) add: theMaximum printString; add: theMinimum printString; add: theInterval printString; add: gutter printString; add: #no.			(label3 _ OrderedCollection new) add: 'Interval <' , theInterval printString , '> :'.			(labelString _ OrderedCollection new) add: label1; add: label2; add: label3; add: #('gutter width'); add: #('recalculate interval?' yes no).			answers _ DBoxView						openFor: #(fill fill fill fill select )						labels: labelString						defaults: defaultString.			answers = nil ifTrue: [^false].			theMaximum _ (answers at: 1) asNumber max: ((answers at: 2) asNumber).			theMinimum _ (answers at: 2) asNumber min: ((answers at: 1) asNumber).			"(theMinimum _ (answers at: 2) asNumber) > 0 ifTrue: [theMinimum _ 0]."			theInterval _ (answers at: 3) asNumber.			gutter _ (answers at: 4) asNumber max: 5.			(answers at: 5) = #yes ifTrue: [self calculateInterval]].	(theABSMax _ theMaximum - theMinimum) = 0		ifTrue: 			[self booboo: 'Scaling is wrong!! Max = Min'.			^false].	"maybe new"	temp _ OrderedCollection new.	0		to: theMaximum		by: theInterval		do: [:i | temp add: i].	0 to: theMinimum by: theInterval negated do: [:i | temp add: i]."	temp add: theMaximum."	temp do: 		[:theMid | 		theMidPoint _ theMinPoint x @ (theMinPoint y + (theMaxPoint y - theMinPoint y * (theMid - theMinimum / theABSMax)) asInteger).		aLine beginPoint: theMidPoint + (5 @ 0); endPoint: theMidPoint - (5 @ 0); displayOn: aForm.		theMidText _ self formFrom: theMid asFloat printString.		theMidTextPoint _ theMidPoint - (theMidText width @ (theMidText height // 2)) - (6 @ 0).		theMidText			displayOn: aForm			at: theMidTextPoint			clippingBox: clipRectangle			rule: Form over			mask: Form black]. 	theMinimum > 0		ifTrue: 			[zeroOffset _ (theMaxPoint y - theMinPoint y * theMinimum / (theMinimum - theMaximum)) asInteger.			scaleLine beginPoint: aRectangle bottomLeft - (10@0); endPoint: aRectangle bottomRight; displayOn: aForm]		ifFalse: 			[zeroOffset _ (theMaxPoint y - theMinPoint y * (theMinimum abs / theABSMax)) asInteger.			temp _ ((aRectangle corner y + zeroOffset) max: aRectangle top) min: aRectangle bottom.			theMaxPoint _ aRectangle origin x - 10 @ temp.			theMinPoint _ aRectangle right @ temp.			scaleLine beginPoint: theMaxPoint; endPoint: theMinPoint; displayOn: aForm].	^true! !!BarChart methodsFor: 'spreadsheet accessing'!title: aString labels: aMatrix data: anotherMatrix	self title: aString.	self isFilled.	self isLabeled.	labelArray _ OrderedCollection new.	dataArray _ OrderedCollection new.	aMatrix do: [:each | labelArray add: each].	anotherMatrix do: [:each | dataArray add: each].	^self! !!BarChart methodsFor: 'accessing'!theInterval	^theInterval!theInterval: anInteger	theInterval _ anInteger!theMaximum	^theMaximum!theMaximum: anInteger	theMaximum _ anInteger!theMinimum	^theMinimum!theMinimum: anInteger	theMinimum _ anInteger!zeroOffset	^zeroOffset!zeroOffset: anInteger	zeroOffset _ anInteger! !LineChart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!LineChart methodsFor: 'displaying'!displayOn: targetForm at: aPoint clippingBox: aRectangle 	"display a line chart on the target form"	| rect norm spacing labeling top dispPoint oldPoint displayRect line aLine theMaxPoint theMinPoint bottom |	(line _ Line new) form: (Form new extent: 2 @ 2) black.	aLine _ Line new.	rect _ self calculateAreaForBars: targetForm within: aRectangle.	(displayRect _ rect copy) corner: displayRect corner x @ (displayRect corner y - 30).	spacing _ (rect width / dataArray size) asInteger.	"calculate max value on array"	theMaximum _ theMinimum _ 0.	dataArray do: 		[:i | 		i > theMaximum ifTrue: [theMaximum _ i].		i < theMinimum ifTrue: [theMinimum _ i]].	(self writeAxisOn: targetForm beside: displayRect clippingBox: aRectangle)		ifFalse: [^false].	norm _ rect height - 30 / (theMaximum - theMinimum).	theMaxPoint _ displayRect origin x - 10 @ displayRect origin y.	theMinPoint _ displayRect origin x - 10 @ displayRect corner y.	"display the bars on the target form"	title = nil ifFalse: [self titleOn: targetForm at: aPoint clippingBox: aRectangle].	1 to: dataArray size do: 		[:i | 		(dataArray at: i)			> 0			ifTrue: 				[top _ rect top + rect height - 30 - ((dataArray at: i)								* norm) asInteger + zeroOffset.				bottom _ displayRect bottom + 10 + zeroOffset.				top _ (theMaxPoint y max: top) min: (theMinPoint y).				bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).				dispPoint _ rect left + (spacing // 2) + (spacing * (i - 1)) @ top.				aLine endPoint: dispPoint; beginPoint: dispPoint x @ bottom; displayOn: targetForm]			ifFalse: 				[top _ displayRect bottom + 10 - ((dataArray at: i)								* norm) asInteger + zeroOffset.				bottom _ rect top + rect height - 40 + zeroOffset.				top _ (theMaxPoint y max: top) min: (theMinPoint y).				bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).				dispPoint _ rect left + (spacing // 2) + (spacing * (i - 1)) @ top.				aLine endPoint: dispPoint; beginPoint: dispPoint x @ bottom; displayOn: targetForm].		oldPoint = nil ifFalse: [line beginPoint: oldPoint; endPoint: dispPoint; displayOn: targetForm].		oldPoint _ dispPoint copy].	isLabeled ifTrue: [self labelOn: targetForm at: aPoint clippingBox: aRectangle ].	isLegended ifTrue: [self legendOn: targetForm at: aPoint clippingBox: aRectangle]! !StackedBarChart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!StackedBarChart methodsFor: 'displaying'!displayOn: targetForm at: aPoint clippingBox: aRectangle	"display a stacked bar chart on the target form"	| rect norm spacing labeling top bottom dispRect displayRect thisValue theMaxPoint theMinPoint mask thatValue |	rect _ self calculateAreaForBars: targetForm within: aRectangle.	(displayRect _ rect copy) corner: displayRect corner x @ (displayRect corner y - 30).	spacing _ (rect width / dataArray size) asInteger.	"calculate max value on array"	theMaximum _ theMinimum _ thisValue _ thatValue _ 0.	1 to: dataArray size do: [:i | (dataArray at: i) 			do: [:j | j > 0					ifTrue: [thisValue _ thisValue + j]					ifFalse: [thatValue _ thatValue + j].				thisValue > theMaximum ifTrue: [theMaximum _ thisValue].				thatValue < theMinimum ifTrue: [theMinimum _ thatValue]].				thisValue _ thatValue _ 0].	(self writeAxisOn: targetForm beside: displayRect clippingBox: aRectangle)		ifFalse: [^false].	norm _ rect height - 30 / (theMaximum - theMinimum).	theMaxPoint _ displayRect origin x - 10 @ displayRect origin y.	theMinPoint _ displayRect origin x - 10 @ displayRect corner y.	"display the bars on the target form"	title = nil ifFalse: [self titleOn: targetForm at: aPoint clippingBox: aRectangle].	1 to: dataArray size do: 		[:i |1 to: (dataArray at: i) size do: 			[:j |thisValue _ 0.			j to: (dataArray at: i) size do: [:k | ((dataArray at: i) at: k)					> 0 ifTrue: [thisValue _ thisValue + ((dataArray at: i) at: k)]].			top _ rect top + rect height - 30 - (thisValue * norm) asInteger + zeroOffset.			bottom _ (rect bottom - 29 + zeroOffset).			top _ (theMaxPoint y max: top) min: (theMinPoint y).			bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).			dispRect _ rect left +gutter + (spacing * (i - 1)) @ top corner: rect left + (spacing * i) - gutter @ bottom.			isFilled				ifTrue: [mask _ self mask: (((j - 1) \\ maskArray size) + 1)]				ifFalse: [mask _ Form white].			targetForm				fill: dispRect				rule: Form over				mask: Form black;				fill: (dispRect insetBy: 1 @ 1)				rule: Form over				mask: mask].		1 to: (dataArray at: i) size do: 			[:j | 			thisValue _ 0.			j to: (dataArray at: i) size do: [:k | ((dataArray at: i) at: k)					< 0 ifTrue: [thisValue _ thisValue + ((dataArray at: i) at: k)]].			top _ rect top + rect height - 30 + zeroOffset.			bottom _ (rect bottom - 30 - (thisValue * norm) asInteger + zeroOffset).			top _ (theMaxPoint y max: top) min: (theMinPoint y).			bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).			dispRect _ rect left + gutter + (spacing * (i - 1)) @ top corner: rect left + (spacing * i) - gutter @ bottom.			isFilled				ifTrue: [mask _ self mask: (((j - 1) \\ maskArray size) + 1)]				ifFalse: [mask _ Form white].			targetForm				fill: dispRect				rule: Form over				mask: Form black;				fill: (dispRect insetBy: 1 @ 1)				rule: Form over				mask: mask]].	isLabeled ifTrue: [self labelOn: targetForm at: aPoint clippingBox: aRectangle].	isLegended ifTrue: [self legendOn: targetForm at: aPoint clippingBox: aRectangle]! !!StackedBarChart methodsFor: 'labeling'!labelOn: targetForm 	"label a stacked bar chart on the target form"	self labelOn: targetForm at: 0@0 clippingBox: targetForm computeBoundingBox!labelOn: targetForm at: aPoint clippingBox: aRectangle 	"label a stacked bar chart on the target form"	| rect norm spacing labeling top dispRect displayRect thisValue form |	dataArray = nil ifTrue: [^self].	rect _ self calculateAreaForBars: targetForm within: aRectangle.	displayRect _ rect copy.	displayRect corner: displayRect corner x @ (displayRect corner y - 30).	spacing _ (rect width / dataArray size) asInteger.	"calculate max value on array"	self class name = #ClusteredBarChart		ifTrue: [1 to: dataArray size do: 				[:i | 				form _ self formFrom: (labelArray at: i).				form displayOn: targetForm at: rect bottomLeft - (0 @ 20) + (spacing * (i - 1) + (spacing - gutter - form width / 2) @ 0)]]		ifFalse: [1 to: dataArray size do: 				[:i | 				form _ self formFrom: (labelArray at: i).				form displayOn: targetForm at: rect bottomLeft - (0 @ 20) + (spacing * (i - 1) + (spacing - form width / 2) @ 0)]]!labelsInStack	"return the labels each stack element has"	^ stackedLabels!labelsInStack: anOrderedCollection	"set the labels each stack element will have"	stackedLabels _ anOrderedCollection! !!StackedBarChart methodsFor: 'legending'!legendOn: targetForm	self legendOn: targetForm at: 0@0 clippingBox: targetForm computeBoundingBox with: stackedLabels!legendOn: targetForm at: aPoint clippingBox: aRectangle	self legendOn: targetForm at: aPoint clippingBox: aRectangle with: stackedLabels! !XYChart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!XYChart methodsFor: 'displaying'!displayOn: targetForm at: aPoint clippingBox: aRectangle 	"display a XY chart on the target form"	| displayRect xMax yMax xMin yMin thisValue aForm xAxis width height point theFit |	"initialize, draw axes and title"	displayRect _ self calculateAreaForBars: targetForm within: aRectangle.	(self writeAxisOn: targetForm beside: displayRect clippingBox: aRectangle)		ifFalse: [^false].	self		titleOn: targetForm		at: aPoint		clippingBox: aRectangle.	"set boundaries"	xMax _ theMaximum x.  yMax _ theMaximum y.  	xMin _ theMinimum x.  yMin _ theMinimum y.	width _ displayRect width.  height _ displayRect height.	"check type of display, and initialize fits if curve is connected"	type = #dot		ifFalse: 			[(aForm _ Form new extent: 1 @ 1) black.			type = #connected ifTrue: [theFit _ SortedLinearFit new].			type = #spline ifTrue: [theFit _ SortedSpline new].			theFit form: aForm].	"process each point"	1 to: dataArray size do: 		[:i | 		point _ displayRect bottomLeft 				+ ((labelArray at: i) asNumber - xMin / (xMax - xMin) * width 						@ ((dataArray at: i) - yMin / (yMin - yMax) * height)).		type = #dot ifFalse: [theFit add: point - 1].		dot			displayOn: targetForm			at: point			clippingBox: aRectangle			rule: Form under			mask: Form black].	type = #spline ifTrue: [theFit computeCurve].	type = #dot ifFalse: [theFit displayOn: targetForm at: 0@0 clippingBox: displayRect]! !!XYChart methodsFor: 'labeling'!writeAxisOn: aForm beside: aRectangle clippingBox: clipRectangle	"the form height is 19 for emphasis = 2.  reset this to other number if  	emphasis changed!!"	| answers max min order offset xScaleLine yScaleLine theMaxPoint theMinPoint tickCollection range theMidPoint theMidText theMidTextPoint |	(answers _ self XYDBox) = nil ifTrue: [^false].	title _ answers at: 1.	type _ answers at: 8.	theMaximum _ max _ (answers at: 2) asNumber @ (answers at: 3) asNumber.	theMinimum _ min _ (answers at: 4) asNumber @ (answers at: 5) asNumber.	theInterval _ order _ (answers at: 6) asNumber abs @ (answers at: 7) asNumber abs.	min x > max x | (min y > max y) | (max x = min x) | (max y = min y)		ifTrue: 			[self booboo: 'Something is wrong about the scaling!! Do it again!!'.			^false].	offset _ aRectangle right - aRectangle left * (min x min: 0) abs / (max x - min x) 		@ (aRectangle bottom - aRectangle top * (min y min: 0) / (max y - min y)).	"draw the axis lines"	xScaleLine _ Line new.	xScaleLine beginPoint: (self constrain: aRectangle origin + (offset x @ 0) toLieWithin: aRectangle).	xScaleLine endPoint: (self constrain: aRectangle bottomLeft + (offset x @ 0) toLieWithin: aRectangle).	xScaleLine displayOn: aForm.	yScaleLine _ Line new.	yScaleLine beginPoint: (self constrain: aRectangle bottomLeft + (0 @ offset y) toLieWithin: aRectangle).	yScaleLine endPoint: (self constrain: aRectangle bottomRight + (0 @ offset y) toLieWithin: aRectangle).	yScaleLine displayOn: aForm.	"now the y tics"	theMaxPoint _ xScaleLine beginPoint.	theMinPoint _ xScaleLine endPoint.	tickCollection _ OrderedCollection new.	min y		to: max y		by: order y		do: [:theMid | tickCollection add: theMid].	tickCollection add: max y.	range _ max x - min x @ (max y - min y).	tickCollection do: 		[:theMid | 		theMidPoint _ theMinPoint x @ (theMinPoint y + (theMaxPoint y - theMinPoint y * (theMid - min y / range y))).		aForm			fill: (theMidPoint - (5 @ 0) corner: theMidPoint + (5 @ 1))			rule: Form over			mask: Form black.		theMidText _ self formFrom: theMid printString.		theMidTextPoint _ theMidPoint - (theMidText width @ 9) - (6@3).		theMidText			displayOn: aForm			at: theMidTextPoint			clippingBox: clipRectangle			rule: Form over			mask: Form black].	"now the x tics"	theMinPoint _ yScaleLine beginPoint.	theMaxPoint _ yScaleLine endPoint.	tickCollection _ OrderedCollection new.	min x		to: max x		by: order x		do: [:theMid | tickCollection add: theMid].	tickCollection add: max x.	tickCollection do: 		[:theMid | 		theMidPoint _ theMinPoint x + (theMaxPoint x - theMinPoint x * (theMid - min x / range x)) @ theMinPoint y.		theMid = 0 "avoid marking the zero twice"			ifFalse: 				[aForm					fill: (theMidPoint - (1@5) corner: theMidPoint + (0@5))					rule: Form over					mask: Form black.				theMidText _ self formFrom: theMid printString.				theMidTextPoint _ theMidPoint x - (theMidText width // 2) @ (theMidPoint y + 5).				theMidText					displayOn: aForm					at: theMidTextPoint					clippingBox: clipRectangle					rule: Form over					mask: Form black]].	^true! !!XYChart methodsFor: 'private'!calculateAreaForBars: targetForm within: aRectangle	"calculate the space available on the form for the bars to be displayed"	| originPoint cornerPoint |	cornerPoint _ aRectangle corner - (30@30).	originPoint _ aRectangle  origin + ((aRectangle width // 10) @ ((aRectangle height // 8) + 10)).	originPoint x < (aRectangle origin x + 40) ifTrue:[originPoint x: aRectangle origin x + 40].	^originPoint corner: cornerPoint!constrain: aPoint toLieWithin: aRectangle	aPoint x < aRectangle origin x ifTrue:[aPoint x: aRectangle origin x].	aPoint y < aRectangle origin y ifTrue:[aPoint y: aRectangle origin y].	aPoint x > aRectangle corner x ifTrue:[aPoint x: aRectangle corner x].	aPoint y > aRectangle corner y ifTrue:[aPoint y: aRectangle corner y].	^aPoint!dot: aForm	"set the dot which will be used to draw the curve on fits"	dot _ aForm!type	"return which type of fit to use"	^type!type: aSymbol	"set which type of fit to use"	type _ aSymbol!XYDBox	| xMax yMax xMin yMin thisValue xOrder yOrder labelString label0 label1 label2 label3 label4 label5 label6 label7 defaultString |	xMax _ yMax _ xMin _ yMin _ 0.	1 to: dataArray size do: 		[:i | 		thisValue _ (labelArray at: i) asNumber.		thisValue > xMax ifTrue: [xMax _ thisValue].		thisValue < xMin ifTrue: [xMin _ thisValue].		thisValue _ dataArray at: i.		thisValue > yMax ifTrue: [yMax _ thisValue].		thisValue < yMin ifTrue: [yMin _ thisValue]].	xOrder _ (10 raisedTo: (self orderOf: xMax - xMin)) asFloat.	yOrder _ (10 raisedTo: (self orderOf: yMax - yMin)) asFloat.	(defaultString _ OrderedCollection new) 		add: title; 		add: (theMaximum isNil ifTrue:[(self computeAppropriateMax: xMax)] ifFalse:[theMaximum x]) printString; 		add: (theMaximum isNil ifTrue:[(self computeAppropriateMax: yMax)] ifFalse:[theMaximum y]) printString; 		add: (theMaximum isNil ifTrue:[(self computeAppropriateMax: xMin)] ifFalse:[theMinimum x]) printString; 		add: (theMaximum isNil ifTrue:[(self computeAppropriateMax: yMin)] ifFalse:[theMinimum y]) printString; 		add: (theInterval isNil ifTrue:[xOrder] ifFalse:[theInterval x]) printString; 		add: (theInterval isNil ifTrue:[yOrder] ifFalse:[theInterval y]) printString; 		add: type.	self areYouAutoScaled ifTrue: [^defaultString].	label0 _ OrderedCollection with: 'Title : '.	label1 _ OrderedCollection with: 'Maximum X <' , xMax printString , '> : '.	label2 _ OrderedCollection with: 'Maximum Y <' , yMax printString , '> : '.	label3 _ OrderedCollection with: 'Minimum X <' , xMin printString , '> :'.	label4 _ OrderedCollection with: 'Minimum Y <' , yMin printString , '> :'.	label5 _ OrderedCollection with: 'X Interval <' , xOrder printString , '> :'.	label6 _ OrderedCollection with: 'Y Interval <' , yOrder printString , '> :'.	label7 _ (OrderedCollection with: 'Select format: ').	label7 add: #dot; add: #connected; add: #spline.	(labelString _ OrderedCollection new) add: label0; add: label1; add: label2; add: label3; add: label4; add: label5; add: label6; add: label7.	^DBoxView		openFor: #(fill fill fill fill fill fill fill select )		labels: labelString		defaults: defaultString! !StackedLineChart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!StackedLineChart methodsFor: 'displaying'!displayOn: targetForm at: aPoint clippingBox: aRectangle 	"display a StackedLineChart on the target form"	"create the array of previous points to be used in the various  	lines."	| aLine displayRect dispPoint line norm oldPoints rect spacing thisValue top theMaxPoint theMinPoint bottom |	oldPoints _ Array new: (dataArray at: 1) size.	aLine _ Line new.	line _ Line new.	line form: (Form extent: 4 @ 4) black.	"calculate a target rectangle on the targetForm"	rect _ self calculateAreaForBars: targetForm within: aRectangle.	displayRect _ rect origin corner: rect corner - (0 @ 30).	spacing _ (rect width / dataArray size) asInteger.	theMaxPoint _ displayRect origin x - 10 @ displayRect origin y.	theMinPoint _ displayRect origin x - 10 @ displayRect corner y.	"calculate max value on array"	theMaximum _ theMinimum _ 0.	1 to: dataArray size do:		[:i |		(dataArray at: i) do:			[:j |			theMaximum _ theMaximum max: j.			theMinimum _ theMinimum min: j.			].		].	(self writeAxisOn: targetForm beside: displayRect clippingBox: aRectangle) ifFalse: [^false].	norm _ rect height - 30 / (theMaximum - theMinimum).	"display the title on the target form"	title = nil ifFalse: [self titleOn: targetForm at: aPoint clippingBox: aRectangle].	"display the lines on the target form"	1 to: dataArray size do:		[:i |		1 to: (dataArray at: i) size do: 			[:j | 			thisValue _ (dataArray at: i) at: j.			top _ rect top + rect height - 30 - (thisValue * norm) asInteger + zeroOffset.			bottom _ displayRect bottom + 10 + zeroOffset.			top _ (theMaxPoint y max: top) min: (theMinPoint y).			bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).			dispPoint _ rect left + (spacing // 2) + (spacing * (i - 1)) @ top.			aLine endPoint: dispPoint.			aLine beginPoint: dispPoint x @ bottom.			aLine displayOn: targetForm.			(oldPoints at: j) = nil ifFalse: 				[line beginPoint: (oldPoints at: j).				line endPoint: dispPoint.				line					displayOn: targetForm					at: 0 @ 0					clippingBox: rect					rule: Form over					mask: (self mask: j).				].			oldPoints at: j put: dispPoint.			].		].	isLabeled ifTrue: [self labelOn: targetForm at: aPoint clippingBox: aRectangle.].	isLegended ifTrue: [self legendOn: targetForm at: aPoint clippingBox: aRectangle.].! !ClusteredBarChart comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!ClusteredBarChart methodsFor: 'displaying'!displayOn: targetForm at: aPoint clippingBox: aRectangle	"display a clustered bar chart on the target form"	| rect norm spacing labeling top dispRect displayRect clusterSpacing tempRect theMaxPoint theMinPoint mask thisValue bottom |	rect _ self calculateAreaForBars: targetForm within: aRectangle.	(displayRect _ rect copy) corner: displayRect corner x @ (displayRect corner y - 30).	spacing _ (rect width / dataArray size) asInteger.	"calculate max value on array"	theMaximum _ theMinimum _ 0.	1 to: dataArray size do: [:i | (dataArray at: i)			do: 				[:j | 				j > theMaximum ifTrue: [theMaximum _ j].				j < theMinimum ifTrue: [theMinimum _ j]]].	(self writeAxisOn: targetForm beside: displayRect clippingBox: aRectangle)		ifFalse: [^false].	norm _ rect height - 30 / (theMaximum - theMinimum).	theMaxPoint _ displayRect origin x - 10 @ displayRect origin y.	theMinPoint _ displayRect origin x - 10 @ displayRect corner y.	"display the bars on the target form"	title = nil ifFalse: [self titleOn: targetForm at: aPoint clippingBox: aRectangle].	1 to: dataArray size do: 		[:i | 		dispRect _ rect left + (spacing * (i - 1)) @ top corner: rect left + (spacing * i) - gutter @ (rect bottom - 30).		clusterSpacing _ (dispRect width // dataArray size * (dataArray at: 1) size -  gutter // (dataArray at: 1) size) max: 10."dispRect width // (dataArray at: 1) size * 2 // 3".		1 to: (dataArray at: i) size do: 			[:j | 			thisValue _ (dataArray at: i)						at: j.			thisValue >= 0				ifTrue: 					[top _ rect top + rect height - 30 - (thisValue * norm) asInteger + zeroOffset.					bottom _ (rect bottom - 29 + zeroOffset).					top _ (theMaxPoint y max: top) min: (theMinPoint y).					bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).					tempRect _ dispRect left + (clusterSpacing * (j - 1)) @ top corner: dispRect left + (clusterSpacing * j) @ bottom]				ifFalse: 					[top _ rect top + rect height - 30 + zeroOffset.					bottom _ (rect bottom - 30 - (thisValue * norm) asInteger + zeroOffset).					top _ (theMaxPoint y max: top) min: (theMinPoint y).					bottom _ (theMinPoint y min: bottom) max: (theMaxPoint y).					tempRect _ dispRect left + (clusterSpacing * (j - 1)) @ top corner: dispRect left + (clusterSpacing * j) @ bottom].			isFilled				ifTrue: [mask _ self mask: (((j - 1) \\ maskArray size) + 1)]				ifFalse: [mask _ Form white].			targetForm				fill: tempRect				rule: Form over				mask: Form black;				fill: (tempRect insetBy: 1 @ 1)				rule: Form over				mask: mask]].	isLabeled ifTrue: [self labelOn: targetForm at: aPoint clippingBox: aRectangle].	isLegended ifTrue: [self legendOn: targetForm at: aPoint clippingBox: aRectangle]! !XDEInterfaceModel comment:'Copyright (c) 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!XDEInterfaceModel methodsFor: 'menu messages'!abort	(self confirm: 'Are you sure youwant to risk abortion now?') ifFalse: [^self].	self quietAbort!changeRequest	TheXDE _ nil.	^true!flushQueue	self class installQueueProcess!ftp	| dirname theReturn command sourceFname destFname sw defaults | 	self loggedIn		ifFalse: [userProfile login == nil ifTrue: [^self] ifFalse: [^self ftp]].	defaults _ Array new: 6.	defaults at: 1 put: #list;		at: 2 put: self defaultHostType;		at: 3 put: userProfile ifsName;		at: 4 put: userProfile connectName;		at: 5 put: String new;		at: 6 put: String new.	theReturn _ DBoxView					openFor: #( select select fill fill fill fill)					title: 'FTP command'					labels: #( #( Command: list retrieve store delete) #( Connection: NS PUP) #( Host:) #( Directory:) #( 'Source File name:') #( 'Destination File name:'))					defaults: defaults.	theReturn == nil ifTrue: [^self].	command _ theReturn at: 1.	userProfile connect: (dirname _ theReturn at: 4).	(theReturn at: 3) isEmpty		ifTrue: [^self show: 'Command aborted - insufficient information'].	dirname isEmpty ifTrue: [dirname _ String with: $*].	dirname _ dirname copyReplaceAll: (String with: $*) with: (String with: $' with: $*).	dirname _ (String with: $"), dirname, (String with: $").	sourceFname _ theReturn at: 5.	destFname _ theReturn at: 6.	sourceFname isEmpty ifTrue: [sourceFname _ String with: $*].	command = #store		ifFalse: [sourceFname _ sourceFname copyReplaceAll: (String with: $*) with: (String with: $' with: $*).				sourceFname _ sourceFname copyReplaceAll: (String with: $ ) with: '" "'.				sourceFname _ (String with: $"), sourceFname, (String with: $")].	(command = #retrieve or: [command = #store])		ifTrue: [destFname isEmpty ifFalse:					[(destFname includes: $*)						ifTrue: [^self show: 'Command aborted - ambiguous file name specified: ', destFname].					command = #store						ifTrue: [destFname _ (String with: $"), destFname, (String with: $")]]].	userProfile ifsName: ((theReturn at: 2) = #NS ifTrue: [self appendHost: (theReturn at: 3)] ifFalse: [theReturn at: 3]).	sw _ String with: $c.	command = #list		ifTrue: [sw _ sw, (String with: $l with: $d)]		ifFalse: [command = #store ifTrue: [sw _ String with: $u with: $a]].	self ftp: command directory: dirname source: sourceFname destination: destFname switches: sw doAfter: [:xdeModel :unusedArgs | ] withArgs: nil!ftp: command directory: dirName source: sourceFname destination: destFname switches: sw doAfter: afterBlock withArgs: afterArgs	"afterBlock takes two arguments, the first is the xde instance, the second is the afterArgs"	(destFname == nil or: [destFname = String new])		ifTrue: [self sendTemplate: 'ftp/l "', userProfile ifsName, (String with: $"), ' dir/c ', dirName, (String with: $ ), command, (String with: $/), sw, (String with: $ ), sourceFname doAfter: afterBlock withArgs: afterArgs]		ifFalse: [self sendTemplate: 'ftp/l "', userProfile ifsName, (String with: $"), ' dir/c ', dirName, (String with: $ ), command, (String with: $/ with: $s), sw, (String with: $ ), sourceFname, (String with: $ ), destFname doAfter: afterBlock withArgs: afterArgs]!login	userProfile login == nil		ifFalse: [self networkLogin]!sendCommandToXDE	| aString | 	aString _ FillInTheBlank request: 'enter command:' initialAnswer: String new.	Queue addLast: [self sendCommandString: aString heading: aString resultsFrom: String new].! !!XDEInterfaceModel methodsFor: 'utility'!addDummy	Queue addFirst: [self sendCommandLine: 'del junk.junk' signal: Semaphore new]!appendHost: aString	"First check aString to determine whether NS or PUP. If NS, append domain and organization if not appended already. return the fully qualified host name."	| index append s next qualification arr |	index _ 0.	append _ 2.	s _ aString.	qualification _ String with: $:.	[next _ s findString: qualification startingAt: index + 1.	next = 0]		whileFalse: [index _ index + next.					append _ append - 1].	arr _ Array with: userProfile domain with: userProfile organization.	1 to: append do: [:i | s _ s, qualification, (arr at: (2 - append + i))].	^s!defaultHostType	^(userProfile ifsName == nil or: [userProfile ifsName includes: $:])		ifTrue: [#NS]		ifFalse: [#PUP]!fixPasswordIn: aString	| start password |	password _ userProfile userPassword.	start _ aString findString: password startingAt: 1.	start = 0 ifTrue: [^aString].	^(aString copyFrom: 1 to: start - 1), ((String new: password size) atAllPut: $*), (aString copyFrom: start+(password size) to: aString size)!loggedIn	^(userProfile userName size > 0		and: [userProfile userPassword size > 0			and: [userProfile domain size > 0				and: [userProfile organization size > 0]]])!networkLogin	"really send the login message to the Tajo executive.  Although this is not waiting for completion, if it has not already done so, it will get time to complete the first time someone tries to use the interface, and thereby serve its purpose of getting the user logged in"	| aSemaphore | 	Cursor wait showWhile: [	Queue addLast: [		aSemaphore _ Semaphore new.		self sendCommandLine: 'login ', UserProfile current userName, (String with: $ ), UserProfile current userPassword signal: aSemaphore.		aSemaphore wait].	(Delay forMilliseconds: 200) wait] "this is to give it a chance to go right now - the primitive call takes 1 - 2 seconds which is very annoying if it hits in a screen flash"!pickFileServer	| theHosts return | 	(theHosts _ UserProfile current fileServerChoices copy) isEmpty ifTrue: [self booboo: 'I do not know about any file servers'. ^nil].	theHosts addFirst: #Hosts:.	self loggedIn ifFalse: [self login].	self loggedIn ifFalse: [self booboo: 'Improper login try again'. ^nil].	UserProfile current ifsName isEmpty ifTrue: [UserProfile current ifsName: (theHosts at: 1)]. 	return _ DBoxView		openFor: #( select )		title: 'Select the File Server'		labels: (Array with: (theHosts asArray))		defaults: (Array with: (UserProfile current ifsName))		autoAccept: true.	return == nil ifTrue: [^nil].	UserProfile current ifsName: (return at: 1).	^ return at: 1!quietAbort	| aSemaphore | 	self sendCommandLine: 'AbortTajoExecCommand' signal: (aSemaphore _ Semaphore new).	self show: '\Aborting current command ... stand by ...\' withCRs.	aSemaphore wait!sendCommandString: aString heading: initMsg resultsFrom: aFileName	"In normal case, ftp command results can be found in 'ftp.log'. But sometimes, the result is in 'ftp.logX'	 - for big list maybe ??"	| aSemaphore lastStatus |	DisplayCritical wait.	self show: ('------------------------------------\', initMsg, '\') withCRs.	DisplayCritical signal.	aSemaphore _ Semaphore new.	self sendCommandLine: aString signal: aSemaphore.	aSemaphore wait.	DisplayCritical wait.	self displayResultsFrom: aFileName.	lastStatus _ self showStatus.	DisplayCritical signal.	^lastStatus!sendTemplate: aString	Queue addLast:		[self sendCommandString: aString heading: (self fixPasswordIn: aString) resultsFrom: 'ftp.log'.		self locked: false].!sendTemplate: aString doAfter: aBlock withArgs: args	| status |	Queue addLast:		[status _ self sendCommandString: aString heading: (self fixPasswordIn: aString) resultsFrom: 'ftp.log'.		status = 'Aborted\' ifFalse: [aBlock value: self value: args].		self locked: false].! !!XDEInterfaceModel methodsFor: 'displaying'!displayFileContents	| aFileName | 	aFileName _ FillInTheBlank request: 'enter file name:' initialAnswer: 'ftp.logX'.	self show: ('------------------\', aFileName, ':\') withCRs.	self displayResultsFrom: aFileName!displayResultsFrom: aFileName	| f sz | 	(aFileName == nil or: [aFileName isEmpty])		ifTrue: [^self].	(Disk includesKey: aFileName)		ifTrue: [f _ (FileStream oldFileNamed: aFileName) readOnly.				sz _ f size.				[sz > 0]				whileTrue: [self showPart: (f next: (5120 min: sz)).							sz _ sz - 5120].				f close]		ifFalse: [self show: (aFileName, ' does not exist\') withCRs]!show: msgString	| theController col | 	(col _ self dependents) isEmpty		ifFalse: [theController _ (col at: 1) controller.				theController appendText: msgString asText]!showPart: msgString	| theController col | 	(col _ self dependents) isEmpty		ifFalse: [theController _ (col at: 1) controller.				theController appendPartialText: msgString asText]!showStatus	| status | 	self showPart: (status _ #('Finished\' 'Warning\' 'Aborted\' 'Error\' 'Inactive\' 'Pending\') at: self status) withCRs.	^status! !!XDEInterfaceModel methodsFor: 'initialize-release'!initialize	userProfile _ UserProfile current.	grounded _ false!locked	^grounded!locked: shouldI	grounded _ shouldI.	grounded		ifTrue: [Cursor mouse show]		ifFalse: [Cursor normal show]! !!XDEInterfaceModel methodsFor: 'menu'!menu	^grounded		ifTrue: [LockedMenu]		ifFalse:[Wheel			ifTrue: [Menu]			ifFalse:[LockedMenu]]! !!XDEInterfaceModel methodsFor: 'primitives'!sendCommandLine: theCommand signal: aSemaphore	"starts a process to send theCommand to the tajo executive window.  When it finishes (for whatever reason), aSemaphore will be signaled"	<primitive: 180>	^self primitiveFailed!status	"returns an integer indicating the status of the last call on the primitive sendCommandLine:signal:	 the integer correspondence is: 1 = success; 2 = warning; 3 = abort; 4 = error; 5 = notStarted; 6 = pending"	<primitive: 181>	^self primitiveFailed! !Matrix comment:'Copyright (c) Xerox Corporation, 1987. All rights reserved.Class Matrix implements a protocol for creating and manipulating 2 dimensional matrices.  The following functions have been implemented:		Simple matrix arithmetic		row and column ops		determinants		inverses		cofactors		statistical functionsStandard collection enumation protocols have been implemented, along with some special enumeration and iteration operations unique to matrices.Some special protocols to allow interaction with spreadsheets are implemented.'!!Matrix methodsFor: 'initialize-release'!release 	1 to: self xSize do:		[:i | 1 to: self ySize do: [:j | (self atPoint: i @ j) release.			 self atPoint: i @ j put: nil]].	super release.! !!Matrix methodsFor: 'arithmetic'!* aValue	"Multiplies a Matrix by another Matrix or scalar"	| sum result k |	(aValue isKindOf: Number)		ifTrue:			[ result _ Matrix new: self ySize by: self xSize.			1 to: self xSize do:				[:i | 1 to: self ySize do:					[:j | result atPoint: i @ j put: (self atPoint: i @ j) * aValue]].			^result].	(aValue isKindOf: Matrix)		ifTrue:			[result _ Matrix new: self ySize by: aValue xSize.			k _ self xSize.			1 to: result ySize do:				[:i | 1 to: result xSize do:					[:j |  sum _ 0.						1 to: k do:							[:t | sum _ sum + ((self atPoint: t @ i) * (aValue atPoint: j @ t ))].						result atPoint: j @ i put: sum]].			^result].	self error: 'Improper object to multiply with a matrix'!+ aMatrix	"Add a Matrix to another Matrix or scalar"	| sum result |	((aMatrix isKindOf: Matrix) and: [self xySize = aMatrix xySize])		ifTrue:			[result _ Matrix new: self ySize by: self xSize.				1 to: self xSize do:					[:i | 1 to: self ySize do:							[:j | result atPoint: i@j put: ((self atPoint: i@j) + (self atPoint: i@j))]].			^result].	self error: 'Improper object to add to a matrix'!- aMatrix	"Subtract a Matrix from another Matrix or scalar"	| sum result |	((aMatrix isKindOf: Matrix) and: [self xySize = aMatrix xySize])		ifTrue:			[result _ Matrix new: self ySize by: self xSize.				1 to: self xSize do:					[:i | 1 to: self ySize do:							[:j | result atPoint: i@j put: ((self atPoint: i@j) - (self atPoint: i@j))]].			^result].	self error: 'Improper object to add to a matrix'!/ aValue	"Divides a Matrix by another Matrix or scalar"	| sum result |	(aValue isKindOf: Number)		ifTrue:			[ result _ Matrix new: self ySize by: self xSize.			1 to: self xSize do:				[:i | 1 to: self ySize do:					[:j | result atPoint: i @ j put: (self atPoint: i @ j) / aValue]].			^result].	(aValue isKindOf: Matrix)		ifTrue:			[result _ self * aValue deepCopy invert.			^result].	self error: 'Improper object to multiply with a matrix'!raisedTo: anInteger 	"Produce an integer power of a square matrix"	| result |	self xSize = self ySize ifFalse: [self error: 'matrix must be square to be raisedTo:'].	(anInteger isKindOf: Integer)		ifFalse: [self error: 'matrices may only be raised to integer powers'].	anInteger < 0 ifTrue: [^self deepCopy invert raisedTo: anInteger abs].	result _ self deepCopy.	1 to: anInteger - 1 do: [:i | result _ result * self].	^result!\\ aScalar	"take the modulo of each element in the matrix against aScalar"	| sum result |	result _ Matrix new: self ySize by: self xSize.	1 to: self xSize do:		[:i | 1 to: self ySize do:				[:j | result atPoint: i@j put: ((self atPoint: i@j) \\ aScalar)]].	^result! !!Matrix methodsFor: 'accessing'!atPoint: aPoint 	"return the contents of the matrix element at the specified row and column 	indices "	^collection at: aPoint x - 1 * self ySize + aPoint y!atPoint: aPoint put: anObject	"enter an object at the specified row and column indices"	collection at: aPoint x - 1 * self ySize + aPoint y put: anObject.!atRow: y column: x	"return the contents of the matrix element at the specified row and column indices"	^collection at:  x - 1 * self ySize + y!atRow: y column: x put: anObject	"enter an object at the specified row and column indices"	collection at: x - 1 * self ySize + y put: anObject!collection	^collection!collection: aCollection	collection _ aCollection!xSize	^xySize x!xysize	"return the x and y density of this matrix"	self size = 0 ifTrue:[^0@0].	^self size @ ((self at: 1) size)!xySize	^xySize!xySize: aPoint	xySize _ aPoint!ySize	^xySize y! !!Matrix methodsFor: 'statistical accessing'!mean	"find the range of the elements of a matrix"	| sum |	sum _ 0.	self do: [:each |			sum _ sum + each].	^sum / (self xSize * self ySize)!median	"find the median of the elements of a matrix"	| arrayOfScores spot |	arrayOfScores _ SortedCollection new.	self do: [:each |			arrayOfScores add: each].	arrayOfScores size even 		ifTrue:[spot _ arrayOfScores size // 2.			^(arrayOfScores at: spot) + (arrayOfScores at: spot + 1) / 2]		ifFalse:[^(arrayOfScores at: arrayOfScores size // 2 + 1)]!mode	"find the mode of the elements of a matrix"	| dictOfScores mode topKeySize topKey |	dictOfScores _ OopConservingDictionary new.	self do: [:each | 			dictOfScores at: each				put: (dictOfScores at: each ifAbsent: [0]) + 1].	topKeySize _ 0.	dictOfScores keys do: [:eachKey | (dictOfScores at: eachKey)			> topKeySize			ifTrue: 				[mode _ OrderedCollection new.				mode add: eachKey.				topKeySize _ dictOfScores at: eachKey]			ifFalse: [(dictOfScores at: eachKey)					= topKeySize ifTrue: [mode add: eachKey]]].	mode size = 1 ifTrue:[^mode at: 1].	^mode!range	"find the range of the elements of a matrix"	| min max |	min _ max _ self atPoint: 1@1.	self do: [:each |			each < min ifTrue:[min _ each].			each > max ifTrue:[max _ each]].	^max - min!standardDeviation	"find the standardDeviation of the elements of a matrix"	| sum standardDeviation thisMean |	sum _ 0.	thisMean _ self mean.	self do: [:each |			sum _ sum + ((each - thisMean) raisedTo: 2)].	standardDeviation _ (sum / ((self ySize * self xSize) - 1)) sqrt.	^standardDeviation!sum	| sum | 	"sum the elements of a matrix"	sum _ 0.	self do: [:each | sum _ sum + each].	^sum!variance	"find the variance of the elements of a matrix"	| variance |	^self standardDeviation raisedTo: 2! !!Matrix methodsFor: 'special setting'!setAsScalar: aValue 	"set the contents of all elements of the matrix on the diagonal to be aValue.  	This is a matrix representation of a scalar.  The matrix must be square to be 	set to this."	self xSize = self ySize		ifTrue: 			[self setToZero.			1 to: self xSize do: [:i | self atPoint: i @ i put: aValue]]		ifFalse: [self error: 'Scalar Matrix Must be Square']!setTo: anObject	1 to: self xSize do: [:x | 1 to: self ySize do: [:y | self atPoint: x@y put: anObject]]!setToOnes	"set the contents of all elements of the matrix to be zero."	1 to: self xSize do:		[:i | 1 to: self ySize do:			[:j | self atPoint: j @ i put: 1]].!setToZero	"set the contents of all elements of the matrix to be zero."	1 to: self xSize do:		[:i | 1 to: self ySize do:			[:j | self atPoint: j @ i put: 0]].! !!Matrix methodsFor: 'row/column operations'!addColumn: aColumnNumber times: aNumber toColumn: anotherColumnNumber	"do an elementary column operation"	1 to: self ySize do: [:each |		self atPoint: anotherColumnNumber @ each			put: (self atPoint: aColumnNumber @ each) * aNumber + (self atPoint: anotherColumnNumber @ each)]!addRow: aRowNumber times: aNumber toRow: anotherRowNumber	"do an elementary row operation"	1 to: self xSize do: [:each |		self atPoint: each @ anotherRowNumber			put: (self atPoint: each @ aRowNumber) * aNumber + (self atPoint: each @ anotherRowNumber)]! !!Matrix methodsFor: 'operations'!cofactorFor: aPoint	"return the cofactor for the matrix element given in aPoint"	| result |	result _ Matrix new: self ySize - 1 by: self xSize - 1.	1 to: aPoint x - 1 do: [:i |		1 to: aPoint y - 1 do: [:j |			result atPoint: i@j put: (self atPoint: i@j)]].	1 to: aPoint x - 1 do: [:i |		aPoint y + 1 to: self ySize do: [:j |			result atPoint: i@(j - 1) put: (self atPoint: i@j)]].	aPoint x + 1 to: self xSize do: [:i |		1 to: aPoint y - 1 do: [:j |			result atPoint: (i - 1)@j put: (self atPoint: i@j)]].	aPoint x + 1 to: self xSize do: [:i |		aPoint y + 1 to: self ySize do: [:j |			result atPoint: (i - 1)@(j - 1) put: (self atPoint: i@j)]].	^result determinant!determinant	| product ltMat |	self xSize = self ySize ifFalse: [self error: 'No determinant is possible in a non-square matrix'].	^self deepCopy upperTriangularForm trace!inverse	^self deepCopy invert!invert	"Invert a matrix in place. Algorithm by P.Z. Ingerman, uses row operations to invert the matrix in place"	| eps q order |	"set the tolerance for singular matrices"	eps _ 0.001.	"check for squareness, set order of matrix"	self xSize ~= self ySize ifTrue: [^nil].	order _ self xSize.	1 to: order do: 		[:i | 		q _ self atPoint: i@i.		q abs <= eps abs ifTrue: [^nil].		self atPoint: i @ i put: 1.		q ~= 1 ifTrue: [1 to: order do: [:k | self atPoint: k @ i put: (self atPoint: k @ i) / q]].		1 to: order do: [:j | j ~= i				ifTrue: 					[q _ self atPoint: i @ j.					self atPoint: i @ j put: 0.					self addRow: i times: q negated toRow: j]]]!lowerTriangularForm	"find the lower triangular form of the matrix"	^self deepCopy lowerTriangularize!lowerTriangularize	"convert a matrix to its lower triangular form"	| multiplier |	self ySize to: 1 by: -1 do: [:i |		i-1 to: 1 by: -1 do: [:j |			(self atPoint: i@j) = 0 				ifFalse:[multiplier _ -1 * ((self atPoint: i@j) / (self atPoint: i@i)).					self addRow: i times: multiplier toRow: j]]].!trace	"compute the trace (product of elements on the main diagonal) of the receiver"	| product |	self xSize = self ySize ifFalse: [self error: 'No trace is possible in a non-square matrix'].	product _ 1.	1 to: self xSize do: [:i |		product _ product * (self atPoint: i@i)].	^product!upperTriangularForm	"find the upper triangular form of the matrix"	^self deepCopy upperTriangularize!upperTriangularize	"convert a matrix to its upper triangular form"	| multiplier |	1 to: self ySize do: [:i |		i+1 to: self ySize do: [:j |			(self atPoint: i@j) = 0 				ifFalse:[multiplier _ -1 * ((self atPoint: i@j) / (self atPoint: i@i)).					self addRow: i times: multiplier toRow: j]]].! !!Matrix methodsFor: 'printing'!printOn: aStream 	| tooMany |	tooMany _ aStream position + 1000.	aStream nextPutAll: self class name,' ('.	1 to: self ySize do: 		[:element | 		aStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].		1 to: self xSize do: [:each | 			(self atPoint: each @ element) printOn: aStream.			aStream nextPut: Character space].		aStream cr].	aStream nextPut: $)!storeOn: aStream 	| newStream |	newStream _ WriteStream on: String new.	newStream nextPutAll: self xSize printString.	newStream cr.	newStream nextPutAll: self ySize printString.	newStream cr.	1 to: self xSize do: 		[:x | 1 to: self ySize do: 			[:y | 			newStream nextPutAll: (self atPoint: x @ y) printString.			newStream cr]].	aStream nextPutAll: '(Matrix readFromString: ''' , newStream contents , ''')'! !!Matrix methodsFor: 'enumerating'!column: anInteger	| theColumn |	theColumn _ OrderedCollection new.	1 to: self ySize do: [:i |		theColumn add: (self atPoint: anInteger @ i)].	^theColumn!copyFromPoint: aPoint toPoint: anotherPoint	"extract a new matrix which runs from the element at aPoint  to the element at anotherPoint"	| theNewMatrix i j iCounter jCounter iStop jStop |	theNewMatrix _ Matrix new: anotherPoint y - aPoint y + 1 by: anotherPoint x - aPoint x + 1.	jStop _ anotherPoint y.	iStop _ anotherPoint x.	iCounter _ 0.	i _ aPoint x.	[i <= iStop]		whileTrue: 			[iCounter _ iCounter + 1.			jCounter _ 0.			j _ aPoint y.			[j <= jStop]				whileTrue: 					[jCounter _ jCounter + 1.					theNewMatrix atPoint: iCounter @ jCounter put: (self atPoint: i @ j) deepCopy.					j _ j + 1].			i _ i + 1].	^theNewMatrix!diagonalElements	"return a collection containing the daigonal elements of a square matrix"	| theDiagonal |	self xSize = self ySize 		ifFalse:[^self error: 'The Diagonal is undefined for a non-square matrix'].	theDiagonal _ OrderedCollection new.	1 to: self xSize do:[:i | theDiagonal add: (self atPoint: i@i)].	^theDiagonal!do: aBlock	"sum the elements of a matrix"	| i j iStop jStop |	jStop _ self ySize.	iStop _ self xSize.	i _ 1.	[i <= iStop]		whileTrue: 			[j _ 1.			[j <= jStop]				whileTrue: 					[aBlock value: (self atPoint: i @ j).					j _ j + 1].			i _ i + 1].	^self!fromPoint: aPoint toPoint: anotherPoint	"extract a new matrix which runs from the element at aPoint  to the element at anotherPoint"	| theNewMatrix i j iCounter jCounter iStop jStop |	theNewMatrix _ Matrix new: anotherPoint y - aPoint y + 1 by: anotherPoint x - aPoint x + 1.	jStop _ anotherPoint y.	iStop _ anotherPoint x.	iCounter _ 0.	i _ aPoint x.	[i <= iStop]		whileTrue: 			[iCounter _ iCounter + 1.			jCounter _ 0.			j _ aPoint y.			[j <= jStop]				whileTrue: 					[jCounter _ jCounter + 1.					theNewMatrix atPoint: iCounter @ jCounter put: (self atPoint: i @ j).					j _ j + 1].			i _ i + 1].	^theNewMatrix!fromPoint: aPoint toPoint: anotherPoint do: aBlock	| jStop iStop i jCounter j | 	"extract a new matrix which runs from the element at aPoint  to the element at anotherPoint"	jStop _ anotherPoint y.	iStop _ anotherPoint x.	i _ aPoint x.	[i <= iStop]		whileTrue: 			[jCounter _ 0.			j _ aPoint y.			[j <= jStop]				whileTrue: 					[aBlock value: (self atPoint: i @ j).					j _ j + 1].			i _ i + 1].	^self!paste: aMatrix atPoint: aPoint clippingSize: anotherPoint	"paste another matrix into this one, with the origin of the area to be overwritten at aPoint.  Make sure that the paste is clippped withinb the boundary size specified in anotherPoint and the bounds of this Matrix"	| iCounter jCounter startPointX stopPointX startPointY stopPointY |	iCounter _ 0.	startPointX _ aPoint x.	startPointY _ aPoint y.	stopPointX _ (startPointX + (aMatrix xSize min: anotherPoint x)) min: self xSize.	stopPointY _ (startPointY + (aMatrix ySize min: anotherPoint y)) min: self ySize.	startPointX to: stopPointX do:[:i | 		iCounter _ iCounter + 1.		jCounter _ 0.		startPointY to: stopPointY do: [:j |			jCounter _ jCounter + 1.			 self atPoint: i @ j put: (aMatrix atPoint: iCounter @ jCounter) deepCopy]].!row: anInteger	| theRow |	theRow _ OrderedCollection new.	1 to: self xSize do: [:i |		theRow add: (self atPoint: i @ anInteger)].	^theRow! !!Matrix methodsFor: 'spreadsheet support'!acronyms	| string | 	"set the contents of all elements of the the acronyms of themselves."	1 to: self xSize do:		[:i | 1 to: self ySize do:			[:j | string _ self atPoint: i @ j.				(string isKindOf: String) ifTrue:[self atPoint: i @ j put: string acronym]]].!copyOn: aStream 	1 to: self ySize do:  		[:element | 		1 to: self xSize do: [:each | 			(self atPoint: each @ element) printOn: aStream.			aStream nextPut: Character tab].		aStream cr]!copyString	| outStream |  	outStream _ WriteStream on: (String new: 200).	self copyOn: outStream.	^outStream contents!sumColumns	"sum the elements of a matrix"	| i j sum iStop jStop |	sum _ Matrix new: 1 by: self xSize.	sum setToZero.	jStop _ self ySize.	iStop _ self xSize.	i _ 1.	[i <= iStop]		whileTrue: 			[j _ 1.			[j <= jStop]				whileTrue: 					[(self atPoint: i @ j) == nil ifFalse: [sum atPoint: i @ 1 put: (sum atPoint: i @ 1) + (self atPoint: i @ j)].					j _ j + 1].			i _ i + 1].	^sum!sumRows	"sum the elements of a matrix"	| i j sum iStop jStop |	sum _ Matrix new: self ySize by: 1.	sum setToZero.	jStop _ self ySize.	iStop _ self xSize.	i _ 1.	[i <= iStop]		whileTrue: 			[j _ 1.			[j <= jStop]				whileTrue: 					[(self atPoint: i @ j) == nil ifFalse: [sum atPoint: 1 @ j put: (sum atPoint: 1 @ j) + (self atPoint: i @ j)].					j _ j + 1].			i _ i + 1].	^sum! !SpreadsheetHolder comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!SpreadsheetHolder methodsFor: 'initialize-release'!release	| cell dependents realFileName innerds row col dep |	realFileName _ fileName asUppercase.	AllHoldersDict removeKey: realFileName ifAbsent: [].	1 to: self rows do: [:row | 1 to: self columns do: 			[:col | 			cell _ self atRow: row column: col.			"check for dependents in other sheets, and save the proper stuff"			(cell == nilCell or: [cell contents == nil])				ifFalse: 					[dependents _ cell dependents.					innerds _ cell contents deepCopy.					cell release.					dependents size > 0						ifTrue: 							[(AllHoldersDict includesKey: realFileName)								ifFalse: [AllHoldersDict at: realFileName put: Dictionary new].							(AllHoldersDict at: realFileName)								at: col @ row put: innerds deepCopy.							dependents do: [:dep | ((dep holder == nil) | (dep holder == self)) not 									ifTrue:[((AllHoldersDict at: realFileName)											at: col @ row) addDependent: dep]]]].			self				atRow: row				column: col				put: nil]].	nilCell release.	nilCell _ nil.	cellsToUpdate release.	cellsToUpdate _ nil.	controller _ nil.	view _ nil.	super release! !!SpreadsheetHolder methodsFor: 'accessing'!allHolders	^AllHoldersDict!atPoint: aPoint 	"answer nilCell if aPoint is off sheet"	| thePoint |	aPoint class == Rectangle		ifTrue: [thePoint _ aPoint origin]		ifFalse: [aPoint class == Array				ifTrue: [thePoint _ (aPoint at: 2)								@ (aPoint at: 3)]				ifFalse: [thePoint _ aPoint]].	thePoint x >= 1 & (thePoint x <= self xSize) & (thePoint y >= 1 & (thePoint y <= self ySize))		ifTrue: [^super atPoint: thePoint]		ifFalse: [^nilCell]!atPoint: aPoint put: anObject	"do nothing if aPoint is off sheet"	(aPoint x >= 1 & (aPoint x <= self xSize)) & (aPoint y >= 1 & (aPoint y <= self ySize))		ifTrue: [super atPoint: aPoint put: anObject]!atRow: row column: column	"answer nilCell if aPoint is off sheet"	(column >= 1 & (column <= self xSize)) & (row >= 1 & (row <= self ySize))		ifTrue: [^super atRow: row column: column]		ifFalse: [^nilCell]!atRow: row column: column put: anObject	"do nothing if aPoint is off sheet"	(column >= 1 & (column <= self xSize)) & (row >= 1 & (row <= self ySize))		ifTrue: [super atRow: row column: column put: anObject]!badRef	"answer the instance used to represent bad references"	^badRef!badRef: anObject	"set the instance used to represent cells with bad references (one's that cause errors)"	^badRef _ anObject!boxAt: boxPoint 	"answer border box for cell at boxPoint, properly translated to fit the view"	| basicBox |	basicBox _ self basicBoxAt: boxPoint.	basicBox = nil		ifTrue: [^nil]		ifFalse: [^basicBox translateBy: view insetDisplayBox origin + 30 - (self originOf: view offsetPoint)]!boxFor: aCell	"answer aCell's box, or answer nil if aCell isNil"	aCell == nil		ifFalse: [^aCell box]		ifTrue: [^nil]!cellsToUpdate	^cellsToUpdate!clearUpdates	cellsToUpdate _ OrderedCollection new!columns	^self xSize!contentsFromPoint: aPoint toPoint: anotherPoint 	"extract a new matrix which runs from the element at aPoint  to the element  	at anotherPoint"	| theNewMatrix i j iCounter jCounter iStop jStop |	theNewMatrix _ Matrix new: anotherPoint y - aPoint y + 1 by: anotherPoint x - aPoint x + 1.	jStop _ anotherPoint y.	iStop _ anotherPoint x.	iCounter _ 0.	i _ aPoint x.	[i <= iStop]		whileTrue: 			[iCounter _ iCounter + 1.			jCounter _ 0.			j _ aPoint y.			[j <= jStop]				whileTrue: 					[jCounter _ jCounter + 1.					theNewMatrix atPoint: iCounter @ jCounter put: (self atPoint: i @ j) contents deepCopy.					j _ j + 1].			i _ i + 1].	^theNewMatrix!controller	^controller!controller: aController	controller _ aController!fileName	^fileName!fileName: aString	fileName _ aString!gridPointClosestTo: screenPoint 	"return holder coordinates for cell that contains screenPoint"	| gridPoint cellRow cellColumn rowIndex colIndex rowsDisplayed columnsDisplayed min thisDist |	rowsDisplayed _ view rowsToDisplay.	columnsDisplayed _ view columnsToDisplay.	cellRow _ rowsDisplayed x.	cellColumn _ columnsDisplayed x.	gridPoint _ screenPoint - view insetDisplayBox origin - 30 + (self originOf: view offsetPoint).	rowsDisplayed _ view rowsToDisplay.	min _ (gridPoint y - (yGrid at: rowsDisplayed x)) abs.	rowsDisplayed x to: rowsDisplayed y do: 		[:each | 		thisDist _ (gridPoint y - (yGrid at: each)) abs.		thisDist < min			ifTrue: 				[min _ thisDist.				cellRow _ each]].	min _ (gridPoint x - (xGrid at: columnsDisplayed x)) abs.	columnsDisplayed x to: columnsDisplayed y do: 		[:each | 		thisDist _ (gridPoint x - (xGrid at: each)) abs.		thisDist < min			ifTrue: 				[min _ thisDist.				cellColumn _ each]].	screenPoint x < (view insetDisplayBox origin x + 30) ifTrue: [cellColumn _ view offsetPoint x].	screenPoint x > view insetDisplayBox corner x ifTrue: [cellColumn _ 0].	screenPoint y < (view insetDisplayBox origin y + 30) ifTrue: [cellRow _ view offsetPoint y].	screenPoint y > view insetDisplayBox corner y ifTrue: [cellRow _ 0].	^cellColumn @ cellRow!initCellAt: aPoint	"Turn a nilCell into a unique cell."	| thePoint |	(aPoint isKindOf: Rectangle) 		ifTrue:[thePoint _ aPoint origin] 		ifFalse:[thePoint _ aPoint].	self atPoint: thePoint put: ((SpreadsheetCell in: self) xcell: thePoint x; ycell: thePoint y).	^self atPoint: thePoint!nilCell	"answer the instance used to represent unintialized cells"	^nilCell!nilCell: aCell	"set the instance used to represent unintialized cells"	^nilCell _ aCell!originOf: aGridPoint	| xPoint yPoint |	aGridPoint x = 1		ifTrue:[xPoint _ 0]		ifFalse:[xPoint _ xGrid at: aGridPoint x - 1].		aGridPoint y = 1		ifTrue:[yPoint _ 0]		ifFalse:[yPoint _ yGrid at: aGridPoint y - 1].	^xPoint @ yPoint!pointAt: screenPoint	"return holder coordinates for cell that contains screenPoint"	| gridPoint cellRow cellColumn rowIndex colIndex |	cellRow _ cellColumn _ 0.	gridPoint _screenPoint - view insetDisplayBox origin - 30 + (self originOf: view offsetPoint).	rowIndex _ view offsetPoint y.	[gridPoint y < (yGrid at: rowIndex) | (rowIndex >= yGrid size)]		whileFalse:[rowIndex _ rowIndex + 1].	colIndex _ view offsetPoint x.	[gridPoint x < (xGrid at: colIndex) | (colIndex >= xGrid size)]		whileFalse:[colIndex _ colIndex + 1].	cellRow _ rowIndex.	cellColumn _ colIndex.	screenPoint x < (view insetDisplayBox origin x + 30) ifTrue: [cellColumn _ view offsetPoint x].	screenPoint x > (view insetDisplayBox corner x) ifTrue: [cellColumn _ 0].	screenPoint y < (view insetDisplayBox origin y + 30) ifTrue: [cellRow _ view offsetPoint y].	screenPoint y > (view insetDisplayBox corner y) ifTrue: [cellRow _ 0].	^cellColumn @ cellRow!rows	^self ySize!view	^view!view: aView	view _ aView!xGrid	^xGrid!xGrid: rowMatrix	^xGrid _ rowMatrix!yGrid	^yGrid!yGrid: columnMatrix	^yGrid _ columnMatrix! !!SpreadsheetHolder methodsFor: 'copying'!deepCopy	^self shallowCopy! !!SpreadsheetHolder methodsFor: 'printing'!storeOn: aStream	"Append to the argument aStream a sequence of characters that is an expression 	whose evaluation creates an object similar to the receiver."	| allFrame contents ruleTags ruleNumber tag |	allFrame _ self allFrame.	Cursor write showWhile:		[self storeLiterals: allFrame on: aStream.		aStream cr.		xGrid storeOn: aStream.		aStream cr.		yGrid storeOn: aStream.		aStream cr.		ruleTags _ Dictionary new.		ruleNumber _ 0.		self do: [:cell |			cell rule == nil ifFalse:				[tag _ cell rule asOop printString asSymbol.				(ruleTags includesKey: tag) ifFalse:					[ruleTags at: tag put: (ruleNumber _ ruleNumber+1).					('<Rule: ', ruleNumber printString) asSymbol printOn: aStream. aStream cr.					cell rule references size printOn: aStream. aStream space.					cell rule references do: [:ref | ref size printOn: aStream. aStream space.						ref do: [:each |  each printOn: aStream. aStream space]].					aStream cr.					aStream nextPutAll: cell rule string.					aStream nextPut: 160 asCharacter.					aStream cr.					self storeFast: cell rule code on: aStream with: allFrame.					aStream cr]]].		self do: [:cell |			(cell rule == nil and: [cell contents == nil and: [cell dependents isEmpty]]) ifFalse:				[aStream nextPut: Character newPage.				cell xcell printOn: aStream.				aStream nextPut: $@.				cell ycell printOn: aStream.				aStream cr.				self store: cell contents on: aStream.				cell rule == nil					ifTrue:						['>Rule: 0' asSymbol printOn: aStream]					ifFalse:						[ruleNumber _ ruleTags at: (cell rule asOop printString asSymbol).						('>Rule: ', ruleNumber printString) asSymbol printOn: aStream].				aStream cr]]]! !!SpreadsheetHolder methodsFor: 'fileIn/Out'!fileOutOn: aFileName withSuitcase: aSuitcase	| aFileStream |	aFileStream _ MixedFileStream fileNamed: aFileName.	aSuitcase == nil ifFalse: [aFileStream writeHeaderFor: aSuitcase dataItem].	aFileStream readWriteShorten.	aFileStream text.	self storeOn: aFileStream.	aFileStream close.! !!SpreadsheetHolder methodsFor: 'hardcopy'!drawRect: elementRect onInterpress: anInterpressFile offset: anOffset borderWidth: border	"draw a rectangle of the given coordinates on the specified interpressFile"	| scale nibWidth aRectangle horizontalBorder verticalBorder origin | 	scale _ PrintStyle pressScale.	nibWidth _border * scale.	scale _ (printScale x * scale) @ (printScale y * scale).	aRectangle _ elementRect scaleBy: scale.	horizontalBorder _ Rectangle origin: 0@0 extent: (aRectangle width abs +nibWidth) @ nibWidth. 	verticalBorder _ Rectangle origin: 0@0 extent: nibWidth @ (aRectangle height abs).	anInterpressFile printRectangle: horizontalBorder translateBy: anOffset.	anInterpressFile printRectangle: horizontalBorder translateBy: (anOffset x @ (anOffset y+ aRectangle height)).	anInterpressFile printRectangle: verticalBorder translateBy: anOffset.	anInterpressFile printRectangle: verticalBorder translateBy: ((anOffset x + aRectangle width) @ anOffset y).!hardcopy: aSuitcase 	"This is the menu message called to print out the chart as a press file or an interpress file."	| default types labels questionArray theBP applicData  |	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].	(default _ OrderedCollection new) add: fileName.	(types _ OrderedCollection new) add: #fill.	(labels _ OrderedCollection new) add: #(Title).	theBP _ BackgroundPrinter askQuestions:			((Array new: 5)					at: 1 put: default;					at: 2 put: types;					at: 3 put: labels;					at: 4 put: (aSuitcase == nil ifTrue: [nil] ifFalse: [aSuitcase classification]);					at: 5 put: (aSuitcase == nil ifTrue: [nil] ifFalse: [aSuitcase centerName]);					yourself).	theBP == nil ifTrue: [^self]. "bailout"	PressOrInterpress == #Press		ifTrue:[self hardcopyPress: theBP]		ifFalse:[self hardcopyInterpress: theBP suitcase: aSuitcase]! !!SpreadsheetHolder methodsFor: 'private-hardcopy'!drawCellBoxes: aRectangle toInterpress: anInterpressFile scale: scale	"this method puts all of the boxes and their contents onto the interpress file"	| nibWidth basicBox topOffset leftOffset width height |	nibWidth _ 20.	leftOffset _ anInterpressFile leftMargin.	topOffset _ anInterpressFile topMargin.	width _ 0.	aRectangle origin x to: aRectangle corner x do: [:xCell |			basicBox _ self basicBoxAt: xCell @ 1.		width _ width + (basicBox width * scale x)].	" draw horizontal lines "	height _ 0.	anInterpressFile		printRectangle: (Rectangle origin: 0@0 extent: width @ nibWidth)		translateBy: leftOffset @ topOffset.	aRectangle origin y to: aRectangle corner y do:[:yCell | 		basicBox _ self basicBoxAt: 1 @ yCell.		height _ height + (basicBox height * scale y).	 	topOffset _ topOffset + (basicBox height * scale y).		anInterpressFile			printRectangle: (Rectangle origin: 0@0 extent: width @ nibWidth)			translateBy: leftOffset @ topOffset].	" draw vertical lines "	topOffset _ anInterpressFile topMargin.	anInterpressFile		printRectangle: (Rectangle origin: 0@0 extent: nibWidth @ height)		translateBy: leftOffset @ topOffset.	aRectangle origin x to: aRectangle corner x do:[:xCell | 		basicBox _ self basicBoxAt: xCell @ 1.	 	leftOffset _ leftOffset + (basicBox width * scale x).		anInterpressFile			printRectangle: (Rectangle origin: 0@0 extent: nibWidth @ height)			translateBy: leftOffset @ topOffset].!drawCells: aRectangle toInterpress: anInterpressFile scale: scale font: fontIndex	"this method puts all of the boxes and their contents onto the interpress file"	| elementRect basicBox clip cell cellItem aPoint rectOffset topOffset leftOffset tempString tempForm |	leftOffset _ anInterpressFile leftMargin.	aRectangle origin x to: aRectangle corner x do: [:xCell |			" clip against the right edge of the printing page"		basicBox _ self basicBoxAt: xCell @ 1.		clip _ anInterpressFile rightMargin < (leftOffset + (basicBox width * scale x)).		clip ifFalse: [			topOffset _ anInterpressFile topMargin.		 	aRectangle origin y to: aRectangle corner y do:[:yCell | 				cell _ self atPoint: xCell @ yCell.				cellItem _ cell contents = nil							ifTrue: [String new]							ifFalse: [cell contents].				elementRect _ self basicBoxAt: xCell @ yCell.				rectOffset _ leftOffset @ topOffset.				aPoint _ ( 10 @ (elementRect height - printFont height) ) * scale // 2.				(cellItem isKindOf: DisplayObject) | (cellItem isKindOf: Chart)					ifTrue:[tempForm _ Form extent: elementRect extent.						cellItem displayOn: tempForm							at: 0@0 							clippingBox: tempForm computeBoundingBox							rule: Form over 							mask: Form black.						anInterpressFile 							printFullForm: tempForm							scale: scale							setPos: rectOffset]					ifFalse: [tempString _ (self 									makeText: cellItem printString asText 									forBox: elementRect ) asString.							 anInterpressFile								lineText: tempString								font: fontIndex								setPos: (aPoint+rectOffset) x @ ((aPoint+rectOffset) y+150)].		 		topOffset _ topOffset + (elementRect height * scale y)]].		leftOffset _ leftOffset + (basicBox width * scale x)].!drawHorizontalLabels: aRectangle toInterpress: anInterpressFile scale: scale font: fontIndex	"This method puts the horizontal label boxes and their contents onto the interpress file"	| elementRect basicBox clip aPoint rectOffset topOffset leftOffset startIndex nibWidth originOffset labelHeight  width |	nibWidth _ 40.	basicBox _ self basicBoxAt: aRectangle origin.	topOffset _ anInterpressFile topMargin - (28 * scale y).	leftOffset _ anInterpressFile leftMargin.	originOffset _ leftOffset @ topOffset.	labelHeight _ 25 * scale y. 	width _ 0.	aRectangle origin x to: aRectangle corner x do: 		[:each | 		elementRect_ self basicBoxAt: each @ aRectangle origin y.		"clip against the right side of the printing page"		clip _ anInterpressFile rightMargin < (leftOffset + (elementRect width * scale x)).		clip ifFalse: [			rectOffset _ leftOffset @ topOffset.			aPoint _ ( (elementRect width @ 25)					 - ((printFont strikeFont widthOfString: each printString) @ printFont height) ) * scale // 2.			aPoint _ aPoint+rectOffset.			anInterpressFile				lineText: each printString				font: fontIndex				setPos: aPoint x @ (aPoint y+150).			anInterpressFile				printRectangle:  (Rectangle origin: 0@0  extent: nibWidth @ labelHeight)				translateBy: rectOffset.			width_ width + (elementRect width * scale x).			leftOffset _ leftOffset + (elementRect width * scale x)]].			anInterpressFile				printRectangle:  (Rectangle origin: 0@0  extent: nibWidth @ labelHeight)				translateBy: leftOffset @ topOffset.			anInterpressFile				printRectangle:  (Rectangle origin: 0@0  extent: width @ nibWidth)				translateBy: originOffset.			anInterpressFile				printRectangle:  (Rectangle origin: 0@0  extent: width @ nibWidth)				translateBy: originOffset x @ (originOffset y+labelHeight - nibWidth).!drawRect: elementRect on: aPressFile nib: nibWidth	"draw a rectangle of the given coordinates on the specified pressFile"	aPressFile setPoint: elementRect topRight.	aPressFile showRectangleExtent: elementRect width abs + nibWidth @ nibWidth.	aPressFile setPoint: elementRect corner.	aPressFile showRectangleExtent: elementRect width abs + nibWidth @ nibWidth.	aPressFile showRectangle: (Rectangle origin: elementRect origin extent: nibWidth @ elementRect height).	aPressFile showRectangle: (Rectangle origin: elementRect topRight extent: nibWidth @ elementRect height)!drawVerticalLabels: aRectangle toInterpress: anInterpressFile scale: scale font: fontIndex	"this method puts the vertical label boxes and their contents onto the interpress file"	| elementRect clip aPoint rectOffset topOffset leftOffset  nibWidth labelWidth originOffset  height |	nibWidth _ 40.	labelWidth _ 40* scale x.	leftOffset _ anInterpressFile leftMargin - (43 * scale x).	topOffset _ anInterpressFile topMargin.	originOffset _ leftOffset @ topOffset.	height _ 0.	aRectangle origin y to: aRectangle corner y do: 		[:each | 		elementRect _ self basicBoxAt: aRectangle origin x @ each.		elementRect extent: 40 @ elementRect height.		rectOffset _ leftOffset @ topOffset.		aPoint _ ( (elementRect width @ elementRect height)				 - ((printFont strikeFont widthOfString: each printString) @ printFont height) ) * scale // 2.		aPoint _ aPoint+rectOffset.		anInterpressFile			lineText: each printString			font: fontIndex			setPos: aPoint x @ (aPoint y+150).		anInterpressFile			printRectangle: (Rectangle origin: 0@0 extent: labelWidth @ nibWidth)			translateBy: rectOffset.		height _ height + (elementRect scaleBy: scale) height.		topOffset _ topOffset + (elementRect height * scale y)].		anInterpressFile			printRectangle: (Rectangle origin: 0@0 extent: labelWidth @ nibWidth)			translateBy: leftOffset @ topOffset.		anInterpressFile			printRectangle: (Rectangle origin: 0@0 extent: nibWidth @ height)			translateBy: originOffset.		anInterpressFile			printRectangle: (Rectangle origin: 0@0 extent: nibWidth @ height)			translateBy: (originOffset x + labelWidth - nibWidth) @ originOffset y.!hardcopy: aRectangle toInterpress: anInterpressFile atScale: scale withFont: fontIndex	"this method puts all of the boxes and their contents onto the interpress file"	self		drawHorizontalLabels: aRectangle		toInterpress: anInterpressFile		scale: scale		font: fontIndex.	self		drawVerticalLabels: aRectangle		toInterpress: anInterpressFile		scale: scale		font: fontIndex.	self		drawCellBoxes: aRectangle		toInterpress: anInterpressFile		scale: scale.	self		drawCells: aRectangle		toInterpress: anInterpressFile		scale: scale		font: fontIndex.!hardcopy: aRectangle toPress: aPressFile atScale: fontScale	"this method puts all of the boxes and their contents onto the pressfile"	| elementRect tempString nibWidth newRect clip offset cornerElem cell labelRect cellItem cellRect tempForm |	elementRect _ Rectangle new.	fontScale = 10		ifTrue: 			[tempString _ 'TimesRoman10'.			printScale _ Point x: 0.85 y: 0.84]		ifFalse: [^false].	aPressFile selectFontDescription: (aPressFile fontDescriptionFor: tempString rotation: 16200).	cornerElem _ self atPoint: aRectangle origin.	offset _ (self basicBoxAt: aRectangle origin x @ aRectangle origin y) origin.	aRectangle origin x to: aRectangle corner x do: 		[:each | 		labelRect _ self basicBoxAt: each @ aRectangle origin y.		labelRect _ labelRect translateBy: 0 @ (labelRect height + 5) negated.		labelRect _ self printTransform: labelRect atOffset: offset.		elementRect _ self printClip: labelRect.		clip _ elementRect ~= labelRect.		elementRect _ aPressFile transformRectangle: elementRect.		aPressFile setPoint: elementRect center - (printFont height // 4 @ ((printFont widthOfString: each printString) negated)  // 2).		aPressFile printString: each printString.		self			drawRect: elementRect			on: aPressFile			nib: 80].	aRectangle origin y to: aRectangle corner y do: 		[:each | 		labelRect _ self basicBoxAt: aRectangle origin x @ each.		labelRect extent: 40 @ labelRect height.		labelRect _ labelRect translateBy: -45 @ 0.		labelRect _ self printTransform: labelRect atOffset: offset.		elementRect _ self printClip: labelRect.		clip _ elementRect ~= labelRect.		elementRect _ aPressFile transformRectangle: elementRect.		aPressFile setPoint: elementRect center - (printFont height // 4 @ ((printFont widthOfString: each printString) negated) // 2 ).		aPressFile printString: each printString.		self			drawRect: elementRect			on: aPressFile			nib: 80].	aRectangle origin x to: aRectangle corner x do: [:xCell | aRectangle origin y to: aRectangle corner y do: 			[:yCell | 			cell _ self atPoint: xCell @ yCell.			nibWidth _ 40.			cellItem _ cell contents = nil						ifTrue: [String new]						ifFalse: [cell contents].			cellRect _ self basicBoxAt: xCell @ yCell.			newRect _ self printTransform: cellRect atOffset: offset.			elementRect _ self printClip: newRect.			clip _ elementRect ~= newRect.			elementRect _ aPressFile transformRectangle: elementRect.			clip				ifFalse: 					[(cellItem isKindOf: DisplayObject) | (cellItem isKindOf: Chart)						ifTrue:[tempForm _ Form extent: cellRect extent.							cellItem displayOn: tempForm								at: 0@0 								clippingBox: tempForm computeBoundingBox								rule: Form over 								mask: Form black.							tempForm _ tempForm rotateBy: 2.							aPressFile scale: 26.							aPressFile setPoint: elementRect corner + (260 @ 120) - (0 @ elementRect height).							aPressFile 								printForm: tempForm 								opaque: true 								landscape: true.							aPressFile scale: PressFile pressScale]						ifFalse:[								aPressFile setPoint: elementRect corner + (160 @ -96).							tempString _ (self 									makeText: cellItem printString asText 									forBox: elementRect) asString.							aPressFile printString: tempString].					self						drawRect: elementRect						on: aPressFile						nib: nibWidth]]]!hardcopyInterpress: theBP suitcase: aSuitcase	| aFileName pressPrinter printRect fontIndex scale array | 	array _ Array new: 3.	array at: 1 put: aSuitcase classification hardcopyString asText;		  at: 2 put: ( theBP applicAnswers at: 1).	printFont _ (PrintStyle default fontAt: (TextStyle default fontNamed: 'TimesRoman10')) asPrinterWidthsFont.	fontIndex _ TextStyle getNumForStrikeFont: 'TimesRoman10'.	printScale _ Point x: 0.87 y: 0.84.	scale _ PrintStyle pressScale.	scale _ (printScale x * scale) @  (printScale y * scale).	aFileName _ Disk makeNewFileName: theBP pressFileName withSuffix: (DataMaster giveMe: #suffixString for: #interpress asString).	Cursor write showWhile: 		[pressPrinter _ (FileStream fileNamed: aFileName) asPressPrinter.		"pressPrinter leftMargin: 800."  		pressPrinter rightMargin: 13200.		"default bottom margin = 12720" 		pressPrinter bottomMargin: 9350.		"default right margin = 9250" 		pressPrinter heading: array.		pressPrinter beginPageBodies. 		((printRect _ controller selectionPoint) isKindOf: Rectangle) 			ifFalse: [printRect _ (0@0 = printRect ifTrue: [(1 @ 1 corner: xySize)] ifFalse: [printRect corner: printRect])]. 		(self partitionRectangle: printRect) do: [:each | 			pressPrinter beginOnePageBodyLandscape: true.			self hardcopy: each				toInterpress: pressPrinter				atScale: scale				withFont: fontIndex.			pressPrinter endOnePageBody].		pressPrinter endPageBodies].		theBP pressFileName: aFileName; pressFileCreated: true; queueData: nil callOnTurn: nil!hardcopyPress: theBP 	"This is the menu message called to print out the chart as a press file."	| aFileName aPressFile aFont fontScale fontArray printRect |	aFileName _ Disk makeNewFileName: theBP pressFileName withSuffix: (DataMaster giveMe: #suffixString for: #press asString).	printFont _ (TextStyle default fontAt: (TextStyle default fontNamed: 'TimesRoman10')) asPrinterWidthsFont.	fontScale _ 10.	Cursor write showWhile: 		[aPressFile _ (PressFile fileNamed: aFileName).		((printRect _ controller selectionPoint) isKindOf: Rectangle) 			ifFalse: [printRect _ (0@0 = printRect ifTrue: [(1 @ 1 corner: xySize)] ifFalse: [printRect corner: printRect])]. 		(self partitionRectangle: printRect) do: [:each | self			hardcopy: each			toPress: aPressFile			atScale: fontScale.			aPressFile closePage].		aPressFile close].	theBP pressFileName: aFileName; pressFileCreated: true; queueData: nil callOnTurn: nil!makeText: aString forBox: aRectangle"Strip the given string fitting into the given rectangle. For interpress, printFont is kind of DisplayPrintFont and rectangle width is taken as a space to fit the string. For press, rectangle height represents the space to fit the string."	| returnText para |	(printFont isKindOf: DisplayPrintFont)	 "case of interpress" 		ifTrue:[ aRectangle width < 0 ifTrue: [^String new].				returnText _ (printFont strikeFont) charsInString: aString fitting: aRectangle width - 10]		ifFalse:[	aRectangle height < 0 ifTrue: [^String new].				returnText _ printFont charsInString: aString fitting: aRectangle height - 100].	^returnText!partitionRectangle: aRectangle	"create an OrderedCollection of rectangles which will give a paged output for 	 a given rectangle of cells"	| partitionCollection xCollection yCollection |	partitionCollection _ OrderedCollection new.	xCollection _ self xPartitionsFrom: aRectangle origin x to: aRectangle corner x.	yCollection _ self yPartitionsFrom: aRectangle origin y to: aRectangle corner y.	1 to: xCollection size - 1 do: [:eachX |		1 to: yCollection size - 1 do: [:eachY |			partitionCollection add: (((xCollection at: eachX)+1) @ ((yCollection at: eachY)+1)									corner: (xCollection at: eachX + 1) @ (yCollection at: eachY + 1))]].	^partitionCollection!printTransform: aRectangle atOffset: offset 	| firstPoint secondPoint printOffset transformedRect offsetNumber | 	"scale and transpose everything on the screen"	firstPoint _ Point x: offset y - aRectangle origin y y:  aRectangle origin x - offset x.	secondPoint _ Point x: offset y - aRectangle corner y y: aRectangle corner x - offset x.	printOffset _ 823.125 @ 50.	transformedRect _ ((Rectangle origin: firstPoint + printOffset + (-80@30) corner: secondPoint + printOffset + (-80@30))		scaleBy: printScale).	^transformedRect!xPartitionsFrom: originX to: cornerX	"create an OrderedCollection of the x cells which will give a paged output for 	a given rectangle of cells"	| partitionCollection width cellWidth |	width _ 0.	partitionCollection _ OrderedCollection new.	partitionCollection add: originX - 1.	originX to: cornerX do: 		[:each | 		cellWidth _ (nilCell boxAt: each @ 1) width.		width _ width + cellWidth.		width > 850			ifTrue: 				[partitionCollection add: each - 1.				width _ cellWidth]].	partitionCollection add: cornerX.	^partitionCollection!yPartitionsFrom: originY to: cornerY	"create an OrderedCollection of the y cells which will give a paged output for 	a given rectangle of cells"	| partitionCollection height cellHeight |	height _ 0.	partitionCollection _ OrderedCollection new.	partitionCollection add: originY - 1.	originY to: cornerY do: 		[:each | 		cellHeight _ (nilCell boxAt: 1 @ each) height.		height _ height + cellHeight.		height > 650			ifTrue: 				[partitionCollection add: each - 1.				height _ cellHeight]].	partitionCollection add: cornerY.	^partitionCollection! !!SpreadsheetHolder methodsFor: 'update management'!addUpdate: aCell	cellsToUpdate add: aCell!displayUpdates	controller updateModeView selector = #update ifTrue: 		[cellsToUpdate do: [:each | each evaluate].		self clearUpdates.		].! !!SpreadsheetHolder methodsFor: 'matrix mimicry'!paste: aMatrix atPoint: aPoint clippingSize: anotherPoint	"paste another matrix into this one, with the origin of the area to be overwritten at aPoint.  Make sure that the paste is clippped withinb the boundary size specified in anotherPoint and the bounds of this Matrix"	| iCounter jCounter startPointX stopPointX startPointY stopPointY dependents cell |	iCounter _ 0.	startPointX _ aPoint x.	startPointY _ aPoint y.	stopPointX _ (startPointX + (aMatrix xSize min: anotherPoint x) - 1) min: self xSize.	stopPointY _ (startPointY + (aMatrix ySize min: anotherPoint y) - 1) min: self ySize.	startPointX to: stopPointX do:[:i | 		iCounter _ iCounter + 1.		jCounter _ 0.		startPointY to: stopPointY do: [:j |			jCounter _ jCounter + 1.			dependents _ (self atPoint: i@j) dependents.			 self atPoint: i @ j put: 				((aMatrix atPoint: iCounter @ jCounter) = nilCell 					ifTrue:[nilCell]					ifFalse:[aMatrix atPoint: iCounter @ jCounter]) deepCopy.			dependents do: [:each | (self atPoint: i@j) addDependent: each].			(self atPoint: i@j) xcell: i ; ycell: j ; holder: self ; setRuleDependencies; display]].! !!SpreadsheetHolder methodsFor: 'private'!allFrame	"Create a reference table of context literals for file-out that can be used on 	file-in to reconstruct all rules' literal frames with one compilation."	| rule method allFrame returnFrame index |	allFrame _ Set new.	self do: [:cell | (rule _ cell rule) == nil 				ifFalse: [(method _ rule code method) literals size = 0 					ifFalse: [allFrame addAll: method literals]]].	^allFrame asOrderedCollection asArray!basicBoxAt: boxPoint	| originX originY |	"rectangular type boxPoint"	(boxPoint isKindOf: Rectangle) ifTrue:[^(self basicBoxAt: boxPoint origin) merge: (self basicBoxAt: boxPoint corner)].	"check bounds"	((boxPoint == nil) or: [boxPoint x = 0 | (boxPoint y = 0) | (boxPoint x > xGrid size) | (boxPoint y > yGrid size)])		ifTrue: [^nil].	"low bound special case = 0"	boxPoint x = 1		ifTrue: [originX _ 0]		ifFalse: [originX _ xGrid at: boxPoint x - 1].	boxPoint y = 1		ifTrue: [originY _ 0]		ifFalse: [originY _ yGrid at: boxPoint y - 1].	"return proper coordinates"	^originX @ originY corner: (xGrid at: boxPoint x) @ (yGrid at: boxPoint y)!printClip: aRectangle	^aRectangle intersect: (0 @ 0 corner: 674.687 @ 873.125)!setAllRules	"I was just read from a Stream (or something); establish all rule dependencies."	self do: [:cell | cell rule == nil			ifFalse: 				[cell setRuleDependencies]].	self do: [:cell | cell rule == nil			ifFalse: 				[(cell rule string indexOf: $;)					~= 0 ifTrue: [cell addUpdate]]].!store: contents on: aStream 	"store the contents onto the stream"	contents = badRef ifTrue: [^aStream nextPut: $B].	(contents isKindOf: Fraction)		ifTrue: 			[aStream nextPut: $*.			aStream nextPut: Character space.			^contents storeOn: aStream].	(contents isKindOf: Number)		ifTrue: 			[aStream nextPut: $N.			aStream nextPut: Character space.			^contents storeOn: aStream].	(contents class == String)		ifTrue: 			[aStream nextPut: $S.			aStream nextPut: Character space.			^contents storeOn: aStream].	(contents class == Label)		ifTrue: 			[aStream nextPut: $L.			aStream nextPut: Character space.			^aStream nextPutAll: contents].	(contents isKindOf: Form)		ifTrue: 			[aStream nextPut: $P.			aStream nextPut: Character space.			^contents writeOnStream: aStream].	(contents isKindOf: ClassifiedFixedFileStream)		ifTrue: 			[aStream nextPut: $D.			aStream nextPut: Character space.			^aStream nextPutAll: contents name].	(contents isKindOf: FileStream)		ifTrue: 			[aStream nextPut: $F.			aStream nextPut: Character space.			^aStream nextPutAll: contents name].	(contents isKindOf: Symbol)		ifTrue: 			[aStream nextPut: $Y.			aStream nextPut: Character space.			^contents storeOn: aStream].	contents = true ifTrue: [aStream nextPut: $t.			^aStream nextPut: Character space].	contents = false ifTrue: [aStream nextPut: $f.			^aStream nextPut: Character space].	contents = nil ifTrue: [aStream nextPut: $n.			^aStream nextPut: Character space].	aStream nextPut: $*.	aStream nextPut: Character space.	contents storeOn: aStream!storeFast: aBlockContext on: aStream with: frameArray 	"Append to the argument aStream a sequence of characters that can be used 	to reconstruct aBlockContext without reCompiling."	| method literals litRefs thisLit |	method _ aBlockContext method.	method basicSize - method initialPC + 1 printOn: aStream.	aStream nextPut: $\.	method header storeOn: aStream.	aStream nextPut: $\.	literals _ method literals.	litRefs _ Array new: literals size.	1 to: literals size do: 		[:index |  litRefs at: index put: (frameArray indexOf: (literals at: index))].	litRefs do: 		[:ref | 		ref storeOn: aStream.		aStream nextPut: $/].	method initialPC to: method size do: 		[:byte | 		(method at: byte)			printOn: aStream.		aStream space]!storeLiterals: allFrame on: aStream 	"store the literals in allFrame onto the stream in a form that can be  	recompiled"	| newStream literalString literalsCount maxLiteralsPerCompilation maxLiteralsPerIteration |	allFrame size = 0 ifTrue:[^aStream nextPutAll: 'N23(OrderedCollection new)'].	literalsCount _ 0.		maxLiteralsPerCompilation _ 63.	maxLiteralsPerIteration _ maxLiteralsPerCompilation - #(OrderedCollection 0 add: yourself Smalltalk associationAt:) size - 5 "leave 5 spares".	[newStream _ WriteStream on: String new.	newStream nextPutAll: '(OrderedCollection new: ', maxLiteralsPerIteration printString, ') add: '.	(allFrame at: literalsCount + 1) class == Association		ifTrue: [newStream nextPutAll: '(Smalltalk associationAt: #'.			(allFrame at: literalsCount + 1) key printOn: newStream.			newStream nextPutAll: ') ']		ifFalse: [(allFrame at: literalsCount + 1)				storeOn: newStream].	literalsCount + 2 to: (literalsCount + maxLiteralsPerIteration min: allFrame size) do: 		[:index | 		newStream nextPutAll: ' ; add: '.		(allFrame at: index) class == Association			ifTrue: [newStream nextPutAll: '(Smalltalk associationAt: #'.			(allFrame at: index) key printOn: newStream.			newStream nextPutAll: ') ']			ifFalse: [(allFrame at: index)					storeOn: newStream]].	newStream nextPutAll: '; yourself'.	literalString _ newStream contents.	aStream nextPutAll: 'N', literalString size printString.	aStream cr.	aStream nextPutAll: literalString.	(literalsCount _ literalsCount + maxLiteralsPerIteration) < allFrame size] whileTrue: [aStream cr]! !SparseMatrix comment:'Copyright (c) Xerox Corporation, 1987. All rights reserved.'!!SparseMatrix methodsFor: 'accessing'!at: key 	^collection at: key!at: key ifAbsent: aBlock	^collection at: key ifAbsent: aBlock!atPoint: aPoint	^(collection at: aPoint x ifAbsent: [^0]) at: aPoint y ifAbsent: [^0]!atPoint: aPoint put: anObject	(collection includesKey: aPoint x) ifFalse:[collection at: aPoint x put: OopConservingDictionary new].	(collection at: aPoint x) at: aPoint y put: anObject.!atRow: y column: x	"return the contents of the matrix element at the specified row and column indices"	^self atPoint: x @ y!atRow: y column: x put: anObject	"return the contents of the matrix element at the specified row and column indices"	^self atPoint: x @ y put: anObject!includesKey: anObject	^collection includesKey: anObject!keysDo: aBlock	collection keysDo: aBlock! !AdjacencyMatrix comment:'Copyright (c) Xerox Corporation, 1987. All rights reserved.AdjacencyMatrix is a subclass of SparseMatrix with special properties making it useful in the description and manipulation of directed graphs.  Two assumptions are made about any graph constructed with AdjacencyMatrix.  These are:	1.  There are no self-loops.  That is to say, there are no nodes which are connected to themselves directly.	2.  There are no multiple edges.  That means that there are never two separate connections between any pair of nodes pointing in the same direction.There are further restrictions on the use of some methods.  The shortest path and longest path algorithms require that the graph described contain no cycles, and assume a single source node and a single sink node. '!!AdjacencyMatrix methodsFor: 'shortest/longest path'!longestPathFrom: source to: sink	"branch and bound longest path algorithm, based on the R.E. Nance algorithm.  graph must have no cycles.  graph should have only one source node."	| lengthTo maxPathTo tenativeLengthTo graphSize isDetermined oneHasBeenDetermined canBeDetermined tenativeMaxPath predecessors|	"initialize the temporary variables"	graphSize _ numberOfNodes.	isDetermined _ Array new: graphSize.	1 to: graphSize do: [:each | isDetermined at: each put: 0].	isDetermined at: source put: 1.	lengthTo _ Array new: graphSize.	maxPathTo _ Array new: graphSize.		1 to: graphSize do: [:each | maxPathTo at: each put: (OrderedCollection new)].	tenativeLengthTo _ nil.	"initialize path"	1 to: graphSize do: [:each | lengthTo at: each put: -9999999999].	lengthTo at: source put: 0.	(maxPathTo at: source) add: source.	"check each node"	[isDetermined includes: 0]		whileTrue:[oneHasBeenDetermined _ false.			1 to: graphSize do: [:eachNode |			"can this node be finally determined?"				canBeDetermined _ true. 				predecessors _ self predecessorsOf: eachNode.				(predecessors = OrderedCollection new) ifTrue:[canBeDetermined _ false].				predecessors do: [:eachPred | ((isDetermined at: eachPred) = 0)&(eachPred ~= eachNode) ifTrue:[canBeDetermined _ false]].				canBeDetermined ifTrue:[					"we have a node which can be finally determined, so find the longest path to the node"					oneHasBeenDetermined _ true.					tenativeLengthTo _ -9999999999.					tenativeMaxPath _ nil.					predecessors do: [:eachPred | 						(((lengthTo at: eachPred) + (self pathLengthFrom: eachPred to: eachNode)) > tenativeLengthTo) 							ifTrue:[								tenativeLengthTo _ ((lengthTo at: eachPred) + (self pathLengthFrom: eachPred to: eachNode)).								tenativeMaxPath _ ((maxPathTo at: eachPred) deepCopy).								tenativeMaxPath add: eachNode]].					"remember the longest path we have just determined"					maxPathTo at: eachNode put: tenativeMaxPath.					lengthTo at: eachNode put: tenativeLengthTo.					isDetermined at: eachNode put: 1]].				"If we haven't found any nodes which can be finally determined on this pass, it will never converge to a solution. Bail out!!" 				oneHasBeenDetermined ifFalse:[^nil]].	"we have determined the longest path to each node, now we simply pick the path to the given sink"	^maxPathTo at: sink!shortestPathFrom: source to: sink	"branch and bound shortest path algorithm, based on the R.E. Nance algorithm.  graph must have no cycles.  graph should have only one source node."	| lengthTo minPathTo tenativeLengthTo graphSize isDetermined oneHasBeenDetermined canBeDetermined tenativeMinPath predecessors|	"initialize the temporary variables"	graphSize _ numberOfNodes.	isDetermined _ Array new: graphSize.	1 to: graphSize do: [:each | isDetermined at: each put: 0].	isDetermined at: source put: 1.	lengthTo _ Array new: graphSize.	minPathTo _ Array new: graphSize.		1 to: graphSize do: [:each | minPathTo at: each put: (OrderedCollection new)].	tenativeLengthTo _ nil.	"initialize path"	1 to: graphSize do: [:each | lengthTo at: each put: 999999999].	lengthTo at: source put: 0.	(minPathTo at: source) add: source.	"check each node"	[isDetermined includes: 0]		whileTrue:[oneHasBeenDetermined _ false.			1 to: graphSize do: [:eachNode |			"can this node be finally determined?"				canBeDetermined _ true. 				predecessors _ self predecessorsOf: eachNode.				(predecessors = OrderedCollection new) ifTrue:[canBeDetermined _ false].				predecessors do: [:eachPred | ((isDetermined at: eachPred) = 0)&(eachPred ~= eachNode) ifTrue:[canBeDetermined _ false]].				canBeDetermined ifTrue:[					"we have a node which can be finally determined, so find the shortest path to the node"					oneHasBeenDetermined _ true.					tenativeLengthTo _ 999999999.					tenativeMinPath _ nil.					predecessors do: [:eachPred | 						(((lengthTo at: eachPred) + (self pathLengthFrom: eachPred to: eachNode)) < tenativeLengthTo) 							ifTrue:[								tenativeLengthTo _ ((lengthTo at: eachPred) + (self pathLengthFrom: eachPred to: eachNode)).								tenativeMinPath _ ((minPathTo at: eachPred) deepCopy).								tenativeMinPath add: eachNode]].					"remember the shortest path we have just determined"					minPathTo at: eachNode put: tenativeMinPath.					lengthTo at: eachNode put: tenativeLengthTo.					isDetermined at: eachNode put: 1]].				"If we haven't found any nodes which can be finally determined on this pass, it will never converge to a solution. Bail out!!" 				oneHasBeenDetermined ifFalse:[^nil]].	"we have determined the shortest path to each node, now we simply pick the path to the given sink"	^minPathTo at: sink!spanningTree	"produce an adjacency matrix which will describe a spanning tree on the graph described by the reciever.  This algorithm ignores any direction for edges"	| newAdjMatrix setOfConnectedNodes |	newAdjMatrix _ AdjacencyMatrix withNodes: numberOfNodes.	setOfConnectedNodes _ Set new.	setOfConnectedNodes add: 1.	self graphIsConnected ifFalse:[^nil].	self addConnectionsFrom: 1 to: newAdjMatrix against: setOfConnectedNodes.	^newAdjMatrix! !!AdjacencyMatrix methodsFor: 'special graph tests'!graphIsATree	^self graphIsConnected & (self numberOfEdges = (numberOfNodes - 1))!graphIsComplete	^(self graphIsConnected) & (self graphIsRegularOfDegree: (numberOfNodes - 1))!graphIsConnected	| degree theSetOfConnectedNodes |	theSetOfConnectedNodes _ Set new.	1 to: numberOfNodes do: [:column |		1 to: numberOfNodes do: [:row |			(self thereIsAConnectionBetween: row and: column) 				ifTrue:[theSetOfConnectedNodes add: row.					theSetOfConnectedNodes add: column]]].	theSetOfConnectedNodes size = numberOfNodes		ifTrue:[^true].	^false!graphIsRegular	| degree |	degree _ self degreeOf: 1.	1 to: numberOfNodes do: [:eachNode | (self degreeOf: eachNode) ~= degree ifTrue:[^false]].	^true!graphIsRegularOfDegree: degree	1 to: numberOfNodes do: [:eachNode | (self degreeOf: eachNode) ~= degree ifTrue:[^false]].	^true! !!AdjacencyMatrix methodsFor: 'node accessing'!degreeOf: anInteger	"find the unweighted order of node anInteger"	| sum |	sum _ 0.	1 to: numberOfNodes do: [:column | ((self atRow: anInteger column: column) ~= 0) ifTrue: [sum _ sum + 1]].	^sum!numberOfNodes	^numberOfNodes!numberOfNodes: anInteger	numberOfNodes _ anInteger!predecessorsOf: anInteger	"find the predecessors ( those nodes which connect to the node) of node anInteger"	| set |	set _ OrderedCollection new.	1 to: numberOfNodes do: [:column | ((self atRow: anInteger column: column) < 0) ifTrue: [set add: column]].	^set!successorsOf: anInteger	"find the succcessors ( those nodes which are connected to the node) of node anInteger"	| set |	set _ OrderedCollection new.	1 to: numberOfNodes do: [:column | ((self atRow: anInteger column: column) > 0) ifTrue: [set add: column]].	^set!weightedDegreeOf: anInteger	"find the unweighted order of node anInteger"	| sum |	1 to: numberOfNodes do: [:column | sum _ sum + (self atRow: anInteger column: column)].	^sum! !!AdjacencyMatrix methodsFor: 'connection accessing'!numberOfEdges	| degree sum |	sum _ 0.	1 to: numberOfNodes do: [:column |		1 to: numberOfNodes do: [:row |			(self thereIsAConnectionFrom: row to: column) 				ifTrue:[sum _ sum + 1]]].	^sum!pathLengthFrom: aNode to: anotherNode	^self atRow: aNode column: anotherNode! !!AdjacencyMatrix methodsFor: 'connection testing'!thereIsAConnectionBetween: anInteger and: anotherInteger 	"check for a connection between node anInteger and node anotherInteger"	(self atRow: anInteger column: anotherInteger) ~= 0 ifTrue:[^true].	^false!thereIsAConnectionFrom: anInteger to: anotherInteger 	"check for a connection between node anInteger and node anotherInteger"	(self atRow: anInteger column: anotherInteger) > 0 ifTrue:[^true].	^false!thereIsAConnectionTo: anInteger from: anotherInteger 	"check for a connection between node anInteger and node anotherInteger"	(self atRow: anInteger column: anotherInteger) < 0 ifTrue:[^true].	^false! !!AdjacencyMatrix methodsFor: 'printing'!printOn: aStream 	| tooMany |	tooMany _ aStream position + 1000.	aStream nextPutAll: self class name,' ('.	1 to: numberOfNodes do: 		[:element | 		aStream position > tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].		1 to: numberOfNodes do: [:each | 			(self atPoint: element @ each) printOn: aStream.			aStream nextPut: Character space].		aStream cr].	aStream nextPut: $)! !!AdjacencyMatrix methodsFor: 'connection creation'!connect: anInteger to: anotherInteger	"produce a directed connection in the adjacency matrix.  A positive number in a location means that the connection is from the node corresponding to the row number, a negative number means that the edge runs to the node corresponding to the row number"	self atRow: anInteger column: anotherInteger put: 1.	self atRow: anotherInteger column: anInteger put: -1.!connect: anInteger to: anotherInteger withWeight: yetAnotherInteger	"produce a directed connection in the adjacency matrix.  A positive number in a location means that the connection is from the node corresponding to the row number, a negative number means that the edge runs to the node corresponding to the row number"	self atRow: anInteger column: anotherInteger put: yetAnotherInteger.	self atRow: anotherInteger column: anInteger put: yetAnotherInteger negated.!disconnect: anInteger from: anotherInteger	"delete a connection in the adjacency matrix. "	self atRow: anInteger column: anotherInteger put: 0.	self atRow: anotherInteger column: anInteger put: 0.! !!AdjacencyMatrix methodsFor: 'private'!addConnectionsFrom: aNode to: adjMatrix against: setOfConnectedNodes 	"recursively walk a matrix to construct a spanning tree"	1 to: numberOfNodes do: [:eachNode | (self thereIsAConnectionBetween: aNode and: eachNode)			& (setOfConnectedNodes includes: eachNode) not			ifTrue: 				[setOfConnectedNodes add: eachNode.				(self thereIsAConnectionFrom: aNode to: eachNode)					ifTrue: [adjMatrix							connect: aNode							to: eachNode							withWeight: (self pathLengthFrom: aNode to: eachNode)]					ifFalse: [adjMatrix							connect: eachNode							to: aNode							withWeight: (self pathLengthFrom: eachNode to: aNode)].				self					addConnectionsFrom: eachNode					to: adjMatrix					against: setOfConnectedNodes]]!addNode	"add space for a new node in the adjacency matrix"	numberOfNodes _ numberOfNodes + 1.	^self!grow	"Become larger.	Typically, a subclass has to override this if the subclass adds instance variables"	| newSelf |	newSelf _ self species new: self size + self growSize.	1 to: self xSize do: [:i |		1 to: self ySize do: [:j |			 newSelf atPoint: i@j put: (self atPoint: i@j)]].	newSelf numberOfNodes: self numberOfNodes.	self become: newSelf!growSize	^8! !HeaderFileStream comment:'Copyright (c) 1986, 1987 Xerox Corporation. All rights reserved.	This is a fake FileStream for use with files that need header information independent of what the host machine''s file system and the Smalltalk implementation on it may allow or require.  This stream simply allows the reservation and use of the first 512 bytes of a file for a header.  It will also handle files with no header.  The idea is to make it as easy as possible for the application to not worry about whether the header is there - in terms of positioning and so forth.  If it wishes to read the header (if any) it may ask for it, and if it wishes to write or change the current header it may, but unless something is done to change it, the file will either keep no header or the same header.	This is a crummy way to do it, but hopefully saves redefining the class for each different file system implementation  (particular trouble has been encountered because some file systems have subclasses of FileStream for accessing the Disk or a remote file server - making subclassing this directly off FileStream unacceptable).	Warning: Because of this approach, there are certain instances where it is necessary to change the application code to safely utilize this kind of stream, namely anyplace this stream is given as an argument to something expecting a true stream, you must actually provide thisStream fileStream.realStream	the actual file streamhasHeader	a BooleanheaderData	nil, or an Array of the label, the classification in DataItem>>headerString format, the DataItem>>dataType byte, nil or $E to indicate an encrypted fileHeaderID	the identifying string put at the beginning of every header - if this string is at the beginning of a file, it is assumed to be a header.'!!HeaderFileStream methodsFor: 'positioning'!position	hasHeader		ifTrue: [^realStream position - 512]		ifFalse: [^realStream position]!position: anInteger	"Position the realStream anInteger bytes from the header"	hasHeader		ifTrue: [realStream position: anInteger + 512]		ifFalse: [realStream position: anInteger]!reset	"reset to just after any header"	hasHeader		ifTrue: [realStream position: 512]		ifFalse: [realStream reset]!skipTo: anObject 	"Position the receiver past the next occurrance of anObject.  Answer true if 	anObject is found, false otherwise."	^realStream skipTo: anObject!wordPosition	"answer the current position in words - which is not what this does (says Bob)"	^self position // 2!wordPosition: wpos	"Position the realStream wpos words from the header"	hasHeader		ifTrue: [realStream wordPosition: wpos + 256]		ifFalse: [realStream wordPosition: wpos]! !!HeaderFileStream methodsFor: 'initialize/release'!initialize: aFileStream	realStream _ aFileStream.	realStream reset.	hasHeader _ (realStream size >= HeaderID size and: [(realStream next: HeaderID size) asString = HeaderID]).	self reset! !!HeaderFileStream methodsFor: 'default behavior'!doesNotUnderstand: aMessage	"aMessage is not implemented in this fake stream, try the realStream instead.  Return the result of this indirection, unless that result is realStream (which means it was returning its self), in which case return this self"	| result | 	result _ realStream perform: aMessage selector withArguments: aMessage arguments.	result == realStream ifFalse: [^result]! !!HeaderFileStream methodsFor: 'header access'!classAndModsFromHeader	hasHeader ifFalse: [^nil].	headerData == nil ifTrue: [headerData _ self readHeader].	^Classification classAndModsFromHeaderString: (headerData at: 2)!classFromHeader	hasHeader ifFalse: [^nil].	headerData == nil ifTrue: [headerData _ self readHeader].	^Classification fromHeaderString: (headerData at: 2)!classification: aClassification	| newClass | 	hasHeader ifFalse: [^nil].	headerData == nil ifTrue: [headerData _ self readHeader].	(newClass _ aClassification headerString) = (headerData at: 2) ifFalse:		[headerData at: 2 put: newClass.		self writeHeader]!dataTypeFromHeader	hasHeader ifFalse: [^nil].	headerData == nil ifTrue: [headerData _ self readHeader].	^headerData at: 3!hasHeader	^hasHeader!isEncrypted	hasHeader ifFalse: [^false "don't know for sure, but"].	headerData == nil ifTrue: [headerData _ self readHeader].	^(headerData at: 4) = $E!labelFromHeader	hasHeader ifFalse: [^nil].	headerData == nil ifTrue: [headerData _ self readHeader].	^headerData at: 1!removeHeader	"The header is the first 512 bytes of the file.  Take it off"	| oldPosition fileName newStream numTransfer |	hasHeader ifFalse: [^self].	oldPosition _ self position.	fileName _ realStream name.	newStream _ (FileStream fileNamed: 'CNVRTXXX.TMP') writeShorten.	self reset.	numTransfer _ self size.	[numTransfer > 0] whileTrue:		[newStream nextPutAll: (realStream next: (8000 min: numTransfer)).		numTransfer _ numTransfer - 8000].	realStream close.	newStream close.	Disk removeKey: fileName.	Disk renameKey: newStream name newName: fileName.	self initialize: (FileStream fileNamed: fileName) readWrite.	headerData _ nil.	self position: oldPosition.	realStream close!writeHeaderFor: aDataItem	headerData _ Array with: aDataItem label with: aDataItem headerString with: aDataItem dataTypeUpdated with: nil.	self writeHeader!writeHeaderLabel: label class: class mods: mods dataType: dataType	headerData _ Array with: label with: (Classification new setFromArray: (Array with: class with: mods)) headerString with: dataType with: nil.	self writeHeader! !!HeaderFileStream methodsFor: 'redirection only'!atEnd	^realStream atEnd!close	realStream close!crtab: anInteger	| cr tab | 	cr _ Character cr.	tab _ Character tab.	anInteger timesRepeat:[self nextPut: cr; nextPut: tab]!next	^realStream next!next: anInteger	"Answer the next anInteger bytes or characters from the file"	^realStream next: anInteger!nextPut: aByteOrChar	^realStream nextPut: aByteOrChar!nextPutAll: aByteOrCharCollection	^realStream nextPutAll: aByteOrCharCollection!nextWord: anInteger	"Answer the next anInteger bytes or characters from the file"	^realStream nextWord: anInteger!nextWordPut: aByteOrChar	^realStream nextWordPut: aByteOrChar!peek	^realStream peek!print: anObject	anObject printOn: self!skip: byteCount	"move forward (byteCount > 0) or backward in the file."	realStream skip: byteCount!through: anObject 	"Answer a subcollection from position through the occurrence (if any) of anObject.	If not there, answer everything."	^realStream through: anObject!upTo: anObject 	"Answer a subcollection from position to the occurrence (if any, not   	inclusive) of anObject. If not there, answer everything."	^realStream upTo: anObject! !!HeaderFileStream methodsFor: 'accessing'!contentsOfEntireFile	"Read all of the contents of the receiver, excluding any header"	| s |	realStream readOnly.	self reset.	s _ self next: self size.	realStream close.	^s!fileStream	"this is for use by those who need the real thing directly and are willing to take the risk.  It is especially dangerous to use in HeaderFileStream subclasses where the form of the data in the realStream may be different than required"	^realStream!size	"return size of non-header part of file"	hasHeader		ifTrue: [^realStream size - 512 max: 0]		ifFalse: [^realStream size]! !!HeaderFileStream methodsFor: 'private'!header: headerArray	"headerArray must be the correct internal format"	headerData _ headerArray.	headerData at: 4 put: nil.	self writeHeader!readHeader	"The header is 512 bytes long. It starts with ..Header followed by 10 reserved bytes, then a $E if the file is encrypted (blank otherwise), then the dataType of aDataItem (older headers may leave this blank), then the label of aDataItem followed by CR; and then the classification and modifier words of aDataItem followed by CR.  Leave file positioned in same place as before read"	| theObj label classAndMods oldPosition dataType specialType | 	hasHeader ifFalse: [^nil].	Cursor read showWhile: [	oldPosition _ realStream position.	realStream reset.	(realStream next: HeaderID size) asString = HeaderID ifTrue:		[realStream position: 18.		realStream isBinary			ifTrue: [specialType _ realStream next asCharacter.					dataType _ realStream next.					label _ (realStream upTo: 13) asString.					classAndMods _ (realStream upTo: 13) asString]			ifFalse: [specialType _ realStream next.					dataType _ realStream next asciiValue.					label _ realStream upTo: Character cr.					classAndMods _ realStream upTo: Character cr].		theObj _ Array with: label with: classAndMods with: dataType with: (specialType = $  ifTrue: [nil] ifFalse: [specialType])].	realStream position: oldPosition].	^theObj!writeHeader	"The header is 512 bytes long. It starts with ..Header followed by 10 reserved bytes, then a character if this is an encrypted (or other special kind) file (left blank otherwise), then the dataType byte of aDataItem followed immediately by the label of aDataItem followed by CR; and then the classification and modifier words of aDataItem followed by CR."	| ws newHeader oldPosition fileName numTransfer newStream binary |	Cursor write showWhile: [	ws _ WriteStream with: (String new: 512 withAll: $ ).	ws reset.	ws nextPutAll: HeaderID.	(headerData at: 4) == nil		ifFalse: [ws position: 18; nextPut: (headerData at: 4)]		ifTrue: [ws position: 19].	ws nextPut: (headerData at: 3) asCharacter.	ws nextPutAll: (headerData at: 1); cr; nextPutAll: (headerData at: 2); cr.	ws position: 512.	newHeader _ (binary _ realStream isBinary)		ifTrue: [(ByteArray new: 512) replaceFrom: 1 to: 512 withString: ws contents startingAt: 1]		ifFalse: [ws contents].	oldPosition _ self position.	(hasHeader or: [realStream size = 0])		ifTrue:			[realStream reset.			realStream nextPutAll: newHeader.			hasHeader _ true]		ifFalse: "we've got to redo this file to add the header"			[realStream reset; readOnly.			fileName _ realStream name.			newStream _ (FileStream fileNamed: 'CNVRTXXX.TMP') writeShorten.			binary ifTrue: [newStream binary].			newStream nextPutAll: newHeader.			numTransfer _ realStream size.			[numTransfer > 0] whileTrue:				[newStream nextPutAll: (realStream next: (8191 min: numTransfer)).				numTransfer _ numTransfer - 8191].			realStream close.			newStream close.			Disk removeKey: fileName.			Disk renameKey: newStream name newName: fileName.			self initialize: (FileStream fileNamed: fileName) readWrite.			binary ifTrue: [self binary]].	self position: oldPosition].	realStream close! !!HeaderFileStream methodsFor: 'odds and ends'!asString	"this is really tacky, but it lets Compiler evaluate: work, and is probably otherwise useful too"	| oldPosition aString |	oldPosition _ self position.	aString _ (self next: (self size - oldPosition min: 64511)) asString. "that size is chosen to stay away from the vicinity of 64K - 1 because the microcode is currently having trouble"	self position: oldPosition.	^aString!store: anObject 	"Have anObject print on me for rereading.	 Not sure necessary in HeaderFileStream, but certainly is for MixedFileStream"	anObject storeOn: self! !!HeaderFileStream methodsFor: 'collection accessing'!at: anIndex	"pretend this is a collection rather than a psuedo-stream, and return the value at the anIndex'th byte beyond the file header"	self position + 1 = anIndex ifFalse: [self position: anIndex - 1].	^self next!at: anIndex put: aByteOrChar	"pretend this is a collection rather than a psuedo-stream, and put aByteOrChar at the anIndex'th byte beyond the file header"	self position + 1 = anIndex ifFalse: [self position: anIndex - 1].	^self nextPut: aByteOrChar! !MixedFileStream comment:'Copyright (c) 1986, 1987 Xerox Corporation. All rights reserved.	This subclass of HeaderFileStream is designed to allow the user to switch between reading and/or writing textual or binary data to one file.  Internally, the file is opened and accessed as a binary file.	bogusBinary		aBoolean which is true if the user wants to do binary I/O, false for text. '!!MixedFileStream methodsFor: 'read/write'!cr	self nextPut: Character cr!next	"find the next byte or character"	bogusBinary		ifTrue: [^realStream next]		ifFalse: [^Character value: realStream next]!next: anInteger	"Answer the next anInteger bytes or characters from the file"	bogusBinary		ifTrue: [^realStream next: anInteger]		ifFalse: [^(String new: anInteger) replaceFrom: 1 to: anInteger withByteArray: (realStream next: anInteger) startingAt: 1]!next: anInteger into: aCollection	"Copy the next anInteger bytes from the receiver into aCollection."	| tempCollection |	bogusBinary		ifTrue: [^realStream next: anInteger into: aCollection]		ifFalse:			[tempCollection _ ByteArray new: aCollection size.			realStream next: anInteger into: tempCollection.			^aCollection replaceFrom: 1 to: anInteger withByteArray: tempCollection startingAt: 1]!nextPut: anIntegerOrCharacter	"put the next byte or character to the file"	bogusBinary		ifTrue: [^realStream nextPut: anIntegerOrCharacter]		ifFalse: [^realStream nextPut: anIntegerOrCharacter asciiValue]!nextPutAll: aByteArrayOrString	| anInteger | 	"put the string or ByteArray to the file"	anInteger _ aByteArrayOrString size.	bogusBinary		ifTrue: [^realStream nextPutAll: aByteArrayOrString]		ifFalse: [^realStream nextPutAll: ((ByteArray new: anInteger) replaceFrom: 1 to: anInteger withString: aByteArrayOrString startingAt: 1)]!nextWord	^realStream nextWord!peek	"find the next byte or character, but don't change position"	| val |	bogusBinary		ifTrue: [^realStream peek]		ifFalse: [^((val _ realStream peek) == nil ifFalse: [Character value: val])]!peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	| nextObject |	realStream atEnd ifTrue: [^false].	nextObject _ self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	realStream skip: -1.	^false!skipTo: anObject 	"Position the receiver past the next occurrance of anObject.  Answer true if 	anObject is found, false otherwise."	^realStream skipTo: anObject asInteger!space	"Append a space character to the receiver."	self nextPut: Character space!through: anObject 	"Answer a subcollection from position through the occurrence (if any) of anObject.	If not there, answer everything."	| newStream element |	bogusBinary		ifTrue: [newStream _ WriteStream on: (ByteArray new: 64)]		ifFalse: [newStream _ WriteStream on: (String new: 64)].	[realStream atEnd or: [(element _ self next) = anObject]]		whileFalse: [newStream nextPut: element].	self atEnd		ifFalse:	[newStream nextPut: element].	^newStream contents!upTo: anObject 	"Answer a subcollection from position to the occurrence (if any, not   	inclusive) of anObject. If not there, answer everything."	| newStream element |	bogusBinary		ifTrue: [newStream _ WriteStream on: (ByteArray new: 64)]		ifFalse: [newStream _ WriteStream on: (String new: 64)].	[realStream atEnd or: [(element _ self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!MixedFileStream methodsFor: 'accessing'!binary	bogusBinary _ true!isBinary	^bogusBinary!text	bogusBinary _ false! !!MixedFileStream methodsFor: 'initialize/release'!initialize: aFileStream	super initialize: aFileStream.	realStream readWrite; binary.	self text! !EncryptedFileStream comment:'Copyright (c) 1986, 1987 Xerox Corporation. All rights reserved.'!!EncryptedFileStream methodsFor: 'read/write'!decryptInto: outStream maxBytes: maxBytes	"it is assumed that outStream is a stream type object and it's current position is where the user wishes to start putting the decrypted data coming from this EncryptedFileStream starting at it's current position and continuing for maxBytes.  If maxBytes is nil, go to the end of this file"	| totalLeft |	Cursor wait showWhile: [	totalLeft _ self size - self position.	maxBytes == nil ifFalse: [totalLeft _ totalLeft min: maxBytes].	[7680 > totalLeft] whileFalse:		[outStream nextPutAll: (self next: 7680).		totalLeft _ totalLeft - 7680].	totalLeft > 0 ifTrue: [outStream nextPutAll: (self next: totalLeft)]]!encryptStream: inStream	"it is assumed that inStream is a stream type object and it's current position is where the user wishes to start getting the data to encrypt and putting in this EncryptedFileStream at it's current position"	| totalLeft |	Cursor wait showWhile: [	totalLeft _ inStream size - inStream position.	[7680 > totalLeft] whileFalse:		[self nextPutAll: (inStream next:  7680).		totalLeft _ totalLeft -  7680].	totalLeft > 0 ifTrue: [self nextPutAll: (inStream next: totalLeft)]]!next	| value | 	keyIndex _ (keyIndex + 1) \\ keySize.	keyIndex = 0 ifTrue: [keyIndex _ 1].	value _ realStream next bitXor: (key at: keyIndex).	^bogusBinary		ifTrue: [value]		ifFalse: [Character value: value]!next: anInteger	"Answer the next anInteger bytes or characters from the file"	| howManyRead aStream theByteArray totalCanRead |	theByteArray _ ByteArray new: anInteger.	totalCanRead _ anInteger min: (self size - self position).	1 to: totalCanRead do:		[:i |		keyIndex _ (keyIndex + 1) \\ keySize.		keyIndex = 0 ifTrue: [keyIndex _ 1].		theByteArray at: i put: (realStream next bitXor: (key at: keyIndex))].	^bogusBinary		ifTrue: [theByteArray]		ifFalse: [(String new: anInteger) replaceFrom: 1 to: anInteger withByteArray: theByteArray startingAt: 1]!nextPut: anIntegerOrCharacter	| value | 	(keyIndex _ (keyIndex + 1) \\ keySize) = 0 ifTrue: [keyIndex _ 1].	value _ bogusBinary		ifTrue: [anIntegerOrCharacter]		ifFalse: [anIntegerOrCharacter asciiValue].	value _ value bitXor: (key at: keyIndex).	^realStream nextPut: value!nextPutAll: aByteArrayOrString 	| size aByteArray convertedByteArray |	size _ aByteArrayOrString size.	aByteArray _ bogusBinary		ifTrue: [aByteArrayOrString]		ifFalse: [(ByteArray new: size) replaceFrom: 1 to: size withString: aByteArrayOrString startingAt: 1].	convertedByteArray _ ByteArray new: size.	1 to: size do: [:i |		(keyIndex _ (keyIndex + 1) \\ keySize) = 0 ifTrue: [keyIndex _ 1].		convertedByteArray at: i put: ((aByteArray at: i) bitXor: (key at: keyIndex))].	^realStream nextPutAll: convertedByteArray!peek	| val nextKeyIndex | 	nextKeyIndex _ (keyIndex + 1) \\ keySize.	nextKeyIndex = 0 ifTrue: [nextKeyIndex _ 1].	^bogusBinary		ifTrue: [realStream peek bitXor: (key at: nextKeyIndex)]		ifFalse:			[((val _ realStream peek) == nil				ifFalse: [Character value: (val bitXor: (key at: nextKeyIndex))])]!peekFor: anObject	^(super peekFor: anObject)		ifTrue: [true]		ifFalse: [self updateKeyIndex. false]! !!EncryptedFileStream methodsFor: 'initialize/release'!initialize: aFileStream	"normally should use initialize:key:	this is disgusting, but make a default key if needed"	super initialize: aFileStream.	key == nil ifTrue: [self key: 'default key']!initialize: aFileStream key: keyString	super initialize: aFileStream.	self key: keyString!key: keyString	"this should be used very carefully"	self reset.	key _ ByteArray new: keyString size.	key		replaceFrom: 1		to: keyString size		withString: keyString		startingAt: 1.	keySize _ key size + 1. "the + 1 is to fool it into using the full thing, since it uses it for modulo"	keyIndex _ 1! !!EncryptedFileStream methodsFor: 'positioning'!position: anInteger	super position: anInteger.	keyIndex _ anInteger \\ (keySize - 1) + 1.	keyIndex = 0 ifTrue: [keyIndex _ 1]!reset	super reset.	keySize == nil ifFalse: [self updateKeyIndex]!setToEnd	super setToEnd.	self updateKeyIndex!skip: anInteger	super skip: anInteger.	self updateKeyIndex!skipTo: anObject 	"Position the receiver past the next occurrance of anObject.  Answer true if 	anObject is found, false otherwise."	[realStream atEnd]		whileFalse: [self next = anObject ifTrue: [^true]].	^false!wordPosition: wpos	"Position the realStream wpos words from the header"	super wordPosition: wpos.	self updateKeyIndex! !!EncryptedFileStream methodsFor: 'private'!header: headerArray	"headerArray must be the correct internal format"	headerData _ headerArray.	headerData at: 4 put: $E.	self writeHeader!updateKeyIndex	keyIndex _ (self position \\ (keySize - 1) + 1).	keyIndex = 0 ifTrue: [keyIndex _ 1]! !!EncryptedFileStream methodsFor: 'header access'!writeHeaderFor: aDataItem	headerData _ Array with: aDataItem label with: aDataItem headerString with: aDataItem dataTypeUpdated with: $E.	self writeHeader!writeHeaderLabel: label class: class mods: mods dataType: dataType	headerData _ Array with: label with: (Classification new setFromArray: (Array with: class with: mods)) headerString with: dataType with: $E.	self writeHeader! !FixedFileStream comment:'The FixedFileStream (Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.) is a FileStream subclass with several additional protocols to support fixed length records, with named and typed fields.  The file has a header section with the following format:<number of fields><cr><field name>,<field length>,<field type><cr> {repeat this format for each field}	{Where}		<field name> ::= a string of indeterminate length, containing no spaces		<field length>::= a positive integer		<field type> ::= string | numberBelow is an example of a header:3name,20,stringrank,20,stringserialNumber,10,numberThe above example produces a file with a fifty character long record.  The fields "name" and "rank" are 20 character strings, while the field "serialNumber" is a 10 character numeric.'!!FixedFileStream methodsFor: 'initialize-release'!initialize: aFileStream	super initialize: aFileStream.	realStream readWrite.	self readFieldData!readFieldData	"load the instance variables describing the fields in this FixedFileStream."	| numberOfFields nextline index index2 index3 theField theFieldStart theFieldLength theFieldName theFieldType |	realStream readWrite.	Cursor read		showWhile: 			[realStream == nil ifTrue: [^false].			fields _ OopConservingDictionary new.			fieldNames _ OrderedCollection new.			length _ 0.			basePosition _ 0.			theFieldStart _ 2.			numberOfFields _ (realStream upTo: Character cr) asNumber.			1 to: numberOfFields do: 				[:i | 				"Get the field information for each field"				nextline _ realStream upTo: Character cr.				index _ nextline findString: ',' startingAt: 1.				theFieldName _ nextline copyFrom: 1 to: index - 1.				index2 _ nextline findString: ',' startingAt: index + 1.				theFieldLength _ (nextline copyFrom: index + 1 to: index2 - 1) asNumber.				index3 _ nextline size.				theFieldType _ nextline copyFrom: index2 + 1 to: index3.				"Having obtained the necessary information, construct a field dictionary "				theField _ OopConservingDictionary new.				theField at: #type put: theFieldType asSymbol.				theField at: #beginColumn put: theFieldStart.				length _ theFieldStart + theFieldLength - 1.				theField at: #endColumn put: length.				theFieldStart _ length + 1.				fields at: theFieldName asSymbol put: theField.				fieldNames add: theFieldName asSymbol]].	basePosition _ self position + 1! !!FixedFileStream methodsFor: 'accessing'!basePosition	"return the base position of the file.  base position indicates where the actual data records begin in the file."	^basePosition!length	"return the length of a record"	^length!numberOfRecords	"return the total number of records in this fixed file"	| number |	length > 0 ifFalse: [^0].	number _ (self size) - basePosition + 1 // length.	number < 1		ifTrue: [^0]		ifFalse: [^number]!record	"return the number of the record last accessed"	^self position - basePosition // length + 1! !!FixedFileStream methodsFor: 'field accessing'!beginningOfField: aSymbol	(fields includesKey: aSymbol) ifFalse:[^0].	^ (fields at: aSymbol) at: #beginColumn!endOfField: aSymbol	(fields includesKey: aSymbol) ifFalse:[^0].	^ (fields at: aSymbol) at: #endColumn!fieldLengthOf: aSymbol	"return the field length of field aSymbol"	(fields includesKey: aSymbol) ifFalse:[^1].	^((self endOfField: aSymbol) - (self beginningOfField: aSymbol) + 1)!fieldLengths	"return a collection of the field lengths"	| aCollection |	aCollection _ OrderedCollection new.	fieldNames do: [:each | aCollection add: ((self endOfField: each) - (self beginningOfField: each) + 1)].	^aCollection!fieldNames	"return a collection of the names of each field"	^fieldNames!fields	"return the field dictionaries"	^fields!fieldTypeOf: aSymbol	"return the field type of field aSymbol"	(fields includesKey: aSymbol) ifFalse:[^1].	^((fields at: aSymbol) at: #type)!fieldTypes	"return the field types"	| aCollection |	aCollection _ OrderedCollection new.	fieldNames do: [:each | aCollection add: ((fields at: each) at: #type)].	^aCollection! !!FixedFileStream methodsFor: 'record accessing'!allRecordNumbers	"return a collection of the contents of each record"	| theCollection aRecord |	theCollection _ OrderedCollection new.	Cursor read showWhile: [1 to: self numberOfRecords do: 			[:each | 			self position: basePosition + (length * (each - 1)) - 1.			realStream next = $* ifFalse: [theCollection add: each]]].	^theCollection!allRecordNumbersFitting: aFixedFileFilter 	"return a collection of the number of each record which fits aFixedFileFilter"	^self		field: nil		vs: aFixedFileFilter		recordNumbers: true		fitting: true		sorted: false		from: nil!allRecords	"return a collection of the contents of each record"	| theCollection aRecord |	theCollection _ OrderedCollection new.	Cursor read showWhile: [		1 to: self numberOfRecords do: 			[:each | 			self position: basePosition + (length * (each - 1)) - 1.			realStream next = $* ifFalse: [theCollection add: (self record: each)]]].	^theCollection!nextRecord	^thisRecord _ realStream next: length!setToRecordBegin	self position: basePosition - 1! !!FixedFileStream methodsFor: 'record locking'!isLocked: anInteger	^((self record: anInteger) at: 1) = $L!lockRecord: anInteger	"place a lock marker in the record's flag byte."	self position: basePosition + (length * (anInteger - 1)) - 1.	realStream next = $*		ifFalse: [self position: self position - 1.				realStream nextPut: $L].!unlockRecord: anInteger	"remove a lock marker in the record's flag byte."	self position: basePosition + (length * (anInteger - 1)) - 1.	realStream next = $*		ifFalse: [self position: self position - 1.				realStream nextPut: Character space].! !!FixedFileStream methodsFor: 'record deletion'!deleteRecord: anInteger	"place a deletion marker in the record's flag byte."	self position: basePosition + (length * (anInteger - 1)) - 1.	realStream next = $L ifFalse:			[self position: self position - 1.			realStream nextPut: $*].!isDeleted: anInteger	^((self record: anInteger) at: 1) = $*!undeleteRecord: anInteger	"remove a deletion marker in the record's flag byte."	self position: basePosition + (length * (anInteger - 1)) - 1.	realStream next = $L		ifFalse: [self position: self position - 1.				realStream nextPut: Character space].! !!FixedFileStream methodsFor: 'record create/edit'!addRecord: aString	"add to this FixedFileStream a record defined by aString.  Truncate this record if it is too long, and pad if it is too short."	| theNewRecord |	aString size <= (length - 1)		ifTrue:			[theNewRecord _ self blankField: length.			theNewRecord replaceFrom: 2 to: aString size + 1 with: aString startingAt: 1]		ifFalse: [theNewRecord _ ' ',(aString copyFrom: 1 to: length - 1)].	realStream setToEnd.	Cursor write showWhile: [realStream nextPutAll: theNewRecord].	realStream flush!replaceRecord: anInteger  field: aString with: anotherString	"replace this FixedFileStream a field at a record defined by anInteger and a field name defined by aSymbol.  Truncate the new field if it is too long, and pad if it is too short."	| newField theFieldSize startOfField endOfField aSymbol|	aSymbol _ aString asSymbol.	startOfField _ ((fields at: aSymbol) at: #beginColumn).	theFieldSize _ ((fields at: aSymbol) at: #endColumn) - startOfField + 1.	anotherString size < theFieldSize		ifTrue: [newField _ self blankField: theFieldSize.				newField replaceFrom: 1 to: anotherString size with: anotherString startingAt: 1]		ifFalse: [newField _ anotherString copyFrom: 1 to: theFieldSize].	self position: (basePosition + (length * (anInteger - 1)) - 1).	realStream next = $L		ifFalse:			[self position: (basePosition + (length * (anInteger - 1)) - 1) + startOfField - 1.			realStream nextPutAll: newField].	realStream flush!replaceRecord: anInteger from: aDictionary	"add to this FixedFileStream a record defined by aDictionary.  The dictionary has a format as follows:	<key> -> <contents>	The key should be a field name as a symbol. Contents should be a string.	Using the field information in this object, a record will be constructed and added to a to this fileStream."	| theNewRecord theString fieldSize theNewField |	theNewRecord _ self blankField: length.	aDictionary keys do: 		[:key | 			fieldSize _ (self endOfField: key) - (self beginningOfField: key) + 1.			theString _ aDictionary at: key asSymbol ifAbsent:[^self booboo: key,' is not a field name'].			theString size < fieldSize				ifTrue:[theNewField _ self blankField: fieldSize.					theNewField replaceFrom: 1 to: theString size with: theString startingAt: 1]				ifFalse:[theNewField _ theString copyFrom: 1 to: fieldSize].			theNewRecord replaceFrom: (self beginningOfField: key) to: (self endOfField: key) with: theNewField startingAt: 1].	self replaceRecord: anInteger with: theNewRecord.!replaceRecord: anInteger  with: aString	"replace in this FixedFileStream a record definedanInteger with a record defined by aString.  Truncate this record if it is too long, and pad if it is too short."	| theNewRecord |	aString size < length		ifTrue: [theNewRecord _ self blankField: length.				theNewRecord replaceFrom: 1 to: aString size with: aString startingAt: 1]		ifFalse: [theNewRecord _ aString copyFrom: 1 to: length].	self position: basePosition + (length * (anInteger - 1)) - 1.	realStream next = $L		ifFalse: [self position: self position - 1.				realStream nextPutAll: theNewRecord].	realStream flush!replaceRecordSelectively: anInteger from: aDictionary	"add to this FixedFileStream a record defined by aDictionary.  The dictionary has a format as follows:	<key> -> <contents>	The key should be a field name as a symbol. Contents should be a string.	Using the field information in this object, a record will be constructed and added to a to this fileStream."	| theNewRecord theString fieldSize theNewField |	theNewRecord _ self record: anInteger.	aDictionary keys do: 		[:key | 			fieldSize _ (self endOfField: key) - (self beginningOfField: key) + 1.			theString _ aDictionary at: key asSymbol ifAbsent:[self booboo: key,' is not a field name'].			theString size < fieldSize				ifTrue:[theNewField _ self blankField: fieldSize.					theNewField replaceFrom: 1 to: theString size with: theString startingAt: 1]				ifFalse:[theNewField _ theString copyFrom: 1 to: fieldSize].			theNewRecord replaceFrom: (self beginningOfField: key) to: (self endOfField: key) with: theNewField startingAt: 1].	self replaceRecord: anInteger with: theNewRecord.! !!FixedFileStream methodsFor: 'querying'!field: aSymbol 	"return a collection of the contents of field aSymbol for each record"	^self		field: aSymbol		vs: nil		recordNumbers: false		fitting: true		sorted: false		from: nil!field: aSymbol andRecordNumbersFitting: aFixedFileFilter	"return a collection of the contents of field aSymbol for each record fitting aFixedFileFilter"^self field: aSymbol 	vs: aFixedFileFilter 	recordNumbers: true 	fitting: true 	sorted: false 	from: nil!field: aSymbol andRecordNumbersFitting: aFixedFileFilter from: aCollection 	"return a collection of the contents of field aSymbol for each  	record from aCollection fitting aFixedFileFilter. Search only the record 	numbers found in aCollection"	^self		field: aSymbol		vs: aFixedFileFilter		recordNumbers: true		fitting: true		sorted: false		from: aCollection!field: aSymbol fitting: aFixedFileFilter	"return a collection of the contents of field aSymbol for each record fitting aFixedFileFilter"	| theCollection |	theCollection _ OrderedCollection new.	Cursor read showWhile:[	SmalltalkSignal	do: [ 1 to: self numberOfRecords do: 			[:each | (self evaluate: each vs: aFixedFileFilter)						ifTrue: [theCollection add: (self fieldFromThisRecord: aSymbol)]]]	handle: [self booboo: 'Format invalid. Query ignored !!'.			SmalltalkSignal handleReturn: nil]].	^ theCollection!field: aSymbol vs: aFixedFileFilter recordNumbers: recnum fitting: fit sorted: sorted from: aCollection 	"return a collection of the contents (and possibly record numbers) of field    	aSymbol for each record fitting (or not fitting) aFixedFileFilter.  Search    	only from the list of record numbers found in aCollection.  This is a very 	flexible routine.    	    	Summary of Arguments:    	field:				-- a field name or nil.  nil signifies don't return any contents  	vs:					-- a FixedFileFilter or nil.  nil signifies return all records.  	recordNumbers: 		-- true means return the record numbers, false means leave   	 them off.    	fitting: 				-- true means all records fitting, false means all records not fitting    	sorted: 				-- true means return a SortedCollection, false gives an    	OrderedCollection   	from: 				-- if nil, search all records.  If non-nil, search only    	the records enumerated in aCollection"	| outCollection recordsToSearch anArray theContentCollection theNumberCollection returnCollection cont all start stop type |	self reset.	cont _ aSymbol ~= nil.	"check to see if some field's contents is to be returned"	all _ aFixedFileFilter == nil.	"check to see if all records are required"	all		ifTrue: [self position: basePosition - 1]		ifFalse: [self initFilter: aFixedFileFilter].	cont | recnum ifFalse: [^self error: 'Nothing to return from database search'].	Cursor read show.	aCollection == nil		ifTrue: ["search all records"			recordsToSearch _ 1 to: self numberOfRecords]		ifFalse: ["search aCollection"			recordsToSearch _ aCollection].	sorted		ifTrue: [(outCollection _ SortedCollection new: recordsToSearch size) sortBlock: [:x :y | (x at: 1) <= (y at: 1)]]		ifFalse: [outCollection _ OrderedCollection new: recordsToSearch size].	SmalltalkSignal do: 		[(fields includesKey: aSymbol)			ifTrue: 				[start _ (fields at: aSymbol) at: #beginColumn.				stop _ (fields at: aSymbol) at: #endColumn.				type _ (fields at: aSymbol) at: #type]			ifFalse: 				[start _ 1.				stop _ 0.				type _ 1].		recordsToSearch do: [:each | "test each vs. fit, to allow a 'not fitting' query"			(all & (((self record: each) at: 1) ~= $*) or: [fit = (self evaluate: each vs: aFixedFileFilter)])				ifTrue: 					[anArray _ Array with: nil with: each.					cont ifTrue: [anArray at: 1 put: (self								fieldFrom: start								to: stop								type: type)].					outCollection add: anArray]]]		handle: 			[self booboo: 'Format invalid. Query ignored !!'.			SmalltalkSignal handleReturn: nil].	cont ifTrue: [theContentCollection _ OrderedCollection new].	recnum ifTrue: [theNumberCollection _ OrderedCollection new].	1 to: outCollection size do: 		[:each | 		cont ifTrue: [theContentCollection add: ((outCollection at: each)					at: 1)].		recnum ifTrue: [theNumberCollection add: ((outCollection at: each)					at: 2)]].	Cursor normal show.	"return either a collection containing both or just a single collection with the   	asked for returns"	cont & recnum		ifTrue: 			[returnCollection _ OrderedCollection new.			returnCollection add: theContentCollection.			returnCollection add: theNumberCollection.			^returnCollection].	cont ifTrue: [^theContentCollection].	recnum ifTrue: [^theNumberCollection]!fieldFrom: start to: stop type: type	| string |	start > stop ifTrue: [^String new].	string _ thisRecord copyFrom: start to: stop.	type = #number ifTrue: [^string stripLeadingSpaces asNumber].	type == #date ifTrue: [^Date readFrom: (ReadStream on: string stripLeadingSpaces)].	type == #time ifTrue: [^Time readFrom: (ReadStream on: string stripLeadingSpaces)].	^string!fieldFromThisRecord: fieldName 	| string type |	(fields includesKey: fieldName)		ifFalse: [^String new].	string _ thisRecord copyFrom: ((fields at: fieldName)					at: #beginColumn)				to: ((fields at: fieldName)						at: #endColumn).	type _ self fieldTypeOf: fieldName.	type = #number ifTrue: [^string stripLeadingSpaces asNumber].	type == #date ifTrue: [^Date readFrom: (ReadStream on: string stripLeadingSpaces)].	type == #time ifTrue: [^Time readFrom: (ReadStream on: string stripLeadingSpaces)].	^string!record: aNumber 	"obtain the characters contained in the record specified by aNumber"	| pos |	pos _ basePosition + (length * (aNumber - 1)) - 1.	self position = pos ifFalse: [self position: pos].	thisRecord _ realStream next: length.	^thisRecord!record: aNumber field: aSymbol	| string type | 	"obtain the characters contained in the record specified by aNumber and field specified by aSymbol"	self record: aNumber.	^self fieldFromThisRecord: aSymbol!returnField: fieldName	(fields includesKey: fieldName)		ifFalse: [^String new].	^thisRecord copyFrom: ((fields at: fieldName)			at: #beginColumn)		to: ((fields at: fieldName)				at: #endColumn)!sortedField: aSymbol andRecordNumbersFitting: aFixedFileFilter from: aList	"return a sorted collection of the contents of field aSymbol for each record 	fitting aFixedFileFilter"	^self		field: aSymbol		vs: aFixedFileFilter		recordNumbers: true		fitting: true		sorted: true		from: aList!sortedFieldAndRecordNumbers: aSymbol from: recordList	"return a collection of the contents of field aSymbol for each record"	^self		field: aSymbol		vs: nil		recordNumbers: true		fitting: true		sorted: true		from: recordList! !!FixedFileStream methodsFor: 'querying private'!check: field vs: otherValue withOp: operation 	| return value fieldType tVal |	operation == #contains		ifTrue: 			[value _ self fieldFromThisRecord: field.			^(value findString: otherValue startingAt: 1) ~= 0].	operation == #doesntContain		ifTrue: 			[value _ self fieldFromThisRecord: field.			^(value findString: otherValue startingAt: 1) = 0].	fieldType _ (fields at: field) at: #type.	value _ (self fieldFromThisRecord: field).	return _ value perform: operation with: otherValue.	^return!evaluate: record vs: aFixedFileFilter 	| returnFlag result conjunction clause |	returnFlag _ false.	(self isDeleted: record) ifTrue:[^false]. "check for deletion reads in record as well"	aFixedFileFilter do: 		[:clause | 		result _ self					check: (clause at: 1)					vs: (clause at: 3)					withOp: (clause at: 2).		conjunction _ clause at: 4.		conjunction == $* ifTrue: [conjunction _ #or].		conjunction == #and ifTrue: [returnFlag _ result & returnFlag].		conjunction == #xor ifTrue: [returnFlag _ result xor: returnFlag].		conjunction == #or ifTrue: [returnFlag _ result | returnFlag]].	^returnFlag!getValue: aString fromType: aSymbol	"obtain the proper value for a comparison based on the type specified.  This is an internal call, and not generally useful in most capacitities."	| theRealValue |	aSymbol == #string ifTrue: [^aString].	aSymbol == #number ifTrue: [^aString asNumber]!initFilter: aFixedFileFilter	| type | 	aFixedFileFilter do: [:each | type _ self fieldTypeOf: (each at: 1).		type = #date ifTrue:[each at: 3 put: (Date readFrom: (ReadStream on: (each at: 3)))].		type = #time ifTrue:[each at: 3 put: (Time readFrom: (ReadStream on: (each at: 3)))]].! !!FixedFileStream methodsFor: 'database extraction'!compress	"compress the deleted records out of the fixed file"	| theNewFileStream newName theRecord |	newName _ 'CNVRTXXX.DB'.	Cursor write showWhile: [		theNewFileStream _ (FileStream fileNamed: newName) writeShorten.		realStream reset.		theNewFileStream nextPutAll: (realStream next: basePosition - 1 + (hasHeader ifTrue: [512] ifFalse: [0])).		theNewFileStream close.		theNewFileStream _ self class fileNamed: newName].	self position: basePosition - 1.	1 to: self numberOfRecords do: [:each |		theRecord _ self nextRecord.		(theRecord at: 1) = $* ifFalse: [theNewFileStream dumpRecord: theRecord]].	theNewFileStream close.	realStream close.	Disk removeKey: realStream name ifAbsent: [].	Disk renameKey: newName newName: realStream name!constructRecordFrom: aDictionary	"add to this FixedFileStream a record defined by aDictionary.  The dictionary has a format as follows:	<key> -> <contents>	The key should be a field name as a symbol. Contents should be a string.	Using the field information in this object, a record will be constructed and added to a to this fileStream."	| theNewRecord theString fieldSize theNewField |	theNewRecord _ self blankField: length - 1.	aDictionary keys do: 		[:key | (fieldNames includes: key) 			ifTrue:[				fieldSize _ (self endOfField: key) - (self beginningOfField: key) + 1.				theString _ aDictionary at: key.				theString class == String ifFalse:[theString _ theString printString].				theString size < fieldSize					ifTrue:[theNewField _ theString]					ifFalse:[theNewField _ theString copyFrom: 1 to: fieldSize].				theNewRecord 					replaceFrom: (self beginningOfField: key) - 1 					to: (self beginningOfField: key) + theNewField size - 2 					with: theNewField startingAt: 1]].	self addRecord: theNewRecord.!dumpRecord: aString	"add to this FixedFileStream a record defined by aString.  Assume this record is PERFECT!!"	realStream setToEnd.	Cursor write showWhile: [realStream nextPutAll: aString].!extractInto: aFileName fromFilter: aFixedFileFilter	"get the records fitting aFixedFileFIlter and create a new file named aFileName with only those records"	| aCollection |	aCollection _ self allRecordNumbersFitting: aFixedFileFilter.	self extractInto: aFileName fromRecords: aCollection!extractInto: aFileName fromRecords: aCollection	"copy the specified records out of the fixed file"	| theNewFileStream newName theRecord |	Cursor write showWhile:[		theNewFileStream _ (FileStream fileNamed: aFileName) writeShorten.		realStream reset.		theNewFileStream nextPutAll: (realStream next: basePosition - 1 + (hasHeader ifTrue: [512] ifFalse: [0])).		theNewFileStream close.		theNewFileStream _ self class fileNamed: aFileName].	aCollection do: [:each |		theRecord _ self record: each.		(theRecord at: 1) = $* ifFalse: [theNewFileStream dumpRecord: theRecord]].	theNewFileStream close! !!FixedFileStream methodsFor: 'file stream mimicry'!close	realStream setToEnd; close.	self release! !!FixedFileStream methodsFor: 'private'!blankField: aNumber	| theString theStream space |	space _ Character space.	theStream _ReadWriteStream on: String new.	1 to: aNumber do: [:each | theStream nextPut: space].	^theStream contents!constrain: theString toSize: anInteger	| theNewRecord theNewField | 	theNewRecord _ self blankField: anInteger.	theString size < anInteger		ifTrue:[theNewField _ theString]		ifFalse:[theNewField _ theString copyFrom: 1 to: anInteger].	theNewRecord 			replaceFrom: 1 			to: theNewField size 			with: theNewField startingAt: 1.	^theNewRecord! !ClassifiedFixedFileStream comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation.  All rights reserved.'!!ClassifiedFixedFileStream methodsFor: 'initialize-release'!grabFieldData	| theFieldStart numberOfFields theFieldName theFieldLength theFieldType theField nextline index index2 index3 out | 	Cursor read		showWhile: 			[realStream == nil ifTrue: [^false].			fields _ OopConservingDictionary new.			fieldNames _ OrderedCollection new.			length _ 0.			basePosition _ 0.			theFieldStart _ classificationSize + 2.			numberOfFields _ (out _ realStream upTo: Character cr) asNumber.			1 to: numberOfFields do: 				[:i | 				"Get the field information for each field"				nextline _ realStream upTo: Character cr.				index _ nextline findString: ',' startingAt: 1.				theFieldName _ nextline copyFrom: 1 to: index - 1.				index2 _ nextline findString: ',' startingAt: index + 1.				theFieldLength _ (nextline copyFrom: index + 1 to: index2 - 1) asNumber.				index3 _ nextline size.				theFieldType _ nextline copyFrom: index2 + 1 to: index3.				"Having obtained the necessary information, construct a field dictionary "				theField _ OopConservingDictionary new.				theField at: #type put: theFieldType asSymbol.				theField at: #beginColumn put: theFieldStart.				length _ theFieldStart + theFieldLength - 1.				theField at: #endColumn put: length.				theFieldStart _ length + 1.				fields at: theFieldName asSymbol put: theField.				fieldNames add: theFieldName asSymbol]].	basePosition _ self position + 1!readFieldData	"load the instance variables describing the fields in this FixedFileStream."	| readStream theFieldStart numberOfFields theFieldName theFieldLength theFieldType theField fileName |	realStream readWrite.	self reset.	realStream peek = $* "is this a classified fixed file stream?"		ifTrue: 			["read the classification"			realStream upTo: Character cr.			classificationScheme _ ClassificationScheme new setupFrom: realStream.			classificationSize _ classificationScheme maxSize.			aggregateLocation _ self position.			aggregateClassification _ (Classification new: classificationSize) readFrom: realStream.			self grabFieldData.			classificationScheme id = DCM id ifFalse: ["convert to different classification scheme"				Cursor wait					showWhile: 						[fileName _ realStream name.						self convertInto: 'CNVRTXXX.DB'.						realStream close.						Disk removeKey: fileName ifAbsent: [].						Disk renameKey: 'CNVRTXXX.DB' newName: fileName.						self initialize: (FileStream fileNamed: fileName)]]]		ifFalse: ["convert into a classified database"			realStream atEnd ifFalse: [self booboo: realStream name, ' is not classified.  I will convert it to classified form'].			Cursor wait				showWhile: 					[super readFieldData.					fileName _ realStream name.					self classifyInto: 'CNVRTXXX.DB'.					realStream close.					Disk removeKey: fileName ifAbsent: [].					Disk renameKey: 'CNVRTXXX.DB' newName: fileName.					self initialize: (FileStream fileNamed: fileName)]]! !!ClassifiedFixedFileStream methodsFor: 'accessing'!classification	^aggregateClassification!classification: aClassification	aggregateClassification _ aClassification.	self writeAggregateClassification! !!ClassifiedFixedFileStream methodsFor: 'record create/edit'!constructRecordFrom: aDictionary	"add to this FixedFileStream a record defined by aDictionary.  The dictionary has a format as follows:	<key> -> <contents>	The key should be a field name as a symbol. Contents should be a string.	Using the field information in this object, a record will be constructed and added to a to this fileStream."	| theNewRecord theString fieldSize theNewField newClassification |	theNewRecord _ self blankField: length - 1.	newClassification _ Classification new.	theNewRecord replaceFrom: 2 to: newClassification size + 1 with: newClassification asString startingAt: 1.	aDictionary keys do: 		[:key | (fieldNames includes: key) 			ifTrue:[				fieldSize _ (self endOfField: key) - (self beginningOfField: key) + 1.				theString _ aDictionary at: key.				theString class == String ifFalse:[theString _ theString printString].				theString size < fieldSize					ifTrue:[theNewField _ theString]					ifFalse:[theNewField _ theString copyFrom: 1 to: fieldSize].				theNewRecord 					replaceFrom: (self beginningOfField: key) - 1 					to: (self beginningOfField: key) + theNewField size - 2 					with: theNewField startingAt: 1]].	self addRecord: theNewRecord.!replaceRecord: anInteger with: aString	"replace in this FixedFileStream a record definedanInteger with a record defined by aString.  Truncate this record if it is too long, and pad if it is too short."	| theNewRecord newClassification |	aString size < length		ifTrue:[theNewRecord _ self blankField: length.			newClassification _ Classification new.			theNewRecord replaceFrom: 2 to: newClassification size + 1 with: newClassification asString startingAt: 1.			theNewRecord replaceFrom: 1 to: aString size with: aString startingAt: 1]		ifFalse:[theNewRecord _ aString copyFrom: 1 to: length.			newClassification _ Classification new.			theNewRecord replaceFrom: 2 to: newClassification size + 1 with: newClassification asString startingAt: 1].	self position: basePosition + (length * (anInteger - 1)) - 1.	realStream next = $L		ifFalse:			[self position: self position - 1.			realStream nextPutAll: theNewRecord].	realStream flush! !!ClassifiedFixedFileStream methodsFor: 'querying'!fieldFromThisRecord: fieldName 	fieldName == #classification		ifTrue: [^self classificationFromThisRecord]		ifFalse: [^super fieldFromThisRecord: fieldName]! !!ClassifiedFixedFileStream methodsFor: 'querying private'!check: field vs: otherValue withOp: operation 	| return value fieldType tVal |	operation == #contains		ifTrue: 			[value _ self fieldFromThisRecord: field.			^(value findString: otherValue startingAt: 1) ~= 0].	operation == #doesntContain		ifTrue: 			[value _ self fieldFromThisRecord: field.			^(value findString: otherValue startingAt: 1) = 0].	field = #classification 		ifFalse:[fieldType _ (fields at: field) at: #type].	value _ (self fieldFromThisRecord: field).	return _ value perform: operation with: otherValue.	^return!initFilter: aFixedFileFilter 	| type |	aFixedFileFilter do: [:each | (each at: 1)			== #classification ifTrue: [each at: 3 put: (Classification array: (Compiler evaluate: (each at: 3)))]].	super initFilter: aFixedFileFilter! !!ClassifiedFixedFileStream methodsFor: 'database extraction'!classifyInto: aFileName	"convert myself into a classified database, adding strings"	| theNewFileStream newName theRecord |	Cursor write showWhile:[		theNewFileStream _ (FileStream fileNamed: aFileName) writeShorten.		realStream reset.		hasHeader ifTrue: [theNewFileStream nextPutAll: (realStream next: 512)].		theNewFileStream nextPutAll: '* '; nextPut: Character cr.		DCM writeClassification: theNewFileStream.		Classification new storeOn: theNewFileStream.		theNewFileStream nextPutAll: (realStream next: basePosition - 1).	self position: basePosition - 1.	1 to: self numberOfRecords do: [:each |		theRecord _ self nextRecord.		(theRecord at: 1) = $* ifFalse: [			theNewFileStream nextPut: (theRecord at: 1).			Classification new storeOn: theNewFileStream.			theNewFileStream nextPutAll: (theRecord copyFrom: 2 to: theRecord size)]].	theNewFileStream close]!compress	"compress the deleted records out of the fixed file"	| theNewFileStream newName theRecord |	newName _ 'CNVRTXXX.DB'.	Cursor write		showWhile: 			[theNewFileStream _ (FileStream fileNamed: newName) writeShorten.			realStream reset.			theNewFileStream nextPutAll: (realStream next: basePosition - 1 + (hasHeader ifTrue: [512] ifFalse: [0])).			theNewFileStream close.			theNewFileStream _ self class fileNamed: newName].	aggregateClassification _ Classification new.	self position: basePosition - 1.	1 to: self numberOfRecords do: 		[:each | 		theRecord _ self nextRecord.		(theRecord at: 1) = $*			ifFalse: 				[aggregateClassification _ aggregateClassification + self classificationFromThisRecord.				theNewFileStream dumpRecord: theRecord]].	theNewFileStream classification: aggregateClassification.	theNewFileStream close.	realStream close.	Disk removeKey: realStream name ifAbsent: [].	Disk renameKey: newName newName: realStream name!convertInto: aFileName	"convert myself to the newest ClassificationScheme"	| theNewFileStream theRecord beginFieldDefs aggClassification class |	self booboo:	'This database is classified according to an old scheme,and will be converted.'.	Cursor write showWhile: [		theNewFileStream _ (FileStream fileNamed: aFileName) readWriteShorten.		hasHeader ifTrue: [realStream reset. theNewFileStream nextPutAll: (realStream next: 512)].		self position: (beginFieldDefs _ aggregateLocation + classificationScheme maxSize).		theNewFileStream nextPutAll: '* '; nextPut: Character cr.		DCM writeClassification: theNewFileStream.		(aggregateClassification convertFrom: classificationScheme) storeOn: theNewFileStream.		theNewFileStream nextPutAll: (realStream next: basePosition - beginFieldDefs - 1).	aggClassification _ Classification new.	self position: basePosition - 1.	1 to: self numberOfRecords do: [:each |		theRecord _ self nextRecord.		(theRecord at: 1) = $* ifFalse: [			theNewFileStream nextPut: (theRecord at: 1).			class _ self classificationFromThisRecord convertFrom: classificationScheme.			aggClassification _ aggClassification + class.			class storeOn: theNewFileStream.			theNewFileStream nextPutAll: (theRecord copyFrom: classificationSize + 2 to: theRecord size)]].	theNewFileStream close.	theNewFileStream _ self class fileNamed: aFileName.	theNewFileStream classification: aggClassification.	theNewFileStream close]!extractInto: aFileName fromRecords: aCollection	"copy the specified records out of the fixed file"	| theNewFileStream newName theRecord aggClassification |	Cursor write showWhile: [	theNewFileStream _ (FileStream fileNamed: aFileName) writeShorten.	realStream reset.	theNewFileStream nextPutAll: (realStream next: basePosition - 1 + (hasHeader ifTrue: [512] ifFalse: [0])).	theNewFileStream close.	theNewFileStream _ self class fileNamed: aFileName.	aggClassification _ Classification new.	aCollection do: [:each |		theRecord _ self record: each.		(theRecord at: 1) = $* ifFalse:			[aggClassification _ aggClassification + self classificationFromThisRecord.			theNewFileStream dumpRecord: theRecord]].	theNewFileStream classification: aggClassification.	theNewFileStream close]! !!ClassifiedFixedFileStream methodsFor: 'classification'!classificationFromThisRecord	| newClassification | 	newClassification _ Classification new.	newClassification replaceFrom: 1 to: newClassification size withString: thisRecord startingAt: 2.	^newClassification!classificationOfRecord: anInteger	self record: anInteger.	^self classificationFromThisRecord!classifyRecord: anInteger with: aClassification	aggregateClassification _ aggregateClassification + aClassification.	self writeAggregateClassification.	self position: (basePosition + (length * (anInteger - 1)) - 1).	realStream next = $L		ifFalse: [aClassification storeOn: realStream].!writeAggregateClassification	super classification: aggregateClassification.	self position: aggregateLocation.	aggregateClassification storeOn: realStream.! !!FileDirectory methodsFor: 'file accessing'!makeNewFileName: fname withSuffix: suffix	"Convert input label into a unique file name of correct length and characters.(20 max from fname)"	|counter char len slen i newName special period baseName tryName|	fname isEmpty		ifTrue: [^'empty-file-name-+1'].	special _ '.-+$!!'.	period _ $..	len _ fname size.	slen _ suffix size.	(len > 20 ) ifTrue: [ len _ 20].	newName _ WriteStream on: (String new: len + slen + 3).	1 to: len do: [:i |		char _ fname at: i.		"check characters: alphanumeric or 5 special"		(char isLetter or: [(special includes: char) or: [char isDigit]])		 	ifTrue: [newName nextPut: char]].	(slen = 0)ifFalse:[1 to: slen do: [:i |		char _ suffix at: i.		newName nextPut: char]].	newName nextPut: $-.	newName nextPut: $+.	baseName _ newName contents.	newName nextPut: $1.	tryName _ newName contents.	counter _ 1.	[self includesKey: tryName]		whileTrue:[counter _ counter + 1.			tryName _ baseName,counter printString.].	^tryName!renameKey: oldName newName: newName	"this addition is meant to allow compatible code to be written with file systems which cannot rename a file while they are already holding access rights to it because it is done by a primitive (eg. use rename:newName:) as is the case with the 7/85 PilotFileDirectory"	self rename: (self findKey: oldName) newName: newName! !!FileDirectory methodsFor: 'file copying'!copy: fromFileName to: toFileName 		"Copy file whose name is fromFileName (usually from this receiver) to a file		whose name is toFileName (usually a local directory)."		| oldFile newFile leftOver |		Cursor write showWhile:		[oldFile _ self oldFile: fromFileName.		oldFile readOnly.		oldFile binary; readOnly.		newFile _ (self file: toFileName) binary.			leftOver _ oldFile size.		[leftOver > 4096] whileTrue:				[newFile nextPutAll: (oldFile next: 4096).				leftOver _ leftOver - 4096].		newFile nextPutAll: (oldFile next: leftOver).		newFile close.		oldFile close]! !!FileDirectory methodsFor: 'filename comparisons'!findFiles: checkFiles inList: mainList inclusive: inclusive addTo: returnList	"look for the filenames in the collection checkFiles in the collection of filenames mainList. If inclusive is true, add the filenames which are in both lists to returnList, otherwise add the filenames which are in only one list.	This is put here to attempt to handle the problems that arise between file systems which have case sensitive filenames and those which are not case sensitive - this particular implementation is for non-case sensitive filenames"	| lowercasedName lowerMainList |	lowerMainList _ OrderedCollection new: mainList size.	mainList do: [:i | lowerMainList add: i asLowercase].	inclusive		ifTrue:			[checkFiles do:				[:fileName |				lowercasedName _ fileName asLowercase.				(lowerMainList includes: lowercasedName) ifTrue: [returnList add: fileName]]]		ifFalse:			[checkFiles do:				[:fileName |				lowercasedName _ fileName asLowercase.				(lowerMainList includes: lowercasedName) ifFalse: [returnList add: fileName]]].	^returnList! !!Controller methodsFor: 'basic control sequence'!controlLoop	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. When 	false is returned, the loop ends. Each time through the loop, the message 	Controller|controlActivity is sent."	[self isControlActive] whileTrue: [Processor yield. BackgroundDelay == 0 ifFalse: [(Delay forMilliseconds: BackgroundDelay) wait]. self controlActivity]! !!Controller methodsFor: 'cursor'!keepCursorIn: box	"Position sensor's mousePoint to the nearest point of box."	| cursor currentCursor |	cursor _ ((currentCursor _ sensor cursorPoint) max: box origin) min: box corner.	cursor = currentCursor ifFalse: [sensor cursorPoint: cursor]!keepCursorInView	"Position sensor's mousePoint to the nearest point of its view's inset display box."	^self keepCursorIn: view insetDisplayBox! !!BinaryChoiceController methodsFor: 'control defaults'!isControlActive	model actionTaken ifTrue: [^false].	[super isControlActive] whileFalse: [self keepCursorInView.].	^true! !!BinaryChoiceController methodsFor: 'cursor'!centerCursorInView	"Position sensor's mousePoint (which is assumed to be connected to the 	cursor) to the center of its view's inset display box (see Sensor|mousePoint: and 	View|insetDisplayBox)."	| lowestSubView subViews |	subViews_ view subViews.	subViews isEmpty		ifFalse:	[lowestSubView _ subViews at: 1.				subViews do:					[:subView |						(subView insetDisplayBox top >							lowestSubView insetDisplayBox top)						ifTrue:	[lowestSubView _ subView]].				^lowestSubView controller centerCursorInView].	^super centerCursorInView! !PreviewTabController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!PreviewTabController methodsFor: 'control defaults'!controlActivity	| i | 	sensor redButtonPressed		ifTrue: [(view tabSelectionAt: sensor cursorPoint) = 0					ifTrue: [self redButtonActivity]					ifFalse: [[sensor redButtonPressed] whileTrue:								[i _ view tabSelectionAt: sensor cursorPoint.								i > 0 ifTrue: [view selectTab: i]]]].	sensor yellowButtonPressed		ifTrue: [self yellowButtonActivity].!isControlActive	^done not!redButtonActivity	| aTab tabPt | 	tabPt _ sensor cursorPoint.	aTab _ view tabAt: tabPt.	aTab == nil ifFalse: [view highlightTab: aTab].	view tabCursor showWhile:		[[sensor redButtonPressed]			whileTrue: [tabPt _ sensor cursorPoint.						view showTabPositionAt: tabPt].		view displayTabAt: tabPt].	aTab == nil ifFalse: [view eraseTab: aTab]!yellowButtonActivity	| index | 	index _ (PopUpMenu labels: 'apply\add new\bailout' withCRs lines: #(2)) startUp.	index = 1		ifTrue: [view updateTabs: false].	index = 2		ifTrue: [view updateTabs: true].	index = 3		ifTrue: [view updateTabs: nil].	index = 0 ifFalse: [done _ true]! !!PreviewTabController methodsFor: 'initialize-release'!initialize	super initialize.	done _ false.! !!MouseMenuController methodsFor: 'menu messages'!blueButtonActivity	"Determine which item in the blue button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	| index |	blueButtonMenu == nil		ifFalse:			[index _ blueButtonMenu startUpBlueButton.			(index = 0 or: [index == nil])				ifFalse: [self menuMessageReceiver perform:							(blueButtonMessages at: index)]]		ifTrue: [super controlActivity]!redButtonActivity	"Determine which item in the red button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	| index |	redButtonMenu == nil		ifFalse:			[index _ redButtonMenu startUpRedButton.			(index = 0 or: [index == nil])				ifFalse: [self menuMessageReceiver perform:							(redButtonMessages at: index)]]		ifTrue: [super controlActivity]!yellowButtonActivity	"Determine which item in the yellow button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	| answer |	yellowButtonMenu == nil ifTrue: [^super controlActivity].	answer _ yellowButtonMenu startUpYellowButton.	(answer = 0 or: [answer == nil]) ifFalse:		[answer class == Array ifTrue:			[answer first numArgs = 0 ifFalse:				[^self menuMessageReceiver perform: answer first with: answer last].			answer _ answer first].		(answer class ~~ Symbol or: [answer numArgs = 0])			ifTrue: [self menuMessageReceiver perform: (yellowButtonMessages at: answer)]			ifFalse: [self menuMessageReceiver perform: answer with: nil]]! !!MouseMenuController methodsFor: 'private'!getLastSelectionIn: aTreeMenu	| lastAnswer | 	aTreeMenu child notNil ifTrue:		[lastAnswer _ self getLastSelectionIn: aTreeMenu child.		 lastAnswer == nil ifFalse: [^lastAnswer]].	^aTreeMenu answer!performBlueSelections 	"Perform all the currently selected messages in my blueButtonMenu, starting at the lowest level subtree."	self performTreeBackwards: blueButtonMenu!performTreeBackwards: aTreeMenu	"Perform all the currently selected messages in aTreeMenu, starting at the lowest level subtree."	aTreeMenu child notNil ifTrue:		[self performTreeBackwards: aTreeMenu child].	aTreeMenu answer notNil ifTrue:		[(aTreeMenu answer isKindOf: Symbol)			ifTrue: [self perform: aTreeMenu answer]]!performYellowSelections 	"Perform all the currently selected messages in my yellowButtonMenu, starting at the lowest level subtree."	self performTreeBackwards: yellowButtonMenu! !!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar _ Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker _ Quadrangle new.	marker borderWidthLeft: 0 right: 0 top:1 bottom: 1.	marker insideColor: Form gray! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"The scrollbar has a two-pixel border, and for alignment it assumes that this sub-view	has a one-pixel border and shares another one-pixel border from its neighbor/super view"	super controlInitialize.	scrollBar region: (0@0 extent: 15 @ (view displayBox height + 2)).	marker region: self computeMarkerRegion.	scrollBar _ scrollBar align: scrollBar topRight with: view displayBox topLeft - (0@1).	marker _ marker align: marker topCenter with: scrollBar inside topCenter.	savedArea _ Form fromDisplay: scrollBar.	scrollBar displayOn: Display.	self moveMarker! !!ScrollController methodsFor: 'scrolling'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor regionPercent |	savedCursor _ sensor currentCursor.	[self scrollBarContainsCursor]		whileTrue: 			[Processor yield.			self changeCursor: Cursor upDown.			(Sensor redButtonPressed) ifTrue:[self scrollUp.				[Sensor anyButtonPressed] whileTrue:[self scrollView:-1].				self moveMarker].			(Sensor blueButtonPressed) ifTrue:[self scrollDown.				[Sensor anyButtonPressed] whileTrue:[self scrollView:1].				self moveMarker].			(Sensor yellowButtonPressed) ifTrue:[self scrollAbsolute]].	savedCursor show! !!ScrollController methodsFor: 'private'!scrollDown	self canScroll		ifTrue:			[Cursor down show.			self scrollViewDown.			self moveMarker]!scrollUp	self canScroll		ifTrue:			[Cursor up show.			self scrollViewUp.			self moveMarker]! !!ParagraphEditor methodsFor: 'scrolling'!scrollView: anInteger 	| maximumAmount minimumAmount amount |	self deselect.	maximumAmount _ 		paragraph clippingRectangle top - paragraph compositionRectangle top max: 0.	minimumAmount _ 		paragraph clippingRectangle bottom 			- paragraph lineGrid - paragraph compositionRectangle bottom min: 0.	amount _ (anInteger min: maximumAmount) max: minimumAmount.	amount ~= 0 ifTrue: [self scrollBy: amount negated].	self select! !!ParagraphEditor methodsFor: 'marker adjustment'!computeMarkerRegion	paragraph compositionRectangle height = 0		ifTrue:	[^0@0 extent: 13 @ scrollBar inside height]		ifFalse:	[^0@0 extent:					13 @ ((paragraph clippingRectangle height asFloat /							self scrollRectangleHeight * scrollBar inside height) rounded							min: scrollBar inside height)]! !!ParagraphEditor methodsFor: 'accessing'!copySelection: aText	Clipboard clip: (CurrentSelection _ UndoSelection _ LastTyped _ aText)!initialText	^initialText! !Pool named: #TextConstants includes: #Space!Pool named: #TextConstants includes: #CR!!ParagraphEditor methodsFor: 'menu messages'!again	"Text substitution.  If the left shift key is down, the substitution is made 	throughout the entire Paragraph.  Otherwise, only the next possible 	substitution is made."	| many |	many _ sensor leftShiftDown.	self deselect.	self closeTypeIn.	CurrentSelection _ LastTyped.	self select.	many		ifTrue: [[self againOnce] whileTrue]		ifFalse: [self againOnce ifFalse: [self flash]].	self moveMarker!copySelection	"Copy the current selection and store it in the shared buffer."	Clipboard clip: (CurrentSelection _ UndoSelection _ LastTyped _ self selection)!cut	"Cut out the current selection and redisplay the paragraph if necessary."	self deselect.	self sometimesCloseTypeIn.	self replaceSelectionWith: Text new.	self selectAndScroll.	self updateMarker.	Clipboard clip: (CurrentSelection _ LastTyped _ UndoSelection copy)!fileIt	| aText return defaultSuitcase keys center fs | 	self controlTerminate.	aText _ self selection.	aText isEmpty		ifTrue: [aText _ self text]		ifFalse: [(self confirm:'File ONLY the selected text?') ifFalse: [aText _ self text]].	(defaultSuitcase _ view topView suitcase) == nil		ifTrue: [defaultSuitcase _ Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem type: #Item label: 'Item Label' atIndex: 0)].	keys _ ((center _ defaultSuitcase center) == nil				ifTrue: [String new]				ifFalse: [center keywordStringFor: defaultSuitcase dataItem]).	return _ InformationCenter fileNameData: #text defaultSuitcase: defaultSuitcase defaultKeys: keys askMethod: true askClass: true.	(return at: 1) == nil ifFalse:		[Cursor execute showWhile: [		fs _ HeaderFileStream fileNamed: (return at: 1) filename.		fs writeHeaderFor: (return at: 1).		self put: aText in: fs].		InformationCenter putFileNameAway: return].	self controlInitialize!findIt	"ask the info center about the current selection."	| match center suitcase |	self deselect.	self closeTypeIn.	self controlTerminate.	suitcase _ view topView suitcase.	suitcase == nil ifFalse: [center _ suitcase center].	center == nil ifFalse: [match _ center match: self selection asString withLinksFrom: view topView suitcase dataItem].	match == nil ifFalse:		[match isFolder			ifTrue: [ContainerModel					openThisFolder: match					inCenter: center					searchString: nil]			ifFalse: [DataMaster viewSelection: match withSuitcase: (Suitcase new packTheSuitcaseFrom: center forItem: match)]].	InformationCenter lookInInfoCentersFor: self selection asString.	self controlInitialize!findOrReplace	| answers findString |	findString _ self selection string.	answers _ DBoxView				openFor: #(fill select fill )				title: 'Find/Replace'				labels: #((Find: ) (Action: find replace 'replace all' ) ('Replace With:' ) )				defaults: (Array with: findString with: #(find ) with: String new)				commands: #(accept cancel bailOut )				autoAccept: false				links: Array new.	answers == nil ifTrue:[^view flash].	(answers at: 1) = String new ifTrue: [^view flash].	(answers at: 2) = 'replace all'		ifTrue: [[self findOnceAndReplace: (answers at: 1) with: (answers at: 3)] whileTrue]		ifFalse: [self findOnceAndReplace: (answers at: 1) with: 					((answers at: 2) = #find ifTrue: [nil] ifFalse: [answers at: 3])]!fontIt	| aFont s | 	"Change the fonting for the the current selection"	(aFont _ FontMenu answer) == nil		ifTrue: [aFont _ Smalltalk at: #LastUsedFont ifAbsent: [1]].	self deselect.	self closeTypeIn.	aFont > 99		ifTrue: [s _ WriteStream on: String new.				self selection asString do: [:ch | s nextPutAll: (ch asciiValue printStringRadix: 16); space].				self replaceSelectionWith: (Text string: s contents emphasis: 1)]		ifFalse: [self replaceSelectionWith: (Text string: self selection asString emphasis: aFont)].	self selectAndScroll.	self updateMarker.	CurrentSelection _ LastTyped _ self selection.	Smalltalk at: #LastUsedFont put: aFont. "this is disgusting, but.."	^true!hardcopy	"print text as a press file."	(Smalltalk includesKey: #BackgroundPrinter) ifFalse: [^self booboo: 'Printing not installed'].	self controlTerminate.	BackgroundPrinter putText: self text annoDict: nil suitcase: view topView suitcase.	self controlInitialize!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary."	| next type fileName |	type _ Clipboard nextClass.	type == Text		ifTrue: 			[self deselect.			self sometimesCloseTypeIn.			self replaceSelectionWith: Clipboard retrieve.			self selectAndScroll.			self updateMarker.			^true].	((Smalltalk includesKey: #DataItem) and: [type == DataItem])		ifTrue:			[self controlTerminate.			(fileName _ InformationCenter getTextFromTransferBuffer) == nil ifTrue: [self controlTerminate. ^false].			self pasteInfoText: fileName.			self updateMarker.			self controlInitialize.			^true].	^Clipboard booboo!put	"store text on a file."	| aText storeTrailer aFileStream |	self controlTerminate.	aFileStream _ FileStream fileNamed: (FillInTheBlank request: '	Please specify a file name.	' initialAnswer: 'WindowPaneContents.text') asFileName.	Cursor write showWhile:		[		aText _ self text.		aText runs values = #(1)			ifTrue: [storeTrailer _ false]			ifFalse:				[Cursor normal showWhile:					[storeTrailer _ self confirm: 'store formatting?']				].		aFileStream nextPutAll: self text.		storeTrailer ifTrue:			[aFileStream nextPut: (Character value: 255); cr; store: aText runs].		aFileStream close		].	self controlInitialize!stripCarraigeReturns	"replace any single carraige return (unless it's at the end) with a space in the selected text, or if no text is selected, in all the text in the window"	| befText textStream |	self controlTerminate.	((befText _ self selection) size < 1)		ifTrue:	"no selection, select all text"			[(self confirm: 'Selection is empty.  Strip CRs on entire document?') ifFalse: [^self controlInitialize].			self selectFrom: 1 to: paragraph text size.			befText _ self selection].	textStream _ ReadWriteStream on: befText from: 1 to: befText size.	[textStream skipTo: CR] whileTrue:		[(textStream atEnd or: [textStream peekForMore: CR])			ifFalse:	"then was single CR not at end of the selection"				[textStream skip: -1.	"backup to replace"				 textStream nextPut: Space]].	self deselect.	self sometimesCloseTypeIn.	self replaceSelectionWith: textStream contents.	self selectAndScroll.	self updateMarker.	self controlInitialize!timeStamp	"Replace the current text selection with the time stamp and 	make the time stamp the new text selection."	self deselect.	self replaceSelectionWith: Time dateAndTimeNow printString asText.	self select! !!ParagraphEditor methodsFor: 'editing'!cr: characterStream	^self normalCharacter: characterStream!cut: characterStream 	"Cut out the current text selection."	sensor keyboard.	"flush character"	self deselect.	self sometimesCloseTypeIn.	self replaceSelectionWith: Text new.	self selectAndScroll.	self updateMarker.	Clipboard clip: (CurrentSelection _ LastTyped _ UndoSelection copy).	^true!selectCurrentTypeIn: characterStream 	"The user just finished typing in some text and then typed the esc key.  The	typed text becomes the current text selection."	sensor keyboard.		"flush character"	characterStream isEmpty		ifTrue: 			[self deselect]		ifFalse: 			[self replaceSelectionWith: 				(Text string: characterStream contents emphasis: emphasisHere).			startBlock _ stopBlock copy].	self closeTypeIn.	CurrentSelection _ LastTyped.	startBlock = stopBlock 		ifFalse: [stopBlock _ 					paragraph characterBlockForIndex: 						(startBlock stringIndex + CurrentSelection size min: stopBlock stringIndex)].	self select.	^true!tab: characterStream	^self normalCharacter: characterStream! !!ParagraphEditor methodsFor: 'private'!closeTypeIn	beginTypeInBlock == nil		ifFalse: 			[beginTypeInBlock < startBlock				ifTrue: 					[LastTyped _ paragraph text copyFrom: beginTypeInBlock stringIndex to: startBlock stringIndex - 1.					startBlock _ beginTypeInBlock copy].			beginTypeInBlock _ nil.			^true].	^false!findOnceAndReplace: aString with: anotherString	| nextStartIndex |	nextStartIndex _ 		paragraph text findString: aString startingAt: stopBlock stringIndex.	nextStartIndex = 0 ifTrue: [^false].	self deselect.	startBlock _ paragraph characterBlockForIndex: nextStartIndex.	stopBlock _ paragraph characterBlockForIndex: nextStartIndex + aString size.	(anotherString == nil) | (anotherString = aString)		ifFalse: [self replaceSelectionWith: anotherString asText].	self selectAndScroll.	^true!maxCanPaste	"just use a rough number, just want to be sure to be under the true limit"	^63000 - paragraph text size!pasteInfoText: fileName	| aFile size run textSize pos chunk |	self deselect.	self sometimesCloseTypeIn.	aFile _ HeaderFileStream oldFileNamed: fileName.	aFile readOnly.	aFile position: (size _ aFile size) - 1.	aFile next = $)		ifTrue: 			[Cursor wait showWhile: [			aFile position: (size _ aFile size) - 1.			pos _ size - 1.			[pos <= 0 | (aFile next asciiValue = 255)]				whileFalse: 					[pos _ pos - 1.					aFile position: pos].			aFile position: pos + 1].			run _ Compiler evaluate: (aFile next: size - pos - 1).			textSize _  pos]		ifFalse: [textSize _ size].	aFile position: 0.	Cursor wait showWhile: [	[((chunk _ self maxCanPaste) < textSize and: [chunk > 0])]		whileTrue: 			[self replaceSelectionWith: (Text string: (aFile next: chunk) runs: (run copyFrom: aFile position - chunk +1 to: aFile position)).			startBlock _ stopBlock.			textSize _ textSize - chunk].	textSize > chunk ifTrue: [self booboo: 'Sorry, the pasted item is too big.I must leave off the last ', (textSize - chunk) printString, ' characters'].	textSize _ chunk min: textSize. "make sure not to paste too much"	textSize > 0 ifTrue:		[self replaceSelectionWith:  (Text string: (aFile next: textSize) runs: (run copyFrom: aFile position - textSize + 1 to: aFile position))].	aFile close.	Disk removeKey: fileName].	self selectAndScroll!scrollRectangleHeight	^paragraph compositionRectangle height		+ paragraph lineGrid!sometimesCloseTypeIn	(selectionShowing and: [beginTypeInBlock ~~ nil])		ifTrue: 			[beginTypeInBlock < startBlock				ifTrue: 					[LastTyped"CurrentSelection" _ paragraph text copyFrom: beginTypeInBlock stringIndex to: startBlock stringIndex - 1.					startBlock _ beginTypeInBlock copy].			beginTypeInBlock _ nil.			^true].	^false! !BigParagraphEditor comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.I am a sort of ParagraphEditor that edits BigParagraphs.I support a different method of absolute scrolling.  (See scrollAbsolute)'!!BigParagraphEditor methodsFor: 'selecting'!findAndSelect: aString	| index |	index _ paragraph text findString: aString startingAt: stopBlock stringIndex.	index = 0 ifTrue: [^false].	self selectAndScrollFrom: index to: index + aString size.	^true!selectAndScroll	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	lineHeight _ paragraph textStyle lineGrid.	clippingRectangle _ paragraph clippingRectangle.	deltaY _ stopBlock top - clippingRectangle top.	deltaY >= 0 		ifTrue: [deltaY _ stopBlock bottom - clippingRectangle bottom max: 0].						"check if stopIndex below bottom of clippingRectangle"	deltaY ~= 0 		ifTrue: [self selectAndScrollFrom: startBlock stringIndex to: stopBlock stringIndex].	self select!selectAndScrollFrom: start to: stop	self deselect.	startBlock _ paragraph characterBlockForIndex: start.	stopBlock _ paragraph characterBlockForIndex: stop" + 1".	paragraph selectAndScrollFrom: start to: stop.	startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.	stopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.	self select! !!BigParagraphEditor methodsFor: 'scrolling'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor regionPercent |	savedCursor _ sensor currentCursor.	[self scrollBarContainsCursor]		whileTrue: 			[Processor yield.			self changeCursor: Cursor upDown."			Cursor upDown show."			(Sensor redButtonPressed) ifTrue:[self scrollUp.				[Sensor anyButtonPressed] whileTrue:[self scrollView:-1].				self markerRegion: self computeMarkerRegion.				self moveMarker].			(Sensor blueButtonPressed) ifTrue:[self scrollDown.				[Sensor anyButtonPressed] whileTrue:[self scrollView:1].				self markerRegion: self computeMarkerRegion.				self moveMarker].			(Sensor yellowButtonPressed) ifTrue:[self scrollAbsolute]].	savedCursor show!scrollTo: characterIndex		self deselect.		paragraph scrollTo: characterIndex.		startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.		stopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.		self select.		scrollBar display.		self markerRegion: self computeMarkerRegion.		self moveMarker!scrollToTop	"Scroll so that the paragraph is at the top of the view."	(paragraph firstCharacter == nil or: [paragraph firstCharacter = 1])		ifTrue: [self scrollView: 0]		ifFalse: [self scrollView: 1]!scrollView: anInteger	self deselect.	anInteger = 0 ifFalse: [self scrollBy: anInteger negated].	self select.! !!BigParagraphEditor methodsFor: 'marker adjustment'!computeMarkerRegion	"NOTE: This is for modified (three-button) scroll bars !!!!"	paragraph string isEmpty		ifTrue:			[ ^ 0@0 extent: 13@ scrollBar inside height ]		ifFalse:			[^ 0@0  extent:				13 @ ((paragraph charactersShown / paragraph size					* scrollBar inside height) rounded					min: scrollBar inside height) ]!markerDelta	paragraph size = 0		ifFalse:			[^ marker top - scrollBar inside top -			( (paragraph firstCharacter -1) asFloat / paragraph size				* scrollBar inside height ) rounded ]		ifTrue:			[ ^0 ]! !!BigParagraphEditor methodsFor: 'menu messages'!againOnce	| nextStartIndex |	nextStartIndex _ 		paragraph text findString: UndoSelection startingAt: stopBlock stringIndex.	nextStartIndex = 0 ifTrue: [^false].	self deselect.	startBlock _ paragraph characterBlockForIndex: nextStartIndex.	stopBlock _ paragraph characterBlockForIndex: nextStartIndex + UndoSelection size.	CurrentSelection = UndoSelection		ifFalse: [self replaceSelectionWith: CurrentSelection].	self selectAndScrollFrom: nextStartIndex to: stopBlock stringIndex.	^true!inspectUs	"Let the user inspect my BigParagraph."	view superView deEmphasize.	self controlTerminate.	paragraph inspect! !!BigParagraphEditor methodsFor: 'editing'!replaceSelectionWith: aText	SmalltalkSignal		do: [super replaceSelectionWith: aText]		handle: [(SmalltalkSignal clue) == #textTooLong					ifTrue:						[self booboo: 'Sorry, too much text for one window'.						paragraph clearVisibleRectangle.						paragraph numberOfLines = 0 ifFalse:							[paragraph displayLines: (1 to: (paragraph numberOfLines min: paragraph linesInWindow))].						Sensor flushKeyboard]					ifFalse: [SmalltalkSignal noHandler].				SmalltalkSignal handleReturn: false].! !!BigParagraphEditor methodsFor: 'private'!scrollAbsolute	| ypos sz oldMarker |	sz _ paragraph string size.	sz = 0 ifTrue: [^view flash].	self changeCursor: Cursor marker.	self canScroll & sensor anyButtonPressed ifTrue:		[[sensor anyButtonPressed] whileTrue:			[oldMarker _ marker.			marker _ marker translateBy:				0@(((ypos _ sensor cursorPoint y) - marker center y min:					scrollBar inside bottom - marker bottom) max: scrollBar inside top - marker top).			(oldMarker areasOutside: marker), (marker areasOutside: oldMarker) do:				[:region |				Display fill: region rule: Form reverse mask: marker insideColor]].		marker height = scrollBar inside height			ifTrue: [Display fill: marker rule: Form reverse mask: marker insideColor.					Display fill: marker rule: Form reverse mask: marker insideColor]			ifFalse: [marker top = scrollBar inside top						ifTrue: [self scrollTo: 1]						ifFalse: [marker bottom = scrollBar inside bottom									ifTrue: ["so that end of text will be in the window .."											self scrollTo: sz - (paragraph charactersShown //2)]									ifFalse: [self scrollTo: (((((marker top min: scrollBar inside bottom) - scrollBar inside top) /scrollBar inside height * sz) rounded max: 1) min: sz)]]]]! !BigTextController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.This subclass of the BigParagraphEditor uses actionMenus for model control protocol.It also makes a stab (localMenuItem:) at the problem of distinguishing user controldirected at the model from that directed at the view/controller.This controller is more tightly connected to its view (for example it asks it for itsyellowButtonMenu), because the view is the current site for "pluggable" parameterization.'!!BigTextController methodsFor: 'menu messages'!accept	(self textHasChanged and: [model changeRequestFrom: view])		ifFalse: [^view flash].	self controlTerminate.	(view accept: self text from: self)		ifTrue: [super accept.			 locked _ false]		ifFalse: [view flash].	self controlInitialize!localMenuItem: selector	^ #(cut paste copySelection again undo cancel accept hardcopy) includes: selector! !!BigTextController methodsFor: 'editing'!insertAndSelect: aString at: anInteger 	self selectAt: anInteger. 	self deselect.	self replaceSelectionWith: (' ' , aString) asText.	self selectAndScroll!replaceSelectionWith: aText	super replaceSelectionWith: aText.	locked _ true! !!BigTextController methodsFor: 'accessing'!paragraph	^ paragraph!resetState	super resetState.	locked _ false!textHasChanged	^ locked" = true"! !!BigTextController methodsFor: 'control activity'!yellowButtonActivity	| index menu selector |	menu _ view yellowButtonMenu.	menu == nil		ifTrue:			[view flash.			super controlActivity]		ifFalse: 			[index _ menu startUpYellowButton.			index ~= 0 				ifTrue:					[selector _ menu selectorAt: index.  "editing to self, rest to model"					(self localMenuItem: selector)						ifTrue: [self perform: selector]						ifFalse: [self controlTerminate.								selector numArgs = 2									ifTrue: [model perform: selector with: self text with: self]									ifFalse: [model perform: selector].								self controlInitialize]]]! !!BigTextController methodsFor: 'composition'!wrappingBox: wrapRectangle clippingBox: clipRectangle	paragraph recomposeIn: wrapRectangle clippingBox: clipRectangle.	self selectFrom: startBlock stringIndex to: stopBlock stringIndex-1! !BigCodeController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.This controller adds some capability appropriate only to viewing Smalltalk code,such as ''explain'' and ''format''.'!!BigCodeController methodsFor: 'menu messages'!doIt	"Evaluate the current text selection as an expression"	| result selectionStart oldTextSize selection |	self controlTerminate.	selectionStart _ startBlock stringIndex.	oldTextSize _ self text size.	selection _ self selection.	result _ 		model doItReceiver class evaluatorClass new				evaluate: self selectionAsStream				in: model doItContext				to: model doItReceiver				notifying: self				ifFail: 					[self controlInitialize.					^#failedDoit].	self selection asString = selection asString ifFalse:		[self selectFrom: selectionStart  "Reselect doIt range after compiler interaction"			to: selectionStart + selection size - 1 + (self text size - oldTextSize)].	Smalltalk logChange: self selection string.	model doItValue: result.	self controlInitialize.	^result!explain	"Try to shed some light on what kind of entity the current selection is.    	The selection must be a single token or construct.  Insert the answer   	after the selection.  Call private routines whose names begin with   	'explain'.  They return a String if they recognise the selection, else nil."	| reply |	reply _ (Explainer new		class: model selectedClass		selector: model selector		instance: model doItReceiver		context: model doItContext		methodText: model text) explain: self selection string for: model.	reply size = 0 ifTrue:		[reply _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.' ,			(model isUnlocked ifTrue: ['"'] ifFalse: ['  Also, please cancel or accept."']).].	self insertAndSelect: reply at: stopBlock stringIndex!format	"Reformat the contents of the receiver's view, formatted, if the view is unlocked."	| selectedClass aCompiler newText |	Sensor leftShiftDown ifTrue: [^self miniFormat].	self textHasChanged		ifTrue: [view flash. ^self].	selectedClass _ model selectedClass.	self controlTerminate.	Cursor execute showWhile:		[aCompiler _ selectedClass compilerClass new.		self selectFrom: 1 to: paragraph text size.		self deselect.		newText _ 			aCompiler				format: model text				in: selectedClass				notifying: self.		newText == nil ifFalse: 			[self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1]].	self controlInitialize!localMenuItem: selector	^ (#(doIt printIt format explain) includes: selector) or:		[super localMenuItem: selector]!miniFormat	"Replace selection with selection un-wrapped."	| inStream outStream char |	inStream _ ReadStream on: (self selection copyWithout: Character tab).	outStream _ WriteStream on: (String new: self selection size).	[inStream atEnd]		whileFalse: 			[char _ inStream next.			char isSeparator				ifTrue: 					[outStream space.					[inStream atEnd not and: [inStream peek isSeparator]]						whileTrue: [inStream next]]				ifFalse: [outStream nextPut: char]].	self deselect.	self replaceSelectionWith: outStream contents asText.	self select!printIt	"Evaluate the current selection as an expression.  If successful, insert and	select the printString of the result of evaluation after the current selection."	| result |	result _ self doIt.	result ~~ #failedDoit		ifTrue: [self insertAndSelect: result printString at: stopBlock stringIndex]! !BigAlwaysAcceptCodeController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!BigAlwaysAcceptCodeController methodsFor: 'menu messages'!accept	(model changeRequestFrom: view)		ifFalse: [^view flash].	self controlTerminate.	(view accept: self text from: self)		ifTrue: [initialText _ paragraph text copy.				locked _ false]		ifFalse: [view flash].	self controlInitialize! !BigOnlyWhenSelectedCodeController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!BigOnlyWhenSelectedCodeController methodsFor: 'control defaults'!isControlWanted	view isSelected		ifFalse:			[sensor yellowButtonPressed ifTrue: [view flash].			self deselect.			^false].	^ self viewHasCursor! !XDEInterfaceController comment:'Copyright (c) 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!XDEInterfaceController methodsFor: 'private'!appendPartialText: aText	self selectWithoutComp: paragraph text size + 1.	self replaceSelectionWith: aText.	self selectWithoutComp: paragraph text size + 1.	self selectAndScroll!appendText: aText	paragraph text size > 2000		ifTrue: [paragraph removeFirstChars: paragraph text size - 1000].	self appendPartialText: aText!selectWithoutComp: charIndex	startBlock _ paragraph characterBlockForIndex: charIndex.	stopBlock _ startBlock copy! !!XDEInterfaceController methodsFor: 'control activity'!controlActivity	| pt | 	pt _ sensor cursorPoint.	self scrollBarContainsCursor		ifTrue: [self scroll]		ifFalse: [self processKeyboard.				sensor redButtonPressed ifTrue: [^self processRedButton].				sensor yellowButtonPressed ifTrue: [^self processYellowButton].				sensor blueButtonPressed ifTrue: [^self processBlueButton].				DisplayCritical signal.				[pt = sensor cursorPoint and: [sensor buttons = 0]]				whileTrue: [Disk includesKey: 'dummy'.							(Delay forMilliseconds: 700) wait].				DisplayCritical wait].!controlInitialize 	super controlInitialize.	model locked ifTrue: [Cursor mouse show]!isControlActive	^(model locked ifTrue: [true] ifFalse: [super isControlActive])! !BigStringHolderController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.I represent a BigParagraphEditor for a single paragraph of text, omitting alignment commands.  I provide items in the yellow button menu so that the text selection can be evaluated and so that the contents of the model can be stored or restored.	doIt -- evaluate the text selection as an expression	printIt -- same as doIt but insert a description of the result after the selection	accept -- store the contents of the StringHolder into the model	cancel -- store the contents of the model into the StringHolderInstance Variables:	isLockingOn	<Boolean> true if the view has been editted so that it should not					be closed without warning the user. '!!BigStringHolderController methodsFor: 'initialize-release'!initialize	super initialize.	isLockingOn _ true.	self initializeYellowButtonMenu! !!BigStringHolderController methodsFor: 'lock access'!isLockingOff	"Answer whether no unsaved modifications have been carried out using	the receiver."	^isLockingOn not!isLockingOn	"Answer whether unsaved modifications have been carried out using the receiver."	^isLockingOn!lockModel	"If the receiver is lock, do so to the receiver's model."	isLockingOn ifTrue: [model lock]!turnLockingOff	"Turn off the receiver's indication that it is locked."	isLockingOn _ false!turnLockingOn	"Turn on the receiver's indication that it is locked."	isLockingOn _ true!unlockModel	"If the receiver is locked, then the model probably is, but should not be, so	unlock the model."	isLockingOn ifTrue: [model unlock]! !!BigStringHolderController methodsFor: 'menu messages'!accept	super accept.	model contents: paragraph string.	self unlockModel!cancel	super cancel.	self unlockModel!doIt	"Treat the current text selection as an expression; evaluate it"	| result |	self controlTerminate.	result _ 		model doItReceiver class evaluatorClass new				evaluate: self selectionAsStream				in: model doItContext				to: model doItReceiver				notifying: self				ifFail: 					[self controlInitialize.					^#failedDoit].	Smalltalk logChange: self selection string.	self controlInitialize.	^result!fontIt	super fontIt		ifTrue: [model lock]!printIt	"Treat the current text selection as an expression;  evaluate it.  Insert	the description of the result of evaluation after the selection and then make this	description the new text selection."	| result |	result _ self doIt.	result ~~ #failedDoit		ifTrue: [self afterSelectionInsertAndSelect: result printString]! !!BigStringHolderController methodsFor: 'model access'!model: aModel	super model: aModel.	view displayContents == nil		ifFalse: [self changeParagraph: view displayContents]! !!BigStringHolderController methodsFor: 'editing'!insertAndSelect: aString at: anInteger 	self selectAt: anInteger. 	self deselect.	self replaceSelectionWith: (' ' , aString) asText.	self selectAndScroll!replaceSelectionWith: aText	super replaceSelectionWith: aText.	model lock! !!BigStringHolderController methodsFor: 'private'!afterSelectionInsertAndSelect: aString 	self insertAndSelect: aString at: stopBlock stringIndex!initializeYellowButtonMenu	self yellowButtonMenu: CodeYellowButtonMenu 		yellowButtonMessages: TreeMenu!put: text in: thisFileStream	Cursor write showWhile:	[thisFileStream		writeShorten;		reset;		nextPutAll: text string.	text runs values = #(1) ifFalse:		[thisFileStream			nextPut: (Character value: 255);			nextPut: (Character  cr);			store: text runs]].	thisFileStream close! !RS232Controller comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!RS232Controller methodsFor: 'As yet unclassified'!appendNext	| num |	self controlTerminate.	[(num _ FillInTheBlank request: 'Append how many?') asString isNumeric] whileFalse: [self booboo: 'Please type a number'].	model appendTextPages: num asNumber asInteger.	self controlInitialize!breakKey	model serialPort sendBreak!browseTextPage: aChar	"get the page requested according to aChar,		where: aChar =			$l gives lastPage, $f gives firstPage, $n gives nextPage,			$p gives previous page, $r gives current page again"	self controlTerminate.	model browseTextPage: aChar.	self controlInitialize!clearBuffer	model userClearMemory.	self browseTextPage: $r!controlActivity 	model receivingRS232		ifTrue: [model checkRS232Input].	model transmitState		ifFalse: [super controlActivity]!controlInitialize 	self initializeYellowButtonMenu.	(model browseState)		ifTrue: [super controlInitialize]!endBrowse	self deselect.	Display white: view insetDisplayBox.	model checkWindowLocation; rs232ToTransmitState!getPage	| firstPage lastPage switch |	(firstPage _ FirstPagesMenu answer) = nil		ifFalse:			[(lastPage _ PagesMenu answer) = nil				ifTrue: [lastPage _ firstPage]. "just get one page"			 firstPage > lastPage ifTrue: [switch _ firstPage. firstPage _ lastPage. lastPage _ switch].			 self controlTerminate.			 model getTextPages: firstPage to: lastPage.			 self controlInitialize]!includePrev	| num |	self controlTerminate.	[(num _ FillInTheBlank request: 'Add how many?') asString isNumeric] whileFalse: [self booboo: 'Please type a number'].	model insertTextPages: num asNumber asInteger.	self controlInitialize!initializeYellowButtonMenu	self yellowButtonMenu: RS232YellowButtonMenu 		yellowButtonMessages: TreeMenu!isControlActive	(RS232Collector receivingRS232)		ifTrue: [^true]		ifFalse:			[(model browseState)				ifTrue: [^super isControlActive]					ifFalse: [^false]]!nextPage	self browseTextPage: $n!prevPage	self browseTextPage: $p!putText: theText inFile: aFileName	"put text in aFileName and store any formatting"	| fileStream |	(fileStream _ FileStream fileNamed: aFileName)		writeShorten;		nextPutAll: theText string.	theText runs values = #(1) ifFalse:		[fileStream			nextPut: (Character value: 255);			nextPut: Character  cr;			store: theText runs].	fileStream close!scrollToEnd	"scroll to end of text display"	self selectAt: paragraph text size + 1.	self deselect!setEmphasisHere	emphasisHere _ RS232Collector defaultFont!updateText 	"The paragraph to be edited is changed to contents of model, but is not displayed"	paragraph text: model contents.	self resetState! !ComposeTextController comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation.  All rights reserved.'!!ComposeTextController methodsFor: 'initialize-release'!initializeYellowButtonMenu	self 		yellowButtonMenu: ComposeYellowButtonMenu		yellowButtonMessages: TreeMenu! !!ComposeTextController methodsFor: 'menu messages'!addKeyWord	"Copy the current selection and add it as a KeyWord to this item."	self controlTerminate.	view topView suitcase addKeyWord: self selection.	self controlInitialize.!annotateCreate	"Cut out the current selection and turn it into a annotation."	|theKey|	self deselect.	self closeTypeIn.	theKey _ model annotateCreate: (self selection) .	super replaceSelectionWith: (Text string: theKey string emphasis:(TextStyle getNumForStrikeFont: 'Helvetica7')).	self selectAndScroll.	self updateMarker.	CurrentSelection _ UndoSelection copy!annotateDisplay	"Open up an annotation editor which initially contains the 	content of the selected annotation"	| annotation annoCode |	annoCode _ self selection asString.	annotation _ model annotateDisplay: annoCode.	model validAnno		ifTrue: 			[view topView deEmphasizeLabel.			self deselect.			self controlTerminate.			AnnotationController new				openLabeled: view superView label, ' ' , annoCode				annoCode: annoCode				bossModel: model 				text: annotation				suitcase: view topView suitcase.			self controlInitialize.			view topView emphasizeLabel.]!annotateExpand	"Return the selected annotation"|annotation|	self deselect.	self closeTypeIn.	annotation _ (model annotateDisplay: ((self selection) asString)).	annotation = (self selection)	ifFalse:[super replaceSelectionWith: annotation].	self selectAndScroll.	self updateMarker.!copySelection	"Copy the current selection and store it in the shared buffer."	super copySelection.	Clipboard last propertyAt: #classification put: view topView suitcase classification.	Clipboard last propertyAt: #passDict put: (model findAnyAnnos: self selection).!cut	"Cut out the current selection and find any annotations in the selection"	super cut.	Clipboard last propertyAt: #classification put: view topView suitcase classification.	Clipboard last propertyAt: #passDict put: (model findAnyAnnos: CurrentSelection).!erase	| classification | 	"Replace file contents with a empty text."	(self confirm:'This will erase all the text from the file. Are you sure?')		ifFalse:[^self].	self controlTerminate.	self deselect.	self closeTypeIn.	classification _ Classification array: (Array with: nil).	view topView suitcase classification: classification.	view topView suitcase accept.	model put: Text new dataItem: view topView suitcase dataItem.	self unlockModel.	self get.	view superView displayEmphasized.	view topView classifyLabel: classification.	view topView displayClassification!fileIt	| aText | 	self controlTerminate.	aText _ self selection.	aText isEmpty		ifTrue: [aText _ self text]		ifFalse: [(self confirm:'File ONLY the selected text')ifFalse:[aText _ self text]].	self file: aText updateSuitcase: false.	self controlInitialize!get	"Get contents of file again, it may have changed."	self controlTerminate.	"it get reintialized by cancel"	view superView controller closeDependentViews.	Cursor read showWhile: 		[initialText _ model getNewContents asText.		UndoSelection _ paragraph text.		self changeParagraph: (paragraph text: initialText).		paragraph displayOn: Display.		self scrollToTop.		self unlockModel].	view topView cancel.	self controlInitialize!hardcopyText	"print text as a press file."	| direct |	direct _ AnnotationModel hardcopyDirect.	direct == nil ifTrue: [^nil].	(direct at: 1) == #Direct		ifTrue: [	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^nil].				BackgroundPrinter					putText: self text					annoDict: (model findAnyAnnos: self text)					suitcase: view topView suitcase]		ifFalse: 			[self controlTerminate.			self class				previewText: paragraph text				annoDict: model annoDictionary				withStartSuitcase: view topView suitcase				portrait: ((direct at: 2) == #Portrait).			self controlInitialize]!makeTable	"Take the selected text and make a table from it. Put it in the copy buffer"	| result | 	(Smalltalk includesKey: #Tables) ifFalse: [^self booboo: 'The table generation tool is not installed'].	(result _ Tables format: self selection update: view topView suitcase) == nil ifTrue: [^self].	CurrentSelection _ result.	Clipboard clip: CurrentSelection.	Clipboard last propertyAt: #classification put: view topView suitcase classification.	Clipboard last propertyAt: #passDict put: (model findAnyAnnos: CurrentSelection)!paste	"Paste the text from the shared buffer over the current selection and 	redisplay  	if necessary."	| type entry fileName stuff maxClass |	(entry _ Clipboard next) == nil ifTrue: [^Clipboard booboo].	type _ entry contents class.	(type == Text or: [type == OrderedCollection])		ifTrue: 			[self deselect.			maxClass _ entry propertyAt: #classification.			type == OrderedCollection				ifTrue: [maxClass = nil							ifTrue: [maxClass _ self maxClassification]							ifFalse: [maxClass _ maxClass + self maxClassification]].			view topView changeClassification: maxClass.			self sometimesCloseTypeIn.			stuff _ type == Text				ifTrue: [entry contents]				ifFalse: [self convertDocumentText].			Clipboard retrieveEntry.			CurrentSelection _ model paste: stuff theDict: (entry propertyAt: #passDict).			self replaceSelectionWith: stuff.			self selectAndScroll]		ifFalse:			[self controlTerminate.			(fileName _ InformationCenter getTextFromTransferBuffer) == nil ifTrue: [self controlTerminate. ^false].			view topView changeClassification: entry contents.			self pasteInfoText: fileName.			self controlInitialize].	self updateMarker.	^true!put	"Replace file contents with contents of view."	| suitcase |	self controlTerminate.	Cursor write		showWhile: 			[suitcase _ view topView suitcase.			(suitcase dataItem centerIndex = 0 and: [(suitcase dataItem filename findString: '.notepad' startingAt: 1) = 0])				ifTrue: [self file: paragraph text updateSuitcase: true]				ifFalse: [view topView accept.						model put: paragraph text dataItem: suitcase dataItem.						self unlockModel]].	self controlInitialize! !!ComposeTextController methodsFor: 'private'!file: aText updateSuitcase: update	| return defaultSuitcase keys center | 	defaultSuitcase _ view topView suitcase.	keys _ ((center _ defaultSuitcase center) == nil				ifTrue: [String new]				ifFalse: [center keywordStringFor: defaultSuitcase dataItem]).	return _ InformationCenter fileNameData: #text defaultSuitcase: defaultSuitcase defaultKeys: keys askMethod: true askClass: true.	(return at: 1) == nil		ifFalse:			[Cursor execute showWhile: [model put: aText dataItem: (return at: 1) in: (HeaderFileStream fileNamed: (return at: 1) filename)].			update ifTrue:				[defaultSuitcase dataItem filename = (return at: 1) filename ifFalse:					[model changeFileStreamTo: (HeaderFileStream fileNamed: (return at: 1) filename) readOnly close.					Disk removeKey: defaultSuitcase dataItem filename ifAbsent: []].				defaultSuitcase packTheSuitcaseFrom: ((return at: 4) at: 1) forItem: (return at: 1).				view topView erase.				view topView label: (return at: 1) label.				view topView classifyLabel: defaultSuitcase classification.				view topView display.				self unlockModel].			InformationCenter putFileNameAway: return]!isControlActive	(sensor anyButtonPressed not)		ifTrue:[^true]		ifFalse:[^super isControlActive &  sensor blueButtonPressed not]!processRedButton	(self viewHasCursor | self scrollBarContainsCursor) ifFalse:[self deselect. ^self].	super processRedButton!processYellowButton	"User pressed the yellow button on the mouse.  Determine what actions to take."	(self viewHasCursor | self scrollBarContainsCursor) ifFalse:[ self deselect. ^self].	super processYellowButton! !AnnotationController comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986.  All rights reserved.'!!AnnotationController methodsFor: 'initialize-release'!initializeYellowButtonMenu	self 		yellowButtonMenu: AnnotationYellowButtonMenu		yellowButtonMessages: TreeMenu! !!AnnotationController methodsFor: 'instance creation'!openLabeled: annoLabel annoCode: annoCode bossModel: aBossModel text: aText suitcase: aSuitcase	"Create annotation editor for annoCode and start-up an instance of myself."	| editorView topView |	editorView _ StringHolderView new.	editorView 		model:((AnnotationModel new) contents: aText; annoDictionary: aBossModel annoDictionary; nextAnno: 100; bossModel: aBossModel; currentAnno: annoCode);		controller: AnnotationController new;		insideColor: Form white;		borderWidth: 2.	topView _ StandardSystemView new	topView 		model: editorView model;		controller: ComposeSystemController new;		label: annoLabel;		minimumSize: 250@100;		addSubView: editorView.	topView classifyLabel: aSuitcase classification.	topView addDependent: aSuitcase.	aBossModel dependentAnnoViews add: topView.	Cursor normal show.	topView controller open! !EditStringHolderController comment:'Copyright (c) 1987 Xerox Corporation. All rights reserved.'!!EditStringHolderController methodsFor: 'menu messages'!accept	super accept.	self controlTerminate.	model evaluateAcceptBlock.	self controlInitialize! !StructureController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!StructureController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: StructureYellowButtonMenu		yellowButtonMessages: StructureYellowButtonMessages! !!StructureController methodsFor: 'menu messages'!displaySelected	| keyEnd | 	keyEnd _ paragraph text findString: (String with: CR) startingAt: startBlock stringIndex.	self selectFrom: startBlock stringIndex to: keyEnd-1!findSelection	"ask the model to fetch this selection"	| crs theString |	crs_1.	theString _ paragraph text asString.	1 to: startBlock stringIndex do: [:each | ((theString at: each) = CR)		ifTrue: [crs _ crs + 1]].	^indexCollection at: crs!getSelection	"ask the model to fetch this selection"	self controlTerminate.	model viewSelection: (model center fileCabinet at: self findSelection)!getSelectionHardcopy	self controlTerminate.	model hardcopySelection: (model center fileCabinet at: self findSelection)!processRedButton	"ask the model to fetch this selection[Sensor redButtonPressed] whileTrue: ["	| realStart theKey keyEnd tabCount tempStart tempStop|	[Sensor redButtonPressed] whileTrue: [	tempStart  _ paragraph characterBlockAtPoint: Sensor cursorPoint.	realStart _ tempStart stringIndex - 1.	[realStart > 0 and: [(paragraph text at: realStart) ~= Tab]]		whileTrue: [realStart _ realStart - 1].	realStart _ realStart + 1.	keyEnd _ paragraph text findString: (String with: CR) startingAt: realStart.	(realStart = oldStart) 		ifFalse:[self deselect.		startBlock _ stopBlock _ paragraph characterBlockAtPoint: Sensor cursorPoint.		oldStart _ realStart.		self selectFrom: realStart to: keyEnd-1]]! !!StructureController methodsFor: 'access'!indexCollection	^indexCollection!indexCollection: aCollection	indexCollection _ aCollection! !ClassifiedStringHolderController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ClassifiedStringHolderController methodsFor: 'menu messages'!accept	super accept.	view topView accept!cancel	super cancel.	view topView cancel!copySelection	super copySelection.	Clipboard last propertyAt: #classification put: view topView suitcase classification!cut	super cut.	Clipboard last propertyAt: #classification put: view topView suitcase classification!initializeYellowButtonMenu	self yellowButtonMenu: UserYellowButtonMenu 		yellowButtonMessages: TreeMenu!paste	| entry type fileName | 	(entry _ Clipboard next) == nil ifTrue: [^Clipboard booboo].	type _ entry contents class.	type == Text		ifTrue: 			[super paste.			view topView changeClassification: (entry propertyAt: #classification)]		ifFalse:			[self controlTerminate.			(fileName _ InformationCenter getTextFromTransferBuffer) == nil ifTrue: [self controlTerminate. ^false].			view topView changeClassification: entry contents.			self pasteInfoText: fileName.			self updateMarker.			self controlInitialize].	^true! !OutlineEditController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!OutlineEditController methodsFor: 'menu messages'!accept	self controlTerminate.	super accept.	theOutline listIndex = 0		ifTrue: [view flash]		ifFalse:			[theOutline updateText: paragraph text.			theOutline thisDataItem = workingClass				ifFalse: [theOutline reClassify: (Array with: workingClass classification with: workingClass modifiers).						theOutline changed: #changeClassification]].	self controlInitialize!againOnceStartingAt: startIndex	| nextStartIndex |	nextStartIndex _ 		paragraph text findString: UndoSelection startingAt: startIndex.	nextStartIndex = 0 ifTrue: [^false].	self deselect.	startBlock _ paragraph characterBlockForIndex: nextStartIndex.	stopBlock _ paragraph characterBlockForIndex: nextStartIndex + UndoSelection size.	CurrentSelection = UndoSelection		ifFalse: [self replaceSelectionWith: CurrentSelection].	self selectAndScroll.	^true!cancel	super cancel.	theOutline thisDataItem = workingClass		ifFalse: [self controlTerminate.				workingClass _ theOutline thisDataItem.				theOutline changed: (Array with: #rename: with: (Array with: (theOutline fullNameOf: workingClass))).				self controlInitialize]!copySelection	super copySelection.	Clipboard last propertyAt: #classification put: theOutline thisDataItem!cut	super cut.	Clipboard last propertyAt: #classification put: theOutline thisDataItem!find	| start | 	self copySelection.	start _ stopBlock stringIndex.	(self againOnceStartingAt: start)		ifFalse: [((self againOnceStartingAt: 1) and: [stopBlock stringIndex ~= start]) ifFalse: [self flash]]!paste	| checkClass newLabel class next entry entryClass type fileName |	(entry _ Clipboard next) == nil ifTrue: [^Clipboard booboo].	type _ entry contents class.	(type == Text or: [type == OrderedCollection])		ifTrue:			[entryClass _ entry propertyAt: #classification.			type == OrderedCollection				ifTrue: [entryClass == nil						ifTrue: [entryClass _ self maxClassification]						ifFalse: [entryClass _ entryClass + self maxClassification]].			super paste]		ifFalse:			[self controlTerminate.			(fileName _ InformationCenter getTextFromTransferBuffer) == nil				ifTrue: [^self controlInitialize]				ifFalse: [self pasteInfoText: fileName.						entryClass _ entry contents].			self controlInitialize].	(workingClass == nil or: [entryClass == nil or: [entryClass = workingClass]]) ifFalse:		[checkClass _ entryClass + workingClass.		 checkClass = workingClass ifFalse:				[self controlTerminate.				workingClass _ checkClass.				newLabel _ theOutline thisLabel.				class _ workingClass classAndWords.				(class == nil or: [class isEmpty]) ifFalse: [newLabel _ newLabel, (String with: ${), class, (String with: $})].				theOutline changed: (Array with: #rename: with: (Array with: newLabel)).				theOutline hasChanged: true.				self controlInitialize]]!spawn	| aStringHolderView topView dataItem newSuitcase | 	aStringHolderView _ StringHolderView container: model deepCopy.	aStringHolderView controller: ClassifiedStringHolderController new.	(dataItem _ DataItem type: (DataItem typeIndexFor: #Item) label: theOutline thisLabel atIndex: 0) class: workingClass classification modifiers: workingClass modifiers.	newSuitcase _ Suitcase new packTheSuitcaseFrom: view topView suitcase centerName forItem: dataItem.	topView _ StandardSystemView new.	topView		borderWidth: 1;		label: theOutline thisLabel;		model: aStringHolderView model;		insideColor: Form white;		addSubView: aStringHolderView;		minimumSize: 200@150.	topView classifyLabel: newSuitcase classification.	topView addDependent: newSuitcase.	topView controller open! !!OutlineEditController methodsFor: 'initialize-release'!initializeYellowButtonMenu	self yellowButtonMenu: OutYellowButtonMenu 		yellowButtonMessages: TreeMenu!theOutline: aOutlineList	theOutline _ aOutlineList.	workingClass _ theOutline thisDataItem.	theOutline isUserGuide		ifTrue: [self yellowButtonMenu: UGYellowButtonMenu yellowButtonMessages: TreeMenu]!workingClass	^workingClass!workingClass: aMemberOfClassification	workingClass _ aMemberOfClassification! !PreviewPageController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.PreviewPageController is the controller for the preview page.Instance Variable========[savedForm ]		due to lengthy display routines, we have created savedForm which is the form of the preview page from the screen; therefore, when you controlInitialize it will simply display savedForm instead of the regular display routine.  savedFrom is updated every time when the program do a controlTerminate. Class Variable======[PreviewYellowButtonNormalMenu] 		this button menu appears only when none of the  rectangles is selected to avoid irrelevent menus.[PreviewYellowButtonSelectedMenu]		this button menu will be used when a rectangle is selected.  Mostly it will be concerned about the operations on rectangles and pictures.'!!PreviewPageController methodsFor: 'marker adjustment'!computeMarkerRegion	^0 @ 0 extent: 13 @ (paragraph computeMarkerRegion: scrollBar inside height)!displayPageMarker	"this figures out the page marker lines in the scroll bar"	| y x markerHeight |	markerHeight _ marker region height.	y _ scrollBar inside top asFloat.	x _ scrollBar inside left.	scrollBar displayOn: Display.	2 to: paragraph findLastGraphicPage"lastPage" + 1 do: 		[:each | 		y _ y + markerHeight.		(each - 1 rem: 5) = 0			ifTrue: [Display black: (x @ (y - 2) rounded extent: 13 @ 4)]			ifFalse: [Display black: (x @ y rounded extent: 13 @ 1)]].	Display veryLightGray: (x @ (y + 2) corner: scrollBar inside bottomRight)!markerDelta	^(paragraph firstCharacter == nil "or: [paragraph totalText = 0]")		ifTrue: [1]		ifFalse: [marker top - scrollBar inside top - (paragraph pageNumber - 1 * marker region height)]!updateAndMoveMarker	"A variation of moveMarker--only redisplay the marker in the scrollbar	if an actual change has occurred in the positioning of the page."	| newMarkerRegion |	newMarkerRegion _ self computeMarkerRegion.	newMarkerRegion extent = marker region extent		ifFalse: 			[self markerRegion: newMarkerRegion.			self displayPageMarker.			self moveMarker]!updateMarker! !!PreviewPageController methodsFor: 'menu messages'!addKeyWord	"Copy the current selection and add it as a KeyWord to this item."	self controlTerminate.	view topView suitcase addKeyWord: self selection.	self controlInitialize!again	"Text substitution.  If the left shift key is down, the substitution is made 	throughout the entire Paragraph.  Otherwise, only the next possible 	substitution is made."	| many |	many _ sensor leftShiftDown.	self deselect.	self closeTypeIn.	CurrentSelection _ LastTyped.	self select.	many		ifTrue: [[self againOnce] whileTrue]		ifFalse: [self againOnce ifFalse: [self flash]].!composeEndPages	self backup.	paragraph composeEndPages!copySelection	super copySelection.	Clipboard last propertyAt: #classification put: model classification!cut	super cut.	Clipboard last propertyAt: #classification put: model classification!displayTabs	| falseOrPageNumber selection | 	((selection _ self getLastSelectionIn: yellowButtonMenu) isKindOf: Character) ifFalse: [selection _ $A].	falseOrPageNumber _ paragraph displayTabsFrom: startBlock stringIndex to: (stopBlock stringIndex - 1 max: startBlock stringIndex) edit: (selection = $E).	falseOrPageNumber == false		ifFalse: [self backup.				(paragraph composePageNumbered: falseOrPageNumber)					ifTrue: [self resetState]]!fileText	| return aFile textSize count numFiles dataItem diskFile runs keys |	(lock ~= #no and: [self confirm: 'Contents have not been saved!!Select YES to file away current text, or NO for saved text.'])		ifTrue: [self backup].	keys _ model center == nil ifTrue: [String new] ifFalse: [model center keywordStringFor: model dataItem].	return _ InformationCenter fileNameData: #text defaultSuitcase: model defaultKeys: keys askMethod: true askClass: false.	(return == nil or: [(return at: 1) == nil]) ifTrue: [^false].	Cursor wait showWhile: 		[textSize _ paragraph textSize.		64512 >= textSize			ifTrue: [numFiles _ 1]			ifFalse: [numFiles _ textSize asFloat // 50176.1 + 1.					self booboo: 'Too much text for one file, it will be split\automatically into multiple files and auto-filed' withCRs.					return at: 3 put: #auto].		(diskFile _ paragraph diskFile) reset.		runs _ paragraph runs.		count _ 0.		dataItem _ return at: 1.		[numFiles > 0] whileTrue: 			[aFile _ (HeaderFileStream fileNamed: dataItem filename) writeShorten.			aFile writeHeaderFor: dataItem.			ComposeTextController putText: (Text string: (diskFile next: (50176 min: textSize - count)) runs: (runs copyFrom: count + 1 to: diskFile position)) inStream: aFile usingAnnoDict: nil.			aFile close.			InformationCenter putFileNameAway: return.			(numFiles _ numFiles - 1) > 0 ifTrue:				[dataItem label: dataItem label, (String with: $x).				dataItem filename: (Disk makeNewFileName: dataItem label withSuffix: (DataMaster giveMe: #suffixString for: dataItem filename)).				count _ 50176 + count]]].!getScreenPicture	| picture fileName |	picture _ Form fromUser.	fileName _ Disk makeNewFileName: ('ScreenInto', model dataItem label) withSuffix: (DataMaster giveMe: #suffixString for: #image asString).	picture writeOn: fileName.	^paragraph handlePicture: picture withFileNamed: fileName!gotoNextPage	(self gotoNextPage: false)		ifTrue: [self resetState]!gotoPreviousPage	self previousPage		ifTrue: [self resetState]!gotoRandomPage	| page labels lastPage menu | 	labels _ String new.	lastPage _ paragraph lastPage.	1 to: lastPage - 1 do:		[:each | labels _ labels, each printString, (String with: Character cr)].	labels _ labels, lastPage printString.	(menu _ ScrollMenu new: 5 on: labels) startUp: #anyButton.	(page _ menu answer) == nil ifFalse:		[self backup.		(paragraph scrollToPage: page)			ifTrue: [self resetState]]!hardcopy	self backup.	paragraph hardcopy!justifyIt	| selection | 	(selection _ self getLastSelectionIn: yellowButtonMenu) == #justifyIt		ifTrue: [selection _ lastJustify].	(selection isKindOf: Integer) ifTrue:		[paragraph doAlign: selection			from: startBlock stringIndex			to: (stopBlock stringIndex - 1 max: startBlock stringIndex).		lastJustify _ selection]!makeTable	"Take the selected text and make a table from it. Put it in the copy buffer"	| result |	(Smalltalk includesKey: #Tables) ifFalse: [^self booboo: 'The table generation tool is not installed'].	(result _ Tables format: self selection update: view topView suitcase) == nil ifTrue: [^self].	CurrentSelection _ result.	Clipboard clip: CurrentSelection.	Clipboard last propertyAt: #classification put: view topView suitcase classification!paste	| type item symbol entryClass fileName |	type _ Clipboard nextClass.	(type == Text or: [type == OrderedCollection]) ifTrue:		[entryClass _ Clipboard next propertyAt: #classification.		type == OrderedCollection			ifTrue: [entryClass == nil					ifTrue: [entryClass _ self maxClassification]					ifFalse: [entryClass _ entryClass + self maxClassification]].			(entryClass == nil) ifFalse:			[(entryClass ~= model classification)				ifTrue: [model changeClassification: entryClass + model classification.						view updateTopView]].		^super paste].		((type == Form) or: [type inheritsFrom: Form]) ifTrue: [^self pasteForm].	type == DataItem		ifTrue:			[item _ Clipboard next.			symbol _ DataMaster giveMe: #symbol for: item contents filename.			(symbol == #image or: [symbol == #map or: [symbol == #chart]])				ifTrue: [^self pasteInfoPicture].			(fileName _ InformationCenter getTextFromTransferBuffer) == nil ifTrue: [^self].			Cursor execute showWhile: [			entryClass _ item contents.			entryClass ~= model classification ifTrue:				[model changeClassification: entryClass + model classification.				view updateTopView].			self pasteInfoText: fileName.			lock _ #yes.			self updateMarker]]		ifFalse: [Clipboard booboo]!pasteForm	| picture fileName dataItem label entry picClass |	entry _ Clipboard retrieveEntry.	picture _ entry contents deepCopy.	picClass _ entry propertyAt: #classification.	label _ 'Pasted in ' , model dataItem label.	fileName _ Disk makeNewFileName: label withSuffix: (DataMaster giveMe: #suffixString for: #image asString).	dataItem _ DataItem				locked: false				classification: picClass classification				modifiers: picClass modifiers				type: #Item				label: label				filename: fileName				bPointers: nil				fPointers: nil				atIndex: 0.	picture writeAsDataItem: dataItem.	picClass == nil ifFalse: [picClass ~= model classification			ifTrue: 				[model changeClassification: picClass + model classification.				view updateTopView]].	^paragraph handlePicture: picture withFileNamed: fileName!pasteInfoPicture	|  picture theItem | 	theItem _ Clipboard retrieve.	picture _ DataMaster formFromItem: theItem.	picture == nil ifTrue:[^self].	(theItem ~= model classification)		ifTrue: [model changeClassification: (theItem + model classification).				view updateTopView].	^paragraph handlePicture: picture withFileNamed: theItem filename!redisplay	paragraph redisplay		ifTrue: [self resetState].!removeRectangle	paragraph removeRectangle.	self initializeYellowButtonMenu."	paragraph checkRecompose		ifTrue: [self resetState]."!restore	"Restore the text of the paragraph to be the text saved since initialization or	the last accept."	(self confirm: 'Restore to the last saved contents?')		ifTrue: [	lock == #no					ifFalse: [UndoSelection _ paragraph text.							paragraph restoreText.							lock _ #no].				paragraph retrieve.				paragraph setRect: view insetDisplayBox.				paragraph recomposePage.				self resetState]!save	lock == #no		ifFalse: [paragraph saveText.				lock _ #no].	self saveLayout.	view updateTopView.!saveLayout	| suffixString return newItem diskFile specialSuffix | 	model dataItem centerIndex = 0 ifTrue:	[return _ InformationCenter fileNameData: model dataItem filename defaultSuitcase: model defaultKeys: String new askMethod: false askClass: true.	(newItem _ return at: 1) == nil ifTrue: [^view flash].	Cursor execute showWhile: [	model dataItem filename = newItem filename		ifFalse: ["the user has decided to save me under a different name than the temporary name I had been using.				by the time get here, I have already saved my text into my temporary file name using saveText"				(diskFile _ paragraph diskFile) close.				specialSuffix _ DataMaster giveMe: #specialSuffixString for: #preview asString.				Disk renameKey: diskFile name newName: newItem filename, specialSuffix.				paragraph diskFile: (FileStream fileNamed: newItem filename, specialSuffix) readOnly.				Disk renameKey: model dataItem filename newName: newItem filename. "rename the structure file"		 		model packTheSuitcaseFrom: ((return at: 4) at: 1) forItem: newItem "update the suitcase"].	InformationCenter putFileNameAway: return]].	model accept.	paragraph store!scaleIt	PreviewPixScaleMenu answer == nil		ifFalse: [paragraph scalePicture: PreviewPixScaleMenu answer]!selectPix	paragraph selectFromPixList		ifTrue: [self deselect.				self yellowButtonMenu: PreviewYellowButtonSelectedMenu					yellowButtonMessages: TreeMenu]!setOption	| newOption |	newOption	_ DBoxView			openFor: #(fill fill fill fill select select select select)			title: 'Margin, Column, and Line Settings'			labels: #((Top ) (Bottom ) (Right ) (Left ) (Columns '1' '2' '3' '4') ( 'Gutter Width' '5' '10' '15' '20' '25' '30' ) ('Tab Unit' inch cm picas points) ( 'Line Spacing' '1.0' '1.5' '2.0' '3.0'))			defaults: paragraph currentOption.	newOption == nil ifTrue: [^false].	(paragraph setOption: newOption)		ifTrue: [self backup.				paragraph composePageNumbered: 0.				self resetState].!updateForm	| headerStream filename c |	filename _ paragraph updateForm.	filename == nil		ifFalse:			[(headerStream _ HeaderFileStream fileNamed: filename) readOnly.			headerStream hasHeader				ifTrue: [c _ headerStream classFromHeader.						c ~= model classification							ifTrue: [model changeClassification: (c + model classification).									view updateTopView]].			headerStream close]! !!PreviewPageController methodsFor: 'scrolling'!gotoNextPage: alwaysIfTrue	self backup.	paragraph checkRecompose.	alwaysIfTrue		ifFalse: [paragraph isThereANextPage					ifFalse: [(self confirm: 'This is the last page!!Do you want to add another page?')								ifTrue: [lock _ #yes] ifFalse: [^false]]].	paragraph nextPage ifTrue: [lock _ #yes].	^true!previousPage	self backup.	^paragraph previousPage!scroll	| savedCursor i |	savedCursor _ sensor currentCursor.	[self scrollBarContainsCursor]		whileTrue: 			[Processor yield.			Cursor upDown show.			Sensor redButtonPressed				ifTrue: 					[self controlTerminate.					self gotoNextPage.					self controlInitialize.					self initializeYellowButtonMenu].			Sensor blueButtonPressed				ifTrue: 					[self controlTerminate.					self gotoPreviousPage..					self controlInitialize.					self initializeYellowButtonMenu].			Sensor yellowButtonPressed ifTrue: [self scrollAbsolute]].	savedCursor show!scrollAbsolute	"preview does not have provide a way to scroll to some particular character.   	it only scroll to certain page"	| ypos line newline pg |	self changeCursor: Cursor marker.	self canScroll & sensor anyButtonPressed		ifTrue: 			[Display lightGray: marker.	"veryLightGray:"			[sensor anyButtonPressed]				whileTrue: 					[ypos _ (Sensor cursorPoint y max: scrollBar inside top)								"min: scrollBar inside bottom + 1".					(line isNil or: [ypos ~= line top])						ifTrue: 							[line notNil ifTrue: [Display reverse: line].							line _ scrollBar inside left @ ypos extent: 13 @ 2.							Display reverse: line]].			Display				fill: marker				rule: Form reverse				mask: Form veryLightGray.			pg _ ypos > scrollBar inside bottom					ifTrue: [1000] ifFalse: [(ypos - scrollBar inside top) // marker height].			self controlTerminate.			self backup.			(paragraph scrollToPage: pg + 1)				ifTrue: [self resetState].			self controlInitialize.			self initializeYellowButtonMenu]!selectAndScroll	self select! !!PreviewPageController methodsFor: 'control defaults'!controlActivity 	self scrollBarContainsCursor		ifTrue: 			[self scroll]		ifFalse: 			[yellowButtonMenu = PreviewMainMenu				ifTrue: [self processKeyboard].			self processMouseButtons].!controlInitialize	scrollBar region: (0 @ 0 extent: 15 @ (view displayBox height + 2)).	marker region: self computeMarkerRegion.	scrollBar _ scrollBar align: scrollBar topRight with: view displayBox topLeft - (0 @ 1).	marker _ marker align: marker topCenter with: scrollBar inside topCenter.	savedArea _ Form fromDisplay: scrollBar.	self displayPageMarker.	self moveMarker.	startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.	stopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.	self initializeSelection.	beginTypeInBlock _ nil.!dispatch: aSelector	| theSelector | 	theSelector	_ (aSelector isKindOf: Symbol)		ifTrue: [aSelector]		ifFalse: [yellowButtonMessages at: aSelector].	(#(recomposePage showReal centerPicture movePicture fitPicture properties getRectangle getListPicture editForm) includes: theSelector)		ifTrue: [paragraph perform: theSelector]		ifFalse: [self perform: theSelector].!initializeSelection	yellowButtonMenu = PreviewYellowButtonSelectedMenu		ifFalse: [super initializeSelection]!processRedButton	| select pt | 	select _ yellowButtonMenu = PreviewYellowButtonSelectedMenu.	(paragraph pageBreakContains: sensor cursorPoint)		ifTrue:  [self controlTerminate.				self deselect.				paragraph pageBreak.				self resetState.				^self controlInitialize].	pt _ sensor cursorPoint - view insetDisplayBox origin.	(paragraph ifPixContaining: pt)		ifTrue: [select					ifFalse: [self deselect.							self yellowButtonMenu: PreviewYellowButtonSelectedMenu								yellowButtonMessages: TreeMenu].				paragraph doPixAt: pt]		ifFalse: [select					ifTrue: [paragraph toggleSelectedRectangle.							self initializeYellowButtonMenu].				paragraph checkRecompose					ifTrue: [self resetState. self							updateAndMoveMarker].				super processRedButton]!readKeyboard	"Key struck on the keyboard. Find out which one and, if special,	carry out the associated special action. Otherwise, add the character to	the stream of characters.	This also includes fast-echo: while the user is typing, it tries to keep up, even if not	exactly correctly. When the user pauses, it fixes things up."	| typeAhead line font x w n charType xTable firstWasCR delay rightSide glyph nextCharacter |	beginTypeInBlock == nil		ifTrue: 			[UndoSelection _ self selection.			beginTypeInBlock _ startBlock copy].	self deselect.	"Prepare for fast-echo loop"	typeAhead _ WriteStream on: (String new: 128).	startBlock = stopBlock		ifTrue:		"Only do fast type-in if null selection"			[x _ startBlock left.			line _ paragraph lineForFastTypeinFrom: startBlock.			"line _ (startBlock expandBy: 7000@0) intersect: (paragraph colContainsPoint: startBlock origin)."			font _ (paragraph textStyle fontAt: emphasisHere) strikeFont.			xTable _ font xTable.			firstWasCR _ sensor keyboardPeek = Character cr.			rightSide _ BitBlt new setDestForm: Display sourceForm: Display halftoneForm: nil combinationRule: Form over destOrigin: startBlock origin sourceOrigin: startBlock origin extent: line corner - startBlock origin clipRect: line.			glyph _ BitBlt new setDestForm: Display sourceForm: font glyphs halftoneForm: nil combinationRule: Form over destOrigin: x@(startBlock bottom - font height) sourceOrigin: 0@0 extent: 0@font height clipRect: line.			"Fast echo loop, accumulates chars in typeAhead stream"			[sensor keyboardPressed and:				[((nextCharacter _ sensor keyboardPeek) = Character cr) == firstWasCR]]				whileTrue: [					n _ nextCharacter asciiValue + 1.					charType _ Keyboard at: n.					(self perform: charType with: typeAhead) ifTrue: [^self].					n _ (n min: font maxAscii) max: font minAscii.					w _ (xTable at: n + 1) - (xTable at: n).					(charType == #normalCharacter: and: [x+w <= line right])						ifTrue:							["Display								copy: ((x+w) @ line top corner: line corner)								from: x @ line top								in: Display rule: Form over."							rightSide destX: x+w; sourceX: x; copyBits.							glyph sourceX: (xTable at: n); destX: x; width: w; copyBits.							"Display								copy: (x @(startBlock bottom - font height) extent: (w@font height))								from: (xTable at: n)@0 in: font glyphs rule: Form over."							x _ x+w].					delay _ 100. [sensor keyboardPressed | (delay=0)] whileFalse: [delay _ delay - 1]].	"end fast echo loop"				]			ifFalse:		"Do normal behavior if non-null selection"				[charType _ Keyboard at: sensor keyboardPeek asciiValue + 1.				(self perform: charType with: typeAhead)						ifTrue: [^self updateAndMoveMarker]].	"Now properly paste and display accumulated characters"	self replaceSelectionWith: 		(Text string: typeAhead contents emphasis: emphasisHere).	self updateAndMoveMarker.	startBlock _ stopBlock copy.	self select!yellowButtonActivity	"Determine which item in the yellow button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	| index |	yellowButtonMenu == nil		ifFalse: 			[index _ yellowButtonMenu startUpYellowButton.			index == nil 				ifFalse: [self controlTerminate.						self deselect.						self dispatch: index.						self controlInitialize]]		ifTrue: [super controlActivity]! !!PreviewPageController methodsFor: 'displaying'!display	"Redisplay the paragraph."	| selectionState |	selectionState _ selectionShowing.	self deselect.	paragraph displayOn: Display.	selectionState ifTrue: [self select]! !!PreviewPageController methodsFor: 'initialize-release'!initialize	super initialize.	lock _ #no!initializeYellowButtonMenu	self yellowButtonMenu: PreviewMainMenu 		yellowButtonMessages: TreeMenu!model: aModel	super model: aModel!resetState 	"Establish the initial conditions for editing the paragraph:  place caret	before first character, set the emphasis to that of the first character."	startBlock _ paragraph characterBlockForIndex: 1.	stopBlock _ startBlock copy.	beginTypeInBlock _ startBlock copy.	self setEmphasisHere.	selectionShowing _ false.! !!PreviewPageController methodsFor: 'private'!backup	lock == #yes		ifTrue: [paragraph backupText.				lock _ #backed]!isUnlocked	^lock == #no and: [paragraph checkLayoutSaved]!maxCanPaste	^32000!replaceSelectionWith: aText	| scroll diff | 	beginTypeInBlock == nil ifTrue: [UndoSelection _ self selection].	scroll _ paragraph				replaceFrom: startBlock stringIndex				to: stopBlock stringIndex - 1				with: aText.	lock _ #yes.	scroll		ifTrue: [paragraph text isEmpty					ifTrue: [self previousPage.							^self resetState].				startBlock stringIndex + aText size > paragraph lastPageCharacter					ifTrue: [diff _ startBlock stringIndex + aText size - paragraph lastPageCharacter - 1.							self gotoNextPage: true.							self resetState.							stopBlock _ paragraph characterBlockForIndex: (startBlock stringIndex + diff).							^self select]].	startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.	stopBlock _ paragraph characterBlockForIndex: ((startBlock stringIndex + aText size) "min: paragraph lastCharacter").!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing _ selectionShowing not.	startBlock = stopBlock		ifTrue: [paragraph displayCaretForBlock: startBlock.				"paragraph displayCaretAt: 					startBlock bottomLeft - (0 @ paragraph textStyle baseline)"]		ifFalse: [paragraph reverseFrom: startBlock to: stopBlock]! !!StringHolderController methodsFor: 'initialize-release'!initialize	super initialize.	isLockingOn _ true.	self initializeYellowButtonMenu! !!StringHolderController methodsFor: 'menu messages'!fontIt	super fontIt		ifTrue: [model lock]! !!StringHolderController methodsFor: 'private'!initializeYellowButtonMenu	self yellowButtonMenu: CodeYellowButtonMenu 		yellowButtonMessages: TreeMenu!put: text in: thisFileStream	Cursor write showWhile:	[thisFileStream		writeShorten;		reset;		nextPutAll: text string.	text runs values = #(1) ifFalse:		[thisFileStream			nextPut: (Character value: 255);			nextPut: (Character  cr);			store: text runs]].	thisFileStream close! !DBTextController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!DBTextController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: DBTextYellowButtonMenu yellowButtonMessages: TreeMenu!initialText: aCollection	initialText _ aCollection! !!DBTextController methodsFor: 'menu messages'!accept	| extraLines contentsStrings | 	"Accept the contents.  If a record is selected, replace that record,  	else add as a new record."	self checkContents ifTrue: [Cursor wait showWhile: 		[self controlTerminate.		self acceptContents.		paragraph asText = String new			ifTrue: [view flash]			ifFalse: 				[contentsStrings _ model parseContents.				model hitListIndex = 0					ifTrue: 						["add a new record"						model file constructRecordFrom: contentsStrings.						model recordList add: model file numberOfRecords.						model hitView atEndAdd: (contentsStrings at: model selectedField).						model hitList add: ((model contents at: 2) at: model selectedFieldIndex).						model hitListIndex: model recordList size]					ifFalse: 						["replace the present record"						model file replaceRecord: (model recordList at: model hitListIndex) from: contentsStrings.						model hitView							renameSelectionTo: (contentsStrings at: model selectedField)							for: ((model contents at: 2) at: model selectedFieldIndex)].				self acceptClassification.				view updateDisplayContents].		self controlInitialize]]!acceptAndAdd	"accept the contents as a new record."	| stringContents |	self checkContents ifTrue: [Cursor wait showWhile: 		[self controlTerminate.		self acceptContents.		paragraph asText = String new			ifTrue: [view flash]			ifFalse: 				[stringContents _ model parseContents.				model file constructRecordFrom: stringContents.				model hitView atEndAdd: (stringContents at: model selectedField).				model hitList add: ((model contents at: 2) at: model selectedFieldIndex).				model recordList add: model file numberOfRecords.				model hitListIndex: model hitList size.				self acceptClassification].		self controlInitialize]]!acceptContents	"Like StringHolderController.accept, sort of."	paragraph text isEmpty		ifTrue: [initialText _ nil]		ifFalse:	[initialText _ OrderedCollection			with: model fieldList with: paragraph valueList ].	self unlockModel!cancel	initialText == nil ifTrue: [^view flash].	initialText isEmpty ifTrue: [^view flash].	self controlTerminate.	classification _ view model selectedRecordClassification.	UndoSelection _ Text new.	view updateClassification.	view clearInside.	view editContents: initialText.    "InitialText is NOT a Text !!!!"	paragraph displayOn: Display.	self scrollToTop.	self controlInitialize!classify	| newClassification oldClassification |	oldClassification _ view model selectedRecordClassification.	oldClassification classification: (oldClassification classificationIndex max: 1).	newClassification _ Classification fromUser: oldClassification.	newClassification == nil ifFalse: [classification _ newClassification].	view updateClassification!exclude	| elements query database type |	self controlTerminate.	database _ view superView model.	elements _ paragraph queryElementsFor: startBlock stringIndex.	(elements isKindOf: Array) ifFalse: [^self controlInitialize].	type _ database file fieldTypeOf: (elements at: 1) asSymbol.	type = #string		ifTrue: [query _ (elements at: 1) , ' doesntContain ''' , (elements at: 2) , ''''].	type = #number ifTrue: [query _ (elements at: 1) , ' ~= ' , (elements at: 2)].	type = #date | (type = #time) ifTrue:[query _ (elements at: 1) , ' ~= ''' , (elements at: 2),''''].	database queryDatabaseAgainstPresentListFrom: query.	model hitListIndex: 0.	model hitView getListAndDisplayView.	model clearContents.	view updateDisplayContents.	self controlInitialize!newRecord	self controlTerminate.	model fieldList size = 0 ifTrue:[self view flash].	model blankContents.	classification _ Classification new.	model textView updateDisplayContents.	self controlInitialize.!paste	| newClassification |	Clipboard isEmpty ifTrue: [^nil].	newClassification _ Clipboard next propertyAt: #classification.	Clipboard next contents class == OrderedCollection		ifTrue: [newClassification == nil					ifTrue: [newClassification _ self maxClassification]					ifFalse: [newClassification _ newClassification + self maxClassification]].	super paste == false ifTrue: [^self]. "This may be a non boolean, so DONT mess with it"	(newClassification == nil or: [newClassification = classification])		ifFalse: 			[self classification: classification + newClassification.			view update: #classifChanged]!require	| elements query database type |	self controlTerminate.	database _ view superView model.	elements _ paragraph queryElementsFor: startBlock stringIndex.	(elements isKindOf: Array) ifFalse: [^self controlInitialize].	type _ database file fieldTypeOf: (elements at: 1) asSymbol.	type = #string 		ifTrue: [query _ (elements at: 1) , ' contains ''' , (elements at: 2) , ''''].	type = #number ifTrue: [query _ (elements at: 1) , ' = ' , (elements at: 2)].	type = #date | (type = #time) ifTrue:[query _ (elements at: 1) , ' = ''' , (elements at: 2), ''''].	database queryDatabaseAgainstPresentListFrom: query.	model hitListIndex: 0.	model hitView getListAndDisplayView.	self controlInitialize! !!DBTextController methodsFor: 'classification'!acceptClassification	| DBFile | 	DBFile _ model file.	(classification + DBFile classification ~= DBFile classification)		ifTrue: [model classify: classification.				model updateClassification.				^true]		ifFalse: [model classify: classification.				^false]!classification	^classification!classification: aClassification	classification _ aClassification! !!DBTextController methodsFor: 'private'!checkContents	"Make sure fields of special type are of the correct format.   	Return true if all is OK, otherwise put an error message in the text and return false"	| newValues i fieldType |	Cursor wait show.	newValues _ paragraph valueList.	i _ newValues size + 1.	SmalltalkSignal do: 		[[(i _ i - 1) > 0] whileTrue: 			[fieldType _ model file fieldTypes at: i.			fieldType = #number				ifTrue:					[(newValues at: i) isNumeric ifFalse: [SmalltalkSignal signal].					model contents last at: i put: (newValues at: i) asNumber]				ifFalse:					[fieldType = #date						ifTrue: [model contents last at: i put: (Date readFrom: (ReadStream on: (newValues at: i)))]						ifFalse:							[fieldType = #time								ifTrue:									[model contents last at: i put: (Time readFrom: (ReadStream on: (newValues at: i)))]								ifFalse: [model contents last at: i put: (newValues at: i)]]]]]		handle:			[self selectAt: (paragraph protectedFields at: i) last + 1; deselect.			self replaceSelectionWith: ('Invalid ', fieldType, ' format --> ') asText.			self selectAndScroll; updateMarker.			Cursor normal show.			^false].	Cursor normal show.	^true!cr: characterStream	"Invoked by the RETURN key.	Special function for FieldParagraphs only."	| field |	(paragraph isKindOf: FieldParagraph)		ifTrue:			[sensor keyboard.			characterStream isEmpty ifFalse:  "KLUUUUUGE:"				[self replaceSelectionWith:     "don't lose what's already typed"					(Text string: characterStream						contents emphasis: emphasisHere) ].			self closeTypeIn.      "(see: selectNextField)"			field _ paragraph nextOpenFieldAfter: startBlock stringIndex.			self selectAt: field first.			self setEmphasisHere.			^true]    "make sure we exit the type-in method"		ifFalse:			[^self normalCharacter: characterStream]!replaceSelectionWith: aText	"Fixed for use with FieldParagraphs --- if replacement failed (replaceFrom: . . . returns false), just flash the view instead of adjusting selection.	Peter Alfke --- 8/84"	beginTypeInBlock == nil ifTrue: [UndoSelection _ self selection].	(paragraph		replaceFrom: startBlock stringIndex		to: stopBlock stringIndex - 1		with: aText		displaying: true) == false	ifTrue: [view flash]    "tried to mess with a protected field"	ifFalse:			[startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.			stopBlock _ 				paragraph characterBlockForIndex: startBlock stringIndex + aText size]!selectNextField	"For FieldParagraphs only."	| field |	self closeTypeIn.	(paragraph isKindOf: FieldParagraph) ifTrue:		[ field _ paragraph nextOpenFieldAfter: startBlock stringIndex.		self selectAndScrollFrom: field first to: field last.		self setEmphasisHere ]!tab: characterStream	"Invoked by the TAB key.	Special function for FieldParagraphs only."	(paragraph isKindOf: FieldParagraph)		ifTrue:			[sensor keyboard.			characterStream isEmpty ifFalse:  "KLUUUUUGE:"				[self replaceSelectionWith:     "don't lose what's already typed"					(Text string: characterStream						contents emphasis: emphasisHere) ].			self selectNextField.			^true]    "make sure we exit the type-in routine"		ifFalse:			[^self normalCharacter: characterStream]! !CellStringHolderController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!CellStringHolderController methodsFor: 'initialize-release'!release	displayModeView model removeDependent: self.	pointModeView model removeDependent: self.	updateModeView model removeDependent: self.	self nilFields.	super release! !!CellStringHolderController methodsFor: 'accessing'!displayModeView	^displayModeView!displayModeView: aView	displayModeView _ aView!pointModeView	^pointModeView!pointModeView: aView	pointModeView _ aView!spreadsheetView	^spreadsheetView!spreadsheetView: aView	spreadsheetView _ aView!updateModeView	^updateModeView!updateModeView: aLabelSwitchView	updateModeView _ aLabelSwitchView.	aLabelSwitchView model addDependent: self! !!CellStringHolderController methodsFor: 'menu messages'!accept	"Change contents or rule of selected cell."	spreadsheetView controller selectionPoint = (0@0) ifTrue:[^spreadsheetView flash].	self rollingAccept.	Cursor normal show.	self selectAll!cancel	super cancel.	self selectAll! !!CellStringHolderController methodsFor: 'editing'!cr: characterStream 	"The carriage return was typed by the user.  This designates that the receiver 	should give up control."	| selection newPoint |	displayModeView selector == #rule ifTrue: [^super cr: characterStream].	sensor keyboard. "gobble cr"	spreadsheetView controller selectionPoint = (0@0) ifTrue:[^spreadsheetView flash].	characterStream isEmpty 		ifFalse: [self replaceSelectionWith: 					(Text string: characterStream contents emphasis: emphasisHere)].	self rollingAccept.	selection _ spreadsheetView controller selectionPoint.	(selection isKindOf: Rectangle)		ifTrue: [selection _ selection origin].	newPoint _ selection x @ (selection y + 1 min: spreadsheetView model yGrid size).	spreadsheetView controller selectionPoint: newPoint.	spreadsheetView moveHighlight: newPoint.	self updateViewNoSelect.	self selectAll.	startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.	stopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.	self initializeSelection.	beginTypeInBlock _ nil.	^true!insertAndSelect: aString at: aPoint 	"KLUDGE alert... KLUDGE alert...  This method is included for compatibility with the basic StringHolderController, and has little to do with the actual function of the message.This method deals with compiler notifications ONLY!!!!"	AcceptSignal signal!read: aString	"Read some input sent from the spreadsheet."	"self controlInitialize."	aString == nil		ifTrue:			[self readKeyboard]		ifFalse:			[self deselect.			self replaceSelectionWith: aString asText.			self selectAt: stopBlock stringIndex].	"self controlTerminate"!rollingAccept	"Change contents or rule of selected cell."	| selectedCell selectionPoint escapeSignal confirmString evalString nextState |	model isUnlocked ifTrue: [^self selectAll].	selectionPoint _ spreadsheetView controller selectionPoint.	(selectionPoint class == Rectangle)		ifTrue: 			[selectionPoint _ selectionPoint origin.			spreadsheetView moveHighlight: selectionPoint].	selectionPoint = (0 @ 0) ifTrue: [^view topView flash].	Cursor execute show.	spreadsheetView clearHighlight: selectionPoint.	selectedCell _ spreadsheetView model atPoint: selectionPoint.	selectedCell = spreadsheetView model nilCell ifTrue: [selectedCell _ spreadsheetView model initCellAt: selectionPoint].	evalString _ paragraph string.	escapeSignal _ Signal new.	(displayModeView selector = #label		ifTrue: 			[selectedCell changeContents: (Label fromString: evalString).			Cursor normal show.			true]		ifFalse: [escapeSignal do: [AcceptSignal do: 					[displayModeView selector = #value						ifTrue: 							[confirmString _ 'Illegal Value -- would you like to accept as Rule?'.							nextState _ #rule.							selectedCell changeContents: (Compiler new evaluate: evalString									in: nil									to: nil									notifying: self									ifFail: [])]						ifFalse: 							[confirmString _ 'Illegal Rule -- would you like to accept as Value?'.							nextState _ #value.							selectedCell changeRule: evalString].					true]					handle: [(self confirm: confirmString)							ifTrue: 								[displayModeView model switchToSelector: nextState.								AcceptSignal doRetry]							ifFalse: [escapeSignal signal]]]				handle: [escapeSignal handleReturn: false]])		ifTrue: 			[selectedCell changed.			displayModeView selector = #rule				ifTrue: [selectedCell addUpdate]				ifFalse: [selectedCell display].			spreadsheetView model displayUpdates.			spreadsheetView setHighlight: selectionPoint.			super accept]!selectAll	"Select and highlight entire contents of window."	self selectAndScrollFrom: 1		to: paragraph text size.	self updateMarker!selectCurrentTypeIn: characterStream 	"The carriage return was typed by the user.  This designates that the receiver 	should give up control."	| selection newPoint |	displayModeView selector == #rule ifTrue: [^super selectCurrentTypeIn: characterStream].	spreadsheetView controller selectionPoint = (0@0) ifTrue:[^spreadsheetView flash].	sensor keyboard. "gobble cr"	characterStream isEmpty 		ifFalse: [self replaceSelectionWith: 					(Text string: characterStream contents emphasis: emphasisHere)].	self rollingAccept.	selection _ spreadsheetView controller selectionPoint.	(selection isKindOf: Rectangle)		ifTrue: [selection _ selection origin].	newPoint _ ((selection x + 1) min: spreadsheetView model xGrid size) @ selection y.	spreadsheetView controller selectionPoint: newPoint.	spreadsheetView moveHighlight: newPoint.	self updateViewNoSelect.	self selectAll.	startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.	stopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.	self initializeSelection.	beginTypeInBlock _ nil.	^true! !!CellStringHolderController methodsFor: 'updating'!update: aParameter	aParameter = #update ifTrue:[^spreadsheetView model displayUpdates].	model isUnlocked ifTrue: [self updateView]!updateView	"set the model to the selectedCell and display"	self updateViewNoSelect.	self selectAll.	startBlock _ paragraph characterBlockForIndex: startBlock stringIndex.	stopBlock _ paragraph characterBlockForIndex: stopBlock stringIndex.	self initializeSelection.	beginTypeInBlock _ nil.!updateViewNoSelect	"set the model to the selectedCell and display"	| selectionPoint cell viewContents contStream |	selectionPoint _ spreadsheetView controller selectionPoint.	(selectionPoint isKindOf: Rectangle)		ifTrue: [selectionPoint _ selectionPoint origin].	selectionPoint = (0 @ 0)		ifTrue: ["no cell selected"			viewContents _ '']		ifFalse: 			["cell selected, set model to proper stuff"			cell _ spreadsheetView model atPoint: selectionPoint.			displayModeView selector = #label ifTrue: [cell contents class == Label					ifTrue: [viewContents _ cell contents printString]					ifFalse: [viewContents _ 'Not a Label']].			displayModeView selector = #value ifTrue: [cell contents == spreadsheetView model badRef					ifTrue: [viewContents _ 'Illegal Reference in Rule']					ifFalse: [viewContents _ cell contents printString]].			displayModeView selector = #rule ifTrue: [cell rule == nil					ifTrue: [viewContents _ 'No Rule']					ifFalse: [viewContents _ cell rule string copy]]].	model contents: viewContents.	view updateDisplayContents! !!CellStringHolderController methodsFor: 'private'!initializeYellowButtonMenu	self yellowButtonMenu: CellCodeYellowButtonMenu		yellowButtonMessages: CellCodeYellowButtonMessages! !AutoBookTextController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!AutoBookTextController methodsFor: 'As yet unclassified'!accept	"save the new text"	model isUnlocked ifTrue: [^view flash].	self controlTerminate.	super accept.	model acceptText.	self controlInitialize!initialize	super initialize.	self initializeYellowButtonMenu!initializeYellowButtonMenu	self yellowButtonMenu: AutoBookYellowButtonMenu 		yellowButtonMessages: AutoBookYellowButtonMessages! !ImageEditorTextCollector comment:'Copyright (c) 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!ImageEditorTextCollector methodsFor: 'menu messages'!copySelection	"Copy the current selection and store it in the shared buffer."	super copySelection.	Clipboard last propertyAt: #classification put: view topView suitcase classification.!cut	super cut.	Clipboard last propertyAt: #classification put: view topView suitcase classification!fontIt	"Change the fonting for the the current selection"	| newEmphasis addEmphasis | 	(addEmphasis _ IEFontSubmenu answer) == nil ifTrue: [^self].	(newEmphasis _ self getLastSelectionIn: IEFontSubmenu) = addEmphasis		ifTrue:			[newEmphasis _ paragraph text emphasisAt: startBlock stringIndex.			(paragraph textStyle isFontUnderlined: newEmphasis) ifTrue: [newEmphasis _ newEmphasis - 39]].	newEmphasis _ newEmphasis + (addEmphasis = $p ifTrue: [0] ifFalse: [39]).	self deselect.	self closeTypeIn.	super replaceSelectionWith:		(Text string: self selection asString emphasis: newEmphasis).	self selectAndScroll.	self updateMarker.	CurrentSelection _ LastTyped _ self selection.	model lock!initializeYellowButtonMenu	self 		yellowButtonMenu: IEYellowButtonMenu		yellowButtonMessages: TreeMenu!paste	| newClassification | 	Clipboard isEmpty ifTrue: [^Clipboard booboo].	newClassification _ Clipboard next propertyAt: #classification.	Clipboard next contents class == OrderedCollection		ifTrue: [newClassification == nil					ifTrue: [newClassification _ self maxClassification]					ifFalse: [newClassification _ newClassification + self maxClassification]].	super paste == false "This may be non boolean"		ifFalse: [view topView changeClassification: newClassification]! !CreateController comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation. All rights reserved.'!!CreateController methodsFor: 'private'!breakDependent	parent _ nil.	self view superView controller closeAndUnschedule!drawChart	self accept; controlTerminate.	parent setTitleAndDraw: model contents.	view superView controller passControlTo: parent view topView controller!drawChartForClose	self accept; controlTerminate.	parent setTitleAndDraw: model contents.	^parent view topView controller!initializeYellowButtonMenu	self yellowButtonMenu: Menu 		yellowButtonMessages: MenuMessage!isControlActive	^(super isControlActive and: [view superView controller isControlActive])!parent: aParent	parent _ aParent!release	parent == nil ifFalse: [parent child: nil]! !!FillInTheBlankController methodsFor: 'menu messages'!bailOut	view topView clear: Form gray.	ScheduledControllers bailOut! !!FillInTheBlankController methodsFor: 'private'!initializeYellowButtonMenu	self yellowButtonMenu: FillInYellowButtonMenu 		yellowButtonMessages: FillInYellowButtonMessages! !!CRFillInTheBlankController methodsFor: 'stop conditions'!cr: characterStream	"The carriage return was typed by the user.  This designates that the receiver should give up control."	sensor keyboard. 	"gobble cr"	characterStream isEmpty ifFalse:		[self replaceSelectionWith:			(Text string: characterStream contents emphasis: emphasisHere)].	self accept.	^true! !UserFillController comment:'Copyright (c) 1987 Xerox Corporation.  All rights reserved.'!!UserFillController methodsFor: 'initialize-release'!reset	cr _ false.	bailOut _ false! !!UserFillController methodsFor: 'basic control sequence'!controlTerminate	cr _ false.	bailOut ifFalse:[super controlTerminate]!isControlActive	^cr not! !!UserFillController methodsFor: 'menu messages'!accept	super accept.	cr _ true!bailOut	model contents: nil.	model selectAction.	cr _ true.	bailOut _ true! !FormsFillController comment:'Copyright (c) 1986, 1987 Xerox Corporation.  All rights reserved.'!!FormsFillController methodsFor: 'initialize-release'!initialize	super initialize.	cr _ false.	bailOut _ false!initializeYellowButtonMenu	self yellowButtonMenu: FormsYellowButtonMenu 		yellowButtonMessages: FormsYellowButtonMessages!resetState 	"Establish the initial conditions for editing the paragraph: place the caret	before the first character, set the emphasis to that of the first character,	and save the paragraph for purposes of cancelling."	| insetDisplayBox |	insetDisplayBox _ paragraph compositionRectangle.	startBlock _ 		CharacterBlock			stringIndex: 1			character: nil			boundingRectangle: (insetDisplayBox topLeft extent: 0 @ 0).	stopBlock _ startBlock copy.	beginTypeInBlock _ startBlock copy.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!FormsFillController methodsFor: 'control activity'!controlActivity	self processKeyboard.	(sensor redButtonPressed and: [self viewHasCursor])		ifTrue: [self processRedButton].	(sensor yellowButtonPressed and: [self viewHasCursor])		ifTrue: [self processYellowButton]!readKeyboard	element hasChanged: true.	super readKeyboard! !!FormsFillController methodsFor: 'basic control sequence'!controlTerminate	cr _ false.	self accept.	self scrollToTop.	self deselect.	super controlTerminate!isControlActive	| answer |	sensor blueButtonPressed ifTrue: [^false]. 	answer _ cr not and: [sensor noButtonPressed or: [view containsPoint: sensor cursorPoint]].	answer ifFalse: [Clicks rememberClickAt: (sensor cursorPoint)].	^answer! !!FormsFillController methodsFor: 'stop conditions'!cr: characterStream	"Override superclass behavior and accept cr's as input"	^self normalCharacter: characterStream!tab: characterStream	| nextElement point  | 	sensor keyboard. 	"gobble tab"	characterStream isEmpty ifFalse:		[self replaceSelectionWith:			(Text string: characterStream contents emphasis: emphasisHere)].	cr _ true.	nextElement _ element controller model nextFillAfter: element.	point _ (element controller view boxForElement: nextElement) origin + 3.	sensor cursorPoint: point.	Clicks rememberClickAt: point.	^true! !!FormsFillController methodsFor: 'accessing'!element	^element!element: anElement	element _ anElement! !!FormsFillController methodsFor: 'menu messages'!accept	super accept.	model contents: paragraph text.	element hasChanged: true.	self unlockModel!cancel	UndoSelection _ paragraph text.	view clearInside.	self changeParagraph: (paragraph text: element initialValue asText).	paragraph displayOn: Display.	self scrollToTop.	element initialValue: element initialValue.	self unlockModel!copySelection	"Cut out the current selection and redisplay the paragraph if necessary."	Clipboard clip: (CurrentSelection _ UndoSelection _ LastTyped _ self selection).	Clipboard last propertyAt: #classification put: element controller view topView suitcase classification!cut	"Cut out the current selection and redisplay the paragraph if necessary."	self deselect.	self sometimesCloseTypeIn.	self replaceSelectionWith: Text new.	self selectAndScroll.	self updateMarker.	Clipboard clip: (CurrentSelection _ LastTyped _ UndoSelection copy).	Clipboard last propertyAt: #classification put: element controller view topView suitcase classification!findIt	"ask the info center about the current selection."	| match center suitcase |	self deselect.	self closeTypeIn.	self controlTerminate.	element controller view updateDisplayCache.	suitcase _ element controller view topView suitcase.	suitcase == nil ifFalse: [center _ suitcase center].	center == nil ifFalse: [match _ center match: self selection asString withLinksFrom: element controller view topView suitcase dataItem].	match == nil ifFalse:		[match isFolder			ifTrue: [ContainerModel					openThisFolder: match					inCenter: center					searchString: nil]			ifFalse: [DataMaster viewSelection: match withSuitcase: (Suitcase new packTheSuitcaseFrom: center forItem: match)]].	InformationCenter lookInInfoCentersFor: self selection asString.	self controlInitialize!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary."	| next type fileName entry stuff maxClass |	type _ Clipboard nextClass.	entry _ Clipboard next.	(type == Text or: [type == OrderedCollection])		ifTrue: 			[self deselect.			self sometimesCloseTypeIn.			maxClass _ entry propertyAt: #classification.			type == Text				ifTrue: [stuff _ Clipboard retrieve]				ifFalse: [stuff _ self convertDocumentText.						maxClass = nil							ifTrue: [maxClass _ self maxClassification]							ifFalse: [maxClass _ maxClass + self maxClassification].						Clipboard retrieve].			self replaceSelectionWith: stuff.			self selectAndScroll.			self updateMarker.			(Smalltalk includesKey: #Suitcase)				ifTrue: [element controller view topView changeClassification: maxClass].			^true].	((Smalltalk includesKey: #DataItem) and: [type == DataItem])		ifTrue:			[self controlTerminate.			(fileName _ InformationCenter getTextFromTransferBuffer) == nil ifTrue: [self controlTerminate. ^false].			self pasteInfoText: fileName.			self updateMarker.			self controlInitialize.			(Smalltalk includesKey: #Suitcase)				ifTrue: [element controller view topView changeClassification: entry contents].			^true].	^Clipboard booboo! !DBoxFillController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!DBoxFillController methodsFor: 'initialize-release'!boundingBox: aRectangle	"this should be set to the insetDisplayBox of the DBoxView"	boundingBox _ aRectangle!initialize	super initialize.	cr _ false.!initializeYellowButtonMenu	self yellowButtonMenu: DBoxYellowButtonMenu 		yellowButtonMessages: DBoxYellowButtonMessages! !!DBoxFillController methodsFor: 'control activity'!controlActivity	(boundingBox containsPoint: sensor cursorPoint)		ifFalse: [self keepCursorIn: boundingBox].	self processKeyboard.	(sensor redButtonPressed and: [self viewHasCursor])		ifTrue: [self processRedButton].	(sensor yellowButtonPressed and: [self viewHasCursor])		ifTrue: [self processYellowButton]! !!DBoxFillController methodsFor: 'basic control sequence'!controlTerminate	self accept.	self deselect.	super controlTerminate!isControlActive	^cr not and: [sensor noButtonPressed or: [view containsPoint: sensor cursorPoint]]! !!DBoxFillController methodsFor: 'stop conditions'!cr	^cr!cr: characterStream		super cr: characterStream.	self deselect.	cr _ true.	^true! !DBoxParaFillController comment:'Copyright (c) 1986, 1987 Xerox Corporation. All rights reserved.'!!DBoxParaFillController methodsFor: 'menu messages'!accept	initialText _ paragraph text copy.	model contents: paragraph text.	self unlockModel.	model setAction: true.! !!DBoxParaFillController methodsFor: 'stop conditions'!cr: characterStream 	"Override superclass behavior and accept cr's as input"	^self normalCharacter: characterStream! !DBoxKeywordFillController comment:'Copyright (c) Xerox Corporation, 1986, 1987.  All rights reserved.'!!DBoxKeywordFillController methodsFor: 'initialize'!getKeyWordMenu	| theCenter | 	InformationCenter lastUsedCenterName == nil		ifTrue: [keywordMenuArray _nil]		ifFalse: [theCenter _ InformationCenter centerFor: InformationCenter lastUsedCenterName.			theCenter == nil				ifTrue: [keywordMenuArray _nil]				ifFalse: [keywordMenuArray _ theCenter keywordMenu]]!initialize	self getKeyWordMenu.	super initialize!initializeYellowButtonMenu	self yellowButtonMenu:  DBoxKYellowButtonMenu 		yellowButtonMessages: DBoxKYellowButtonMessages! !!DBoxKeywordFillController methodsFor: 'menu message'!addKeyword	| index theKeyword | 	keywordMenuArray == nil ifTrue:[^self booboo:'There are no keywords in this Information Center yet'].	self deselect.	index _ (keywordMenuArray at: 1) startUp.	index ==nil ifTrue:[ self select.^self].	theKeyword _ (keywordMenuArray at: 2) at: index.	self selectAt: (self text size + 1).	self deselect.	self replaceSelectionWith: ((self text size = 0) ifTrue:[theKeyword] ifFalse:[(String with: $,),theKeyword]) asText.	self select! !RS232SendController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!RS232SendController methodsFor: 'control activity'!controlActivity 	RS232Collector takeControlIfNeeded.	(autoSendStream atEnd not and: [autoSend and: [self autoSend]])		ifFalse:			[super controlActivity]!controlInitialize"	echo ifFalse: [paragraph mask: Form white]."	^ super controlInitialize!isControlActive	^ (self isTransmitControl & sensor blueButtonPressed not)!isControlWanted	RS232Collector receivingRS232 ifTrue: [^false].	^self isTransmitControl!isTransmitControl	^ (RS232Collector transmitState and:		[(view superView containsPoint: sensor cursorPoint) and:			[RS232Collector functionKeysWindow = nil or:				[(RS232Collector functionKeysWindow containsPoint: sensor cursorPoint) not]]])!processRedButton	((view containsPoint: sensor cursorPoint) or: [self class == TekController])		ifFalse: [self controlTerminate.				self addOnEnd: RS232Collector displayMemory selectFromRedButton.				self controlInitialize]		ifTrue: [super processRedButton]! !!RS232SendController methodsFor: 'initialize/release'!initialize	super initialize.	echo _ true.	self initializeAutoSending: String new	"initialize empty"!initializeAutoSending: theString	| readStream aCollection |	autoSend _ true.	readStream _ ReadStream on: theString.	aCollection _ OrderedCollection new.	[readStream atEnd] whileFalse:		[aCollection add: (readStream upTo: $,)].	autoSendStream _ ReadStream on: aCollection!initializeYellowButtonMenu 	self yellowButtonMenu: RS232YellowButtonMenu		yellowButtonMessages: TreeMenu! !!RS232SendController methodsFor: 'private'!endKeyboardInputWith: characterStream	"The text in characterStream is inserted properly. Control is terminated"	sensor keyboard.	"gobble the cr"	self isControlActive ifTrue: [self controlTerminate].	self replaceSelectionWith: (Text string: characterStream contents emphasis: emphasisHere)!readKeyboard	"Copied from an old ParagraphEditor to gain access to carriage return termination--read a key that the user strikes on the keyboard."	| typeAhead currentCharacter |	self deselect.	typeAhead _ WriteStream on: (String new: 128).	beginTypeInBlock == nil		ifTrue: 			[UndoSelection _ self selection.			beginTypeInBlock _ startBlock copy].	[sensor keyboardPressed]		whileTrue: 			[currentCharacter _ sensor keyboardPeek.			currentCharacter = Character cr ifTrue: [^self send: typeAhead].			(self perform: (Keyboard at: currentCharacter asciiValue + 1)				 with: typeAhead)				ifTrue: [^self]].	self replaceSelectionWith:		(Text string: typeAhead contents emphasis: emphasisHere).	startBlock _ stopBlock copy.	self selectAndScroll!scrollToEnd	"scroll to end of text display"	self		selectWithoutComp: paragraph text size + 1;		selectAndScroll.	paragraph displayOn: Display!selectWithoutComp: characterIndex 	startBlock _ paragraph characterBlockForIndex: characterIndex.	stopBlock _ startBlock copy!setEmphasisHere	emphasisHere _ RS232Collector defaultFont "Gacha 10"! !!RS232SendController methodsFor: 'menu messages'!clearBuffer	RS232Collector userClearMemory!generalKermit	| index | 	(Smalltalk includesKey: #RS232Kermit) ifFalse: [^self booboo: 'Sorry, no Kermit protocols available'].	self controlTerminate.	(index _ (PopUpMenu labels: 'Queue upTransfer files' lines: #()) startUpYellowButton) = 0		ifFalse:			[index = 1 ifTrue: [RS232Kermit queueFileTransfer] ifFalse: [RS232Collector fileTransferUser]].	self controlInitialize!getLastLine 	"send the first line of text in the collector, remembering what line has just been sent"	lastLine == nil ifTrue:[^nil].	model contents: lastLine.	view updateDisplayContents.	self selectAndScroll!getText	"get saved text into window, give control to it"	RS232Collector rs232ToBrowseState!sendLastLine 	"make lastLine be the text contents, and send it again"	paragraph text: lastLine.	self sendFirstLine! !!RS232SendController methodsFor: 'sending'!addOnEnd: aString	"Insert aString at the end of the text."	| insertLoc |	"I realize that this is scummy code, but I found myself unable to resist it.  This is a special routine to allow hex specification of special characters in function keys.  Format is: <<xx>> where xx is a hex character specification. -- Kurt"	(aString size > 4 and: [((aString at: 1) = $<) and: [((aString at: 2) = $<)]])		ifTrue: ["self selectWithoutComp: paragraph text size + 1.""Changed to replace whatever is selected"				self  replaceSelectionWith: 					(Text string: (String with: 							('16r' , (aString copyFrom: 3 to: 4)) asNumber asCharacter)						emphasis: emphasisHere).				^self scrollToEnd].	"double ampersand substitution stuff is scummy as well. -- Kurt"	insertLoc _ aString findString: '&&' startingAt: 1.	insertLoc = 0 		ifFalse:			[paragraph text:				(aString copyFrom: 1 to: insertLoc - 1) asText, 				paragraph text, 				(aString copyFrom: insertLoc + 2 to: aString size) asText]		ifTrue:			[self "selectWithoutComp: paragraph text size + 1;"	"select end of text"				replaceSelectionWith: (Text string: aString emphasis: emphasisHere)].	self scrollToEnd!addOnEndandSend: aString	"Insert aString at the end of the text.		Then transmit the first line of text on the RS232		Sender to this method should terminate control before sending and reinitialize on return"	| insertLoc |	"I realize that this is scummy code, but I found myself unable to resist it.  This is a special routine to allow hex specification of special characters in function keys.  Format is: <<xx>> where xx is a hex character specification. -- Kurt"	(aString size > 4 and: [((aString at: 1) = $<) and: [((aString at: 2) = $<)]])		ifTrue: [(aString at: 3) = $# ifTrue: [^RS232Collector addKeyboardEvent: (aString copyFrom: 4 to: 5)]. "this is another hack"				^self sendMindlessly: (String with: (('16r', (aString copyFrom: 3 to: 4)) asNumber) asCharacter), (String with: Character cr)].	"double ampersand substitution stuff is scummy as well. -- Kurt"	insertLoc _ aString findString: '&&' startingAt: 1.	insertLoc = 0 		ifFalse:			[paragraph text:				(aString copyFrom: 1 to: insertLoc - 1) asText, 				paragraph text, 				(aString copyFrom: insertLoc + 2 to: aString size) asText]		ifTrue:			[self "selectWithoutComp: paragraph text size + 1;" "select end of text"				replaceSelectionWith: (Text string: aString emphasis: emphasisHere)]. 	self sendFirstLine!autoSend	"If autoSend is true, send the string which is the next item in autoSendStream.		If the next item is empty, then switch autoSend to false, and		leave so user can enter through keyboard"	| sendString |	((sendString _ autoSendStream next) = String new) ifTrue: [^(autoSend _ false)].	self controlTerminate;		selectWithoutComp: 1;	"select start of text"		replaceSelectionWith: (Text string: sendString emphasis: emphasisHere);		sendFirstLine;		controlInitialize.	^true!echo	echo _ true.	paragraph mask: Form black!forcedStop	| buffer |	autoSendStream setToEnd.	"cancel auto login"	"put anything further typed into transmit pane"	buffer _ WriteStream on: (String new: 128).	[sensor keyboardPressed]		whileTrue: 			[buffer nextPut: sensor keyboard].	self addOnEnd: buffer contents!getFirstLine	"grabs for return the first line in view, takes out of view"	| allText lastSent |	allText _ self text string.	lastSent _ 1.	allText isEmpty		ifTrue: [allText _ String with: CR]		ifFalse:			[[lastSent = allText size or: [(allText at: lastSent) = CR]]					whileFalse: [lastSent _ lastSent + 1].	"find first cr"			 allText _ allText copyFrom: 1 to: lastSent.			 model contents: (self text copyFrom: lastSent + 1 to: self text size).  "remove text sent from transmit window"			 view updateDisplayContents.			 self selectWithoutComp: paragraph text size + 1.	"put selection pt. at end of text"].	^allText!noEcho	echo _ false.	paragraph mask: Form white!send: characterStream	"The text in characterStream is inserted properly and control terminated.		Then the first line of text transmitted on the RS232, control		given to RS232Controller to receive the answer, and send control reinitialized"	self endKeyboardInputWith: characterStream.	self sendFirstLine.	self isControlWanted ifTrue: [self controlInitialize]!sendFirstLine	"The first line of text is transmitted on the RS232, and control given to		RS232Controller to receive the answer before returning.		The first line is considered to be all text up to the first carraige return.		Senders should terminate control before sending this message,		and reinitialize control after return"	| logText allText |	echo ifTrue: "save text for re-send or fix"		[lastLine _ paragraph text deepCopy.		 (lastLine size > 1 and: [(lastLine at: lastLine size) = Character cr])			ifTrue: [lastLine _ lastLine copyFrom: 1 to: lastLine size - 1]].	allText _ self getFirstLine.	(allText at: allText size) = CR	"be sure CR on end so will send Xoff"		ifFalse: [allText _ allText, (String with: CR)].	logText _ allText copy.	echo ifFalse: [1 to: (allText size - 1) do: [:i | logText at: i put: $ ]].	RS232Collector logSentText: logText.	RS232Collector sendTextString: allText; takeControl. "send text, wait for return message"	autoSend _ true!sendMindlessly: aString	"send this string mindlessly to the host, without following any cr conventions, etc."	echo ifTrue: "save text for re-send or fix"		[lastLine _ aString].	RS232Collector sendTextString: aString; takeControl. "send text, wait for return message"	autoSend _ true! !TekController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!TekController methodsFor: 'As yet unclassified'!alwaysEcho	"this to cause the window to stop recognizing the suppress password command from the host"	alwaysEcho _ true!captureGraphics	"Enable/disable storing of graphics commands in a file."	| which |	(which _ OnOffMenu answer) == nil		ifFalse:			[view topView model captureGraphics: (which = $Y"on") ]!copyGraphics	"Allow user to select area of display to be put in ImageEditor's copy buffer"	| which |	(which _ SubMenu answer) == nil		ifFalse:			[self controlTerminate.			 Clipboard clip: ((which = $E"ntire")				ifTrue: [RS232Collector graphicsWindow model]				ifFalse: [Form fromUser]).			 self controlInitialize]!fileOutGraphics	"Allow user to select area of display to be filed into the info center as an image"	| form imageLabelArray which |	(which _ SubMenu answer) == nil		ifFalse:			[self controlTerminate.			 (form _ (which = $E"ntire")				ifTrue: [RS232Collector graphicsWindow model]				ifFalse: [Form fromUser]).			 imageLabelArray _ InformationCenter fileNameData: #image defaultSuitcase: (Suitcase new packTheSuitcaseFrom: nil forItem: (DataItem type: (DataItem typeIndexFor: #Item) label: 'TekImage' atIndex: 0)) defaultKeys: String new askMethod: true askClass: true.			 ((imageLabelArray at: 1) == nil) ifTrue: [^nil].			 form writeAsDataItem: (imageLabelArray at: 1).			 InformationCenter putFileNameAway: imageLabelArray.			 self controlInitialize]!hardcopyGraphics	| which |	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].	(which _ SubMenu answer) == nil		ifFalse:			[self controlTerminate.			 (which = $E"ntire")				ifTrue: [BackgroundPrinter printForm: RS232Collector graphicsWindow model]				ifFalse: [BackgroundPrinter printForm: Form fromUser].			 self controlInitialize]!initialize	alwaysEcho _ false.	super initialize!initializeYellowButtonMenu 	self yellowButtonMenu: TekYellowButtonMenu		yellowButtonMessages: TreeMenu!noEcho	alwaysEcho ifFalse: [super noEcho]!page	RS232Collector nextPage!reset	RS232Collector resetTek; nextPage! !!ListController methodsFor: 'marker adjustment'!computeMarkerRegion	| viewList |	viewList _ view list.	^ 0@0 extent: 13@			((viewList clippingRectangle height asFloat /						viewList compositionRectangle height *							scrollBar inside height)					rounded min: scrollBar inside height)! !DataListController comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation. All rights reserved.'!!DataListController methodsFor: 'initialize/activity'!controlInitialize	| topDelimiter s theDataView |	super controlInitialize.	view topView subViews size = 3		ifTrue: 			[theDataView _ view topView subViews at: 3.			topDelimiter _ theDataView topDelimiter.			topDelimiter = theDataView bottomDelimiter				ifTrue: 					[topDelimiter _ model padString: (String with: Character space)								withSpaceInBack: DataListModel labelSpace.					model stackList do: 						[:each | 						s _ model padString: each withSpaceInFront: DataListModel dataSpace.						topDelimiter _ topDelimiter , s].					theDataView topDelimiter: topDelimiter; update: #list]]!initialize	super initialize.	self yellowButtonMenu: DataMenu 		yellowButtonMessages: DataMenuMessages!redButtonActivity	| selectionMovement oldSelection trialSelection nextSelection |	selectionMovement _ false.	oldSelection _ view selection.	[sensor redButtonPressed]		whileTrue: 			[trialSelection _ view findSelection: sensor cursorPoint.			trialSelection == nil				ifFalse: 					[nextSelection _ trialSelection.					view moveSelectionBox: nextSelection.					nextSelection ~= oldSelection ifTrue: [selectionMovement _ true]]].	nextSelection == nil ifTrue: [^self].	nextSelection = oldSelection ifTrue:		[selectionMovement ifTrue: [^self].		nextSelection _ 0.		view moveSelectionBox: nextSelection].	model changeRequest ifFalse:			[view moveSelectionBox: oldSelection.			^ view flash].! !!DataListController methodsFor: 'menu messages'!chartIt	whichType = #stacked		ifTrue: [(view topView subViews at: 3) model dataList isEmpty ifTrue: [^self booboo: 'There are no data to chart!!']]		ifFalse: [(view topView subViews at: 2) model dataList isEmpty ifTrue: [^self booboo: 'There are no data to chart!!']].	self controlTerminate.	(view superView subViews at: 1) controller drawChart!copy		view selection = 0 ifTrue: [^ view flash].	self controlTerminate.	model copyLabel: (view list list at: view selection + 1) atIndex: view selection.	self controlInitialize!cut		view selection = 0 ifTrue: [^ view flash].	self controlTerminate.	model cutLabel: (view list list at: view selection + 1) atIndex: view selection.	view removeCurrentSelection.	self dataChanged.	self controlInitialize!edit	view selection = 0 ifTrue: [^ view flash].	self controlTerminate.	whichType = #stacked		ifTrue: [self editStackData]		ifFalse: [self editSingleData].	self controlInitialize!editSingleData	| item labels theModel defaultArray answers labelList dataList  s t |	(item _ view selection) = 0 ifTrue: [^view flash].	theModel _ ((view topView subViews) at: 2) model.	whichType = #single		ifTrue: [labels _ #((Label: ) (Value: ) )]		ifFalse: [labels _ #(('X Value:' ) ('Y Value:' ) )].	defaultArray _ Array with: (theModel labelList at: item)				with: (theModel dataList at: item) printString.	answers _ DBoxView				openFor: #(fill fill )				title: 'Edit Data'				labels: labels				defaults: defaultArray.	answers == nil		ifFalse: 			[self checkForNumeric: answers.			(labelList _ theModel labelList) at: item put: (answers at: 1).			theModel labelList: labelList.			(dataList _ theModel dataList) at: item put: (answers at: 2) asNumber.			theModel dataList: dataList.	self dataChanged.	s _ model padString: (answers at: 1) withSpaceInBack: DataListModel labelSpace.	t _ model padString: ((answers at: 2) asNumber printString) withSpaceInFront: DataListModel dataSpace.	view renameSelectionTo: (s,t)]!editStackData	| item theDataModel stackList labels answers labelList temp dataList aList dataSpace s |	(item _ view selection) = 0 ifTrue: [^view flash].	theDataModel _ (self view topView subViews at: 3) model.	stackList _ ((self view topView subViews at: 2) model) stackList.	(labels _ Array new: stackList size + 1) at: 1 put: #('the Label' ).	1 to: stackList size do: [:each | labels at: each + 1 put: (Array with: (stackList at: each))].	(answers _ OrderedCollection new) add: (theDataModel labelList at: item) copy.	(theDataModel dataList at: item)		do: [:each | answers add: each printString].	answers _ DBoxView				openFor: (Array new: stackList size + 1 withAll: 'fill')				title: 'Edit Stack Data'				labels: labels				defaults: answers.	answers = nil		ifFalse: 			[self checkForNumeric: answers.			(labelList _ theDataModel labelList) at: item put: (answers at: 1).			theDataModel labelList: labelList.			temp _ OrderedCollection new.			2 to: answers size do: [ : each | temp add: (answers at: each) asNumber].			(dataList _ theDataModel dataList) at: item put: temp.			theDataModel dataList: dataList.			dataSpace _ DataListModel dataSpace.			self dataChanged.			aList _ model padString: (answers at: 1) withSpaceInBack: DataListModel labelSpace.			2 to: answers size do: [:each | s _ model padString: (answers at: each) asNumber printString withSpaceInFront: dataSpace. aList _ aList , s].		view renameSelectionTo: aList]!enterData	| answers aCursor labels newLine |	whichType = #stacked ifTrue: [^self enterStackData].	whichType = #single		ifTrue: 			[answers _ #('theLabel' '0' ).			labels _ #((Label: ) (Value: ) )]		ifFalse: 			[answers _ #('0' '0' ).			labels _ #(('X Value:' ) ('Y Value:' ) )].	aCursor _ sensor cursorPoint.	[answers = nil] whileFalse: 			[sensor cursorPoint: aCursor.			answers _ DBoxView						openFor: #(fill fill )						title: 'Enter Data'						labels: labels						defaults: answers						commands: #(accept cancel done)						autoAccept: true.			answers = nil				ifFalse: 					[self checkForNumeric: answers.					newLine _ model addData: answers.					view addNew: newLine.					self dataChanged.					self scrollViewToEnd]].!enterStackData	| answers aCursor anArray labelArray stackList stackSize newLine |	stackList _ (view topView subViews at: 2) model stackList.	(stackSize _ stackList size) = 0 ifTrue: [^view flash].	anArray _ Array new: stackSize + 1 withAll: 'fill'.	(answers _ Array new: stackSize + 1) at: 1 put: 'theLabel'.	(labelArray _ Array new: stackSize + 1) at: 1 put: #('Label: ').	1 to: stackSize do: 		[:each | 		answers at: each + 1 put: '0'.		labelArray at: each + 1 put: (Array with: (stackList at: each))].	aCursor _ sensor cursorPoint.	[answers = nil]		whileFalse: 			[sensor cursorPoint: aCursor.			answers _ DBoxView						openFor: anArray						title: 'Enter stack data'						labels: labelArray						defaults: answers						commands: #(accept cancel done)						autoAccept: true.			answers = nil				ifFalse: 					[self checkForNumeric: answers.					newLine _ model addStackData: answers.					view addNew: newLine.					self dataChanged.					self scrollViewToEnd]].!paste	self controlTerminate.	(model paste: view selection)		ifTrue: [view atCurrentSelectionAdd: (model copyBuffer at: 5).				self dataChanged.				view selection = (view maximumSelection - 1) ifTrue: [self scrollViewToEnd]].	self controlInitialize! !!DataListController methodsFor: 'private'!checkForNumeric: answers 	2 to: answers size do: [:i | (answers at: i) isNumeric ifFalse: [^self booboo: 'You may have entered wrong data in a value field!!Please re-edit if necessary!!']]!dataChanged	view topView controller chartIt: true!scrollViewToEnd	| viewList amount |	viewList _ view list.	amount _ viewList clippingRectangle bottom - viewList compositionRectangle bottom min: 0.	amount ~= 0		ifTrue: [view deselect.			viewList scrollBy: amount negated.			view isSelectionBoxClipped ifFalse: [ view displaySelectionBox ]]! !!DataListController methodsFor: 'access'!whichType	^whichType!whichType: theType	whichType _ theType! !StackListController comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation. All rights reserved.'!!StackListController methodsFor: 'menu messages'!copy		view selection = 0 ifTrue: [^ view flash].	self controlTerminate.	model copyStackLabel: view selection.	self updateList: view selection action: #copy.	self controlInitialize!cut	| item | 	(item _ view selection) = 0 ifTrue: [^ view flash].	self controlTerminate.	model cutStackLabel: item.	view removeCurrentSelection.	self updateList: item action: #cut.	self dataChanged.	self controlInitialize!editStack	| index temp answers |	(index _ view selection) = 0 ifTrue: [^view flash].	self controlTerminate.	temp _ model stackList at: index.	answers _ DBoxView				openFor: #(fill )				title: 'Edit stack'				labels: #(('Stack Label: ') )				defaults: (Array with: temp).	answers = nil		ifFalse: 			[model stackList at: index put: (answers at: 1).			self updateList: nil action: nil.			self dataChanged.			view renameSelectionTo: (answers at: 1)].	self controlInitialize!enterStack	| answers aCursor |	aCursor _ sensor cursorPoint.	answers _ #('theLabel' ).	[answers = nil]		whileFalse: 			[sensor cursorPoint: aCursor.			answers _ DBoxView						openFor: #(fill )						title: 'Enter Stack'						labels: #(('Stack Label:' ) )						defaults: answers						commands: #(accept cancel done)						autoAccept: true.			answers = nil				ifFalse: 					[model addStack: answers.					self updateList: nil action:#enter.					view addNew: (answers at: 1).					self dataChanged.					self scrollViewToEnd]]!initialize	super initialize.	self yellowButtonMenu: StackMenu yellowButtonMessages: StackMenuMessages!paste	self controlTerminate.	(model pasteStackLabel: view selection)		ifTrue: [view atCurrentSelectionAdd: (model copyBuffer at: 4).				view selection = (view maximumSelection-1) ifTrue: [self scrollViewToEnd].				self dataChanged.				self updateList: view selection action:#paste].	self controlInitialize!updateList: index action: aSymbol 	"index range | 0..size of stackList |"	|  theDataView theDataModel dataList labelList copyBuffer aBuffer minimum dataSpace topDelimiter s |	theDataView _ (view topView subViews at: 3).	theDataModel _ theDataView model.	dataList _ theDataModel dataList.	labelList _ theDataModel labelList.	copyBuffer _ theDataModel copyBuffer.	aSymbol = #enter		ifTrue:			[dataList do: [ : each | each add: 0]].	aSymbol = #paste		ifTrue: 			[aBuffer _ copyBuffer at: 3.			minimum _ aBuffer size min: dataList size.			index = 0				ifTrue: [1 to: minimum do: [:each | (dataList at: each)							add: (aBuffer at: each)]]				ifFalse: [1 to: minimum do: [:each | (dataList at: each)							add: (aBuffer at: each)							atIndex: index]].			minimum = dataList size ifFalse: [minimum + 1 to: dataList size do: [:each | index = 0						ifTrue: [(dataList at: each)								add: 0]						ifFalse: [(dataList at: each)								add: 0 atIndex: index]]]].	aSymbol = #cut		ifTrue: 			[aBuffer _ OrderedCollection new.			dataList do: 				[:each | 				aBuffer add: (each at: index).				each removeObjectAt: index].			copyBuffer at: 3 put: aBuffer.			theDataModel copyBuffer: copyBuffer].	aSymbol = #copy		ifTrue: 			[aBuffer _ OrderedCollection new.			dataList do: 				[:each | 				aBuffer add: (each at: index)].			copyBuffer at: 3 put: aBuffer.			theDataModel copyBuffer: copyBuffer. ^self].	dataSpace _ DataListModel dataSpace.	topDelimiter _ model padString: (String with: Character space) withSpaceInBack: DataListModel labelSpace.	model stackList do: [: each | s _ model padString: each withSpaceInFront: dataSpace.	topDelimiter _ topDelimiter , s].	theDataView topDelimiter: topDelimiter; update: #list! !OutlineController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!OutlineController methodsFor: 'menu messages'!accept	self controlTerminate.	(view okToChange: view selection change: true)		ifTrue: [	Cursor execute show.				model accept.				view topView accept.				Cursor normal show].	self controlInitialize!addEntry	| labelArray defaultArray typeArray answer | 	(model listIndex = 0 and: [model collection isEmpty not])		ifTrue: [view flash]		ifFalse: [self controlTerminate.				(view okToChange: view selection change: false)					ifTrue: [labelArray _ OrderedCollection new.							labelArray add: #('Position:' before after under); add: #(Name).							defaultArray _ OrderedCollection new.							defaultArray add: #after; add: model thisLabel.							(typeArray _ OrderedCollection new) addAll: #(select); add: #fill.							answer _ DCM getNewClassification: model thisClassDefaults title: 'Add Entry' appendLabel: labelArray types: typeArray defaults: defaultArray links: OrderedCollection new.							answer == nil								ifFalse: [model addEntry: answer.	view changeClassification]].				self controlInitialize]!cancel	self controlTerminate.	(view okToChange: view selection change: false)		ifTrue: [Cursor execute show.				model cancel = 0					ifTrue: [view flash]					ifFalse: [view changeClassification].				Cursor normal show].	self controlInitialize!changeSelection	"set up a popup menu of other views to close "	| labelArray answer defaultArray typeArray |	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	(view okToChange: view selection change: true) ifTrue:		[labelArray _ OrderedCollection new.		labelArray add: #(Name).		defaultArray _ OrderedCollection new.		defaultArray add: model thisLabel.		(typeArray _ OrderedCollection new) add: #fill.		answer _ DCM getNewClassification: model thisClassDefaults title: 'Rename and Change Classification' appendLabel: labelArray types: typeArray defaults: defaultArray links: OrderedCollection new.		answer == nil			ifFalse: [model changeSelection: (Array with: (answer at: 1) with: nil with: (answer at: 2) with: (answer at: 3)).					view changeClassification]].	self controlInitialize!composeDocument	self controlTerminate.	model composeDocument: view topView suitcase.	self controlInitialize!composeStructure	self controlTerminate.	model composeStructure: view topView suitcase.	self controlInitialize!compress	self controlTerminate.	Cursor execute show.	(view okToChange: view selection change: true)		ifTrue: [(model hasChanged				and: [(self confirm: 'Compress will accept all changes. Are you sure?') ifTrue: [false] ifFalse: [true]])					ifFalse: [model compress]].	Cursor normal show.	self controlInitialize!concat	| fileName item englishDataType | 	self controlTerminate.	((item _ InformationCenter getItemInCopyBuffer) ~~ nil and: [self confirm: 'Concatenate from ', item label]) ifTrue:		[fileName _ item filename.		fileName == nil ifFalse:			[englishDataType _ DataMaster giveMe: #englishString for: fileName.			englishDataType = #text				ifTrue: [(fileName _ ComposeTextController makeSimpleTextFileFromSuitcase: (Suitcase new packTheSuitcaseFrom: nil forItem: item)) == nil ifFalse:						[Cursor execute showWhile: [model concat: item label text: fileName].						view changeClassification]]				ifFalse: [englishDataType = #outline							ifTrue: [(fileName sameAs: model fileName)										ifTrue: [self booboo: 'Can not concat self']										ifFalse: [Cursor execute showWhile: [model concat: fileName at: (self listIndexOf: item)].												view changeClassification]]]]]		ifFalse: [view flash].	self controlInitialize!copy	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model copy.	self controlInitialize!cut	model listIndex = 0 ifTrue:[^view flash].	self controlTerminate.	(view okToChange: view selection change: false)		ifTrue: [model cut.				view changeClassification].	self controlInitialize!editParagraph	self controlTerminate.	view addOrRemoveEditSubview = false		ifTrue: [view changeEditViewDisplaying: true].	self controlInitialize!hardcopyDocument	self controlTerminate.	model hardcopyDocument: view topView suitcase.	self controlInitialize!hideSubs	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model hideSubs = 0 ifTrue: [view flash].	self controlInitialize!pasteAfter	(model listIndex = 0 and: [model collection isEmpty not]) ifTrue: [^view flash].	self controlTerminate.	Cursor execute show.	(view okToChange: view selection change: false)		ifTrue: [(model pasteEntry: #after) = 0 ifTrue: [view flash] ifFalse: [view changeClassification]].	Cursor normal show.	self controlInitialize!pasteBefore	(model listIndex = 0 and: [model collection isEmpty not]) ifTrue: [^view flash].	self controlTerminate.	Cursor execute show.	(view okToChange: view selection change: false)		ifTrue: [(model pasteEntry: #before) = 0 ifTrue: [view flash] ifFalse: [view changeClassification]].	Cursor normal show.	self controlInitialize!pasteUnder	(model listIndex = 0 and: [model collection isEmpty not]) ifTrue: [^view flash].	self controlTerminate.	Cursor execute show.	(view okToChange: view selection change: false)		ifTrue: [(model pasteEntry: #under) = 0 ifTrue: [view flash] ifFalse: [view changeClassification]].	Cursor normal show.	self controlInitialize!repair	| t v | 	self controlTerminate.	(self confirm: 'Repair outline files. Are you sure ?')		ifTrue: [	t _ model repairText.				t size > 0					ifTrue: [(self confirm: 'Do you want to examine the result?')								ifTrue: [view topView subViews size > 1 ifFalse: [view addOrRemoveEditSubview].										v _ view topView subViews at: 2.										v model contents: t string, v model contents.										v model changed.										v model unlock]]					ifFalse: [self booboo: 'The file is in perfect condition!!']].	self controlInitialize!showSubs	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	Cursor execute show.	model showSubs = 0 ifTrue: [view flash].	Cursor normal show.	self controlInitialize! !!OutlineController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: OutlineYellowButtonMenus 		yellowButtonMessages: TreeMenu!listIndexOf: anotherOL	| theSuitcase | 	ScheduledControllers scheduledControllers do: [:each |		((each isKindOf: StandardSystemController)		and: [theSuitcase _ each view suitcase.			theSuitcase ~~ nil and: [theSuitcase dataItem == anotherOL]])				ifTrue: [^each model listIndex = 0 ifTrue: [1] ifFalse: [each model collection at: (each model listIndex)]]].	^1! !!OutlineController methodsFor: 'control activity'!redButtonActivity	| oldSelection trialSelection nextSelection |	oldSelection _ view selection.	[sensor redButtonPressed]		whileTrue: 			[trialSelection _ view findSelection: sensor cursorPoint.			trialSelection == nil				ifFalse: 					[nextSelection _ trialSelection.					view moveSelectionBox: nextSelection]].	(view okToChange: oldSelection change: false)		ifTrue: [(nextSelection == nil or: [nextSelection = oldSelection])					ifTrue: [self changeModelSelection: 0]					ifFalse: [self changeModelSelection: nextSelection]]		ifFalse: [view moveSelectionBox: oldSelection]! !ChapterController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!ChapterController methodsFor: 'menu messages'!lookFor	FillInTheBlank request: 'What word'		displayAt: Sensor cursorPoint		centered: true		action: [:answer | answer]		initialAnswer: String new.	model key: answer.	self nextReference!nextReference	| old amount scrollAmount | 	"find the next reference to the key"	model key == nil ifTrue: [^view flash].	self controlTerminate.	old _ view selectionBoxOffset.	(model nextReferenceFrom: model listIndex) = 0		ifTrue: [view flash]		ifFalse: [scrollAmount _ view scrollAmount: old.				scrollAmount ~= 0 ifTrue: [self scrollView: scrollAmount]].	self controlInitialize!reset	self controlTerminate.	model reset.	self controlInitialize!showTopSubs	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	Cursor execute show.	model showTopSubs = 0 ifTrue: [view flash].	Cursor normal show.	self controlInitialize! !!ChapterController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: ChapterYellowButtonMenu		yellowButtonMessages: ChapterYellowButtonMessages! !!ChapterController methodsFor: 'control activity'!redButtonActivity	| oldSelection trialSelection nextSelection |	oldSelection _ view selection.	[sensor redButtonPressed]		whileTrue: 			[trialSelection _ view findSelection: sensor cursorPoint.			trialSelection == nil				ifFalse: 					[nextSelection _ trialSelection.					view moveSelectionBox: nextSelection]].	(nextSelection == nil or: [nextSelection = oldSelection])		ifTrue: [self changeModelSelection: 0]		ifFalse: [self changeModelSelection: nextSelection]! !FunctionKeyEditorController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!FunctionKeyEditorController methodsFor: 'menu messages'!copyFunctionKey	"get from selected item the key, label, and action. Store in FunctionKeyBuffer"	model viewListIndex = 0 ifTrue: [^view flash].	"no label selected"	FunctionKeyBuffer _ model bufferSelectedFunction.	self updateStatus!createFunctionKey	"allow user to define their own function key"	"need to get from user a label, the string to send, and whether it		should send it immediately or wait for more input.		Need to generate a key for it"	| theString return |	return _ self editFunctionKey: (Array with: #label asString with: String new with: (Array with: #yes) with: 'Create').	return == nil ifTrue: [^self].	theString _ return at: 2.	(return at: 3) = #yes ifTrue: [theString _ theString, (String with: Character cr)].	FunctionKeyBuffer _ self bufferKey: model newUserKey label: (return at: 1) action: theString.	self updateStatus.	self pasteFunctionKey!editFunctionKey	"allow user to change the function key"	"need to get from user a label, the string to send, and whether it		should send it immediately or wait for more input.		Need to generate a key for it"	| return label theAction includeEnter |	model viewListIndex = 0 ifTrue: [^view flash].	"no label selected"	label _ model viewList at: model viewListIndex.	theAction _ model viewActionList at: model viewListIndex.	includeEnter _ (theAction = String new ifTrue: [false] ifFalse: [(theAction at: theAction size) = Character cr]).	includeEnter ifTrue: [theAction _ theAction copyFrom: 1 to: theAction size - 1].	return _ self editFunctionKey: (Array with: label with: theAction with: (Array with: (includeEnter ifTrue: [#yes] ifFalse: [#no])) with: 'Edit').	return == nil ifTrue: [^self].	(((return at: 2) ~= theAction) or: [includeEnter xor: ((return at: 3) = #yes)])		ifTrue:			[(return at: 3) = #yes ifTrue: [return at: 2 put: (return at: 2), (String with: Character cr)].			model viewActionList at: model viewListIndex put: (return at: 2).			saved _ false].	(return at: 1) = label		ifFalse:	"update the view's list and display it"			[model changeSelectedLabelTo: (return at: 1).			saved _ false.			view resetView].!editFunctionKey: arrayOfDefaults	"arrayOfDefaults contains the defaults for the label, the string to send, whether to send it immediately (true) or wait for more input, and the first word of the title"	| return |	^DBoxView		openFor: #(fill fill select)		title: (arrayOfDefaults at: 4), ' Function Key'		labels: (Array with: (Array with: #Label:) with: (Array with: 'Text to transmit:') with: #( 'Include enter key?' yes no))		defaults: arrayOfDefaults!getLabelDefs	"re-get the definition of the function keys from the file"	Cursor wait show.	model getLabelDefs.	saved _ true.	view resetView.	"update the view's list and display it"	Cursor normal show!pasteFunctionKey	"if there is a function key in FunctionKeyBuffer, insert it into the function list in		front of what is now selected, or if nothing selected, put at the end of the list.		Give it a new key if there is already a function using the current one"	(FunctionKeyBuffer == nil) ifTrue: [view flash. ^ false].	self controlTerminate.	model addBufferedFunction: FunctionKeyBuffer.	saved _ false.	view resetView.	"update the view's list and display it"	self controlInitialize!putLabelDefs	"store the current definition of the function keys"	saved ifTrue: [^false].	Cursor wait showWhile:		[model putLabelDefs.		saved _ true]!removeFunctionKey	"remove the selected key, put it in FunctionKeyBuffer"	(model viewListIndex > 0) ifFalse: [view flash. ^self].	"no key selected"	self controlTerminate.	FunctionKeyBuffer _ model bufferSelectedFunction.	model removeSelectedItem.	saved _ false.	view resetView.	"update the view's list and display it"	self controlInitialize.	self updateStatus!scrollUpSome	self scrollView: 0-100! !!FunctionKeyEditorController methodsFor: 'control'!controlInitialize	super controlInitialize.	self initializeYellowButtonMenu.	self updateStatus!saved: aBoolean	saved _ aBoolean! !!FunctionKeyEditorController methodsFor: 'initialize/release'!checkAndPutLabelDefs	"store the current definition of the function keys, if the user wants to"	(saved not and: [self confirm: 'Save current functionkey definitions?'])		ifTrue: [self putLabelDefs]!initialize	super initialize.	saved _ true.	self initializeYellowButtonMenu!initializeYellowButtonMenu	(yellowButtonMenu == nil or: [model userWriteAccess])		ifTrue:			[self yellowButtonMenu: (FuncKeysYellowButtonMenu at: 2)			 	yellowButtonMessages: (FuncKeysYellowButtonMessages at: 2)]		ifFalse:			[self yellowButtonMenu: (FuncKeysYellowButtonMenu at: 1)				 yellowButtonMessages: (FuncKeysYellowButtonMessages at: 1)]! !!FunctionKeyEditorController methodsFor: 'private'!bufferKey: theKey label: theLabel action: theString	"put parameters together in an Array where first element is key, second is label, third is action"	| buffer |	buffer _ Array new: 3.	buffer		at: 1 put: theKey;		at: 2 put: theLabel;		at: 3 put: theString.	^ buffer!displayStatus: aString	"display aString in function key view's status window"	view statusView model contents: aString asString.	view statusView updateDisplayContents!updateStatus	"display contents of copy buffer in function key view's status window"	FunctionKeyBuffer == nil ifFalse:		[view statusView model contents: (FunctionKeyBuffer at: 2).		view statusView updateDisplayContents]! !RS232FunctionKeysController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!RS232FunctionKeysController methodsFor: 'menu messages'!endEditMode	"change back to normal mode"	RS232Collector rs232ToTransmitState.	model toggleListIndex: model viewListIndex.	"deselect"	self displayStatus: String new.	self controlTerminate.	editMode _ false.	self initializeYellowButtonMenu.	sensor flushKeyboard	"flush keys buffer"!getLabelDefs	"re-get the definition of the function keys from the file"	RS232Collector displayStatus: 'Getting function key definitions'.	super getLabelDefs.	RS232Collector displayStatus: 'Editing Function Keys'!initEditMode	"change into edit mode"	RS232Collector rs232ToEditFunctionKeysState.	editMode _ true.	self controlInitialize.	self initializeYellowButtonMenu!putLabelDefs	"store the current definition of the function keys"	saved ifTrue: [^false].	Cursor wait showWhile:		[RS232Collector displayStatus: 'Saving function key definitions'.		model putLabelDefs.		saved _ true.		RS232Collector displayStatus: 'Editing Function Keys']!scrollDownSome	self scrollView: 100! !!RS232FunctionKeysController methodsFor: 'control'!changeModelSelection: anInteger 	model toggleListIndex: anInteger.	editMode		ifFalse:			[model toggleListIndex: anInteger.			 self giveControlToTransmit: (model viewActionList at: anInteger)]!controlActivity	editMode		ifTrue: [super controlActivity]		ifFalse:			["check for user typing message; cursor happens to be in this window"			 [sensor keyboardPressed]				whileTrue:					[self controlTerminate.					 RS232Collector sendWindow controller readKeyboard.					 self controlInitialize].			 RS232Collector takeControlIfNeeded.			 "check these in here to make sure scroll bar doesn't get a chance"			 sensor redButtonPressed & self viewHasCursor 				ifTrue: [^self redButtonActivity].			 sensor yellowButtonPressed & self viewHasCursor 				ifTrue: [^self yellowButtonActivity].			 sensor blueButtonPressed & self viewHasCursor 				ifTrue: [^self blueButtonActivity]			]!controlInitialize	"only initialize if want scroll bar; which is only in edit mode"	editMode		ifTrue: [super controlInitialize]!controlTerminate	"only de-initialize if initialized scroll bar; which is only in edit mode"	editMode		ifTrue: [super controlTerminate]!giveControlToTransmit: aString	"this puts aString as the next thing to send in the transmit window"	"If it is supposed to, it also sends aString out over the RS232 as if it had been typed in followed by CR"	self controlTerminate.	aString size < 1 ifTrue:[^self controlInitialize].	((aString at: aString size) = Character cr)		ifTrue: [RS232Collector sendWindow controller addOnEndandSend: aString]		ifFalse: [RS232Collector sendWindow controller addOnEnd: aString].	self controlInitialize!isControlActive	editMode		ifTrue: [^super isControlActive]		ifFalse: [^ (self viewHasCursor & sensor blueButtonPressed not & RS232Collector transmitState)]	"avoid scrollBar if not in editMode"!isControlWanted	^ (super isControlWanted & (RS232Collector transmitState | RS232Collector editFuncKeysState))!moveMarker: anInteger 	"override default marker behavior to avoid trashing the display area"	editMode ifTrue: [super moveMarker: anInteger]! !!RS232FunctionKeysController methodsFor: 'initialization'!initialize	editMode _ false.	super initialize!initializeYellowButtonMenu	editMode		ifTrue:			[self yellowButtonMenu: (RS232FuncKeysYellowButtonMenu at: 2)			 yellowButtonMessages: (RS232FuncKeysYellowButtonMessages at: 2)]		ifFalse:			[self yellowButtonMenu: (RS232FuncKeysYellowButtonMenu at: 1)			 yellowButtonMessages: (RS232FuncKeysYellowButtonMessages at: 1)]! !BioController comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation.  All rights reserved.'!!BioController methodsFor: 'initialize-release'!initialize	super initialize.	self initializeYellowButtonMenu!initializeYellowButtonMenu	self 		yellowButtonMenu: BioYellowButtonMenu		yellowButtonMessages: TreeMenu! !!BioController methodsFor: 'menu messages'!deleteImage	model listIndex = 0 ifTrue: [^view flash].	(self confirm: 'Are you certain that you want to delete this image?')		ifTrue: [			self controlTerminate.			model deleteImage.			self controlInitialize]!hardcopyAll	"print all the images"	(DataMaster backgroundPrintingAvailable: true) ifTrue:		[BackgroundPrinter printReportText: nil annoDict: nil forms: model list2 titles: model list suitcase: view topView suitcase]!hardcopyOne	"make a hardcopy of the selected image."	| index |	index _ model listIndex.	index  = 0 ifTrue: [^view flash].	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].	self controlTerminate.	BackgroundPrinter printReportText: nil annoDict: nil forms: (Array with: (model list2 at: index)) titles: (Array with: (model list at: index)) suitcase: view topView suitcase.	self controlInitialize!hardcopyReport	"make a hardcopy of all the images and the text"	| textToHardcopy annoDict |	(DataMaster backgroundPrintingAvailable: true) ifFalse: [^self].	self controlTerminate.	view superView model dependents do: [:aView |		(aView isKindOf: StringHolderView) ifTrue:			[textToHardcopy _ aView controller text.			 annoDict _ aView controller model findAnyAnnos: textToHardcopy]].	BackgroundPrinter printReportText: textToHardcopy annoDict: annoDict forms: model list2 titles: model list suitcase: view topView suitcase.	self controlInitialize!pasteImage	| type entry symbol picture |	view moveSelectionBox: 0.	self controlTerminate.	type _ Clipboard nextClass.	type == Form | (type == Text)		ifTrue: 			[entry _ Clipboard retrieveEntry.			(model pasteImage: (type == Form					ifTrue: [entry contents]					ifFalse: [entry contents asDisplayText form]) class: (entry propertyAt: #classification))				ifTrue: 					[view moveSelectionBox: model listIndex.					self scrollViewUp.					view topView changeClassification: (entry propertyAt: #classification)]				ifFalse: 					[model whereToPutIt model white.					model whereToPutIt display]].	(type == DataItem and:		[entry _ Clipboard next.		symbol _ (DataMaster giveMe: #englishString for: entry contents filename) asSymbol.		(symbol == #image or: [symbol == #map or: [symbol == #chart]])])		ifFalse: [Clipboard booboo]		ifTrue:			[entry _ Clipboard retrieveEntry.			(picture _ DataMaster formFromItem: entry contents)== nil ifFalse:				[model pasteImage: picture class: entry contents.				view moveSelectionBox: model listIndex.				self scrollViewUp.				view topView changeClassification: entry contents]].	self controlInitialize!rename	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	model rename ifTrue: [ view moveSelectionBox: model listIndex.								self scrollViewUp].	self controlInitialize.! !!BioController methodsFor: 'control'!viewHasCursor	^(super viewHasCursor | (model whereToPutIt containsPoint: Sensor cursorPoint))! !ContainerListController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!ContainerListController methodsFor: 'modular menu messages'!addSelection: aSymbol	| theArray | 	self controlTerminate.	Cursor execute showWhile: [(aSymbol isKindOf: Symbol)		ifFalse:[theArray _ model addDataItem: aSymbol]		ifTrue:[theArray _ model perform: aSymbol].		theArray == nil ifFalse:[view hasChanged: false. view atCurrentSelectionAdd: (theArray at: 1)]].	self controlInitialize!checkAndUpdate: aSymbol	self controlTerminate.	(model perform: aSymbol) ifTrue:[view getListAndDisplayView].	self controlInitialize.!checkAndUpdateSelection: aSymbol	model listIndex = 0 ifTrue: [^view flash].	self checkAndUpdate: aSymbol!closeAfter: aSymbol	self controlTerminate.	(model perform: aSymbol)		ifTrue:[sensor cursorPoint: (view topView insetDisplayBox origin - 5 max: 0@0)."this cursor move is required for obvious reasons"			view superView controller close]		ifFalse:[self controlInitialize]!createNewSelection: aSymbol	| theArray | 	self controlTerminate.	(aSymbol isKindOf: Symbol)		ifFalse:[theArray _ model addDataItem: aSymbol]		ifTrue:[theArray _ model perform: aSymbol].		theArray == nil ifFalse:			[view hasChanged: false. view atCurrentSelectionAdd: (theArray at: 1).			model viewSelection]!cutSelection: aSymbol	| theString | 	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	(model perform: aSymbol) ifTrue:[view removeCurrentSelection].	self controlInitialize!editSelection: aSymbol	| theString | 	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	theString _ (model perform: aSymbol).	theString == nil ifFalse:[view hasChanged: false. view renameSelectionTo: theString].	self controlInitialize.!justDoIt: aSymbol	self controlTerminate.	model perform: aSymbol.	self controlInitialize.!mustHaveASelection: aSymbol	model listIndex = 0 ifTrue: [^view flash].	self justDoIt: aSymbol!renameKeyword: aSymbol	| theString | 	model listIndex = 0 ifTrue: [^view flash].	self controlTerminate.	theString _ (model perform: aSymbol).	theString == nil ifTrue:[^self controlInitialize].	theString isEmpty		ifTrue:[view removeCurrentSelection]		ifFalse:[view hasChanged: false.				view renameSelectionTo: theString].	self controlInitialize!type5menu: aSymbol	model listIndex = 0 ifTrue: [^view flash].	self type1menu: aSymbol! !!ContainerListController methodsFor: 'control defaults'!controlInitialize	super controlInitialize.	model userAccessMessage.	model listIndex = 0		ifTrue: [Cursor normal show]		ifFalse: [Cursor mouse show].	model folder centerIndex = 1		ifTrue:[model center totalCenterClass ifTrue:[view checkClassification]]!controlTerminate	super controlTerminate.	Cursor normal show.!redButtonActivity	super redButtonActivity.	sensor leftShiftDown ifTrue:		[model listIndex = 0 ifFalse:			[self controlTerminate.			model viewSelection]]!yellowButtonActivity	"Determine which item in the yellow button pop-up menu is selected.  	If one is selected, then send the corresponding message to the object  	designated as the menu message receiver. "	| index |	yellowButtonMenu == nil		ifTrue: [super controlActivity]		ifFalse: 			[index _ yellowButtonMenu startUpYellowButton.			 index = 0 ifFalse:				[(yellowButtonMessages == TreeMenu)					ifTrue: [self menuMessageReceiver performYellowSelections]					ifFalse: [((yellowButtonMessages at: 1) at: index) == nil ifFalse:								[self menuMessageReceiver									perform: ((yellowButtonMessages at: 1) at: index)									with: ((yellowButtonMessages at: 2) at: index)]]]]! !!ContainerListController methodsFor: 'private'!centerName	^model centerName!fcUser	^model centerName!performTreeBackwards: aTreeMenu	| selection |  	"Perform all the currently selected messages in aTreeMenu, starting at the 	lowest level subtree."	aTreeMenu child notNil ifTrue: [^self performTreeBackwards: aTreeMenu child].	selection _ aTreeMenu selection.	selection = 0 ifTrue:[^nil].	((aTreeMenu answers at: 1) at: selection) notNil ifTrue: 		[(((aTreeMenu answers at: 1) at: selection) isKindOf: Symbol)			ifTrue: [^self perform: ((aTreeMenu answers at: 1) at: selection)						with: ((aTreeMenu answers at: 2) at: selection)]]! !!ContainerListController methodsFor: 'initialize - release'!initMenu: aMenuNumber	"1 = container; 2 = in box; 3 = trash; 4 = key word; 5 = item; 6 = folder 7 = scavenger "	| theMenu | 	theMenu _ AllTheMenus at: aMenuNumber.	^self yellowButtonMenu: (theMenu at: 1) yellowButtonMessages: (theMenu at: 2)! !!ContainerListController methodsFor: 'button messages'!showInBox	model showInBox!showKeywords	model showKeywords!showMenu	model selectFromOpenMenu!showTrash	model showTrash!sort 	self controlTerminate.	(model perform: #sort) ifTrue:[view getListAndDisplayView].! !FunctionKeyEditor comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987.  All rights reserved.FuncKeySectionBuffer at: 1 is an instance of RS232FunctionKeys, at: 2 is an array with three strings for section name, window type, and auto login sequence.'!!FunctionKeyEditor methodsFor: 'private'!autoLoginForSelection	| autoLogin | 	(autoLogin _ Array new: 3)		at: 1 put: ((autoLoginSection at: 1) at: programIndex);		at: 2 put: ((autoLoginSection at: 2) at: programIndex);		at: 3 put: ((autoLoginSection at: 3) at: programIndex).	^autoLogin!editAutoLoginFor: autoLoginArray	"answer nil or an array containing the resulting sectionName, type, autoLogin. autoLoginArray has the same format"	| answers |	answers _ DBoxView		openFor: #(fill select fill)		title: 'OIT Login' 		labels: #(#(Name:) #('Window type:' 'Delta Data' 'Tek') #('Auto login sequence:'))		defaults: (Array with: (autoLoginArray at: 1) with: (autoLoginArray at: 2) with: (autoLoginArray at: 3)).	^answers!fileOutAutoLoginSection	"the autoLoginSection is an array of three OrderedCollections whose string contents correspond to the name (1), window type (2), and its auto login sequence (3)"	| sectionString names types logins asteriskString commaString |	sectionString _ String new.	names _ autoLoginSection at: 1.	types _ autoLoginSection at: 2.	logins _ autoLoginSection at: 3.	asteriskString _ String with: $*.	commaString _ String with: $,.	1 to: names size do:		[:i | sectionString _ sectionString, asteriskString, (names at: i), commaString, (types at: i), commaString, (logins at: i), (String with: Character cr)].	(ConfigFile userConfigFor: theUser)		writeSection: #OIT with: sectionString;		close.	theUser = UserName ifTrue: [ScreenController changeOITMenu]!initializeAutoLoginSection	"the autoLoginSection is an array of three OrderedCollections whose string contents correspond to the name (1), window type (2), and its auto login sequence (3)"	| sectionStream names types logins configFile |	configFile _ ConfigFile userConfigFor: theUser.	sectionStream _ ReadStream on: (configFile getSection: #OIT).	configFile close.	autoLoginSection _ Array new: 3.	names _ OrderedCollection new.	types _ OrderedCollection new.	logins _ OrderedCollection new.	[sectionStream atEnd] whileFalse:		[sectionStream upTo: $*.		names add: (sectionStream upTo: $,).		types add: (sectionStream upTo: $,).		logins add: (sectionStream upTo: Character cr)].	autoLoginSection at: 1 put: names; at: 2 put: types; at: 3 put: logins!passControlToController: aStandardSystemController	aStandardSystemController == nil ifFalse:		[aStandardSystemController centerCursorInView.		 (ScheduledControllers activeController isKindOf: ScreenController) ifFalse:				[ScheduledControllers activeController under.				ScheduledControllers unschedule: aStandardSystemController.				ScheduledControllers scheduleActive: aStandardSystemController].		 ^true].	^false!pasteFunctionKeysFrom: anRS232FunctionKeys withLogin: revisedAutoLogin	| index keysController newFunctionKeys | 	revisedAutoLogin == nil ifTrue: [^self].	newFunctionKeys _ anRS232FunctionKeys copy changeToUser: theUser andProgram: (revisedAutoLogin at: 1).	index _ (autoLoginSection at: 1) findFirst: [:name | name asLowercase = (revisedAutoLogin at: 1) asLowercase].	index = 0		ifTrue:			[programIndex _ (programIndex = 0 ifTrue: [(autoLoginSection at: 3) size + 1] ifFalse: [programIndex]).			(autoLoginSection at: 1) add: (revisedAutoLogin at: 1) atIndex: programIndex.			(autoLoginSection at: 2) add: (revisedAutoLogin at: 2) atIndex: programIndex.			(autoLoginSection at: 3) add: (revisedAutoLogin at: 3) atIndex: programIndex.			newFunctionKeys putLabelDefs]		ifFalse:			[(self confirm: 'Overwrite ', (revisedAutoLogin at: 1)) ifFalse: [^self].			keysController _ self lookForLabel: theUser, '''s ', (revisedAutoLogin at: 1), ' function keys'.			keysController == nil ifFalse: [^self booboo: 'Error: Please close the function key editor on ', (revisedAutoLogin at: 1), ' first'].			(autoLoginSection at: 1) at: index put: (revisedAutoLogin at: 1).			(autoLoginSection at: 2) at: index put: (revisedAutoLogin at: 2).			(autoLoginSection at: 3) at: index put: (revisedAutoLogin at: 3).			newFunctionKeys putLabelDefs.			programIndex _ index].	self fileOutAutoLoginSection.	self updateList.	"update the view's list and display it"! !!FunctionKeyEditor methodsFor: 'menu messages'!copySection	| keysController | 	programIndex = 0 ifTrue: [^view flash].	"no label selected"	keysController _ self lookForLabel: theUser, '''s ', (programList at: programIndex), ' function keys'.	keysController == nil ifFalse:		[(self confirm: 'Copy version in open function keys window?') ifTrue:			[FuncKeySectionBuffer				at: 1 put: keysController model;				at: 2 put: self autoLoginForSelection.			^self updateStatus]].	FuncKeySectionBuffer		at: 1 put: (RS232FunctionKeys new initForUser: theUser onSection: (programList at: programIndex));		at: 2 put: self autoLoginForSelection.	self updateStatus!createSection	"need to get an auto login sequence, from which the section name can be derived"	| newSection | 	self controlTerminate.	newSection _ self editAutoLoginFor: (Array with: String new with: 'Delta Data' with: String new).	newSection == nil ifTrue: [^self].	FuncKeySectionBuffer at: 1 put: (RS232FunctionKeys new initForUser: theUser onSection: (newSection at: 1)).	FuncKeySectionBuffer at: 2 put: newSection.	self updateStatus.	self pasteFunctionKeysFrom: (FuncKeySectionBuffer at: 1) withLogin: newSection.	self controlInitialize!cutSection	| keysController | 	programIndex = 0 ifTrue: [^view flash].	"no label selected"	keysController _ self lookForLabel: theUser, '''s ', (programList at: programIndex), ' function keys'.	keysController == nil ifFalse: [^self booboo: 'Please close the function keys window for this first'].	self controlTerminate.	FuncKeySectionBuffer		at: 1 put: (RS232FunctionKeys new initForUser: theUser onSection: (programList at: programIndex));		at: 2 put: self autoLoginForSelection.	ConfigFileModel replaceSection: (programList at: programIndex) inFile: theUser, '-functionKeyDefs' with: nil inSectionName: nil.	(autoLoginSection at: 1) removeObjectAt: programIndex.	(autoLoginSection at: 2) removeObjectAt: programIndex.	(autoLoginSection at: 3) removeObjectAt: programIndex.	programIndex _ 0.	self fileOutAutoLoginSection.	self updateList; updateStatus.	self controlInitialize!editAutoLogin	"if let them change the name, then have to make sure no function key windows are open on it"	| revisedAutoLogin keysController oldAutoLogin aStream theKeys | 	programIndex = 0 ifTrue: [^view flash].	"no label selected"	keysController _ self lookForLabel: theUser, '''s ', (programList at: programIndex), ' function keys'.	keysController == nil ifFalse: [^self booboo: 'Please close the function keys window for this first'].	self controlTerminate.	oldAutoLogin _ self autoLoginForSelection.	revisedAutoLogin _ self editAutoLoginFor: oldAutoLogin.	revisedAutoLogin == nil ifTrue: [^self].	(oldAutoLogin at: 1) asLowercase = (revisedAutoLogin at: 1) asLowercase ifFalse: "rename section"		[((autoLoginSection at: 1) findFirst: [:name | name asLowercase = (revisedAutoLogin at: 1) asLowercase]) = 0			ifFalse: [^self booboo: 'Error: There is already a section by that name'].		 aStream _ (FileStream fileNamed: theUser, '-FunctionKeyDefs' asFileName) readOnly.		 theKeys _ ConfigFileModel getSection: (oldAutoLogin at: 1) inStream: aStream.		 aStream close.		 ConfigFileModel replaceSection: (oldAutoLogin at: 1) inFile: theUser, '-functionKeyDefs' with: theKeys inSectionName: (revisedAutoLogin at: 1)].	(autoLoginSection at: 1) at: programIndex put: (revisedAutoLogin at: 1).	(autoLoginSection at: 2) at: programIndex put: (revisedAutoLogin at: 2).	(autoLoginSection at: 3) at: programIndex put: (revisedAutoLogin at: 3).	self fileOutAutoLoginSection.	self updateList.	"update the view's list and display it"	self controlInitialize!editKeys	| topView keyView statusView theLabel | 	programIndex = 0 ifTrue: [^view flash].	"no label selected"	self controlTerminate.	theLabel _ theUser, '''s ', (programList at: programIndex), ' function keys'.	self passControlToController: (self lookForLabel: theLabel).	(topView _ StandardSystemView new)		label: theLabel;		borderWidth: 1;		minimumSize: 80@330;		maximumSize: 300@660.	(statusView _ StringHolderView new)		model: (StringHolder new contents: String new);		controller: NoController new;		borderWidth: 1;		window: (0 @ 0 extent: 300 @ 44).	topView addSubView: statusView.	keyView _ FunctionKeyEditorController newWithStatusView: statusView forUser: theUser onSection: (programList at: programIndex).	keyView		window: (0 @ 0 extent: 300 @ 616);		borderWidth: 1.	topView addSubView: keyView below: statusView.	topView model: keyView model.	Cursor normal show.	topView controller open!pasteSection	| revisedAutoLogin | 	(FuncKeySectionBuffer at: 2) == nil ifTrue: [self createSection]. "nothing in buffer to paste"	self controlTerminate.	revisedAutoLogin _ self editAutoLoginFor: (FuncKeySectionBuffer at: 2).	self pasteFunctionKeysFrom: (FuncKeySectionBuffer at: 1) withLogin: revisedAutoLogin.	self controlInitialize! !!FunctionKeyEditor methodsFor: 'access'!list	^programList!listIndex	^programIndex!lookForLabel: theLabel	| theRightOne | 	Project top projectWindows scheduledControllers do:		[:each | (each isKindOf: StandardSystemController)					ifTrue: [each view label asLowercase = theLabel asLowercase ifTrue: [theRightOne _ each]]].	^theRightOne!toggleListIndex: anInteger	"If anInteger is the current view selection, deselect it.		Else make it the new selection."	programIndex _		(programIndex = anInteger			ifTrue: [0] ifFalse: [anInteger]).	self changed: #listIndex!updateList	self changed: #list.	self changed: #listIndex!updateStatus	"display contents of section copy buffer"	view topView subViews do:		[:v | (v isKindOf: StringHolderView) ifTrue:				[v model contents:						((FuncKeySectionBuffer at: 1) == nil							ifTrue: [String new]							ifFalse: [(FuncKeySectionBuffer at: 1) userAndProgram at: 2]).				 v updateDisplayContents]]!userWriteAccess	"return whether this user has write permission (either the owner or a wheel)"	^(theUser = UserName or: [Wheel])! !!FunctionKeyEditor methodsFor: 'initialize/release'!controlInitialize	super controlInitialize.	self initializeYellowButtonMenu.	self updateStatus!initialize	super initialize.	self initializeYellowButtonMenu!initializeYellowButtonMenu	(yellowButtonMenu == nil or: [self userWriteAccess])		ifTrue:			[self yellowButtonMenu: (FKEYellowButtonMenu at: 2)			 	yellowButtonMessages: (FKEYellowButtonMessages at: 2)]		ifFalse:			[self yellowButtonMenu: (FKEYellowButtonMenu at: 1)				 yellowButtonMessages: (FKEYellowButtonMessages at: 1)]!openOnUser: aUserName	| topView myView statusView theLabel theRightOne | 	theUser _ aUserName.	theLabel _ theUser, '''s OIT list'.	(self passControlToController: (self lookForLabel: theLabel)) ifTrue: [^self].	self initializeAutoLoginSection.	programList _ autoLoginSection at: 1.	programIndex _ 0.	(topView _ StandardSystemView new)		model: self;		label: theLabel;		borderWidth: 1;		minimumSize: 100@198;		maximumSize: 300@376.	(statusView _ StringHolderView new)		model: (StringHolder new contents: String new);		controller: NoController new;		borderWidth: 1;		window: (0 @ 0 extent: 300 @ 44).	topView addSubView: statusView.	(myView _ ListView new)		model: self controller: self;		borderWidth: 1;		window: (0@0 extent: 300@352);		list: programList.	topView addSubView: myView below: statusView.	Cursor normal show.	topView controller open!release	model _ nil.	super release! !DQueryListController comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.'!!DQueryListController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: DQueryYellowButtonMenu 		yellowButtonMessages: DQueryYellowButtonMessages! !!DQueryListController methodsFor: 'menu messages'!addQuery	| queryStringHolder |	self controlTerminate.	model fieldList size = 0		ifTrue: 			[self controlInitialize.			^self booboo: 'no fields to query with!!'].	queryStringHolder _ Querier				request: 'Enter your query:          '				withFields: model fieldList , #(classification )				types: model file fieldTypes , #(classification ).	queryStringHolder = nil | (queryStringHolder = '')		ifTrue: 			[self controlInitialize.			^false].	model queryList add: queryStringHolder.	model queryListIndex: model queryList size.	view getListAndDisplayView.	self controlInitialize.!deleteQuery	self controlTerminate.	model queryListIndex = 0 ifTrue: [^view flash].	model queryList remove: (model queryList at: model queryListIndex).	model queryListIndex: 0.	view getListAndDisplayView.	self controlInitialize!invertList	self controlTerminate.	model hitView controller invertList.	self controlInitialize!lastQuery	self controlTerminate.	model getFromPastList.	model hitListIndex: 0.	model hitView getListAndDisplayView.	model clearContents.	model textView updateDisplayContents.	self controlInitialize!query	self controlTerminate.	(model queryDatabase) ifFalse: [^self controlInitialize].	model hitListIndex: 0.	model hitView getListAndDisplayView.	model clearContents.	model textView updateDisplayContents.	self controlInitialize!queryVsPresent	self controlTerminate.	(model queryDatabaseAgainstPresentList) ifFalse: [^self controlInitialize].	model hitListIndex: 0.	model hitView getListAndDisplayView.	model clearContents.	model textView updateDisplayContents.	self controlInitialize!showAll	self controlTerminate.	model hitView controller showAll.	self controlInitialize!smashQueries	self controlTerminate.	model queryList: OrderedCollection new.	model queryListIndex: 0.	view getListAndDisplayView.	self controlInitialize!sortList	self controlTerminate.	model hitView controller sortList.	self controlInitialize! !!DQueryListController methodsFor: 'control activity'!changeModelSelection: anInteger	"Tell my model about a change of selection "	self controlTerminate.	anInteger = model queryListIndex		ifTrue: [model queryListIndex: 0]		ifFalse: [model queryListIndex: anInteger].	view moveSelectionBox: model queryListIndex.	self controlInitialize.! !DFieldListController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!DFieldListController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: DFieldYellowButtonMenu 		yellowButtonMessages: DFieldYellowButtonMessages! !!DFieldListController methodsFor: 'menu messages'!addNewField	self controlTerminate.	model closeAllSpawnedRecords; clearHitList.	Cursor wait showWhile: [model addNewField].	view getListAndDisplayView.	model clearContents.	model hitView getListAndDisplayView.	model textView updateDisplayContents.	self controlInitialize.!allFieldStat	| aString | 	self controlTerminate.	aString _ String new.	1 to: model fieldList size do:		[:index |		aString _ aString, 'The ', (model fieldList at: index) asString, ' field is a ',  (model file fieldLengths at: index) printString, ' character ', (model file fieldTypes at: index) asString, (String with: Character cr)].	aString _ aString copyFrom: 1 to: aString size - 1.	self booboo: aString.	self controlInitialize!changeFieldLength	model fieldListIndex = 0 ifTrue:[^view flash].	self controlTerminate.	model closeAllSpawnedRecords; changeFieldLength.	Cursor wait showWhile: [	model getFieldFromPresentList].	model clearContents.	model hitView getListAndDisplayView.	model textView updateDisplayContents.	self controlInitialize.!deleteField	model fieldListIndex = 0 ifTrue:[^view flash].	self controlTerminate.	model closeAllSpawnedRecords.	(self confirm: 'Deletion will permanently destroy the contents of this field.Are you sure you want to delete it?') ifFalse: [^self controlInitialize].	Cursor wait showWhile: [model deleteField].	model fieldListIndex: 0.	model clearContents.	model textView updateDisplayContents.	view getListAndDisplayView.	model hitView getListAndDisplayView.	self controlInitialize.!fieldStat	| index |	model fieldListIndex = 0 ifTrue:[^view flash].	self controlTerminate.	index _ model selectedFieldIndex.	index = 0		ifTrue: [view flash]		ifFalse: [self booboo:'Field name:  ', (model fieldList at: index) asString, 'Field length:  ', (model file fieldLengths at: index) printString, 'Field type:  ', (model file fieldTypes at: index) asString].	self controlInitialize!renameField	model fieldListIndex = 0 ifTrue:[^view flash].	self controlTerminate.	model closeAllSpawnedRecords.	model renameField.	model getFieldFromPresentList.	model clearContents.	model hitView getListAndDisplayView.	model textView updateDisplayContents.	self controlInitialize.! !!DFieldListController methodsFor: 'control activity'!changeModelSelection: anInteger 	"Tell my model about a possible change of selection"	| index |	index _ model fieldListIndex.	anInteger = index ifTrue: [^self].	self controlTerminate.	model fieldListIndex: anInteger.	view moveSelectionBox: model fieldListIndex.	model getFieldFromPresentList.	model hitView changeListAndDisplayView.	self controlInitialize! !DReportListController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!DReportListController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: DReportYellowButtonMenu 		yellowButtonMessages: DReportYellowButtonMessages! !!DReportListController methodsFor: 'menu messages'!addReport	| reportStringHolder | 		model fieldList size = 0 ifTrue: [self booboo: 'no fields to report on!!'. ^false].	self controlTerminate.	reportStringHolder _ (SimpleQuerier			request: 'Enter your report:          '			withFields: model fieldList, #(classification)).	(reportStringHolder = nil or: [reportStringHolder isEmpty]) ifTrue: [self controlInitialize. ^false].	model reportList add: reportStringHolder.	model reportListIndex: model reportList size. 	view getListAndDisplayView.	self controlInitialize.	^true!deleteReport	self controlTerminate.	model reportListIndex = 0		ifTrue: 			[self controlInitialize.			^view flash].	model reportList remove: (model reportList at: model reportListIndex).	model reportListIndex: 0.	view getListAndDisplayView.	self controlInitialize!invertList	self controlTerminate.	model hitView controller invertList.	self controlInitialize!report	| mySuitcase dataItem annoModel aSuitcase | 	"do the query"	self controlTerminate.	mySuitcase _ view topView suitcase.	dataItem _ DataItem locked: mySuitcase dataItem isLocked classification: mySuitcase classification classification modifiers: mySuitcase classification modifiers type: #Item label: 'Report from ', mySuitcase dataItem label filename: (Disk makeNewFileName: #TMPV asString, UserName withSuffix: (DataMaster giveMe: #suffixString for: #text asString)) bPointers: nil fPointers: nil atIndex: 0.	(model report: dataItem update: mySuitcase)		ifFalse: [view flash]		ifTrue:			[annoModel _ AnnotationModel fileStream: (HeaderFileStream fileNamed: dataItem filename) withSuitcase: (aSuitcase _ Suitcase new packTheSuitcaseFrom: mySuitcase centerName forItem: dataItem).			annoModel lock. "so they can't close it without warning"			annoModel withSuitcase: (aSuitcase spare: mySuitcase spare) defaultSize: 486@550].	self controlInitialize!showAll	self controlTerminate.	model hitView controller showAll.	self controlInitialize!smashReports	self controlTerminate.	model reportList: OrderedCollection new.	model reportListIndex: 0.	view getListAndDisplayView.	self controlInitialize!sortList	self controlTerminate.	model hitView controller sortList.	self controlInitialize! !!DReportListController methodsFor: 'control activity'!changeModelSelection: anInteger	"Tell my model about a change of selection "	self controlTerminate.	anInteger = model reportListIndex		ifTrue: [model reportListIndex: 0]		ifFalse: [model reportListIndex: anInteger].	view moveSelectionBox: model reportListIndex.	self controlInitialize.! !DHitListController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!DHitListController methodsFor: 'initialize-release'!initialize	super initialize.	self yellowButtonMenu: DHitYellowButtonMenu yellowButtonMessages: TreeMenu! !!DHitListController methodsFor: 'menu messages'!chartDatabase	| answers dataArray labelArray dataCollection theFile dataType theChart stackLabels tempDataArray temp theData |	(Smalltalk includesKey: #ChartEditor)		ifFalse: [^self booboo: 'charts are not in this system'].	model recordList isEmpty | (model recordList = nil) ifTrue: [^view flash].	(answers _ self chartDBox) == nil ifTrue: [^view flash].	(answers at: 2) == nil | ((answers at: 3) == nil) 		ifTrue: [^self booboo: 'no label or value to work with.'].	self controlTerminate.	dataArray _ OrderedCollection new.	labelArray _ OrderedCollection new.	dataCollection _ self parseValue: (answers at: 3).	theFile _ model file.	model recordList do: [:eachRecord | 		labelArray 			add: (theFile record: eachRecord 			field: (answers at: 2))].	dataCollection size > 1		ifTrue: 			[dataType _ #stacked.			theChart _ StackedBarChart new.			stackLabels _ dataCollection.			model recordList do: 				[:eachRecord | 				tempDataArray _ OrderedCollection new.				dataCollection do: [:eachField | 					tempDataArray add: (theFile record: eachRecord field: eachField asSymbol)].					dataArray add: tempDataArray]]		ifFalse: 			[dataType _ #single.			theChart _ BarChart new.			model recordList do: [:eachRecord | 				dataArray add: (theFile record: eachRecord field: (dataCollection at: 1) asSymbol)]].	theChart isAutoScaled: true; 		isFilled: true; 		isLabeled: true; 		isLegended: true; 		labeledByPercent: false.	(answers at: 1) = #yes		ifTrue: 			["compress data"			(temp _ OrderedCollection new) add: labelArray; add: dataArray.			temp _ self compressData: temp.			labelArray _ temp at: 1.			dataArray _ temp at: 2].	(theData _ OrderedCollection new) add: 'Untitled'; add: dataArray; add: (model stripSpaces: labelArray); add: (model stripSpaces: stackLabels); add: theChart; add: nil; add: dataType.	self openChart: theData!clearList	self controlTerminate.	model clearHitList.	model hitView getListAndDisplayView.	model textView updateDisplayContents.	self controlInitialize!cloneDataBase	| theArray mySuitcase |	self controlTerminate.	mySuitcase _ view topView suitcase.	theArray _ InformationCenter fileNameData: #database defaultSuitcase: mySuitcase defaultKeys: (mySuitcase center keywordStringFor: mySuitcase dataItem) askMethod: true askClass: true.	(theArray at: 1) == nil		ifTrue: [view flash]		ifFalse: [Cursor execute showWhile: [model cloneDataBase: (theArray at: 1)].				InformationCenter putFileNameAway: theArray].	self controlInitialize!compressDatabase	| sysView theClass | 	"undelete the selected record"	self controlTerminate.	model closeAllSpawnedRecords.	Cursor execute showWhile: [model compressDatabase].	view getListAndDisplayView.	model textView updateDisplayContents.	self controlInitialize!deletedRecords	"undelete the selected record"	self controlTerminate.	model getDeletedRecords.	model hitListIndex: 0.	view getListAndDisplayView.	self controlInitialize!deleteRecord	| index | 	"delete the selected record"	(index _ model hitListIndex) = 0 ifTrue:[^view flash].	self controlTerminate.	model file deleteRecord: (model recordList at: index).	model recordList removeObjectAt: index.	model hitList removeObjectAt: index.	model hitListIndex: 0.	model hitView getListAndDisplayView.	"view removeCurrentSelection."	model clearContents.	model textView updateDisplayContents.	self controlInitialize.!dumpEntryForm	"spawn the selected record into a form window"	| index | 	self controlTerminate.	model dumpEntryForm.	self controlInitialize.!invertList	self controlTerminate.	model inverseSortList.	view getListAndDisplayView.	model hitListIndex: 0.	model clearContents.	model textView updateDisplayContents.	self isControlActive ifTrue: [self controlInitialize]!showAll	self controlTerminate.	model getAllRecords		ifTrue:			[view getListAndDisplayView.			model clearContents.			model hitListIndex: 0.			model textView updateDisplayContents]		ifFalse: [view flash].	self isControlActive ifTrue: [self controlInitialize]!sortList	self controlTerminate.	model sortList.	view getListAndDisplayView.	model hitListIndex: 0.	model clearContents.	model textView updateDisplayContents.	self isControlActive ifTrue: [self controlInitialize]!spawnRecord	"spawn the selected record into a form window"	| index | 	(index _ model hitListIndex) = 0 ifTrue:[^view flash].	self controlTerminate.	model showRecordForm.	self controlInitialize.!undeleteRecord	"undelete the selected record"	| index |	(index _ model hitListIndex) = 0 ifTrue: [^view flash].	self controlTerminate.	model file undeleteRecord: (model recordList at: index).	model recordList removeObjectAt: index.	model hitList removeObjectAt: index.	model hitListIndex: 0.	view removeCurrentSelection.	model clearContents.	model textView updateDisplayContents.	self controlInitialize! !!DHitListController methodsFor: 'control activity'!changeModelSelection: anInteger	"Tell my model about a change of selection "	self controlTerminate.	anInteger = model hitListIndex		ifTrue: [model hitListIndex: 0]		ifFalse: [model hitListIndex: anInteger].	view moveSelectionBox: model hitListIndex.	model setContents.	model textView updateDisplayContents.	self controlInitialize.! !!DHitListController methodsFor: 'private'!chartDBox	| labelCollection tempCollection defaultCollection fieldList fieldTypes |	fieldList _ model fieldList. 	fieldTypes _ model file fieldTypes.	labelCollection _ #(#('Compress?' yes no)) asOrderedCollection.	tempCollection _ #(Labels:) asOrderedCollection.	tempCollection addAllLast: fieldList.	labelCollection add: tempCollection.	labelCollection add: #(Value:).	defaultCollection _ OrderedCollection new.	tempCollection _ OrderedCollection new.	1 to: fieldList size do: [:i | (fieldTypes at: i) = #number ifTrue: [tempCollection add: (fieldList at: i)]].	defaultCollection add: #no; add: nil; add: tempCollection.	^DBoxView openFor: #(select select multiple) title: 'Chart Data' 	labels: labelCollection defaults: defaultCollection!compressData: aCollection	| tempLabelArray tempDataArray labelArray dataArray eachLabel where temp |	tempLabelArray _ OrderedCollection new.	tempDataArray _ OrderedCollection new.	labelArray_ aCollection at: 1.	dataArray_ aCollection at: 2.	1 to: labelArray size do: [:each| eachLabel _ labelArray at: each.		(tempLabelArray includes: eachLabel)			ifTrue: [where _ tempLabelArray find: eachLabel.				temp _ tempDataArray basicAt: where.				(temp isKindOf: OrderedCollection)	"stacked data"	ifTrue:[1 to: temp size do: [:index| temp at: index put: (temp at: index) + ((dataArray at: each) at: index)]]	"single data"	ifFalse:[temp _ temp + (dataArray at: each)].					tempDataArray basicAt: where put: temp]			ifFalse:[tempLabelArray add: eachLabel.				tempDataArray add: (dataArray at: each)]].	^ (Array with: tempLabelArray with: tempDataArray) asOrderedCollection!openChart: theData	| mySuitcase myDataItem newSuitcase | 	(Smalltalk includesKey: #ChartEditor) ifFalse: [^self booboo: 'Chart tool is not installed'].	self controlTerminate.	mySuitcase _ view topView suitcase.	myDataItem _ mySuitcase dataItem.	newSuitcase _ Suitcase new packTheSuitcaseFrom: mySuitcase centerName forItem: (DataItem locked: myDataItem isLocked classification: mySuitcase classification classification modifiers: mySuitcase classification modifiers type: myDataItem type label: 'New Chart' filename: nil bPointers: nil fPointers: nil atIndex: 0).	ChartEditor createNewImageOnForm: (Form extent: Rectangle fromUser extent) withSuitcase: newSuitcase andData: theData!parseValue: aString 	| newIndex oldIndex tempString tempArray |	tempArray _ OrderedCollection new.	newIndex _ 1.	oldIndex _ 1.	[newIndex <= aString size]		whileTrue: 			[newIndex _ aString findString: ' ' startingAt: oldIndex.			newIndex = 0 ifTrue: [newIndex _ aString size + 1].			tempString _ aString copyFrom: oldIndex to: newIndex - 1.			(tempArray includes: tempString)				ifFalse: [tempArray add: tempString].			oldIndex _ newIndex + 1].	^tempArray! !AutoBookListController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!AutoBookListController methodsFor: 'initialize'!initialize	super initialize.	self initializeYellowButtonMenu!initializeYellowButtonMenu	self 		yellowButtonMenu: ABListYellowButtonMenu		yellowButtonMessages: ABListYellowButtonMessages!redButtonActivity		model isLocked		ifTrue:[view flash]		ifFalse:[super redButtonActivity].!yellowButtonActivity		model isLocked		ifTrue:[view flash]		ifFalse:[super yellowButtonActivity].! !FirstABListController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!FirstABListController methodsFor: 'private'!changeModelSelection: anInteger	"Tell my model about a change of selection "	self controlTerminate.	model toggleFirstListIndex: anInteger.	self controlInitialize.!redButtonActivity	model isLocked		ifTrue:[view flash]		ifFalse:[ model changedFlag = true			ifTrue:[self controlTerminate.				model writeCountryData.				self controlInitialize.].			super redButtonActivity].! !!FirstABListController methodsFor: 'menu messages'!addEntry	(model mapSection = 0) ifTrue:[^view flash].	self controlTerminate.	model addCountry.	self controlInitialize.!copyEntry		(model firstListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model copyCountry.	self controlInitialize.!cutEntry	(model firstListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model cutCountry.	self controlInitialize.!deleteEntry		(model firstListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model deleteCountry.	self controlInitialize.!editEntry	(model firstListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model editCountry.	self controlInitialize.!pasteEntry		self controlTerminate.	model pasteCountry.	self controlInitialize.!showAll	(model firstListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model showAllCountry.	self controlInitialize.! !ThirdABListController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ThirdABListController methodsFor: 'private'!changeModelSelection: anInteger	"Tell my model about a change of selection "	self controlTerminate.	model toggleThirdListIndex: anInteger.	self controlInitialize.! !!ThirdABListController methodsFor: 'menu messages'!addEntry	"add a sub chapter to this chapter"	(model secondListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model addSubChapter.	self controlInitialize.!copyEntry	"copy the selected sub-chapter to this chapter"	(model thirdListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model copySubChapter.	self controlInitialize.!cutEntry	"cut the selected sub-chapter to this chapter"	(model thirdListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model cutSubChapter.	self controlInitialize.!editEntry	"cut the selected sub-chapter to this chapter"	(model thirdListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model editSubChapter.	self controlInitialize.!pasteEntry	"paste a sub chapter to this chapter"	(model secondListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model pasteSubChapter.	self controlInitialize.!showAll	(model thirdListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model showSubChapter.	self controlInitialize.! !SecondABListController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!SecondABListController methodsFor: 'private'!changeModelSelection: anInteger	"Tell my model about a change of selection "	self controlTerminate.	model toggleSecondListIndex: anInteger.	self controlInitialize.! !!SecondABListController methodsFor: 'menu messages'!addEntry	"add a chapter to this section"	(model firstListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model addChapter.	self controlInitialize.!copyEntry	"copy the selected chapter"	(model secondListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model copyChapter.	self controlInitialize.!cutEntry	"cut the selected chapter from this section"	(model secondListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model cutChapter.	self controlInitialize.!editEntry	"edit the selected chapter heading"	(model secondListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model editChapter.	self controlInitialize.!pasteEntry	"paste the selectedchapter to this chapter"		(model firstListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model pasteChapter.	self controlInitialize.!showAll	(model secondListIndex = 0) ifTrue:[^view flash].	self controlTerminate.	model showAllChapter.	self controlInitialize.! !FormsController comment:'Copyright (c) 1986, 1987 Xerox Corporation.  All rights reserved.'!!FormsController methodsFor: 'initialize-release'!initialize	super initialize.	swappedOut _ false.	self yellowButtonMenu: FormsYellowButtonMenu 		yellowButtonMessages: FormsYellowButtonMessages! !!FormsController methodsFor: 'control activity'!controlActivity	(sensor redButtonPressed & self viewHasCursor) | Clicks hasClick		ifTrue: [^self redButtonActivity].	sensor yellowButtonPressed & self viewHasCursor 		ifTrue: [^self yellowButtonActivity]!defaultDisabledAction: anElement	"may be used by elements to determine what to do if they are selected when they are disabled.	Default here is to do nothing.  Some menus may wish to do anElement toggle to enable it.	Individual subclass element types may very well choose not to call this, but by using this, the behavior of all the standard type elements in a menu can be modified without having to subclass each type" 	^anElement!isControlActive	swappedOut ifTrue:[model _ nil. view _ nil. ^false].	^(view containsPoint: sensor cursorPoint) & sensor blueButtonPressed not!redButtonActivity	| element point |	Clicks hasClick		ifTrue: [point _ Clicks lastClick]		ifFalse: [point _ sensor cursorPoint].	(element _ view elementForPoint: point) == nil		ifFalse: 			[element redButtonAt: point - view insetDisplayBox origin]!yellowButtonActivity	| element point |	sensor leftShiftDown ifTrue:[^super yellowButtonActivity].	(element _ view elementForPoint: (point _ sensor cursorPoint)) == nil 		ifFalse:	[element yellowButtonAt: point - view insetDisplayBox origin]! !!FormsController methodsFor: 'example support'!choose	(self confirm: 'Neat, isn''t it?')		ifTrue: [self booboo: 'What do you know, anyway?']		ifFalse: [self booboo: 'Oh yeah? Well, you''re no prize yourself, kid!!']!flash	view flash!reverse	view highlight! !!FormsController methodsFor: 'menu messages'!accept	model setInitialValues!clipContents	Clipboard clip: model fillElementsString asText.	(Smalltalk includesKey: #Suitcase)		ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]!clipForm	Clipboard clip: model copy.	(Smalltalk includesKey: #Suitcase)		ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]!edit	| newController |	Cursor execute		showWhile: 			[newController _ FormsEditController new.			view controller: newController.			model updateControllers: newController.			model elements do: [:element | (element isKindOf: ExecuteElement)					ifTrue: [element targetController == self ifTrue: [element targetController: newController]]].			swappedOut _ true]!save	model save! !DatabaseFormsController comment:'Copyright (c) 1987 Xerox Corporation.  All rights reserved.'!!DatabaseFormsController methodsFor: 'menu messages'!addDatabaseRecord	| theRecord database recordNumber | 	self accept.	theRecord _ model fillElementsDict.	database _ ClassifiedFixedFileStream fileNamed: (view topView suitcase spare at: 1).	database constructRecordFrom: theRecord.	recordNumber _ database numberOfRecords.	view topView suitcase spare at: 2 put: recordNumber.	database classifyRecord: recordNumber with: (view topView suitcase classification).	database close!edit	| newController |	Cursor execute		showWhile: 			[newController _ DatabaseFormsEditController new.			view controller: newController.			model updateControllers: newController.			model elements do: [:element | (element isKindOf: ExecuteElement)					ifTrue: [element targetController == self ifTrue: [element targetController: newController]]].			swappedOut _ true]!editDatabaseRecord	| theRecord database recordNumber | 	self accept.	theRecord _ model fillElementsDict.	database _ ClassifiedFixedFileStream fileNamed: (view topView suitcase spare at: 1).	recordNumber _ view topView suitcase spare at: 2.	database replaceRecord: recordNumber from: theRecord.	database classifyRecord: recordNumber with: (view topView suitcase classification).	database close!getDatabaseRecord	| databaseStream fieldValue newValue recordClassification | 	databaseStream _ ClassifiedFixedFileStream fileNamed: (view topView suitcase spare at: 1).	databaseStream record: (view topView suitcase spare at: 2).	model elements do: [:theElement | (theElement isKindOf: FillElement)		ifTrue: [fieldValue _ (databaseStream fieldFromThisRecord: theElement name asSymbol).				newValue _ ((fieldValue isKindOf: String)					ifTrue:[fieldValue stripLeadingAndTrailingSpaces]					ifFalse:[fieldValue printString]) asText.			theElement initialValue: newValue ]].	recordClassification _ databaseStream classificationFromThisRecord.	view topView suitcase changeClassification: recordClassification.	view topView classifyLabel: recordClassification.	databaseStream close.	view resetDisplayCache; displayView.	view topView displayClassification!save	model save! !LockedFormsController comment:'Copyright (c) 1986 Xerox Corporation.  All rights reserved.'!!LockedFormsController methodsFor: 'control activity'!yellowButtonActivity	| element point |	(element _ view elementForPoint: (point _ sensor cursorPoint)) == nil 		ifFalse:	[element yellowButtonAt: point - view insetDisplayBox origin]! !SpreadsheetController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!SpreadsheetController methodsFor: 'initialize-release'!checkCopyBuffer	SpreadsheetCopyBuffer == nil ifTrue: [SpreadsheetCopyBuffer _ model nilCell]!initialize	super initialize.	yellowButtonMenu _ YellowButtonMenu.	yellowButtonMessages _ YellowButtonMessages.	selectionPoint _ 0@0.	saveFile == nil ifTrue: [saveFile _ 'Default.Sheet']!release	self nilFields.	super release! !!SpreadsheetController methodsFor: 'accessing'!displayModeView	^displayModeView!displayModeView: aView	displayModeView _ aView!inputView	^inputView!inputView: aView	inputView _ aView!pointModeView	^pointModeView!pointModeView: aView	pointModeView _ aView!saveFile: aFileName	saveFile _ aFileName!selectionPoint	^selectionPoint!selectionPoint: newSelectionPoint	^selectionPoint _ newSelectionPoint!updateModeView	^updateModeView!updateModeView: aView	updateModeView _ aView! !!SpreadsheetController methodsFor: 'basic control sequence'!controlInitialize	inputView controller controlInitialize!controlTerminate	inputView controller controlTerminate! !!SpreadsheetController methodsFor: 'control defaults'!controlActivity	"Pass control to the inputView controller upon keyboard input."	sensor keyboardPressed		ifTrue: [^inputView controller processKeyboard].	super controlActivity!isControlActive	^self viewHasCursor & sensor blueButtonPressed not! !!SpreadsheetController methodsFor: 'menu messages'!clearCell	"Clear the value and rule for all cells in the selection, breaking dependencies."	| cell |	(selectionPoint isKindOf: Rectangle)		ifTrue: 		"multiple cells selected"			[view clearHighlight: selectionPoint.			"inform all cells top be cleared of impending clear"			selectionPoint origin x to: selectionPoint corner x do: [:i | selectionPoint origin y to: selectionPoint corner y do: 					[:j | 					cell _ model atPoint: i @ j.					cell == model nilCell ifFalse: [cell updateFlag: true]]].			"reset all cells in selection"			selectionPoint origin x to: selectionPoint corner x do: [:i | selectionPoint origin y to: selectionPoint corner y do: 					[:j | 					cell _ model atPoint: i @ j.					cell == model nilCell ifFalse: [cell reset.  view blacken: (i @ j corner: i @ j)]]]]		ifFalse: 		"single cell selected"			[selectionPoint = (0 @ 0) ifTrue: [^view flash].			view clearHighlight: selectionPoint.			cell _ model atPoint: selectionPoint.			view blacken: (selectionPoint corner: selectionPoint).			cell == model nilCell				ifFalse: 					[cell updateFlag: true.					cell reset]].	"display cells and stabilize views"	model displayUpdates.	"view setForm."	view setHighlight: selectionPoint.	inputView controller updateView!copy	"copy the cells selected into the SpreadsheetCopyBuffer"	| cell contentsBuffer |	selectionPoint = (0 @ 0) ifTrue: [^view flash].	view clearHighlight: selectionPoint.	(selectionPoint class == Rectangle and: [selectionPoint origin = selectionPoint corner])		ifTrue: [selectionPoint _ selectionPoint origin].	selectionPoint class == Rectangle		ifTrue: 			[SpreadsheetCopyBuffer _ model copyFromPoint: selectionPoint origin toPoint: selectionPoint corner.			contentsBuffer _ model contentsFromPoint: selectionPoint origin toPoint: selectionPoint corner.			ParagraphEditor copyText: contentsBuffer copyString asText.			(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification].			(Smalltalk includesKey: Clipboard) ifTrue:				[Clipboard clip: (Form fromDisplay: (model boxAt: selectionPoint)).				(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]]]		ifFalse: 			[SpreadsheetCopyBuffer _ (model atPoint: selectionPoint) deepCopy.			((SpreadsheetCopyBuffer contents isKindOf: DisplayObject)				| (SpreadsheetCopyBuffer contents isKindOf: Chart)) & (Smalltalk includesKey: Clipboard)				ifTrue: [Clipboard clip: (Form fromDisplay: (SpreadsheetCopyBuffer boxAt: selectionPoint)).						(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]]				ifFalse: [ParagraphEditor copyText: SpreadsheetCopyBuffer contents printString asText.						(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]]].	view setHighlight: selectionPoint!cut	"cut the cells selected into the SpreadsheetCopyBuffer, removing them from the sheet"	| cell |	selectionPoint = (0@0) ifTrue:[^view flash].	view clearHighlight: selectionPoint.	(selectionPoint isKindOf: Rectangle)		ifFalse:[SpreadsheetCopyBuffer _ (model atPoint: selectionPoint) deepCopy.		(SpreadsheetCopyBuffer contents isKindOf: DisplayObject) | (SpreadsheetCopyBuffer contents isKindOf: Chart)			ifTrue: [(Smalltalk includesKey: Clipboard) ifTrue:					[ImageEditor clip: (Form fromDisplay: (SpreadsheetCopyBuffer boxAt: selectionPoint)).					(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]]]			ifFalse: [ParagraphEditor copyText: SpreadsheetCopyBuffer contents printString asText.					(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]]]		ifTrue: [SpreadsheetCopyBuffer _ model copyFromPoint: selectionPoint origin toPoint: selectionPoint corner].	view setHighlight: selectionPoint.	self clearCell!details	"open linked sheets to selected cells"	| cell |	self controlTerminate.	selectionPoint = (0 @ 0)		ifTrue: 			[self controlInitialize.			^view flash]		ifFalse: [(selectionPoint isKindOf: Rectangle)				ifTrue: 					[selectionPoint origin x to: selectionPoint corner x do: [:i | selectionPoint origin y to: selectionPoint corner y do: 							[:j | 							cell _ model atPoint: i @ j.							cell details.							cell displayDependents]]]				ifFalse: 					[cell _ model atPoint: selectionPoint.					cell details]].	self controlInitialize!displayLinks	"draw links across entire sheet"	| cell |	selectionPoint = (0 @ 0)		ifTrue: 			[model do: [:cell |					cell displayReferences].			Sensor waitButton.			model do: [:cell |					cell displayReferences]]		ifFalse: [(selectionPoint isKindOf: Rectangle)				ifTrue: 					[selectionPoint origin x to: selectionPoint corner x do: [:i | selectionPoint origin y to: selectionPoint corner y do: 							[:j | 							cell _ model atPoint: i @ j.							cell displayReferences.							cell displayDependents]].					Sensor waitButton.					selectionPoint origin x to: selectionPoint corner x do: [:i | selectionPoint origin y to: selectionPoint corner y do: 							[:j | 							cell _ model atPoint: i @ j.							cell displayReferences.							cell displayDependents]]]				ifFalse: 					[cell _ model atPoint: selectionPoint.					cell displayReferences.					cell displayDependents.					Sensor waitButton.					cell displayReferences.					cell displayDependents]]!hardcopy	self controlTerminate.	model hardcopy: (view topView suitcase).	self controlInitialize!paste	"paste the cells in the SpreadsheetCopyBuffer back into the sheet"	| selectedPoint dependents clipFlag cell |	selectionPoint = (0@0) ifTrue: [^view flash].	(selectionPoint isKindOf: Rectangle)		ifTrue: 			[selectedPoint _ selectionPoint origin.			clipFlag _ true]		ifFalse: 			[selectedPoint _ selectionPoint.			clipFlag _ false].	(SpreadsheetCopyBuffer isKindOf: Matrix)		ifTrue: [model				paste: SpreadsheetCopyBuffer deepCopy				atPoint: selectedPoint				clippingSize: (clipFlag						ifTrue: [selectionPoint extent + 1]						ifFalse: [SpreadsheetCopyBuffer xySize])]		ifFalse: [(selectionPoint isKindOf: Rectangle)				ifTrue: [selectionPoint origin x to: selectionPoint corner x do: [:i | 					selectionPoint origin y to: selectionPoint corner y do: 							[:j | 							dependents _ (model atPoint: i @ j) dependents.							model atPoint: i @ j put: (SpreadsheetCopyBuffer = model nilCell									ifTrue: [model nilCell]									ifFalse: [SpreadsheetCopyBuffer deepCopy]).							dependents do: [:each | (model atPoint: i @ j)									addDependent: each].							(model atPoint: i @ j) xcell: i; ycell: j; setRuleDependencies]]]				ifFalse: 					[dependents _ (model atPoint: selectedPoint) dependents.					model atPoint: selectedPoint put: (SpreadsheetCopyBuffer = model nilCell							ifTrue: [model nilCell]							ifFalse: [SpreadsheetCopyBuffer deepCopy]).					dependents do: [:each | (model atPoint: selectedPoint)							addDependent: each].					cell _ (model atPoint: selectedPoint).					cell xcell: selectedPoint x.					cell ycell: selectedPoint y.					cell setRuleDependencies]].	self updateCell.	model displayUpdates!redButtonActivity	| noSelectionMovement oldSelectionPoint trialSelectionPoint trialPoint nilCell topLeftPoint topLeftCell trialCell scrollFlag rowMarker colMarker |	sensor leftShiftDown ifTrue: [^self shiftRedButtonActivity].	topLeftPoint _ sensor cursorPoint.	nilCell _ model nilCell.	noSelectionMovement _ true.	oldSelectionPoint _ selectionPoint.	topLeftCell _ model pointAt: topLeftPoint.	rowMarker _ colMarker _ false.	topLeftPoint x < (view insetDisplayBox left + 30) ifTrue:[topLeftCell x: 1].	topLeftPoint y < (view insetDisplayBox top + 30) ifTrue:[topLeftCell y: 1].	scrollFlag _ false.	((view insetDisplayBox origin extent: 30 @ 30)		containsPoint: topLeftPoint)		ifTrue: [^self scrollActivity].	[sensor redButtonPressed]		whileTrue: 			[trialPoint _ sensor cursorPoint.			trialCell _ model pointAt: trialPoint.			trialPoint x < (view insetDisplayBox left + 30) ifTrue:[trialCell x: model xSize].			trialPoint y < (view insetDisplayBox top + 30) ifTrue:[trialCell y: model ySize].			trialCell x = 0 | (trialCell y = 0) ifTrue: [trialSelectionPoint = nil ifFalse: [view clearHighlight: trialSelectionPoint]].			trialCell x = 0				ifTrue: 					[trialCell x: view scrollRight.					scrollFlag _ true].			trialCell y = 0				ifTrue: 					[trialCell y: view scrollDown.					scrollFlag _ true].			trialSelectionPoint _ topLeftCell corner: trialCell.			view moveHighlight: trialSelectionPoint.			"replace zero extent rectangle with point"			trialSelectionPoint origin = trialSelectionPoint corner ifTrue: [trialSelectionPoint _ trialSelectionPoint origin].			trialSelectionPoint ~= oldSelectionPoint ifTrue: [noSelectionMovement _ false]].	"nil selection becomes top left cell selected"	trialSelectionPoint = nil ifTrue:[trialSelectionPoint _ topLeftCell].	"select entire row if row marker tapped""	trialSelectionPoint class == Point & rowMarker ifTrue:[trialSelectionPoint _ (1 @ topLeftCell y) corner: (model xSize @ topLeftCell y).  view moveHighlight: trialSelectionPoint]. 	trialSelectionPoint class == Point & colMarker ifTrue:[trialSelectionPoint _ (topLeftCell x @ 1) corner: (topLeftCell x @ model ySize).  view moveHighlight: trialSelectionPoint]. "	"deselect on identical selection"	(trialSelectionPoint = oldSelectionPoint and: [noSelectionMovement])		ifTrue: 			[trialSelectionPoint = (0 @ 0) ifFalse: [view clearHighlight: oldSelectionPoint].			selectionPoint _ 0 @ 0]		ifFalse: [selectionPoint _ trialSelectionPoint].	inputView model isLocked ifTrue: [inputView controller cancel].	inputView controller updateView!ruleCopy	"copy the selected box's rule"	selectionPoint = (0@0) ifTrue: [^view flash].	SpreadsheetRuleBuffer _ (model atPoint: selectionPoint) rule!rulePaste	"paste the selected box's rule"	| cell |	selectionPoint = (0 @ 0) ifTrue: [^view flash].	view clearHighlight: selectionPoint.	(selectionPoint isKindOf: Rectangle)		"multiple selections, paste rule into each cell"		ifTrue: [selectionPoint origin x to: selectionPoint corner x do: 				[:i | selectionPoint origin y to: selectionPoint corner y do: 					[:j | 					cell _ model atPoint: i @ j.					cell = model nilCell ifTrue: [cell _ model initCellAt: i @ j].					cell removeOldRule.					cell rule: SpreadsheetRuleBuffer.					cell setRuleDependencies.					cell addUpdate.					cell evaluate]]]		ifFalse: 		"single selection, paste rule into cell"			[cell _ model atPoint: selectionPoint.			cell = model nilCell ifTrue: [cell _ model initCellAt: selectionPoint].			cell removeOldRule.			cell rule: SpreadsheetRuleBuffer.			cell setRuleDependencies.			cell addUpdate.			cell evaluate].	model displayUpdates.	view setHighlight: selectionPoint.	inputView controller updateView!save	"save the spreadsheet to the file specified"	| aSuitcase |	self controlTerminate.	(Smalltalk includesKey: #Suitcase) ifTrue: [(aSuitcase _ view topView suitcase) == nil ifFalse: [aSuitcase accept]].	model fileOutOn: saveFile withSuitcase: aSuitcase.	self controlInitialize!shiftRedButtonActivity	"Allow user to point at a cell while writing a rule. return reference for 	requested cell(s)"	| newCellPoint trialPoint x1String y1String x2String y2String refString topLeftPoint selectedPoint topLeftCell trialCell scrollFlag |	topLeftPoint _ sensor cursorPoint.	"check for row or column size change request"	topLeftPoint x - view insetDisplayBox left < 30 & (topLeftPoint y - view insetDisplayBox top > 30) 		ifTrue: [^self rowActivity].	topLeftPoint y - view insetDisplayBox top < 30 & (topLeftPoint x - view insetDisplayBox left > 30) 		ifTrue: [^self columnActivity].	"determine point or rectangle being requested"	selectionPoint = (0@0) ifTrue: [^nil].	newCellPoint _ 0 @ 0 extent: 0 @ 0.	scrollFlag _ false.	view clearHighlight: selectionPoint.	selectionPoint class == Rectangle		ifTrue: [selectedPoint _ selectionPoint origin]		ifFalse: [selectedPoint _ selectionPoint].	topLeftCell _ model pointAt: topLeftPoint.	[sensor redButtonPressed]		whileTrue: 			[trialCell _ model pointAt: sensor cursorPoint.			trialCell x = 0 | (trialCell y = 0) ifTrue: [newCellPoint = nil ifFalse: [view clearHighlight: newCellPoint]].			"scroll view if user pulls off right or bottom"			trialCell x = 0 ifTrue: 				[trialCell x: view scrollRight.				scrollFlag _ true.				].			trialCell y = 0 ifTrue: 				[trialCell y: view scrollDown.				scrollFlag _ true.				].			newCellPoint _ topLeftCell corner: trialCell.			view moveHighlight: newCellPoint].	view moveHighlight: selectionPoint.	"construct reference, either relative or absolute"	pointModeView selector = #relative		ifTrue: 			[x1String _ (newCellPoint left - selectedPoint x) printString.			x1String asNumber > 0 ifTrue: [x1String _ '+' , x1String].			y1String _ (newCellPoint top - selectedPoint y) printString.			y1String asNumber > 0 ifTrue: [y1String _ '+' , y1String].			x2String _ (newCellPoint right - selectedPoint x) printString.			x2String asNumber > 0 ifTrue: [x2String _ '+' , x2String].			y2String _ (newCellPoint bottom - selectedPoint y) printString.			y2String asNumber > 0 ifTrue: [y2String _ '+' , y2String]]		ifFalse: 			[x1String _ newCellPoint left printString.			y1String _ newCellPoint top printString.			x2String _ newCellPoint right printString.			y2String _ newCellPoint bottom printString].	newCellPoint origin = newCellPoint corner		ifTrue: [refString _ ' {R' , y1String , 'C' , x1String , '} ']		ifFalse: [refString _ ' {R' , y1String , 'C' , x1String , ':R' , y2String , 'C' , x2String , '} '].	newCellPoint = (0 @ 0) ifFalse: [inputView controller read: refString]!updateCell	"Bring cell and its dependents up to date."	selectionPoint = (0@0) ifTrue: [^view flash].	view clearHighlight: selectionPoint.	(selectionPoint isKindOf: Rectangle) 		ifFalse:[(model atPoint: selectionPoint) userUpdate]		ifTrue:[ 			selectionPoint origin x to: selectionPoint corner x do: [:i |				selectionPoint origin y to: selectionPoint corner y do: [:j |			 		(model atPoint: i@j) userUpdate: i@j]]].	model displayUpdates.	"view setForm."	view setHighlight: selectionPoint.	inputView controller updateView!updateSheet	"Bring entire sheet up to date."	| cell |	selectionPoint = (0@0)		ifFalse:			[view clearHighlight: selectionPoint.			selectionPoint _ 0@0].	model do: [:cell | cell addUpdate].	model displayUpdates.	inputView controller updateView! !!SpreadsheetController methodsFor: 'private'!columnActivity	"set the height of a column"	| columnNumber columnTop addNumber thisPoint oldPoint columnBottom |	columnNumber _ (model gridPointClosestTo: sensor cursorPoint) x.	columnTop _ (model xGrid at: columnNumber)				- (model originOf: view offsetPoint) x + view insetDisplayBox origin x + 30.	columnBottom _ (model originOf: columnNumber @ 1) x - (model originOf: view offsetPoint) x + view insetDisplayBox origin x + 30.	thisPoint _ columnTop - 1 @ view insetDisplayBox origin y.	Cursor blank show.	[sensor redButtonPressed]		whileTrue: 			[oldPoint _ thisPoint.			thisPoint _ sensor cursorPoint.			thisPoint x - columnBottom < 25 ifTrue: [thisPoint x: columnBottom + 25].			addNumber _ thisPoint x - columnTop.			Display				fill: (oldPoint x @ view insetDisplayBox origin y extent: 2 @ (view insetDisplayBox height))				rule: Form reverse				mask: Form black.			Display				fill: (thisPoint x @ view insetDisplayBox origin y extent: 2 @ (view insetDisplayBox height))				rule: Form reverse				mask: Form black].	Display		fill: (thisPoint x @ view insetDisplayBox origin y extent: 2 @ (view insetDisplayBox height))		rule: Form reverse		mask: Form black.	columnNumber to: model xGrid size do: [:each | model xGrid at: each put: (model xGrid at: each)				+ addNumber].	(model column: columnNumber)		do: [:each | each form: nil].	view form: nil.	view scrollMap: nil.	view displayView.	Cursor normal show!rowActivity	"set the height of a row"	| rowNumber rowTop addNumber thisPoint oldPoint rowBottom |	rowNumber _ (model gridPointClosestTo: sensor cursorPoint) y.	rowTop _ (model yGrid at: rowNumber)				- (model originOf: view offsetPoint) y + view insetDisplayBox origin y + 30.	rowBottom _ (model originOf: 1 @ rowNumber) y - (model originOf: view offsetPoint) y + view insetDisplayBox origin y + 30.	thisPoint _ view insetDisplayBox origin x @ rowTop - 1.	Cursor blank show.	[sensor redButtonPressed]		whileTrue: 			[oldPoint _ thisPoint.			thisPoint _ sensor cursorPoint.			thisPoint y - rowBottom < 25 ifTrue: [thisPoint y: rowBottom + 25].			addNumber _ thisPoint y - rowTop.			Display				fill: (view insetDisplayBox origin x @ oldPoint y extent: (view insetDisplayBox width) @ 2)				rule: Form reverse				mask: Form black.			Display				fill: (view insetDisplayBox origin x @ thisPoint y extent: (view insetDisplayBox width) @ 2)				rule: Form reverse				mask: Form black].	Display		fill: (view insetDisplayBox origin x @ thisPoint y extent: (view insetDisplayBox width) @ 2)		rule: Form reverse		mask: Form black.	rowNumber to: model yGrid size do: [:each | model yGrid at: each put: (model yGrid at: each)				+ addNumber].	(model row: rowNumber)		do: [:each | each form: nil].	view form: nil.	view scrollMap: nil.	view displayView.	Cursor normal show!scrollActivity	"user has pressed the scroll button.  Pop-up a scrolling map and allow him to 	place a window in relation to the map"	| savedArea thePoint xGrid yGrid cellRow cellColumn mapOrigin windowRect mapRect |	xGrid _ model xGrid.	yGrid _ model yGrid.	"display the map"	mapOrigin _ Point new.	mapOrigin x: (view insetDisplayBox origin x - view scrollMap extent x max: 0).	mapOrigin y: view insetDisplayBox origin y.	mapRect _ mapOrigin extent: view scrollMap extent.	savedArea _ Form fromDisplay: mapRect.	view scrollMap displayAt: mapOrigin.	"wait for button release, then display the window marker against the map"	sensor waitNoButton.	windowRect _ mapOrigin + 2 + ((model originOf: view offsetPoint)					// 15) extent: view insetDisplayBox extent - 30 // 15.	Display		fill: windowRect		rule: Form reverse		mask: Form lightGray.	"wait for button press.  If yellow or blue button, exit scroll routine. If red 	button, allow dynamic placement of window marker against scroll map"	sensor waitButton.	sensor yellowButtonPressed | sensor blueButtonPressed		ifTrue: 			[savedArea displayAt: mapOrigin.			^nil].	[sensor redButtonPressed]		whileTrue: [((mapRect origin + 2 corner: mapRect corner - 2)				containsPoint: sensor cursorPoint)				ifTrue: 					[Cursor blank show.					Display						fill: windowRect						rule: Form reverse						mask: Form lightGray.					thePoint _ sensor cursorPoint - mapOrigin - 2 - (windowRect extent // 2).					thePoint x: (thePoint x max: 0).					thePoint y: (thePoint y max: 0).					windowRect _ mapOrigin + 2 + thePoint extent: view insetDisplayBox extent // 15.					Display						fill: windowRect						rule: Form reverse						mask: Form lightGray]				ifFalse: 					[Cursor normal show.					thePoint _ -1 @ -1]].	"clean up after window marker"	Display		fill: windowRect		rule: Form reverse		mask: Form lightGray.	Cursor normal show.	"restore pop-up area under scroll map"	savedArea displayAt: mapOrigin.	"find closest offset point to origin asked for"	thePoint x > view scrollMap width | (thePoint x < 0) | (thePoint y > view scrollMap height) | (thePoint x < 0) ifTrue: [^nil].	yGrid size		to: 1		by: -1		do: [:row | thePoint y * 15 <= (yGrid at: row) ifTrue: [cellRow _ row]].	xGrid size		to: 1		by: -1		do: [:column | thePoint x * 15 <= (xGrid at: column) ifTrue: [cellColumn _ column]].	"set new offset for window, and redisplay cells"	view offsetPoint: cellColumn @ cellRow.	view form: nil.	view displayView! !BoxController comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!BoxController methodsFor: 'control activity'!controlInitialize	selectionBox == nil ifFalse:[view deEmphasize: (selectionBox translateBy: view offsetPoint)].	^super controlInitialize!controlTerminate	selectionBox == nil ifFalse:[view deEmphasize: (selectionBox translateBy: view offsetPoint)].	"view form copyBits: view insetDisplayBox from: Display at: 0@0 clippingBox: view form boundingBox rule: Form over mask: nil."	^super controlTerminate!isControlActive	^(view containsPoint: sensor cursorPoint) & sensor blueButtonPressed not!redButtonActivity	| noSelectionMovement oldSelectionBox trialSelection trialPoint trialSelectionBox |	noSelectionMovement _ true.	oldSelectionBox _ selectionBox.	[trialPoint _ sensor cursorPoint.	 trialSelectionBox _ view getBoxFor: trialPoint.	 self moveSelectionBox: trialPoint.	 trialSelectionBox ~= oldSelectionBox ifTrue: [noSelectionMovement _ false].	 sensor redButtonPressed] whileTrue: [].	(trialSelectionBox = oldSelectionBox			ifTrue: [noSelectionMovement]			ifFalse: [false])		ifFalse: 			[selection _ view getSelectionFor: trialPoint.			selectionBox _ trialSelectionBox.			selectionPoint _ trialPoint]		ifTrue: 			[selection _ nil.			selectionBox == nil 				ifFalse: [view deEmphasize: (selectionBox translateBy: view offsetPoint)].			selectionBox _ nil.			selectionPoint _ nil]! !!BoxController methodsFor: 'initialize-release'!initialize	super initialize.	yellowButtonMenu _ BoxYellowButtonMenu.	yellowButtonMessages _ BoxYellowButtonMessages.! !!BoxController methodsFor: 'menu messages'!addBox	"add a box to the screen"	| theNewRect theNewContents offset theTempRect |	offset _ view insetDisplayBox origin.	theNewRect _ Rectangle fromUser.	theTempRect _ Rectangle new origin: (theNewRect origin - offset) corner:(theNewRect corner - offset).	(self checkOverlap: 	theTempRect) ifFalse:[^false].	view addBox:	theTempRect.	theNewContents _ (self getName: 'What are the contents' defaultAnswer: (String with: Character space)). 	model add: theNewContents.	view update: theNewContents	 inRectangle: theNewRect.	"view form: (Form fromDisplay: view insetDisplayBox)."!addMatrix	"add a Matrix to the screen"	| theNewRect theNewContents matrixSizeX matrixSizeY offset theTempRect |	offset _ view insetDisplayBox origin.	theNewRect _ Rectangle fromUser.	theTempRect _ Rectangle new origin: (theNewRect origin - offset) corner:(theNewRect corner - offset).	(self checkOverlap: 	theTempRect) ifFalse:[^false].	view addBox:	theTempRect.	matrixSizeX _ (self getName: 'How many x elements' defaultAnswer:' ') asNumber. 	matrixSizeY _ (self getName: 'How many yelements' defaultAnswer:' ') asNumber.	theNewContents _ (Matrix new: matrixSizeY by: matrixSizeX) setToZero.	model add: theNewContents.	view update: theNewContents	 inRectangle: theNewRect.	"view form: (Form fromDisplay: view insetDisplayBox)."!boxChange	"change the selected box's shape and location"	| boxList boxAddr newBox tempBox offset |	selectionBox == nil ifTrue:[^view flash].	offset _ view insetDisplayBox origin.	boxList _ view boxList.	1 to: boxList size do:		[:i | ((boxList at: i) containsPoint: (selectionPoint - offset - view offsetPoint))				ifTrue:[boxAddr _ i]].	tempBox _ Rectangle fromUser.	newBox _ Rectangle new origin: (tempBox origin - offset) corner:(tempBox corner - offset - view offsetPoint).	(self checkOverlap: newBox) ifFalse:[^false].	Display fill: (Rectangle new origin: ((boxList at: boxAddr) origin + offset + view offsetPoint) corner:((boxList at: boxAddr) corner + offset + view offsetPoint)) rule: Form over mask: view insideColor.	boxList at: boxAddr put: newBox.	view update: (model at: boxAddr) inRectangle: tempBox.	"view form: (Form fromDisplay: view insetDisplayBox)."	selection _ nil.	selectionBox _ nil.	selectionPoint _ nil.!boxMove	"change the selected box's shape and location"	| boxList boxAddr newBox tempBox tempSpot offset |	selectionBox == nil ifTrue: [^view flash].	offset _ view insetDisplayBox origin.	boxList _ view boxList.	1 to: boxList size do: [:i | ((boxList at: i)			containsPoint: selectionPoint - offset - view offsetPoint)			ifTrue: [boxAddr _ i]].	tempSpot _ Sensor waitButton.	tempBox _ Rectangle new 			origin: tempSpot 			corner: tempSpot x + selectionBox width @ (tempSpot y + selectionBox height).	newBox _ Rectangle new origin: tempBox origin - offset - view offsetPoint corner: tempBox corner - offset - view offsetPoint.	(self checkOverlap: newBox excepting: boxAddr)		ifFalse: [^false].	Display		fill: (((boxList at: boxAddr) origin + offset - view offsetPoint extent: (boxList at: boxAddr) extent)				intersect: view insetDisplayBox)		rule: Form over		mask: view insideColor.	boxList at: boxAddr put: newBox.	view update: (model at: boxAddr)		inRectangle: tempBox.	"view form: (Form fromDisplay: view insetDisplayBox)."	selection _ nil.	selectionBox _ nil.	selectionPoint _ nil.	view mapChanged: true!getName: question defaultAnswer: startAnswer 	| answer |	Cursor normal showWhile:[FillInTheBlank		request: (Text string: question emphasis: 4)		displayAt: Sensor cursorPoint		centered: true		action: [:answer | answer]		initialAnswer: (Text string: startAnswer emphasis: 1) asParagraph.].	^answer!selectionChange	"change the selected box's contents"	| inputString outputString |	selectionBox == nil ifTrue:[^view flash].	view borderFlag ifTrue:[view bound: selectionBox].	Display fill: selectionBox rule: Form over mask: Form white.	(selection isKindOf: String)		ifTrue:[inputString _ selection]		ifFalse:[inputString _ selection printString].		outputString _ self getName:'Change to what value?' defaultAnswer: inputString.	(selection isKindOf: Number)		ifTrue:[view setSelectionFor: selectionPoint  to: outputString asNumber.				selection _ outputString asNumber]		ifFalse:[view setSelectionFor: selectionPoint  to: outputString.				selection _ outputString].	view update: selection inRectangle:selectionBox.	"view form: (Form fromDisplay: view insetDisplayBox)."	Display fill: selectionBox rule: Form reverse mask: Form black.! !!BoxController methodsFor: 'accessing'!selection	^selection!selection: anObject	selection _ anObject!selectionBox	^selectionBox!selectionBox: anObject	selectionBox _ anObject!selectionPoint	^selectionPoint!selectionPoint: anObject	selectionPoint _ anObject! !!BoxController methodsFor: 'private'!checkOverlap: newBox	"check the selected box's shape and location to make sure it doesn't  overlay any other boxes"	| boxList |	boxList _ view boxList.	1 to: boxList size do:		[:i | ((boxList at: i) intersects: newBox)				ifTrue:[self booboo: 'you can''t overlay boxes!!'.						^false]].	^true!checkOverlap: newBox excepting: aBoxAddr	"check the selected box's shape and location to make sure it doesn't  overlay any other boxes"	| boxList |	boxList _ view boxList.	1 to: boxList size do:		[:i | ((boxList at: i) intersects: newBox) & (i ~= aBoxAddr)				ifTrue:[self booboo: 'you can''t overlay boxes!!'.						^false]].	^true!moveSelectionBox: trialPoint	"select which box on the controller is being pointed to"	"BoxView openTest"	| newBox |	newBox _ view getBoxFor: trialPoint.	newBox = selectionBox		ifFalse: 			[selectionBox == nil ifFalse: [Display					fill: ((selectionBox translateBy: view offsetPoint) intersect: view insetDisplayBox)					rule: Form reverse					mask: Form black].			selectionBox _ newBox.			newBox == nil ifFalse: [Display					fill: ((newBox translateBy: view offsetPoint) intersect: view insetDisplayBox)					rule: Form reverse					mask: Form black]]! !DBoxController comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986, 1987.  All rights reserved.'!!DBoxController methodsFor: 'control activity'!controlActivity	| i modelAti aType |	(view containsPoint: sensor cursorPoint)		ifFalse: [self keepCursorInView].	(sensor anyButtonPressed or: [cr])		ifTrue: [i _view boxIndexContains: sensor cursorPoint.				cr _ false.				(i > 0 and: [i <= model size])					ifTrue: [	modelAti _ model at: i.							(modelAti ~= nil							and: [(aType _ modelAti type) ~= nil and: [modelAti enabled]])								ifTrue: [	self perform: (TypeActivity at: (Type indexOf: aType)) with: i]]]!controlLoop	self wakeUpFirstFill.	super controlLoop!controlTerminate	"this is simply to overwrite the saving of stuff that the super class of this does"!isControlActive	^accepted not! !!DBoxController methodsFor: 'red button activity'!startExecuteAt: anIndex	"Execute a command from one of the three command boxes."	| aModel old new |  	aModel _ model at: anIndex.	view colorReverseBoxIndexed: anIndex.	old _ anIndex.	[new _ view boxIndexContains: sensor cursorPoint.	(aModel group includes: new) and: [sensor anyButtonPressed]]		whileTrue: [old ~= new					ifTrue: [view colorReverseBoxIndexed: old.							view colorReverseBoxIndexed: new].					old _ new].	new =anIndex		ifTrue: [self perform: (model at: anIndex) description asSymbol]		ifFalse: [view colorReverseBoxIndexed: old].!startFillControllerAt: anIndex 	| fillView fillController aBox fillIn aModel |	aModel _ model at: anIndex.	aBox _ view getBoxIndexed: anIndex.	fillIn _ FillInTheBlank new				action: [:answer |					aModel variable: answer.					aModel description: answer].	fillController _		(aModel type == #keyword			ifTrue: [	DBoxKeywordFillController]			ifFalse: [aModel type == #paragraph						ifTrue: [DBoxParaFillController]						ifFalse: [DBoxFillController]]) new.	fillController initialize.	fillController boundingBox: view viewport.	fillView _ FillInTheBlankView new borderWidth: 1.	fillView model: fillIn controller: fillController.	fillView		window: (0@0 extent: aBox extent)		viewport: aBox;		editString: aModel variable copy.	aModel type == #password		ifTrue: [fillController paragraph textStyle: TextStyle passwordStyle].	fillController startUp.	cr _ fillController cr.	fillView release.	fillIn _ fillView _ fillController _ nil.	cr ifTrue: [self wakeUpFill: anIndex + 1].	cr _ true!startMultipleSelectAt: anIndex	"select the box which the cursor is pointing to"	| aBox aModel |	aModel _ model at: anIndex.	aModel variable == nil		ifTrue: [view selectMe: aModel]		ifFalse: [view deselectMe: aModel].	view colorReverseBoxIndexed: anIndex.	sensor waitNoButton!startQuerierControllerAt: anIndex	| aModel queryView | 	aModel _ model at: anIndex.	queryView _ self openQuerierViewOn: aModel query indexed: anIndex.	queryView display.	queryView controller startUp.	aModel query contents == nil 		ifTrue: [Display fill: queryView insetDisplayBox mask: Form white].	aModel variable: aModel query contents.	queryView release.	queryView _ nil.!startSelectAt: anIndex	"select the box which the cursor is pointing to"	| aBox aModel |	aModel _ model at: anIndex.	aModel variable ~= nil ifTrue: [^self].	aBox _ view colorReverseBoxIndexed: anIndex.	aModel group do:		[:i | (model at: i) variable ~=nil				ifTrue: [(model at: i) enabled ifTrue: [view colorReverseBoxIndexed: i].						(model at: i) deselected]].	aModel selected.	Cursor execute showWhile: [view updateGroup: aModel group]! !!DBoxController methodsFor: 'utilities'!openQuerierViewOn: aSimpleQuerier indexed: anIndex	"open a QuerierView"	| aBox aQuerierView topView |	aBox _ view getBoxIndexed: anIndex.	(aQuerierView _ QuerierView new) model: aSimpleQuerier; 		window: (Rectangle new origin:0@0 extent: aBox extent);		controller: DBoxQueryController new.	(topView _ View new) model: aSimpleQuerier			controller: Controller new;			window: aQuerierView window 			viewport: aBox;	 		borderWidth: 1;			addSubView: aQuerierView.	^topView!wakeUpFill: anIndex	"Searching the first element of 'fill' or 'password' type in the 	model (OrderedCollection) starting from anIndex.  Then envoke a 	CRFillInTheBlank view in the corresponding box."	| displacement aType |	displacement _ view insetDisplayBox origin.	cr _ true.	anIndex to: model size do: 		[:i | aType _ (model at: i) type.			(((aType == #fill or: [aType == #password]) or: [aType == #keyword]) or: [aType == #paragraph])				ifTrue: [^sensor cursorPoint: ((view getBoxIndexed: i) center)]].	self autoAccept		ifTrue: [^sensor cursorPoint: ((view getBoxIndexed: 1) center)].	1 to: anIndex - 2 do: 		[:i | aType _ (model at: i) type.			(((aType == #fill or: [aType == #password]) or: [aType == #keyword]) or: [aType == #paragraph])				ifTrue: [^sensor cursorPoint: ((view getBoxIndexed: i) center)]].	cr _ false!wakeUpFirstFill	"Check if the first element is 'fill' or 'password' type in the 	model (OrderedCollection).  If so Then envoke a 	CRFillInTheBlank view in the corresponding box."	| aType |	aType _ (model at: 5) type.	((aType == #fill or: [aType == #password]) or: [aType == #keyword])		ifTrue: [	cr _ true.				^sensor cursorPoint: ((view getBoxIndexed: 5) center)].! !!DBoxController methodsFor: 'menu messages'!accept	"Answer an array of updated values."	accepted _ true.	view answerArray: view getAnswer.!autoAccept	"An escape mechanism. If the condition is tested true, then wakeUpFill: will cause automatic accept"	^(model at: 1) variable!bailOut	accepted _ true!cancel	"Cancel the selections and reassign all the variables 	to their initial values."	| aModel |	1 to: model size do: 		[:i | 		aModel _ model at: i.		aModel variable: aModel initial.		aModel enable.		(aModel variable ~~ nil and: [aModel type = #fill or: [aModel type = #paragraph]])			ifTrue: [aModel description: aModel initial]].	view displayView; resetView!done	accepted _ true! !!DBoxController methodsFor: 'initialize-release'!initialize	Cursor normal show.	super initialize.	cr _ false.	accepted _ false.		yellowButtonMenu _ nil.	yellowButtonMessages _ nil.! !GrapherController comment:'Copyright (c) 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!GrapherController methodsFor: 'private'!allSelectorsButObjectSelectors: aClass	"Answer a set of all the message selectors that instances of the receiver can	understand."	| aSet  aCollection|	aSet _ Set new.	aCollection _ aClass withAllSuperclasses.	aCollection remove: Object.	aCollection do: [:each | aSet addAll: each selectors].	^aSet!browseTheImplementorOf: selector	"Create and schedule a message browser on each method that implements the	message whose selector is the argument, selector.	For example,		Smalltalk browseAllImplementorsOf: #at:put:.	"	^Smalltalk browseMessageList: (self theImplementorOf: selector) name: 'Implementor of ' , selector!initialize	super initialize.	yellowButtonMenu _ GrapherControllerYellowButtonMenu.	yellowButtonMessages _ GrapherControllerYellowButtonMessages.!showMenuThenBrowseMessagesFor: aClass	"Show a menu of the given selectors, abbreviated to 20 characters.	Create and schedule a message set browser of all implementors of the 	message chosen.  Do nothing if no message is chosen."	| aStream menu index selectorCollection realCollection |	realCollection _ SortedCollection new.	selectorCollection _ self allSelectorsButObjectSelectors: aClass.	selectorCollection do: [:each | realCollection add: each].	selectorCollection _ nil.	realCollection isEmpty ifTrue: [^Transcript cr; show: 'No messages sent.']."	aStream _ WriteStream on: (String new: 200).	realCollection do:		[:sel |		aStream nextPutAll: (sel contractTo: 20); cr].	aStream skip: -1."	index _ (ScrollMenu new: 20 on: realCollection) startUp.	index > 0 ifTrue: [self browseTheImplementorOf: (realCollection at: index)]!theImplementorOf: aSelector  	"Answer a SortedCollection of all the methods that implement the message aSelector."	| aCollection |	aCollection _ SortedCollection new.	selection withAllSuperclasses do:			[:class |			(class includesSelector: aSelector)				ifTrue: [aCollection add: class name, ' ', aSelector.						^aCollection]].! !!GrapherController methodsFor: 'menu messages'!addConnection	| firstSpot secondSpot boxAddr secondBoxAddr offset theBlt |	offset _ view insetDisplayBox origin.	theBlt _ BitBlt		destForm: Display		sourceForm: nil		halftoneForm: nil		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: 0 @ 0		extent: 1@1		clipRect: view insetDisplayBox.	Cursor crossHair show.	firstSpot _ Sensor waitClickButton.	secondSpot _ Sensor waitClickButton.	Cursor normal show.	1 to: view boxList size do:		[:i | ((view boxList at: i) containsPoint: (firstSpot - offset - view offsetPoint))				ifTrue:[boxAddr _ i]].	1 to: view boxList size do:		[:i | ((view boxList at: i) containsPoint: (secondSpot - offset - view offsetPoint))				ifTrue:[secondBoxAddr _ i]].	view addConnectionFrom: boxAddr to: secondBoxAddr.	view drawConnectionFrom: (view boxList at: boxAddr) to: (view boxList at: secondBoxAddr) blt: theBlt flag: true.	"view form: (Form fromDisplay: view insetDisplayBox)."!boxMove	"change the selected box's shape and location"	| boxList boxAddr newBox tempBox tempSpot offset |	selectionBox = nil ifTrue: [^view flash].	offset _ view insetDisplayBox origin.	boxList _ view boxList.	1 to: boxList size do: [:i | ((boxList at: i)			containsPoint: selectionPoint - offset - view offsetPoint)			ifTrue: [boxAddr _ i]].	Cursor origin show.	tempSpot _ Sensor waitClickButton.	Cursor normal show.	(view insetDisplayBox containsPoint: tempSpot)		ifFalse: [^view flash].	tempBox _ Rectangle new origin: tempSpot corner: tempSpot x + selectionBox width @ (tempSpot y + selectionBox height).	newBox _ Rectangle new origin: tempBox origin - offset - view offsetPoint corner: tempBox corner - offset - view offsetPoint.	(self checkOverlap: newBox excepting: boxAddr)		ifFalse: [^false].	view eraseConnectionsOn: boxAddr.	Display		fill: ((Rectangle new origin: (boxList at: boxAddr) origin + offset + view offsetPoint corner: (boxList at: boxAddr) corner + offset + view offsetPoint)				intersect: view insetDisplayBox)		rule: Form over		mask: Form white.	view map		fill: ((boxList at: boxAddr) origin // 10 extent: (boxList at: boxAddr) extent // 10)		rule: Form over		mask: Form white.	view map		fill: (newBox origin // 10 extent: newBox extent // 10)		rule: Form over		mask: Form black.	boxList at: boxAddr put: newBox.	view update: (view labelList at: boxAddr)		inRectangle: tempBox.	view drawConnectionsOn: boxAddr.	"view form: (Form fromDisplay: view insetDisplayBox)."	selection _ nil.	selectionBox _ nil.	selectionPoint _ nil!browseClass	self controlTerminate.	Browser newOnClass: selection.!browseMessages	self controlTerminate.	self showMenuThenBrowseMessagesFor: selection.	self controlInitialize.!browseSubclasses	self controlTerminate.	ConnectedBoxView openClassView: selection!removeConnection	| firstSpot secondSpot boxAddr secondBoxAddr offset theBlt |	offset _ view insetDisplayBox origin.	theBlt _ BitBlt		destForm: Display		sourceForm: Form black		halftoneForm: Form black		combinationRule: Form erase		destOrigin: 0@0		sourceOrigin: 0 @ 0		extent: 1@1		clipRect: view insetDisplayBox.	Cursor crossHair show.	firstSpot _ Sensor waitClickButton.	secondSpot _ Sensor waitClickButton.	Cursor normal show.	1 to: view boxList size do:		[:i | ((view boxList at: i) containsPoint: (firstSpot - offset - view offsetPoint))				ifTrue:[boxAddr _ i]].	1 to: view boxList size do:		[:i | ((view boxList at: i) containsPoint: (secondSpot - offset - view offsetPoint))				ifTrue:[secondBoxAddr _ i]].	view removeConnectionFrom: boxAddr to: secondBoxAddr.	view drawConnectionFrom: (view boxList at: boxAddr) to: (view boxList at: secondBoxAddr) blt: theBlt flag: true.	"view form: (Form fromDisplay: view insetDisplayBox)."!scroll	| thePoint |	self controlTerminate.	view scrollForm.	self controlInitialize! !InfoCenterGraphController comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!InfoCenterGraphController methodsFor: 'initialize'!initialize	super initialize.	yellowButtonMenu _ ICGCYellowButtonMenu.	yellowButtonMessages _ ICGCYellowButtonMessages.! !!InfoCenterGraphController methodsFor: 'private'!getLinkTypeFrom: pointers	| links theReturn | 	links _ OrderedCollection with: 'Link Types:'.	pointers do: [:each | links add: (view center linkTypes at: each linkType)].	links size = 2 ifTrue:[^Array with: (links at: 2)].	links size < 2 ifTrue:[^nil].	theReturn _ DBoxView		openFor: #(multipleSelect)		title: 'Remove which connections?'		labels: (Array with: links)		defaults: (Array with:#()).	theReturn == nil ifTrue: [^nil].	^(theReturn at: 1)! !!InfoCenterGraphController methodsFor: 'menu messages'!addConnection	| toSpot fromSpot toBoxAddr fromBoxAddr offset linkType |	offset _ view insetDisplayBox origin.	(linkType _ view center linkTypeMenu) == nil ifTrue: [^self].	Cursor crossHair show.	fromSpot _ Sensor waitClickButton.	toSpot _ Sensor waitClickButton.	Cursor normal show.	1 to: view boxList size do:		[:i | ((view boxList at: i) containsPoint: fromSpot - offset - view offsetPoint) ifTrue: [fromBoxAddr _ i].			((view boxList at: i) containsPoint: toSpot - offset - view offsetPoint) ifTrue: [toBoxAddr _ i]].	fromBoxAddr == nil | (toBoxAddr == nil) ifTrue: [^view flash].	(view center addLinkOfType: linkType from: (model at: fromBoxAddr) to: (model at: toBoxAddr)) == nil ifTrue: [^self].	view addConnectionFrom: toBoxAddr to: fromBoxAddr.	view drawConnectionFrom: (view boxList at: fromBoxAddr) to: (view boxList at: toBoxAddr).	ContainerModel changed: (model at: fromBoxAddr).	view hasChanged: false!cleanItUp	view hasChanged: true.	view form: nil.	selection _ selectionBox _ nil.	view display!deselect	selection _ nil.	selectionBox _ nil.	selectionPoint _ nil.!editLinkTypes	self controlTerminate.	view center editLinkTypes.	self controlInitialize!graphElement	selection == nil ifTrue: [^view flash].	InfoCenterGraphView viewTwoWayGraphFor: selection in: view center!hardcopy	"check the selection to see if it is a dictionary or text or what ever"	selection == nil ifTrue:		[((DataMaster backgroundPrintingAvailable: true) and: [self confirm: 'Nothing has been selected.  Print hardcopy of structure?'])			ifTrue: [^BackgroundPrinter						printForm: (Form fromDisplay: view insetDisplayBox)						withTitle: view topView label						alignMark: false						suitcase: (Suitcase new packTheSuitcaseFrom: view centerName forItem: (model at: 1))]			ifFalse: [^nil]].	DataMaster hardcopyItemInSuitcase: (Suitcase new packTheSuitcaseFrom: view centerName forItem: selection)!moveSelectionBox: trialPoint 	"select which box on the controller is being pointed to"	"BoxView openTest"	| newBox selectionRect newRect |	newBox _ view getBoxFor: trialPoint.	selectionBox == nil		ifFalse: 			[selectionRect _ (selectionBox translateBy: view offsetPoint)						intersect: view insetDisplayBox].	newBox == nil		ifFalse: 			[newRect _ (newBox translateBy: view offsetPoint)						intersect: view insetDisplayBox].	newBox = selectionBox		ifFalse: 			[selectionBox == nil ifFalse: [Display					fill: selectionRect					rule: Form reverse					mask: Form black].			selectionBox _ newBox.			newBox == nil ifFalse: [Display					fill: newRect					rule: Form reverse					mask: Form black]]!redisplay	"tidy up the display"	view form: nil.	selection _ selectionBox _ nil.	view display!removeConnection	| firstSpot secondSpot fromBoxAddr toBoxAddr offset fromItem toItem linkTypes |	offset _ view insetDisplayBox origin.	Cursor crossHair show.	firstSpot _ Sensor waitClickButton.	secondSpot _ Sensor waitClickButton.	Cursor normal show.	1 to: view boxList size do: 		[:i | 		((view boxList at: i)			containsPoint: firstSpot - offset - view offsetPoint)			ifTrue: [fromBoxAddr _ i].		((view boxList at: i)			containsPoint: secondSpot - offset - view offsetPoint)			ifTrue: [toBoxAddr _ i]].	(fromBoxAddr == nil or: [toBoxAddr == nil])		ifTrue: [^view flash].	fromItem _ model at: fromBoxAddr.	toItem _ model at: toBoxAddr.	(linkTypes _ self getLinkTypeFrom: (fromItem pointersTo: toItem)) == nil ifTrue:[^self].	linkTypes do: [:each| (view center		removeLinkOfType: each		from: fromItem		to: toItem)		== nil ifTrue: [^self].	(fromItem pointersTo: toItem) size > 0		ifFalse: [view eraseConnectionFrom: (view boxList at: fromBoxAddr) to: (view boxList at: toBoxAddr).	view removeConnectionFrom: fromBoxAddr to: toBoxAddr.]].	ContainerModel changed: fromItem.	view hasChanged: false!viewIt	"view the selection"	selection == nil ifTrue: [^view flash].	selection isFolder ifTrue: [^ContainerModel openThisFolder: selection inCenter: view center searchString: nil].	(selection typeSymbol = #Item)		ifTrue: [^DataMaster viewSelection: selection withSuitcase: (Suitcase new packTheSuitcaseFrom: view centerName forItem: selection)].	self booboo: 'I do not know how to view that'! !!StandardSystemController methodsFor: 'basic control sequence'!controlTerminate	status == #closed		ifTrue: 			[view ~~ nil ifTrue: [view release].			ScheduledControllers unschedule: self.			^self].	status == #inactive		ifTrue: 			[view deEmphasize.			ScheduledControllers pullBottomToTop.			^self].	status _ #inactive.	view deEmphasize! !!StandardSystemController methodsFor: 'menu messages'!blueButtonActivity	"Use special menu if collapsed."	| selection |	view isCollapsed		ifTrue: [((selection _ MenuWhenCollapsed startUp) = 0 or: [selection == nil])					ifFalse: [self menuMessageReceiver perform: (MenuWhenCollapsed answer)]]		ifFalse: [^super blueButtonActivity]!close	"The receiver's view should be removed from the screen and from the	collection of scheduled views."	model changeRequest  "check for changes in progress"		ifFalse: [^self].	status _ #closed.	(Smalltalk includesKey: #Auditor) ifTrue: [Auditor add: 'Close Window titled: ', view label].	Cursor normal show.	view erase!collapse		| oldFrame | 	"Change the receiver's view to a collapsed view "	Cursor normal show.	view deEmphasize.	view erase.	oldFrame _ view displayBox.	view collapse. 	view lastLabelLocation == nil		ifTrue: [view display.				^ self move].	view align: view displayBox topLeft with: view lastLabelLocation.	Display zoom: oldFrame to: view displayBox speed: 1000.	view displayEmphasized!expand	"The receiver's view was collapsed; open it again and ask the user 	to designate its rectangular area."	Cursor normal show.	view deEmphasize.	view erase.	view expand.	view resize.	view displayEmphasized!findOne	| theCollect aString ans | "set up a popup menu of other views to close "	Cursor normal show.	theCollect _ OrderedCollection new.	aString _ String new.	(ScheduledControllers scheduledControllers) do:		[:each |		(each isMemberOf: ScreenController) ifFalse: [			(each  == self)				ifFalse: [aString _ aString, (each view label),(String with: $\).						theCollect add: each]]].	aString _ aString, (self view label),' (me)'.	theCollect add: self.	ans _ (TreeMenu labels: aString withCRs)			answers: theCollect;			selectBlock: [:menu | 4 timesRepeat: [menu answer view displayTextReverse]];			startUp: nil.	(ans = 0 or: [ans == nil]) ifTrue: [^nil].	ans == self ifTrue: [^self centerCursorInView].	ans centerCursorInView.	status _ #silly.	ScheduledControllers promote: ans!frame	"The receiver's view was collapsed; open it again and ask the user 	to designate its rectangular area."	view erase.	view expand2.	view resize.	view displayEmphasized.	Cursor normal show.!getLinks	"set up a popup menu of other views to close"	| suitcase theStartItem center thePointers forwards backwards theTabLabel |	(suitcase _ view suitcase) == nil		ifTrue: [model class == ContainerModel				ifTrue: [center _ model center.					theStartItem _ model folder]				ifFalse: [^self booboo: 'There are no connections for this window']]		ifFalse: [theStartItem _ suitcase dataItem.			center _ suitcase center].	center == nil ifTrue:[^self booboo: 'There are no connections for this window'].	center connectionsForThisItem: theStartItem!help	"Pop-up a window with help information for the view."	view helpIndex notNil ifTrue:			[Helper new showHelpForIndex: view helpIndex]		ifFalse:			[Object booboo: 'Sorry, no help available for this window.' ]!move	"Ask the user to designate a new position for the recevier's view."	| form box handle |view isCollapsedifTrue:	[Sensor cursorPoint: view labelDisplayBox origin.	view deEmphasize.	form _ Form fromDisplay: (view labelDisplayBox).	view erase.	Cursor origin showWhile:		[form follow: [Sensor cursorPoint] while: [Sensor noButtonPressed]].	view align: view labelDisplayBox origin		with: sensor cursorPoint.	view lastLabelLocation: sensor cursorPoint.	view displayEmphasized.]ifFalse:	[box _ view displayBox.	handle _ view nearestVertexTo: sensor cursorPoint.	sensor cursorPoint: (box  perform: handle).	view deEmphasize.	view erase.	view align: box topLeft with: (Rectangle fromUserAtVertex: handle withExtent: box extent) 	topLeft.	view displayEmphasized.	Cursor normal show.]!restoreFullView	view restoreFullView!smashOne	| theCollect aString index refresh theSet closeSelf | "set up a popup menu of other views to close "	Cursor normal show.	refresh _ closeSelf _ false.	theCollect _ OrderedCollection new.	aString _ String new.	(ScheduledControllers scheduledControllers) do:		[:each |		(each isMemberOf: ScreenController) ifFalse: [			(each  == self)				ifFalse:[aString _ aString,(each view label),(String with: $\).						theCollect add: each]]].	aString _ aString,(self view label),' (me)'.	theCollect add: self.	theSet _ (TreeMenu labels: aString withCRs)				answers: theCollect;				selectBlock: [:menu | 4 timesRepeat: [menu answer view displayTextReverse]];				multipleStartUp: nil.	theSet isEmpty ifTrue: [^nil].	view deEmphasize.	theSet do:		[:each |		each == self			ifTrue: [closeSelf _ true]			ifFalse:				[refresh _ ((each view displayBox) intersects: (view displayBox)) | refresh.				each closeAndUnschedule]].	closeSelf ifTrue: [^self close].	refresh ifTrue: [view displayEmphasized.					"view reverseLabel"]!smashThem"close all other scheduled windows on the screen"	Cursor normal show.	(self confirm: 'Close all other windows.Are you sure you want to ?') ifFalse: [^self].	self controlTerminate.	(ScheduledControllers scheduledControllers) do:		[:each |		(each isMemberOf: ScreenController) ifFalse: [(each  == self)ifFalse:[		each closeAndUnschedule]]		].	ScheduledControllers restore.	self controlInitialize! !!StandardSystemController methodsFor: 'scheduling'!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled controllers."	model changeRequest  "check for changes in progress"		ifFalse: [^false].	status _ #closed.	(Smalltalk includesKey: #Auditor) ifTrue:		[Auditor add: 'Close Window titled: ', view label].	view erase.	view release.	ScheduledControllers unschedule: self.	^true!open	"Create an area on the screen in which the receiver's scheduled controller can	be displayed.  Make it the active controller."	view resize.	status _ #open.	Auditor add: 'Open Window titled: ', view label.	ScheduledControllers scheduleActive: self! !ICGStandardSystemController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!ICGStandardSystemController methodsFor: 'menu messages'!deSelect	| theController |	theController _ self view firstSubView  controller.	theController selection: nil.	theController selectionBox: nil.	theController selectionPoint: nil.	self view firstSubView oldElement: 0.!expand	self view firstSubView  form: nil.	self deSelect.	super expand!frame	view erase.	view expand2.	view firstSubView form: nil.	self deSelect.	view resize.	view displayEmphasized!move	"Ask the user to designate a new position for the receiver's view."	view isCollapsed		ifTrue:  [super move]		ifFalse: 			[view firstSubView form: nil.			self deSelect.			super move]! !ClockController comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!ClockController methodsFor: 'initialize-release'!initialize	super initialize.	running _ false.	clockSemaphore _ Semaphore new.	clockProcess _ [			[(Delay forSeconds: 60 - Time now seconds) wait.			clockSemaphore wait.			clockSemaphore signal.			view display.			true] whileTrue] newProcess.	clockProcess resume!release	clockProcess terminate! !!ClockController methodsFor: 'private'!runFlag^ running! !!ClockController methodsFor: 'menu messages'!expand	view label: nil.	super expand!start	running		ifFalse:			[clockSemaphore signal.			running _ true]!stop	running 		ifTrue:			[running _ false.			clockSemaphore wait]! !RS232SystemController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!RS232SystemController methodsFor: 'menu messages'!close	"The receiver's view should be removed from the screen and from the	collection of scheduled views."	(RS232Collector shutDown: true) ifFalse: [^false].	sensor flushKeyboard.	status _ #closed.	view erase.	RS232Collector _ nil.	^true!closeAndUnschedule	"If user confirms that closure wanted, then erase		the receiver's view and remove it from the collection		of scheduled controllers; otherwise don't close it"	(RS232Collector shutDown: false) ifFalse: [^false].	status _ #closed.	view erase.	RS232Collector _ nil.	view release.	ScheduledControllers unschedule: self.	^true!collapse	model browseState ifFalse: [model saveSaveState].	super collapse!controlTerminate	(model browseState or: [view isCollapsed]) ifFalse: [model saveSaveState].	super controlTerminate!expand	(model browseState or: [view isCollapsed]) ifFalse: [model saveSaveState].	super expand!move	(model browseState or: [view isCollapsed]) ifFalse: [model saveSaveState].	super move!release	model release.	super release! !AutoBookStandardSystemController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!AutoBookStandardSystemController methodsFor: 'As yet unclassified'!close	"file out the country index if required"	model saveIndexFile.	super close!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled controllers."	model saveIndexFile.	super closeAndUnschedule! !ClassifiedStandardSystemController comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.'!!ClassifiedStandardSystemController methodsFor: 'menu message'!changeClassification	| suitcase answer oldClass |	suitcase _ view suitcase.	oldClass _ suitcase classification.	answer _ Classification fromUser: oldClass.	answer == nil ifTrue: [^nil].	answer = oldClass ifTrue: [^nil].	suitcase changeClassification: answer.	view classifyLabel: answer.	view displayClassification! !!ClassifiedStandardSystemController methodsFor: 'initialize'!initialize	super initialize.	self blueButtonMenu: ClassifiedBlueButtonMenu 		blueButtonMessages: ClassifiedBlueButtonMessages! !DataListStandardSystemController comment:'Copyright (c) 1986 Xerox Corporation. All rights reserved.'!!DataListStandardSystemController methodsFor: 'menu messages'!close	| parentController | 	(chartIt or: [(view subViews at: 1) model isLocked]) ifTrue:		[parentController _ (view subViews at: 1) controller drawChartForClose.		super close.		self passControlTo: parentController].	super close! !!DataListStandardSystemController methodsFor: 'access'!chartIt: aBoolean 	chartIt _ aBoolean!passControlTo: aStandardSystemController	aStandardSystemController centerCursorInView.	status = #closed ifFalse: [status _ #silly].	ScheduledControllers unschedule: aStandardSystemController.	ScheduledControllers scheduleActive: aStandardSystemController! !ComposeSystemController comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986.  All rights reserved.'!!ComposeSystemController methodsFor: 'menu messages'!close	"The receiver's view should be removed from the screen and from the	collection of scheduled views."	model bossModel == nil	"only check the top model for changes"		ifTrue: [model changeRequest ifFalse: [^false]].	self closeDependentViews ifFalse: [^false].	model bossModel isNil ifFalse: "release circular references"		[model bossModel dependentAnnoViews remove: view ifAbsent: [].		 model bossModel: nil].	status _ #closed.	view erase.	^true!closeAndUnschedule	"The receiver's view should be removed from the screen and from the	collection of scheduled views."	self close ifFalse:[^false].	view release.	ScheduledControllers unschedule: self.	^true!closeDependentViews	| aController annoViews |	model dependentAnnoViews isEmpty ifFalse:		[annoViews _ model dependentAnnoViews asArray.		 annoViews do: 			[:eachView | 			 (aController _ eachView controller) close				ifTrue:					[eachView release.					 ScheduledControllers unschedule: aController]				ifFalse: [^false]]].	^true! !BackgroundController comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.'!!BackgroundController methodsFor: 'blue button'!close	self closeAndUnschedule!closeAndUnschedule	(self confirm: 'Do you really want toABORT EVERYTHING  in BACKGROUND?') ifTrue:		[BackgroundPrinter accessQueue; emptyBackground; abortCurrent; deAccessQueue]! !!BackgroundController methodsFor: 'yellow button'!abortCurrent	BackgroundPrinter abortCurrent!accessQueue	BackgroundPrinter accessQueue.	self class initializeQueueEntryMenu.	self initializeYellowButtonMenu.	view label: 'Printing - access'.	self updateDisplay!emptyQueue	BackgroundPrinter emptyBackground.	self class initializeQueueEntryMenu!fakeForeground	"Delay for long periods of time so the background can go fast - terminate if everything done or user types ESC"	view label: 'ESC for control'.	self updateDisplay.	[commitSuicide or: [Sensor keyboardPressed and: [Sensor keyboard = Character esc]]]		whileFalse: [(Delay forSeconds: 5) wait].	view label: 'Printing - active '.	self updateDisplay!idleForeground	"Delay for long periods of time so the background can go fast - terminate if everything done or user types a key"	| theForm | 	theForm _'   Printing in ProgressType any key for control' asParagraph asForm.	[commitSuicide or: [Sensor keyboardPressed]]		whileFalse: [theForm reverse displayOn: Display at: Display boundingBox center. (Delay forSeconds: 5) wait].	theForm fill: theForm boundingBox mask: Form black.	theForm displayOn: Display at: Display boundingBox center!modCurrent	| current |	(current _ BackgroundPrinter getCurrent)  == nil			ifTrue: [self booboo: 'Nothing currently in progress']		ifFalse: [current changeWhenOrWhere]!modEntry	| entryNum |	(entryNum _ QueueEntryMenu answer) == nil ifFalse:		[(BackgroundPrinter getEntry: entryNum) changeWhenOrWhere]!moveEntry	| entryNum |	(entryNum _ QueueEntryMenu answer) == nil ifFalse:		[BackgroundPrinter givePriorityTo: entryNum]!removeEntry	| entryNum |	(entryNum _ QueueEntryMenu answer) == nil ifFalse:		[BackgroundPrinter removeEntry: entryNum.		 self class initializeQueueEntryMenu]!restartQueue	BackgroundPrinter deAccessQueue.	self initializeYellowButtonMenu.	view label: 'Printing - active '.	self updateDisplay!showCurrent	| current |	(current _ BackgroundPrinter getCurrent)  == nil		ifTrue: [self booboo: 'Nothing currently in progress']		ifFalse: [current showSelf]!showEntry	| entryNum |	(entryNum _ QueueEntryMenu answer) == nil ifFalse:		[(BackgroundPrinter getEntry: entryNum) showSelf]!showWaiting	self booboo: 'There are ', BackgroundPrinter numWaiting printString, ' items in the queue'! !!BackgroundController methodsFor: 'messages'!cr	"for Transcript compatibility"!show: aString	"make aString be the contents of the view"	view contents: aString.	self updateDisplay.	Auditor add: aString!updateDisplay	DisplayUpdate		ifTrue: [view clearInside; displayView.				self isControlActive ifTrue: [view reverseLabel]]! !!BackgroundController methodsFor: 'creation/controls'!commitSuicide: authority	"if authority is true (background is commanding) set set commitSuicide for foreground to do it.	 If authority is false (foreground checking), then just check if commitSuicide is true and if it is, close the window. "	authority		ifTrue:			[commitSuicide _ true]		ifFalse:			[self class accessInstanceDo:				[(commitSuicide and: [DisplayUpdate]) ifTrue: [WindowLocation _ view displayBox origin. super closeAndUnschedule. AccessInstance _ nil]]]!controlActivity	super controlActivity.	self commitSuicide: false	"check"!controlInitialize	super controlInitialize.	self initializeYellowButtonMenu!initialize	super initialize.	commitSuicide _ false!initializeYellowButtonMenu	BackgroundPrinter dequeProtected		ifFalse:			[self yellowButtonMenu: (TreeMenu labels:'access queue{changes menu to allow queue access}number waiting{show length of queue}foreground{takeover the foreground untildone or user types ESC}' lines: #()) 				yellowButtonMessages: #(accessQueue showWaiting fakeForeground)]		ifTrue:			[self yellowButtonMenu: BackgroundYellowButtonMenu 				yellowButtonMessages: TreeMenu]!isControlWanted	"for the case where ControlManager was in middle of working on scheduled list when descheduled this one"	self commitSuicide: false.	^ (view ~= nil and: [view containsPoint: sensor cursorPoint])!openBackgroundView	| theView |	(NotifierView new)		model: self;	"this controller is its own model"		controller: self;		label: 'Printing - ', (BackgroundPrinter dequeProtected ifFalse: ['active '] ifTrue: ['halted']);		helpIndex: #Printing;		minimumSize: 250 @ 28;		maximumSize: 250 @ 28;		borderWidth: 2;		contents: 'start up'.	view resizeMinimumCenteredAt: WindowLocation + (125@14).	status _ #open.	view display.	view deEmphasizeLabel.	ScheduledControllers schedulePassive: self!release	super release.	model _ nil!reprieve	commitSuicide _ false! !StandardSystemSpreadsheetController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!StandardSystemSpreadsheetController methodsFor: 'menu messages'!close	"confirm the close"	(self confirm: 'Do you really want to close this Spreadsheet?')		ifTrue: [super close]!collapse	(view subViews at: 1) form: nil.	(view subViews at: 1) controller selectionPoint: 0@0.	super collapse!expand	view isCollapsed ifFalse:[(view subViews at: 1) form: nil.	(view subViews at: 1) controller selectionPoint: 0@0].	super expand!frame	view isCollapsed ifFalse:[(view subViews at: 1) form: nil].	super frame! !DBStandardSystemController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DBStandardSystemController methodsFor: 'menu messages'!close	"close the database file"	model closeFile.	super close!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled controllers."	model closeFile.	super closeAndUnschedule!startUpSave	| temp | 	self controlInitialize.	model changed: #fieldListChanged. 	model changed: #fieldSelectionChanged.	self controlLoop.	self controlTerminate! !!NotifierController methodsFor: 'model access'!model: aDebugger	"Intercept to possible enable spelling correction."	super model: aDebugger.	model interruptedContext selector == #doesNotUnderstand: ifTrue:		[self yellowButtonMenu: (PopUpMenu labels: 'proceed{Continue execution.}debug{Open a debugger window.}correct{Attempt to correct spelling.}'		lines: #(2))			yellowButtonMessages: #(proceed debug correct)]! !!BitEditor methodsFor: 'control defaults'!controlActivity"control the setting or erasing of bits buy toggling the state of the first bit indicated and then continuing to set or clear bits until the red button is released" 	| absoluteScreenPoint formPoint displayPoint |	sensor yellowButtonPressed & self viewHasCursor ifTrue: [^self yellowButtonActivity].	[sensor redButtonPressed]	  whileTrue: 		[self viewHasCursor ifTrue:			[absoluteScreenPoint _ sensor cursorPoint.				formPoint _ (view inverseDisplayTransform: absoluteScreenPoint - (scale//2)) rounded.			displayPoint _ view displayTransform: formPoint.			displayPoint y: (displayPoint y min: 807).			squareForm 				displayOn: Display				at: displayPoint 				clippingBox: view insetDisplayBox 				rule: Form over				mask: (Form perform: color).			view changeValueAt: formPoint put:				(#(white black gray) indexOf: color) -1]].	displayPoint == nil ifFalse: [(Display valueAt: displayPoint) = 0		ifTrue: [self setColor: #black]		ifFalse: [self setColor: #white]]!isControlActive	^super isControlActive & sensor blueButtonPressed not! !ImageEditor comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation.  All Rights Reserved.'!!ImageEditor methodsFor: 'basic control sequence'!controlInitialize	tool _ previousTool.	super controlInitialize!controlTerminate	view updateDisplay.! !!ImageEditor methodsFor: 'control defaults'!controlActivity	self viewHasCursor ifTrue:		[sensor redButtonPressed ifTrue: [^self redButtonActivity].		sensor yellowButtonPressed ifTrue: [^self yellowButtonActivity].		sensor blueButtonPressed ifTrue: [^self blueButtonActivity].		self dragForm]"	ifFalse:[Cursor normal show.]"!isControlActive	^sensor noButtonPressed			or: [sensor blueButtonPressed not and: [self viewHasCursor]]!isControlWanted	^self viewHasCursor! !!ImageEditor methodsFor: 'initialize-release'!createMenuButtonLabeled: aString	| aForm aLabel x y |	x _ 80.	y _ 60.	aForm _ Form new extent: x@y.	aLabel _ aString asParagraph.	aLabel displayOn: aForm at: ((x@y) // (2@4)) - (aLabel boundingBox center) - (0@2).	aForm fill: (0@(y//2 - 2) corner: x@(y//2 - 1)) rule: Form over mask: Form black.	^FormView new		model: aForm;		controller: RemoteMenuController new;		insideColor: Form white;		borderWidth: 2!createMenuView: horizButtonDisplay	| menuView previousView thisView |	menuView _ View new.	#(Activity Brush Color Grid Mode) do:		[:aLabel |		thisView _ self createMenuButtonLabeled: aLabel.		thisView controller			menuMessageReceiver: self;			yellowButtonMenu: (self class perform: (aLabel asLowercase, 'Menu') asSymbol)			yellowButtonMessages: (FakeCollection withAll: (aLabel asLowercase, (String with: $:)) asSymbol).		previousView isNil			ifTrue: [menuView addSubView: thisView]			ifFalse:				[menuView					addSubView: thisView					align: thisView viewport topLeft					with: (horizButtonDisplay						ifTrue: [previousView viewport topRight + (8@0)]						ifFalse: [previousView viewport bottomLeft + (0@8)])].		previousView _ thisView].	^menuView!initialize	super initialize.	locked _ #no.	self setVariables.	self initializeYellowButtonMenu!mapControl: theFileName	"set the file name"	whatFile _ theFileName! !!ImageEditor methodsFor: 'general menu messages'!accept	"The edited information should now be accepted by the view."	view updateDisplay.	locked _ #accept.	view accept!cancel	"The edited informatin should be forgotten by the view."	view updateDisplay.	locked == #accept ifFalse: [locked _ #no].	view cancel!copy	view updateDisplay.	Clipboard clip: view workingForm.	(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]!erase	(self confirm: 'Are you sure you want to erase this?') ifFalse: [^self].	view workingForm white.	view display!hardcopyImage	view updateDisplay.	(Smalltalk includesKey: #BackgroundPrinter) ifFalse: [^self booboo: 'Sorry, I do not know how to hardcopy'].	BackgroundPrinter printForm: view workingForm suitcase: view topView suitcase!invert	view workingForm copy: view workingForm boundingBox from: view insetDisplayBox topLeft in: Display rule: Form over.	view workingForm reverse.	view display!magnify	"Allow for bit editing of an area of the Form. The user designates a rectangular 	area that is scaled by 8 or 4 to allow individual screens dots to be modified."	| smallRect smallForm scaleFactor tempRect |	scaleFactor _ 8@8.	smallRect _ (Rectangle fromUser: grid) intersect: view insetDisplayBox.	smallRect isNil ifTrue: [^self].	smallRect extent x > 50 ifTrue:[scaleFactor _ 4@4].	smallRect extent y > 50 ifTrue:[scaleFactor _ 4@4].	smallRect extent x > 100 ifTrue:[scaleFactor _ 2@2].	smallRect extent y > 100 ifTrue:[scaleFactor _ 2@2].	smallRect extent x > 200 ifTrue:[^self booboo: 'This area is too big to magnify'].	smallRect extent y > 200 ifTrue:[^self booboo: 'This area is too big to magnify'].	smallForm _ Form fromDisplay: smallRect.	"Do this computation here in order to be able to save the existing display screen."	tempRect _ BitEditor locateMagnifiedView: smallForm scale: scaleFactor.	BitEditor		openScreenViewOnForm: smallForm 		at: smallRect topLeft 		magnifiedAt: tempRect topLeft 		scale: scaleFactor.	tool _ previousTool!oldTool	tool _ previousTool!paste	| type entry acted picture classif stuff |	(entry _ Clipboard next) == nil ifTrue: [^Clipboard booboo].	acted _ false.	type _ entry contents class.	classif _ entry propertyAt: #classification.	((type == Form) or: [type inheritsFrom: Form]) ifTrue: 		[entry contents displayOn: view workingForm white.		acted _ true].	(type == Text or: [type == OrderedCollection]) ifTrue: 		[stuff _ type == Text			ifTrue: [entry contents]			ifFalse: [classif == nil						ifTrue: [classif _ self maxClassification]						ifFalse: [classif _ classif + self maxClassification].					self convertDocumentText].		stuff asDisplayText displayOn: view workingForm white.		acted _ true].	type == DataItem ifTrue: 		[picture _ DataMaster formFromItem: entry contents.		picture == nil ifFalse: 			[picture displayOn: view workingForm white.			acted _ true.			classif _ entry contents]].	acted		ifTrue: 			[Clipboard retrieve. "get it out of the buffer"			(Smalltalk includesKey: #Suitcase)				ifTrue: [view topView changeClassification: classif].			^view display]		ifFalse: [Clipboard booboo]!putMap	"Ask the user for a file name and then save the currently 	displayed image under that name into the information center."	| imageLabelArray mySuitcase keys |	(Smalltalk includesKey: #Suitcase) ifFalse:			[self accept.			(whatFile ~= nil and: [self confirm: 'overwrite ', whatFile, (String with: $?)])				ifTrue: [view workingForm writeOn: whatFile. locked _ #no]				ifFalse: [(imageLabelArray _ self request: 'Enter file name') isEmpty ifFalse: [view workingForm writeOn: (whatFile _ imageLabelArray). locked _ #no]].			^self].	view topView suitcase accept.	self accept.	mySuitcase _ view topView suitcase.	(whatFile ~= nil and: [self confirm: 'overwrite ', mySuitcase dataItem label, (String with: $?)])		ifTrue: [view workingForm writeAsDataItem: mySuitcase dataItem. locked _ #no]		ifFalse:			[keys _ (mySuitcase dataItem centerIndex = 0						ifTrue: [String new]						ifFalse: [mySuitcase center keywordStringFor: mySuitcase dataItem]).			imageLabelArray _ InformationCenter fileNameData: #image defaultSuitcase: mySuitcase defaultKeys: keys askMethod: true askClass: true.			(imageLabelArray at: 1) isNil ifTrue: [^nil].			Cursor wait showWhile:				[view workingForm writeAsDataItem: (imageLabelArray at: 1)].			whatFile = nil ifTrue:					[whatFile _ (imageLabelArray at: 1) filename.					mySuitcase packTheSuitcaseFrom: ((imageLabelArray at: 4) at: 1) forItem: (imageLabelArray at: 1).					view topView erase.					view topView label: (imageLabelArray at: 1) label.					view topView classifyLabel: mySuitcase classification.					view topView display].			locked _ #no.			InformationCenter putFileNameAway: imageLabelArray]!redButtonActivity	locked _ #yes.	Cursor blank showWhile: [self perform: tool]!setVariables	| aController tempForm |	tool _ #repeatCopy.	previousTool _ tool _ #draw.	grid _ 1 @ 1.	togglegrid _ 8 @ 8.	xgridOn _ false.	ygridOn _ false.	mode _ Form over.	unNormalizedColor _ color _ Form black.	self defaultBrush.	view notNil ifTrue:		[self allSubViewsOf: view topView do:			[:aView |			aController _ aView controller.			(aController isKindOf: RemoteMenuController) ifTrue:				[aController yellowButtonMenu resetSelection.				aController menuMessageReceiver perform: (aController yellowButtonMessages at: 1) with: aController]]]! !!ImageEditor methodsFor: 'activity (tool)'!activity: aController	| aForm aLabel aTreeMenu child x y |	aTreeMenu _ self class activityMenu.	[(child _ aTreeMenu child) isKindOf: TreeMenu] whileTrue: [aTreeMenu resetSelection. aTreeMenu _ child].	aTreeMenu answer notNil ifTrue: [tool _ aTreeMenu answer].	aTreeMenu resetSelection.	previousTool _ tool.	self showStatus: tool asParagraph of: aController!block	"Allow the user to fill a rectangle with the gray tone and mode  	currently selected."	| rectangle |	rectangle _ Rectangle fromUser: grid.	rectangle isNil 		ifFalse: [Display					fill: (rectangle intersect: view insetDisplayBox)					rule: mode					mask: color]!changeTool: aCharacter 	"Changes the value of the instance variable tool to be the tool 	corresponding to aCharacter. Typically sent from a Switch in a 	FormMenuView. "	previousTool _ tool.	tool _ self selectTool: aCharacter.	(#(singleCopy repeatCopy line curve block) includes: tool)		ifFalse:			[self perform: tool]!circle	"Draw a circle on the map based on obtained center and radial point."		| center radialPoint aCircle |	radialPoint _ center _ self cursorPoint.	[sensor redButtonPressed] whileFalse.	aCircle _ self rubberBandCircleFrom: center until:		[sensor redButtonPressed not]. 	aCircle form: form.	Cursor execute showWhile:		[aCircle displayOn: Display at: 0@0 clippingBox: view insetDisplayBox rule: mode mask: color]!clCurve	"Select points on a Path using the red button.  Terminate by selecting any other	button.  Creates a closed curve from the points and displays it. " 	self spline: Spline closed: true!clLinear	"Select points on a Path using the red button.  Terminate by selecting any other	button.  Creates a closed polygon from the points and displays it." 	self spline: LinearFit closed: true!curve	"Conic-section specified by three points from the mouse.   	the resultant curve on the display is displayed according to the   	current form and mode."	| firstPoint secondPoint curve |	firstPoint _ self cursorPoint.	form		displayOn: Display		at: firstPoint		clippingBox: view insetDisplayBox		rule: mode		mask: color.	secondPoint _ self trackForm: form until: [sensor noButtonPressed].	curve _ self rubberBandCurve: firstPoint to: secondPoint until: [sensor redButtonPressed].	curve		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: mode		mask: color.	sensor waitNoButton!draw	self repeatCopy!fill	| aForm aRectangle interiorPoint |	interiorPoint _ Sensor cursorPoint.	view updateDisplay.	aRectangle _ view insetDisplayBox.	aForm _ Form fromDisplay: aRectangle.	aForm offset: aRectangle origin.	Cursor execute showWhile:		 [aForm floodFill: interiorPoint - aRectangle origin mask: color interim: true].	aForm		displayOn: Display		at: 0@0		clippingBox: view insetDisplayBox		rule: Form over		mask: nil!line	"Rubber-band line is specified by two points from the mouse. The resultant   	line on the display is displayed according to the current form and mode."	| firstPoint endPoint |	firstPoint _ self cursorPoint.	endPoint _ self rubberBandFrom: firstPoint until: [sensor noButtonPressed].	(Line from: firstPoint to: endPoint withForm: form)		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: mode		mask: color!opnCurve	"Select points on a Path using the red button.  Terminate by selecting any other	button.  Creates a curve from the points and displays it." 	self spline: Spline closed: false!opnLinear	"Select points on a Path using the red button.  Terminate by selecting any other	button.  Creates a Path from the points and displays it as a piece-wise linear	approximation." 	self spline: LinearFit closed: false!rectangle	| aRectangle |	aRectangle _ Rectangle fromUser: grid.	LinearFit new		form: form;		add: aRectangle origin;		add: (aRectangle origin x @ aRectangle corner y);		add: aRectangle corner;		add: (aRectangle corner x @ aRectangle origin y);		add: aRectangle origin;		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: mode		mask: color!repeatCopy	"As long as the red button is pressed, copy the source form onto the display screen."	[sensor redButtonPressed]		whileTrue: 			[form				displayOn: Display				at: self cursorPoint				clippingBox: view insetDisplayBox				rule: mode				mask: color]!singleCopy	form		displayOn: Display		at: self cursorPoint		clippingBox: view insetDisplayBox		rule: mode		mask: color.	sensor waitNoButton!stamp	self singleCopy! !!ImageEditor methodsFor: 'brush'!borderBrush	| response | 	response _ self request: 'Line width for border: '.	response isEmpty ifTrue:[^self].	form borderWidth: response asNumber!brush: aController	self performTreeBackwards: self class brushMenu.	form offset: 0@0.	self showStatus: form of: aController.	form offset: ((0@0) - (form boundingBox center)).	self oldTool!circleBrush		| aCircle futureBrush response lineSize box |	response _ self request: 'Line width for circle: '.	response isEmpty ifTrue:[^self].	lineSize _ ((Integer readFromString: response) min: 50) max: 1.	form _ Form dotOfSize: lineSize.	Cursor blank show.	self trackForm: Cursor crossHair until: [sensor redButtonPressed].	aCircle _ self rubberBandCircleFrom: self cursorPoint		until: [sensor redButtonPressed not]. 	aCircle form: form; center: 0@0.	box _ aCircle computeBoundingBox rounded.	futureBrush _ (Form extent: box extent) offset: box origin.	Cursor execute showWhile:		[aCircle displayOn: futureBrush at: 0@0 - futureBrush offset			clippingBox: futureBrush boundingBox rule: Form under mask: color].	form _ futureBrush!copyBrush	Clipboard clip: form deepCopy.	Clipboard last contents offset: 0@0.	(Smalltalk includesKey: #Suitcase) ifTrue: [Clipboard last propertyAt: #classification put: view topView suitcase classification]!defaultBrush	form _ Form new extent: 4@4; black!dot	| newBrushSize circ box futureBrush |	newBrushSize _ self request: 'New round brush diameter: '.	newBrushSize isEmpty ifFalse: [Cursor execute showWhile:		[newBrushSize _ ((Integer readFromString: newBrushSize) min: 800) max: 1.		circ _ (Circle new) center: Display boundingBox center; radius: newBrushSize // 2; form: (Form dotOfSize: 1).		box _ circ computeBoundingBox rounded.		futureBrush _ (Form extent: box extent) offset: box origin.		circ displayOn: futureBrush at: 0@0 - futureBrush offset			clippingBox: futureBrush boundingBox rule: Form over mask: Form black.		futureBrush floodFill: futureBrush boundingBox center mask: Form black interim: nil.		form _ futureBrush]]!fileOutForm	"Ask the user for a file name and then save the current source form (form)	under that name.  Does not change the tool."	| brushLabelArray defaultItem defaultSuitcase |	tool _ previousTool.	(Smalltalk includesKey: #Suitcase) ifFalse:			[(defaultItem _ self request: 'Enter file name') isEmpty ifFalse: [form writeOn: defaultItem].			 ^self].	defaultItem _ view topView suitcase dataItem deepCopy.	defaultItem label: 'new brush'.	defaultSuitcase _ Suitcase new packTheSuitcaseFrom: view topView suitcase centerName forItem: defaultItem.	brushLabelArray _ InformationCenter fileNameData: #image defaultSuitcase: defaultSuitcase defaultKeys: String new askMethod: true askClass: true.	(brushLabelArray at: 1) isNil ifTrue: [^nil].	Cursor wait showWhile: [	form writeAsDataItem: (brushLabelArray at: 1)].	InformationCenter putFileNameAway: brushLabelArray!grabArbitraryImage	"This method allows the user to grab an arbitrary image from a form.	The method starts by having the user sketch  a closed area on the screen.  	At the same time it also draws the closed area on an extra form.  It then selects	a rectangular area of the extra form which includes all off the area to be grabbed.	The method then picks an interior point, fills the extra form,to determine 	the extent of the grabbed area, and ANDs the extra form with the original 	to determine the portion of the original image to grab."	| interiorPoint  aPen anotherPen extraForm outlineForm grabbedForm mapRect extraRect grabbedRect |	extraForm _ Form new extent: model boundingBox extent.	aPen _ Pen new" combinationRule: Form reverse".	anotherPen _ Pen new destForm: extraForm.	Cursor normal showWhile:		[		Sensor waitButton.		aPen place: Sensor cursorPoint.		anotherPen place:  ((aPen location)-(view insetDisplayBox topLeft)).		mapRect _ aPen location extent: 0@0.		extraRect _ anotherPen location extent: 0@0.		"Draw boundary and keep track of a Rectangle that contains the boundary."		[Sensor anyButtonPressed]			whileTrue: 				[aPen goto: Sensor cursorPoint.				anotherPen goto: ((aPen location) - (view insetDisplayBox topLeft)).				mapRect _ mapRect merge: (aPen location extent: 0@0).				extraRect _ extraRect merge: (anotherPen location extent: 0@0).				].		].	"Produce  the  image."	outlineForm  _ Form new extent: extraRect extent.	grabbedRect _ outlineForm  boundingBox.	outlineForm 		copyBits: extraRect		from: extraForm at:0@0 		clippingBox: grabbedRect		rule: Form over 		mask: nil.	extraForm _ nil. "Free up some core space"	Cursor crossHair showWhile:		[interiorPoint _ Sensor waitButton-(view insetDisplayBox topLeft)-extraRect origin].	grabbedForm _ outlineForm deepCopy.	(grabbedRect containsPoint: interiorPoint) ifFalse:[^view display].	Cursor execute showWhile:		["grabbedForm shapeFill: Form black interiorPoint: interiorPoint"		 grabbedForm floodFill: interiorPoint mask: Form black interim: nil].	view display.	"get rid of outline over view - otherwise is picked up after leave here"	"Construct the final form."	grabbedForm		copyBits: grabbedRect  		from: outlineForm		at: 0@0		clippingBox: grabbedRect		rule: Form reverse		mask: nil;		copyBits: mapRect  		from: Display		at: 0@0		clippingBox: grabbedRect		rule: 1		mask: nil.	form _ grabbedForm!hardcopyBrush	(Smalltalk includesKey: #BackgroundPrinter) ifFalse: [^self booboo: 'Sorry, I do not know how to hardcopy.'].	BackgroundPrinter printForm: form suitcase: view topView suitcase!horizontalReflection	Cursor execute showWhile: [form _ form reflect: 1@0]!icon	| aCharacter aForm |	(aCharacter _ IconSubmenu answer) isNil ifFalse:		[ParagraphEditor copyText: (String with: aCharacter) asText.		form _ (Text string: (String with: aCharacter) emphasis: IconFontNumber) asParagraph asForm].	IconSubmenu resetSelection!invertBrush	form reverse!magnifyBrush	| aPoint response howBig |	aPoint _ 1@1.	howBig _ Point x: (1024 // form extent x) y: (808 // form extent y).	response _ self request: 'max width magnification factor ', howBig x printString.	response isEmpty ifFalse: [aPoint x: (((Number readFromString: response) max: 1) min: howBig x)].	response _ self request: 'max height magnification factor ', howBig y printString.	response isEmpty ifFalse: [aPoint y: (((Number readFromString: response) max: 1) min: howBig y)].	Cursor execute showWhile: [form _ form magnifyBy: aPoint]!newSourceForm	"Allow the user to define a new sourceForm for the FormEditor. Copying the	sourceForm onto the display is the primary graphical operation. Resets the tool to	be repeatCopy."	form _ Form fromUser: grid.	tool _ previousTool!pasteBrush	| type entry acted picture classif |	(entry _ Clipboard next) == nil ifTrue: [^Clipboard booboo].	acted _ false.	type _ entry contents class.	classif _ entry propertyAt: #classification.	type == Form ifTrue: 		[picture _ entry contents.		picture == view workingForm ifTrue: [form _ picture deepCopy] ifFalse: [form _ picture].		acted _ true].	type == Text ifTrue: 		[form _ entry contents asParagraph asForm.		acted _ true].	type == DataItem ifTrue: 		[picture _ DataMaster formFromItem: entry contents.		picture == nil ifFalse: 			[form _ picture.			acted _ true.			classif _ entry contents]].	acted		ifTrue: 			[Clipboard retrieve.			(Smalltalk includesKey: #Suitcase)				ifTrue: [view topView changeClassification: classif].			^view display]		ifFalse: [Clipboard booboo]!rectangleBrush	| response newBrushSize drawRectangle futureBrush |	response _ self request: 'Line width for rectangle: '.	response isEmpty ifTrue:[^self].	Cursor blank show.	newBrushSize _ ((Integer readFromString: response) min: 50) max: 1.	self trackForm: Cursor origin until: [sensor redButtonPressed].	drawRectangle _ (Rectangle fromUser: grid) moveTo: grid.	futureBrush  _ Form extent: drawRectangle corner.	futureBrush borderWidth: newBrushSize.	form _ futureBrush!rotate180	Cursor execute showWhile: [form _ form rotateBy: 2]!rotate270	Cursor execute showWhile: [form _ form rotateBy: 3]!rotate90	Cursor execute showWhile: [form _ form rotateBy: 1]!shrink	| aPoint response |	aPoint _ 1@1.	response _ self request: 'width reduction factor: '.	response isEmpty ifFalse: [aPoint x: ((Number readFromString: response) max:1)].	response _ self request: 'height reduction factor: '.	response isEmpty ifFalse: [aPoint y: ((Number readFromString: response) max:1)].	Cursor execute showWhile: [form _ form shrinkBy: aPoint]!square	| newBrushSize response |	response _ self request: 'New square brush size: '.	response isEmpty ifFalse: [newBrushSize _ ((Integer readFromString: response) min: 800) max: 1].	Cursor execute showWhile: [form _ Form new extent: newBrushSize@newBrushSize; black]!symbol	| aCharacter aForm |	(aCharacter _ SymbolSubmenu answer) isNil ifFalse:		[ParagraphEditor copyText: (String with: aCharacter) asText.		form _ (Text string: (String with: aCharacter) emphasis: IconFontNumber) asParagraph asForm.		((SymbolSubmenu child) notNil and: [(aCharacter _ SymbolSubmenu child answer) notNil]) ifTrue:			[aForm _ Form new extent: ((form extent) + (0@4)).			(Text string: (String with: aCharacter) emphasis: IconFontNumber) asParagraph asForm displayOn: aForm at: (0@-9).			form displayOn: aForm at: ((0@4) - form offset) rule: Form under.			form _ aForm]].	SymbolSubmenu resetSelection! !!ImageEditor methodsFor: 'color'!color: aController	self performTreeBackwards: self class colorMenu.	self oldTool.	self showStatus: color of: aController!colorBlack	"Set the mask (color) to black. Leaves the tool set in its previous state."	self normalizeColor: Form black.	tool _ previousTool!colorDarkGray	"Set the mask (color) to dark gray.  Leaves the tool set in its previous state."	self normalizeColor: Form darkGray.	tool _ previousTool!colorGray	"Set the mask (color) to gray.  Leaves the tool set in its previous state."	self normalizeColor: Form gray.	tool _ previousTool!colorLightGray	"Set the mask (color) to light gray.  Leaves the tool set in its previous state."	self normalizeColor: Form lightGray.	tool _ previousTool!colorPinStripe	"Set the mask (color) to 'pin stripe'.  Leaves the tool set in its previous state."	self normalizeColor: self class pinStripe.	tool _ previousTool!colorSlant	"Set the mask (color) to slant.  Leaves the tool set in its previous state."	self normalizeColor: self class slant.	tool _ previousTool!colorStripe	"Set the mask (color) to 'stripe'.  Leaves the tool set in its previous state."	self normalizeColor: self class stripe.	tool _ previousTool!colorVeryLightGray	"Set the mask (color) to very light gray.  Leaves the tool set in its previous state."	self normalizeColor: Form veryLightGray.	tool _ previousTool!colorWhite	"Set the mask (color) to white.  Leaves the tool set in its previous state."	self normalizeColor: Form white.	tool _ previousTool!copyColor	Clipboard clip: color.	tool _ previousTool!normalizeColor: halftoneForm	unNormalizedColor _ halftoneForm.	color _ unNormalizedColor wrapAround: view insetDisplayBox origin.!pasteColor	| tempForm type entry |	type _ Clipboard nextClass.	type == Form ifFalse: [^Clipboard booboo]. 	tempForm _ Form extent: 16@16.	Clipboard retrieveEntry contents displayOn: tempForm.	self normalizeColor: tempForm.	tool _ previousTool! !!ImageEditor methodsFor: 'grid'!changeGridding	"Allow the user to change the values of the horizontal and(or) vertical grid 	modules.  Does not change the primary tool."	| response gridInteger |	response _ 		self promptRequest: 'Current horizontal gridding is: ', togglegrid x printString, '.Type new horizontal gridding.'.	response isEmpty		ifFalse: 			[gridInteger _ Integer readFromString: response.			togglegrid x: ((gridInteger max: 1) min: Display extent x)].	response _ 		self promptRequest: 'Current vertical gridding is: ', togglegrid y printString, '.Type new vertical gridding.'.	response isEmpty		ifFalse: 			[gridInteger _ Integer readFromString: response.			togglegrid y: ((gridInteger max: 1) min: Display extent y)].	xgridOn ifTrue: [grid x: togglegrid x].	ygridOn ifTrue: [grid y: togglegrid y].	tool _ previousTool!grid: aController	| aString |	self performTreeBackwards: self class gridMenu.	self oldTool.	(xgridOn | ygridOn)		ifTrue:			[aString _ String new.			xgridOn ifTrue: [aString _ 'x: ', grid x printString, (String with: Character space)].			ygridOn ifTrue: [aString _ aString, 'y: ', grid y printString]]		ifFalse: [aString _ '(off)'].	self showStatus: aString asParagraph asForm of: aController!toggleGridding	self togglexGridding; toggleyGridding!togglexGridding	"Turns x (horizontal) gridding off, if it is on, and turns it on, if  	it is off.  Does not change the primary tool."	xgridOn		ifTrue: 			[grid x: 1.			xgridOn _ false]		ifFalse: 			[grid x: togglegrid x.			xgridOn _ true].	tool _ previousTool!toggleyGridding	"Turns y (vertical) gridding off, if it is on, and turns it on, if  	it is off.  Does not change the primary tool."	ygridOn		ifTrue: 			[grid y: 1.			ygridOn _ false]		ifFalse: 			[grid y: togglegrid y.			ygridOn _ true].	tool _ previousTool! !!ImageEditor methodsFor: 'mode'!eraseMode	"Set the mode for the tools that copy the form onto the display to erase.  	Leaves the tool set in its previous state."	mode _ 4.	tool _ previousTool!mode: aController	self performTreeBackwards: self class modeMenu.	self oldTool.	self showStatus: (#(and ? over erase ? reverse under) at: mode) asParagraph asForm of: aController!overMode	"Set the mode for the tools that copy the form onto the display to over.  	Leaves the tool set in its previous state."	mode _ Form over.	tool _ previousTool!reverseMode	"Set the mode for the tools that copy the form onto the display to reverse.  	Leaves the tool set in its previous state."	mode _ Form reverse.	tool _ previousTool!underMode	"Sets the mode for the tools that copy the form onto the display to under.  	Leaves the tool set in its previous state."	mode _ Form under.	tool _ previousTool! !!ImageEditor methodsFor: 'private'!allSubViewsOf: aView do: aBlock	aBlock value: aView.	aView subViews do: [:eachSubview | self allSubViewsOf: eachSubview do: aBlock]!dragForm	| drageeForm lastPoint |	drageeForm _ form.	(#(block rectangle) includes: tool)		ifTrue: [drageeForm _ Cursor origin].	(#(circle opnCurve clCurve opnLinear clLinear fill) includes: tool)		ifTrue: [drageeForm _ Cursor crossHair].	Cursor blank show.	lastPoint _ self trackForm: drageeForm until: [sensor anyButtonPressed or: [self viewHasCursor not]].	Cursor normal show.	^lastPoint!fastRubberBandFrom: startPoint until: aBlock	| saveForm saveColor endPoint |	saveForm _ form.	saveColor _ color.	form _ Form new extent: 1@1; black. "Looks better if size is odd."	color _ Form black.	endPoint _ self rubberBandFrom: startPoint until: aBlock.	form _ saveForm.	color _ saveColor.	^endPoint!fieldThis	locked == #no ifFalse: [(self confirm: view topView label , '''s contents have not been saved.  Are youcertain that you want to close?')				ifTrue: [Cursor normal show.^true]				ifFalse: [Cursor normal show.^false]].	^true!initializeYellowButtonMenu 	self yellowButtonMenu: AnnotationEditorYellowButtonMenu yellowButtonMessages: TreeMenu!promptRequest: outputMessage 	"Answers with a string typed by the user on the keyboard. keyboard input is 	terminated by a line feed character. Typing feedback happens in a window that 	is at least 100 bits wide and 50 bits high."	| answer |	FillInTheBlank		request: outputMessage		displayAt: view insetDisplayBox topCenter + (0@80)		centered: true		action: [:answer] 		initialAnswer: String new.	^answer!request: message	^self request: message default: String new!request: message default: default	| answer saveCursor |	saveCursor _ self cursorPoint.	sensor cursorPoint: view insetDisplayBox topCenter + (0@80).	answer _ FillInTheBlank request: message default: default.	sensor cursorPoint: saveCursor.	^answer!rubberBandCircleFrom: centerPoint until: aBlock	"Show an xor circle from centerPoint to the cursor point until aBlock evaluates to true, then remove the circle and answer it."	| circ rad |	circ _ (Circle new) center: centerPoint; radius: 0; form: (Form dotOfSize: 1).	circ displayOn: Display at: 0@0 clippingBox: view insetDisplayBox		rule: Form reverse mask: nil.		"display"	Cursor crossHair showWhile:	[ [aBlock value] whileFalse:		[(rad _ (self cursorPoint - centerPoint) r rounded) = circ radius ifFalse:			[circ displayOn: Display at: 0@0 clippingBox: view insetDisplayBox				rule: Form reverse mask: nil.		"erase"			circ radius: rad.			circ displayOn: Display at: 0@0 clippingBox: view insetDisplayBox				rule: Form reverse mask: nil.		"display"			]]].	circ displayOn: Display at: 0@0 clippingBox: view insetDisplayBox		rule: Form reverse mask: nil.		"erase"	^circ!rubberBandCurve: startPoint to: endPoint until: aBlock	| curve previousApex apex | "Return a curve"	curve _ Curve new.	curve firstPoint: startPoint.	curve secondPoint: (previousApex _ self cursorPoint).	curve thirdPoint: endPoint.	curve form: form.	curve		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: Form reverse		mask: Form black.	[aBlock value] whileFalse:		[Cursor crossHair showWhile: [(apex _ sensor cursorPoint) = previousApex 			ifFalse:			[curve				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				mask: Form black.			curve secondPoint: apex.			curve				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				mask: Form black.			previousApex  _ apex]]].		curve				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form reverse				mask: Form black.	^ curve!rubberBandFrom: startPoint until: aBlock	"Show an xor line from startPoint to the cursor point until aBlock evaluates to true, then remove the line and answer the endPoint."	| line endPoint |	line _ Line from: startPoint to: startPoint withForm: form.	line displayOn: Display at: 0@0 clippingBox: view insetDisplayBox		rule: Form reverse mask: nil.		"display"	[aBlock value] whileFalse:		[(endPoint _ self cursorPoint) = line endPoint ifFalse:			[line displayOn: Display at: 0@0 clippingBox: view insetDisplayBox				rule: Form reverse mask: nil.		"erase"			line endPoint: endPoint.			line displayOn: Display at: 0@0 clippingBox: view insetDisplayBox				rule: Form reverse mask: nil.		"display"			]].	line displayOn: Display at: 0@0 clippingBox: view insetDisplayBox		rule: Form reverse mask: nil.		"erase"	^line endPoint!showStatus: statusForm of: aController	| aForm aRectangle x y |	aForm _ aController model.	x _ aForm extent x.	y _ aForm extent y.	aRectangle _ 0@(y//2) corner: x@y.	aForm fill: aRectangle rule: Form erase mask: Form black.	statusForm displayOn: aForm at: (x@(3*y)) // (2@4) - (statusForm boundingBox center) + (0@1) clippingBox: aRectangle.	aController view topView controller = ScheduledControllers activeController ifTrue:		[aController view display]!spline: aPathSubclass closed: closed	"Select points on a Path using the red button.  Terminate by selecting any other	button.  Creates a Path from the points and displays it as a piece-wise linear	approximation." 	| aPath anOrderedCollection flag i |	aPath _ aPathSubclass new form: form.	anOrderedCollection _ OrderedCollection new.	flag _ true.	[flag] whileTrue:		[self trackForm: Cursor crossHair until: [sensor anyButtonPressed].		sensor redButtonPressed			ifTrue: [aPath add: self waitClickButton.				(anOrderedCollection addLast: aPath size printString asForm) displayOn: Display at: aPath last clippingBox: view insetDisplayBox rule: Form reverse mask: nil.form displayOn: Display at: aPath last clippingBox: view insetDisplayBox rule: Form reverse mask: color]			ifFalse: [flag _ false]].	i _ 0.	anOrderedCollection isEmpty ifTrue: [^self].	anOrderedCollection do: [:each | each displayOn: Display at: (aPath at: (i _ i + 1)) clippingBox: view insetDisplayBox rule: Form reverse mask: nil].	(closed and: [aPath size > 0]) ifTrue: [aPath add: (aPath at: 1)].	(aPath isKindOf: Spline) ifTrue: [aPath computeCurve].	aPath		displayOn: Display		at: 0 @ 0		clippingBox: view insetDisplayBox		rule: mode		mask: color.	[sensor anyButtonPressed] whileTrue: ["wait for the user to get off the button - only needed on fast machines"]!trackForm: theForm until: aBlock	| previousPoint cursorPoint |	previousPoint  _ self cursorPoint.	theForm displayOn: Display at: previousPoint		clippingBox: view insetDisplayBox		rule: Form reverse mask: Form black.	[aBlock value] whileFalse:		[cursorPoint _ self cursorPoint.		(cursorPoint ~= previousPoint) ifTrue:			[theForm displayOn: Display at: previousPoint				clippingBox: view insetDisplayBox				rule: Form reverse mask: Form black.			theForm displayOn: Display at: cursorPoint				clippingBox: view insetDisplayBox				rule: Form reverse mask: Form black.			previousPoint  _ cursorPoint]].	theForm displayOn: Display at: previousPoint		clippingBox: view insetDisplayBox		rule: Form reverse mask: Form black.	^ previousPoint!transcriptController: aTextCollectorController	textPaneController _ aTextCollectorController! !!ImageEditor methodsFor: 'cursor'!cursorPoint	"Answer the mouse coordinate data gridded according to the receiver's grid."	^sensor cursorPoint grid: grid!waitClickButton	"Answer the mouse coordinate data gridded according to the receiver's grid."	sensor waitButton.	[sensor anyButtonPressed] whileTrue.	^self cursorPoint! !MapEditor comment:'Copyright (c) 1983, 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.I am a subclass of ImageEditor which knows how to deal with geographic maps. I provide additional editing tools specific to maps. I know about latitudes and longitudes. I can draw new maps from World Data Bank II (WDBII) vector data read from files.My map drawing methods are designed along with WDBII data file formats to allow rapid drawing on machines which have no floating point hardware support. Integer operations, instead of floating point operations, are used within all drawing loops.Map data is stored as follows:''.control'' - For each map there is an ascii file with the extension ''.control'' which specifies geographic boundaries, resolution, and name of the vector data files from which the map is drawn or is to be drawn. The format is: southernmost latitude (expressed as ascii text), followed by a space character, westernmost longitude, space, northernmost latitude, space, easternmost longitude, space, resolution, space, single quote character, file name (minus extension), single quote. The lat/lon numbers are all either integers or floating point. In this file, latitudes must be between -90 and 90, inclusive. Positive latitude numbers always mean north of the equator, and negative latitudes mean south of the equator. Longitudes may be in any range (multiples of 360 will be automatically be added or subtracted as appropriate). For longitudes, east is the positive direction, and west is negative. The resolution number for WDBII data is the integer 4096. Although I don''t currently use the resolution for anything because I don''t yet know how to draw map formats other than WDBII, I nonetheless require that a number be present here. For example, a control file for a map of the United States might be called ''USA.control'' or ''USA.map.control'', and might contain the following:	23.5 -130 50 -60 4096 ''ContinentalUS1'''''' - For each map which has been previously drawn from vector data and then stored as a bit map, there is a file without any particular extension which contains the bits. This file is in a format suitable for reading by the Form class method for #readFromFile:. The first word of the file is the "file code," which is the integer 1. The second word is the width of the Form (in bits), and the third word of the file is the height of the Form in bits. The fourth and fifth words are the Form''s offset point x and y respectively. Following that are ((width +15) //16) * height words which can be read directly into a WordArray.''.mapData''Instance Variables:	pointsByteArray	<ByteArray>	Buffer containing one segment''s worth of map vectors read from a ''.mapData'' file.	aBitBlt	<BitBlt>	An instance of BitBlt is kept around while drawing a map because it is faster just to change the BitBlt''s destX and destY than it is to set up a new instance of BitBlt over and over again.	xTable	<MapTransformationTable>		yTable	<MapTransformationTable>		shiftAmountX	<SmallInteger>		shiftAmountY	<SmallInteger>		headerClippingBox	<ByteArray>	hintsFile	<FileStream>	dataFile	<FileStream>	hints	<?>	pointsWordArray	<WordArray>	skipAmount	<Integer>resolution centerX crossesZeroX tablesOffsetPoint mapName displayedItems drawPending ''Class VariablesDataBufferSize DataFormatToLatLonWindowingTransformation HeaderSize HintsBufferSize HintSize MapBrushMenu MapDatabaseSubmenu MapYellowButtonMenu '''!!MapEditor methodsFor: 'initialize-release'!fieldThis	 super fieldThis		ifTrue: [(whatFile ~~ nil and: [whatFile = (TempMapName, (DataMaster giveMe: #suffixString for: #map asString))])					ifTrue: [Disk removeKey: (TempMapName, (DataMaster giveMe: #suffixString for: #map asString)), (DataMaster giveMe: #specialSuffixString for: #map asString) ifAbsent: []].				^ true].	^false!initializeMapDatabaseSubmenuWithSuitcase: aSuitcase	| itemList center labelString | 	mapDatabases _ Array new: 3.	itemList _ OrderedCollection new.	(center _ aSuitcase center) == nil ifFalse:		[(aSuitcase dataItem fPointersOfType: (center linkTypeFor: #database)) do: 			[:dbPtr | itemList add: (center fileCabinet at: (dbPtr at: 3))]].	labelString _ String new.	itemList do: [:dbItem | labelString _ (labelString, dbItem label, (String with: Character cr))].	mapDatabases at: 3 put: labelString.	mapDatabases at: 1 put: (PopUpMenu labels: labelString).	mapDatabases at: 2 put: itemList asArray!mapControl: controlFileName"	Read the control file for this map.	controlFileName	<String> the name of the map's .control file (The extension '.control' will be automatically appended to controlFileName.)	"	self initializeMapDatabaseSubmenuWithSuitcase: view topView suitcase.	self readControlFile: controlFileName.	displayedItemsUndo _ OrderedCollection new.	displayedItems _ OrderedCollection new.	whatFile _ controlFileName!mapControl: controlFileName withSuitcase: aSuitcase"	Read the control file for this map.	controlFileName	<String> the name of the map's .control file (The extension '.control' will be automatically appended to controlFileName.)	"	self initializeMapDatabaseSubmenuWithSuitcase: aSuitcase.	self readControlFile: controlFileName.	displayedItemsUndo _ OrderedCollection new.	displayedItems _ OrderedCollection new.	whatFile _ controlFileName!mapWaitingToBeDrawn: controlFileName	drawPending _ controlFileName! !!MapEditor methodsFor: 'basic control sequence'!controlInitialize	super controlInitialize.	drawPending == nil		ifFalse: [self drawMap: drawPending.			drawPending _ nil]! !!MapEditor methodsFor: 'editing tools'!accept	"When accept changes to the map, keep the lists of displayed items. "	displayedItemsUndo _ displayedItems deepCopy.	^super accept!cancel	"When cancelling changes to the map, clear the lists of displayed items. "	displayedItems _ displayedItemsUndo deepCopy.	^super cancel!distanceBearingBig	"Compute distance and bearing from two geographic positions."	| geoPoint1 geoPoint2 sinp1 sinp2 cosp1 cosp2 cosa ang dist firstCursorPoint cosaz bear sign saveColor saveForm tpBox secondCursorPoint | 	Cursor crossHair showWhile:[		[sensor redButtonPressed] whileFalse: [].		firstCursorPoint _ sensor cursorPoint.		tpBox _ textPaneController view insetDisplayBox.		textPaneController model cr; cr; endEntry.		geoPoint1 _ view inverseLatLonDisplayTransform: firstCursorPoint.		sinp1 _ geoPoint1 y degreesToRadians sin.		cosp1 _ geoPoint1 y degreesToRadians cos.		self fastRubberBandFrom: firstCursorPoint until:			[secondCursorPoint _ sensor cursorPoint.			firstCursorPoint = secondCursorPoint				ifTrue: [dist _ 0. bear _ 0]				ifFalse:					[" compute distance "					geoPoint2 _ view inverseLatLonDisplayTransform: secondCursorPoint.					sinp2 _ geoPoint2 y degreesToRadians sin.					cosp2 _ geoPoint2 y degreesToRadians cos.					sign _ (geoPoint2 - geoPoint1) x degreesToRadians.					cosa _ (sinp1 * sinp2) + (cosp1 * cosp2 * (sign abs cos)).					cosa >= 1.0 ifTrue: [cosa _ 0.99].					ang _ cosa arcCos.					dist _ (ang * 3437.9768) "roundTo: 0.001".					dist < 3.848 ifTrue: [dist _ (geoPoint1 dist: geoPoint2) * 60.0].					" compute azimuth "					cosaz _ (sinp2 - (sinp1 * cosa)) / (cosp1 * (ang sin)).					cosaz >= 1.0 ifTrue: [cosaz _ 0.99.].					bear _ (cosaz arcCos) radiansToDegrees roundTo: 0.01.					sign < 0.0 ifTrue: [bear _ 360.0 - bear].					" display distance and bearing "					('Distance = ', dist printString, '        Bearing =  ', bear printString) asForm displayOn: Display at: tpBox origin + (10 @ 0) clippingBox: tpBox].					sensor redButtonPressed not]].			textPaneController				deselect;				closeTypeIn;				replaceSelectionWith:					(Text string: ('Distance = ', dist printString, '        Bearing =  ', bear printString,' ') emphasis: (TextStyle getNumForStrikeFont: 'Helvetica12b'));				selectAndScroll.	textPaneController model show: ' '.	Sensor waitNoButton!drawMap	| theSuitcase | 	Cursor normal show.	(self checkForMapDataFiles) ifFalse: [^self].	self controlTerminate.	theSuitcase _ view topView suitcase deepCopy.	theSuitcase spare: displayedItems.	(TempMapName, (DataMaster giveMe: #suffixString for: #map asString)) = theSuitcase dataItem filename		ifTrue: [self writeControlFile: TempMapName, (DataMaster giveMe: #suffixString for: #map asString)]. "control file may have been used by another zoom"	self class drawNewMapWithSuitcase: theSuitcase!drawMap: theFileName	| delta tempMapBounds |	Cursor execute showWhile:		[self mapControl: theFileName .		tempMapBounds _ model latLonBox copy.		self correctDistortion.		delta _ model latLonBox extent abs.		delta _ (delta x min: delta y) * 0.05.		(((model latLonBox expandBy: delta) contains: tempMapBounds) and: [tempMapBounds contains: (model latLonBox insetBy: delta)])			ifFalse: [self writeControlFile: theFileName].		view clearInside.		self drawMapDataPoints]!erase	displayedItemsUndo _ OrderedCollection new.	displayedItems _ OrderedCollection new.	super erase!geogGrid	| spacing endLat endLon xPoint yPoint lonGrid latGrid gridPoint pilot vbtl index |	spacing _ (Number readFromString: (self request:'type spacing for grid (deg)') ). 	vbtl _ view insetDisplayBox topLeft.	pilot _ self setUpBitBlt.	endLat _ model latLonBox corner y ceiling.	endLon _ model latLonBox corner x ceiling.	lonGrid _ model latLonBox origin x floor.	latGrid _ model latLonBox origin y floor.	lonGrid _ lonGrid - (lonGrid \\ spacing).	latGrid _ latGrid - (latGrid \\ spacing).	locked _ #yes.	latGrid to: endLat by: spacing do:		[:index|		yPoint _ ((model latLonBox corner y - index) / (model latLonBox extent y)) * view insetDisplayBox extent y.		gridPoint _ (0 @ yPoint) + vbtl.		pilot place: gridPoint.		gridPoint _ (view insetDisplayBox extent x @ yPoint) + vbtl.		pilot goto: gridPoint].	lonGrid to: endLon by: spacing do:		[:index|		xPoint _ (((index - model latLonBox origin x) / (model latLonBox extent x)) * view insetDisplayBox extent x).		gridPoint _ (xPoint @ 0) + vbtl.		pilot place: gridPoint.		gridPoint _ (xPoint @ view insetDisplayBox extent y) + vbtl.		pilot goto: gridPoint.]!getMap	self getMap: (self request: 'type in a name for recalling a source form . . . ')!getMap: theMapName	"replaces the current map with the selected one."	(Disk isLegalFileName: theMapName)		ifTrue:[			view model: (MapForm readFrom: (self getFileName: theMapName)); display.			self mapControl: (model latLonBox extent y = 512 ifTrue: ['image'] ifFalse: [theMapName]) withSuitcase: view topView suitcase]!getPoint	| stringBlock mapPoint direction |	Cursor crossHair showWhile:		[sensor waitButton.		[sensor redButtonPressed] whileTrue:			[mapPoint _ view inverseLatLonDisplayTransform: sensor cursorPoint]].	^mapPoint!latLonBig	| degrees minutes seconds direction stringBlock mapPoint |	stringBlock _		[:coordinate :directions |		direction _ String with: (directions at: (coordinate < 0 ifTrue: [2] ifFalse: [1])).		"degrees _ coordinate abs truncated printString, ' '.		 minutes _ ((coordinate abs fractionPart) * 60) asFloat.		 seconds _ ((minutes fractionPart) * 60) truncated printString, '""'.		 minutes _ minutes truncated printString, (String with: $').		 degrees, minutes, seconds, ' ', direction."		coordinate abs printString, (String with: Character space), direction].	Cursor crossHair showWhile:		[textPaneController model cr; endEntry.		sensor waitButton.		[sensor redButtonPressed] whileTrue:			[mapPoint _ view inverseLatLonDisplayTransform: sensor cursorPoint.			mapPoint x > 180 ifTrue: [mapPoint x: mapPoint x - 360].			textPaneController				deselect;				closeTypeIn;				replaceSelectionWith:					(Text string: ('Latitude =  ', (stringBlock value: mapPoint y value: 'NS'), '   Longitude = ', (stringBlock value: mapPoint x value: 'EW')) emphasis: 2);				selectAndScroll]].	stringBlock _ nil.  "Avoid circular garbage"	textPaneController model show: ' '!putMap	"Ask the user for a file name and then save the currently 	displayed map under that name into the information center."	| mapLabelArray mySuitcase keys |	mySuitcase _ view topView suitcase.	mySuitcase accept.	self accept.	(whatFile ~= nil and: [whatFile ~= (TempMapName, (DataMaster giveMe: #suffixString for: #map asString)) and: [self confirm: 'overwrite ', mySuitcase dataItem label, (String with: $?)]])		ifTrue: 			[view workingForm writeAsDataItem: mySuitcase dataItem.			self writeControlFile: whatFile.			locked _ #no]		ifFalse: 			[keys _ (mySuitcase dataItem centerIndex == 0					ifTrue: [String new]					ifFalse: [mySuitcase center keywordStringFor: mySuitcase dataItem]).			mapLabelArray _ InformationCenter fileNameData: #map defaultSuitcase: mySuitcase defaultKeys: keys askMethod: true askClass: true.			(mapLabelArray at: 1) == nil ifTrue: [^nil].			Cursor wait showWhile: [			view workingForm writeAsDataItem: (mapLabelArray at: 1).			self writeControlFile: (mapLabelArray at: 1) filename.			(whatFile == nil or: [whatFile = (TempMapName, (DataMaster giveMe: #suffixString for: #map asString))]) ifTrue:					[whatFile _ (mapLabelArray at: 1) filename.					mySuitcase packTheSuitcaseFrom: ((mapLabelArray at: 4) at: 1) forItem: (mapLabelArray at: 1).					view topView erase.					view topView label: (mapLabelArray at: 1) label.					view topView classifyLabel: mySuitcase classification.					view topView display].			locked _ #no].			InformationCenter putFileNameAway: mapLabelArray]!zoom	| aRectangle mapWindow saveLatLonBox theSuitcase newSuitcase |	(self checkForMapDataFiles) ifFalse: [^self].	mapWindow _ Rectangle fromUser.	mapWindow expandBy: 2.	Cursor wait show.	saveLatLonBox _ model latLonBox deepCopy.	aRectangle _ view inverseLatLonDisplayTransform: mapWindow.	aRectangle top < -89 ifTrue: [^self].	aRectangle bottom > 89 ifTrue: [^self].	model latLonBox: (aRectangle bottomLeft corner: aRectangle topRight).	self writeControlFile: (TempMapName, (DataMaster giveMe: #suffixString for: #map asString)).	model latLonBox: saveLatLonBox.	self controlTerminate.	Cursor normal show.	theSuitcase _ view topView suitcase.	newSuitcase _ Suitcase new packTheSuitcaseFrom: theSuitcase centerName forItem: (DataItem					locked: theSuitcase dataItem isLocked					classification: theSuitcase classification classification					modifiers: theSuitcase classification modifiers					type: #Item					label: 'Zoom Map'					filename: (TempMapName, (DataMaster giveMe: #suffixString for: #map asString))					bPointers: nil					fPointers: nil					atIndex: 0).	displayedItems isEmpty ifFalse: [newSuitcase spare: (displayedItems copyFrom: 1 to: displayedItems size)].	self class drawNewMapWithSuitcase: newSuitcase! !!MapEditor methodsFor: 'draw map'!checkForMapDataFiles	| theFiles theFile | 	theFiles _ String new.	(self getOldFileName: (theFile _ mapName, (DataMaster mapSuffixFor: #mapHints))) == nil		ifTrue: [theFiles _ theFiles, theFile, (String with: $ )].	(self getOldFileName: (theFile _ mapName, (DataMaster mapSuffixFor: #mapData))) == nil		ifTrue: [theFiles _ theFiles, theFile].	theFiles isEmpty ifTrue: [^true]		ifFalse: [(self confirm:'The map vector data files are missing.This will try to fetch the required map vectordata files from the file server. Do you want to?')			ifTrue: [view topView suitcase center getTheseMapFilesFromServer: theFiles]			ifFalse: [^false]]!drawMapData	self drawMapInitialize.	Cursor wait showWhile:		[		self drawMapLoop.		self drawMapTerminate		]!drawMapInitialize	| temp |	xTable _ MapTransformationTable		windowingTransformation: (view latLonDisplayTransformation compose: self class headerToLatLonTransformation)		xOrY: #x		destinationStart: view insetDisplayBox left		destinationStop: view insetDisplayBox right.	yTable _ MapTransformationTable		windowingTransformation: (view latLonDisplayTransformation compose: self class headerToLatLonTransformation)		xOrY: #y		destinationStart: view insetDisplayBox top		destinationStop: view insetDisplayBox bottom.	shiftAmountX _ xTable shiftAmount + 12.	shiftAmountY _ yTable shiftAmount + 12.	centerX _ xTable size bitShift: -1 - shiftAmountX.	tablesOffsetPoint _ (xTable offset bitShift: 0 - shiftAmountX) @ (yTable offset bitShift: 0 - shiftAmountY). 	aBitBlt _ self setUpBitBlt.	self initializeHeaderClippingBox.	(self getOldFileName: (temp _ mapName, (DataMaster mapSuffixFor: #mapHints))) == nil ifTrue: [^self booboo:'Map hints file is missing'].	hintsFile _ (self openOldFile: temp) binary readOnly.	hints _ ByteArray new: HintsBufferSize.	(self getOldFileName: (temp _ mapName, (DataMaster mapSuffixFor: #mapData))) == nil ifTrue: [^self booboo:'Map data file is missing'].	dataFile _ (self openOldFile: temp) binary readOnly.	pointsByteArray _ ByteArray new: DataBufferSize.	skipAmount _ 0.	pointsWordArray _ WordArray new: (DataBufferSize bitShift: -1)!drawMapLoop	| temp mapBoundsNorth mapBoundsSouth mapBoundsEast mapBoundsWest headerSkip |	headerSkip _ HeaderSize / 4.	mapBoundsNorth _ headerClippingBox at: 4.	mapBoundsSouth _ headerClippingBox at: 2.	mapBoundsEast _ headerClippingBox at: 3.	mapBoundsWest _ headerClippingBox at: 1.	hintsFile size - hintsFile position to: 1 by: 0 - HintsBufferSize do:		[:bytesRemaining |		temp _ HintsBufferSize min: bytesRemaining.		Cursor read showWhile: [hintsFile next: temp into: hints].		1 to: temp by: HintSize do:			[:position |			(self mapBoundsIntersectsSegmentAt: position mapNorth: mapBoundsNorth mapSouth: mapBoundsSouth mapEast: mapBoundsEast mapWest: mapBoundsWest)				ifTrue: [self drawSegment]				ifFalse: [skipAmount _ skipAmount + headerSkip + ((hints at: position) bitShift: 8) + (hints at: position + 1)]			]		]!drawMapTerminate	hintsFile close.	dataFile close.	view workingForm copy: view workingForm boundingBox from: view insetDisplayBox topLeft in: Display rule: Form over!drawSegment	| byteCount mapPoint pointCount |	dataFile skip: (skipAmount bitShift: 2).	pointCount _ dataFile nextWord.	skipAmount _ 0.	dataFile "next:" skip: 18.	mapPoint _ (Point numbersReverseInit: [(dataFile nextWord bitShift: 16) + dataFile nextWord + 2r1e11 bitShift: -12]) - tablesOffsetPoint.	2r1e19 < (centerX - mapPoint x) abs ifTrue:		[mapPoint x:			(	(2r1e19 < mapPoint x)					ifTrue: [mapPoint x - 2r1e20]					ifFalse: [mapPoint x + 2r1e20]			)		].	pointCount * 4 to: 1 by: 0 - DataBufferSize do:		[:bytesRemaining |		byteCount _ bytesRemaining min: DataBufferSize.		Cursor execute showWhile: [dataFile next: byteCount into: pointsByteArray].		self			drawSegmentLoopPrimitive: pointsByteArray			byteCount: byteCount			firstMapPoint: mapPoint			bitBlt: aBitBlt			xTable: xTable			yTable: yTable			shiftAmountX: shiftAmountX			shiftAmountY: shiftAmountY		]!drawSegmentLoopByteCount: byteCount firstMapPoint: mapPoint	"dataPoints is a ByteArray. byteCount is 4 times the number of points. mapPoint is a pair of positive integers. theXTable and theYTable are MapTransformationTables (note MapTransformationTable special definition of 'at:'). xShift and yShift are SmallIntegers."	| deltaX deltaY mapX mapY nextScreenX nextScreenY screenX screenY temp wordCount |	wordCount _ byteCount bitShift: -1.	pointsWordArray specialReplaceFrom: 1 to: wordCount with: pointsByteArray startingAt: 1.	mapX _ mapPoint x.	mapY _ mapPoint y.	aBitBlt		destX: (screenX _ xTable at: (mapX bitShift: shiftAmountX));		destY: (screenY _ yTable at: (mapY bitShift: shiftAmountY)).	1 to: wordCount by: 2 do:		[:i |		temp _ pointsWordArray at: i.		2r1e15 > temp ifFalse: [temp _ temp - 2r1e16].		mapY _ mapY + temp.		nextScreenY _ yTable at: (mapY bitShift: shiftAmountY).		deltaY _ nextScreenY - screenY.		temp _ pointsWordArray at: i + 1.		2r1e15 > temp ifFalse: [temp _ temp - 2r1e16].		mapX _ mapX + temp.		nextScreenX _ xTable at: (mapX bitShift: shiftAmountX).		deltaX _ nextScreenX - screenX.		(deltaX bitOr: deltaY) = 0 ifFalse:			[			aBitBlt				drawLoopX: deltaX Y: deltaY;				destX: (screenX _ nextScreenX);				destY: (screenY _ nextScreenY)			]		].	mapPoint x: mapX; y: mapY!drawSegmentLoopPrimitive: dataPoints byteCount: byteCount firstMapPoint: mapPoint bitBlt: theBitBlt xTable: theXTable yTable: theYTable shiftAmountX: xShift shiftAmountY: yShift"	dataPoints	<ByteArray>	byteCount	<Integer> 4 times the number of points	mapPoint	<Point> pair of positive integers	theBitBlt	<BitBlt>	theXTable	<MapTransformationTable> for fast conversion of data 'longitude' coordinates to screen x coordinates by table lookup (note MapTransformationTable special definition of 'at:')	theYTable	<MapTransformationTable> for fast conversion of data 'latitude' coordinates to screen y coordinates by table lookup	xShift	<Integer> amount to shift data 'longitude' coordinates before looking in theXTable	yShift	<Integer> amount to shift data 'latitude' coordinates before looking in theYTable"	"<primitive: nnn>"	self drawSegmentLoopByteCount: byteCount firstMapPoint: mapPoint!initializeHeaderClippingBox	| aRectangle i |	headerClippingBox _ ByteArray new: 4.	aRectangle _ self class headerToLatLonTransformation applyInverseTo: model latLonBox.	aRectangle origin numbersDo: [:aNumber | (aNumber timesTwoPower: -20) floor - 1 bitShift: -4.].	aRectangle corner numbersDo: [:aNumber | (aNumber timesTwoPower: -20) ceiling + 1 bitShift: -4.].	aRectangle right - aRectangle left > 255 ifTrue:		[aRectangle left: 1.		aRectangle right: 0.		].	aRectangle top: (aRectangle top max: 0).	aRectangle bottom: (aRectangle bottom min: 255).	i _ 0.	aRectangle numbersDo: [:aNumber | headerClippingBox at: (i _ i + 1) put: aNumber \\ 256.].	crossesZeroX _ aRectangle width < 0.!mapBoundsIntersectsSegmentAt: hintsIndex mapNorth: mapBoundsNorth mapSouth: mapBoundsSouth mapEast: mapBoundsEast mapWest: mapBoundsWest	"Answer true if the segment whose header starts at hintsIndex has a chance of intersecting the map area. Speed is important, so take short cuts, but err on the side of caution. Borderline or indecisive cases return true, not false."	| segmentEast segmentWest |	(hints at: hintsIndex + 5) < mapBoundsSouth ifTrue: [^false "Segment is too far south"].	mapBoundsNorth < (hints at: hintsIndex + 3) ifTrue: [^false "Segment is too far north"].	crossesZeroX = ((segmentEast _ hints at: hintsIndex + 6) < (segmentWest _ hints at: hintsIndex + 4))		ifTrue:			[			crossesZeroX ifTrue: [^true "Segment and map bounds both include Longitude 0"].			segmentEast < mapBoundsWest ifTrue: [^false "Segment is too far west"].			mapBoundsEast < segmentWest ifTrue: [^false "Segment is too far east"].			^true			].	segmentEast < mapBoundsWest ifFalse: [^true].	mapBoundsEast < segmentWest ifFalse: [^true].	^false! !!MapEditor methodsFor: 'private'!correctDistortion	| center mapExtent targetRatio |	"Longitudes are more closely spaced at the high latitudes. Expand the map bounds, if necessary, to minimize distortion at the center of the map."	center _ [:aRectangle | aRectangle origin + aRectangle corner / 2].	mapExtent _ model latLonBox extent.	targetRatio _ ((center value: model latLonBox) y degreesToRadians cos) * (view insetDisplayBox height / view insetDisplayBox width).	(mapExtent y / mapExtent x) > targetRatio		ifTrue: "Expand east-west coverage" [mapExtent x: (mapExtent y / targetRatio)]		ifFalse: "Expand north-south coverage" [mapExtent y: (mapExtent x * targetRatio)].	mapExtent _ 0@0 extent: mapExtent.	model latLonBox: 		((mapExtent align: (center value: mapExtent) with: (center value: model latLonBox))" pointsDo:			[:aPoint |			aPoint x: (aPoint x) \\ 360.0			]").	center _ nil.!drawMapDataPoints	self drawMapData; accept.	(view topView suitcase spare == nil)		ifFalse:[self redisplayAllPoints: view topView suitcase spare].!drawPolygon:aPolyPen aStream:aPolyStream labelOffset: labelOffset theScanner: fastTextScanner	"Draw and label a polygon read from the current record of the FixedFileStream 'aPolyStream'. "	| getNextPoint aPoint key polyIcon polyLineWidth polyLineColor label pointCount pointNumber labelPt firstPt textOffset dummy |			"A block to evaluate when it's time to read the next point:"	getNextPoint _ [ self readPointNumber: (pointNumber _ pointNumber+1) from: aPolyStream ].	aPolyPen combinationRule: Form under.	textOffset _ 0@0.	label _ aPolyStream fieldFromThisRecord: #Label.	key _ aPolyStream fieldFromThisRecord: #Key.	polyIcon _ aPolyStream fieldFromThisRecord: #Icon.	polyLineWidth _ (aPolyStream fieldFromThisRecord: #LineWidth) asNumber.	polyLineColor _ (aPolyStream fieldFromThisRecord: #LineColor) asNumber.	pointCount _ (aPolyStream fieldFromThisRecord: #PointCount) asNumber.		(pointCount = 0) ifFalse:			[pointNumber _ 0.			labelPt _ getNextPoint value + labelOffset.			(polyIcon at: 1) = $0 ifFalse: 				[fastTextScanner					displayString: polyIcon					emphasis: IconFontNumber					on: Display					at: labelPt - (6@15)					clippingBox: view insetDisplayBox					rule: 7 "Form under"					mask: nil.				textOffset _ (6@-15)].			fastTextScanner					displayString: label					emphasis: LabelFontNumber					on: Display					at: labelPt + textOffset					clippingBox: view insetDisplayBox					rule: 7 "Form under"					mask: nil.			(pointCount = 1)				ifFalse:[firstPt _ getNextPoint value.				aPolyPen					place: firstPt;					mask: (Form perform: (#(black darkGray gray lightGray veryLightGray white) at: polyLineColor));					defaultNib: polyLineWidth.				(pointCount - 2) timesRepeat:					[aPolyPen goto: getNextPoint value].				aPolyPen goto: firstPt; mask: Form black]].	getNextPoint _ nil!initializeYellowButtonMenu 	self yellowButtonMenu: MapYellowButtonMenu yellowButtonMessages: TreeMenu!readControlFile: controlFileName"	Read the control file for this map.	controlFileName	<String> the name of the map's .control file (The extension '.control' will be automatically appended to controlFileName.)	"	| aFileStream aRectangle average |	aFileStream _ self openFile: controlFileName, (DataMaster giveMe: #specialSuffixString for: #map asString). 	Cursor read showWhile:		[aRectangle _ Rectangle numbersReverseInit: [Number readNumberFrom: aFileStream].		aRectangle top < -89 ifTrue: [aRectangle top: -89.].		aRectangle bottom > 89 ifTrue: [aRectangle bottom: 89.].		model latLonBox: aRectangle.		resolution _ Number readNumberFrom: aFileStream.		mapName _ String readFrom: aFileStream.		].	aFileStream close!readPointNumber: pointNumber from: aStream	"Read a point from the Xn and Yn fields of the current record of the FixedFileStream."	| aPoint |	aPoint _ Point		x: (aStream fieldFromThisRecord: #lon )		y: (aStream fieldFromThisRecord: #lat ).	[model latLonBox right < aPoint x]		whileTrue:[ aPoint x: aPoint x - 360].	^ view latLonDisplayTransform: aPoint!setUpBitBlt	^(Pen		destForm: Display		sourceForm: (Form extent: 1@1) black		halftoneForm: nil		combinationRule: Form under		destOrigin: (0@0)		sourceOrigin: (0@0)		extent: (1@1)		clipRect: view insetDisplayBox)		frame: view insetDisplayBox	"^(GoldenPressPen new: (FillInTheBlank request: 'What shall I call the press file?' default: 'Map'), '.press')		defaultNib: 1;		frame: view insetDisplayBox"!writeControlFile: aFileName"the the control file for this map"	| aFileStream average latLonBox |	aFileStream _ (self openFile: aFileName,(DataMaster giveMe: #specialSuffixString for: #map asString)) writeShorten. 	Cursor write showWhile:		[latLonBox _ model latLonBox copy.		latLonBox top < -89 ifTrue: [latLonBox top: -89.].		latLonBox bottom > 89 ifTrue: [latLonBox bottom: 89.].		latLonBox right - latLonBox left > 360 ifTrue:			[average _ (latLonBox left + latLonBox right / 2) \\ 360.			latLonBox left: average - 180.			latLonBox right: average + 180.			].		latLonBox numbersReverseDo:			[:aNumber |			aNumber storeOn: aFileStream.			aFileStream nextPut: (Character space).			aNumber			].		resolution storeOn: aFileStream.		aFileStream nextPut: (Character space). 		mapName storeOn: aFileStream		].	aFileStream close.! !!MapEditor methodsFor: 'target database'!addPointToDatabase	| thePoint lat lon answer theDatabaseIndex theRecord gotIt aFileStream keepStuff screenPoint savePoint fileName defaultArray labelArray typeArray time date index |	gotIt _ false.	theDatabaseIndex _ (mapDatabases at: 1) startUp.	(theDatabaseIndex == nil or: [theDatabaseIndex = 0])		ifTrue: [^nil].	fileName _ ((mapDatabases at: 2) at: theDatabaseIndex) filename.	ClassifiedFixedFileStream allInstances do: [:one | "check for stream already open on this file, and if one, use it"		((FileDirectory decomposeName: one name) at: 'Name-Body') = fileName			ifTrue: 				[aFileStream _ one.				gotIt _ true]].	gotIt ifFalse: [aFileStream _ ClassifiedFixedFileStream fileNamed: fileName].	(defaultArray _ OrderedCollection new) add: (String with: $J); add: String new; add: String new.	(labelArray _ OrderedCollection new) add: (Array with: #Icon:); add: (Array with: #Label:); add: (Array with: #Key:).	(typeArray _ OrderedCollection new) add: #fill; add: #fill; add: #fill.	time _ false.	date _ false.	index _ 4.	aFileStream fieldNames do: 		[:each | 		each = #Time			ifTrue: 				[time _ index.				index _ index + 1.				typeArray add: #fill.				labelArray add: (Array with: #Time:).				defaultArray add: Time now printString].		each = #Date			ifTrue: 				[date _ index.				index _ index + 1.				typeArray add: #fill.				labelArray add: (Array with: #Date:).				defaultArray add: Date today printString]].	(thePoint _ self getPoint) == nil ifTrue: [gotIt ifFalse: [aFileStream close]. ^self].	lat _ thePoint y.	thePoint x: (lon _ thePoint x < 0					ifTrue: [360.0 + thePoint x]					ifFalse: [thePoint x]).	answer _ DBoxView				openFor: typeArray				title: 'Identify this point'				labels: labelArray				defaults: defaultArray				autoAccept: true.	(answer == nil or: [(answer at: 2) == nil]) ifTrue: [gotIt ifFalse: [aFileStream close]. ^self].	theRecord _ OopConservingDictionary new.	theRecord at: #Label put: (answer at: 2); at: #Icon put: (answer at: 1); at: #lat put: lat printString; at: #lon put: lon printString; at: #key put: (answer at: 3).	(time isKindOf: Number) ifTrue: [theRecord at: #Time put: (answer at: time)].	(date isKindOf: Number) ifTrue: [theRecord at: #Date put: (answer at: date)].	[model latLonBox right < thePoint x] whileTrue: [thePoint x: thePoint x - 360].	screenPoint _ view latLonDisplayTransform: thePoint.	savePoint _ screenPoint - view insetDisplayBox origin.	keepStuff _ Array new: 8.	keepStuff at: 8 put: (self saveThisAreaUnder: (answer at: 2) at: screenPoint).	self		showThePointAt: screenPoint		withIcon: (answer at: 1)		withLabel: (answer at: 2)		usingScanner: FastTextDisplayScanner new.	keepStuff at: 1 put: savePoint; at: 2 put: (answer at: 2); at: 3 put: (answer at: 1); at: 4 put: theDatabaseIndex; at: 6 put: lat; at: 7 put: lon.	aFileStream constructRecordFrom: theRecord.	keepStuff at: 5 put: aFileStream numberOfRecords.	gotIt ifFalse: [aFileStream close].	displayedItems add: keepStuff!cleanMap	^super cancel!dataDisplay	| index | 	"take the answer from the database menu and give it as a file name to displayTarget "	index _ (mapDatabases at: 1) startUp.	index = 0 ifFalse: [self displayPlaces: index].	Cursor normal show.	view updateDisplay.	self oldTool!dataDisplayQuery	| index | 	"take the answer from the database menu and give it as a file name to displayTarget"	index _ (mapDatabases at: 1) startUp.	index = 0 ifFalse: [self displayPlacesQueried: index].	Cursor normal show.	view updateDisplay.	self oldTool!displayPlaces: theIndex	"Note that the TargetFile should be a ClassifiedFixedFileStream"	| databaseStream scanner |	Cursor read show.	ClassifiedFixedFileStream allInstances do:		[:one | ((FileDirectory decomposeName: one name) at: 'Name-Body') = ((mapDatabases at: 2) at: theIndex) filename ifTrue: [databaseStream _ one]].	databaseStream == nil ifTrue: [databaseStream _ (ClassifiedFixedFileStream fileNamed: ((mapDatabases at: 2) at: theIndex) filename)].	((databaseStream fieldNames includes: #lat) and: [databaseStream fieldNames includes:#lon])		ifTrue:			[scanner _ FastTextDisplayScanner new.			1 to: databaseStream numberOfRecords do:				[:eachRecord |				(databaseStream isDeleted: eachRecord) ifFalse:					[self drawPlaceFromAStream: databaseStream scanner: scanner index: theIndex recordNumber: eachRecord]]]		ifFalse:			[self booboo:((mapDatabases at: 2) at: theIndex) label, ' database has no location fields'].	databaseStream close.	Cursor normal show!displayPlacesQueried: databaseFileIndex	| databaseStream query scanner |	ClassifiedFixedFileStream allInstances do:		[:one | ((FileDirectory decomposeName: one name) at: 'Name-Body') = ((mapDatabases at: 2) at: databaseFileIndex) filename ifTrue: [databaseStream _ one]].	databaseStream == nil ifTrue: [databaseStream _ (ClassifiedFixedFileStream fileNamed: ((mapDatabases at: 2) at: databaseFileIndex) filename)].	((databaseStream fieldNames includes: #lat) and: [databaseStream fieldNames includes:#lon]) ifTrue:		[query _ Querier request: 'Enter query on ', ((mapDatabases at: 3) at: databaseFileIndex)			withFields: databaseStream fieldNames			types: databaseStream fieldTypes.		query==nil ifTrue: [databaseStream close. ^self].		query _ FixedFileFilter on: query.		scanner _ FastTextDisplayScanner new.		(databaseStream allRecordNumbersFitting: query) do:			[:eachRecord |			databaseStream record: eachRecord.			self drawPlaceFromAStream: databaseStream scanner: scanner index: databaseFileIndex recordNumber: eachRecord].		databaseStream close]!drawPlaceFromAStream: databaseStream scanner: fastTextScanner index: databaseIndex recordNumber: theRecord	"Draw and label a polygon read from the current record of the FixedFileStream 'databaseStream'. "	| labelPt theLabel index keepStuff savePt |	labelPt _ (self readPointNumber: 1 from: databaseStream).	(view insetDisplayBox containsPoint: labelPt) ifFalse: [^self].	savePt _ labelPt - (view insetDisplayBox origin).	theLabel _ (databaseStream fieldFromThisRecord: #Label).	index _ theLabel findLast: [:ch | ch ~= Character space].	theLabel _ (theLabel copyFrom: 1 to: index).	keepStuff _ Array new: 8.	keepStuff		at: 1 put: savePt;		at: 2 put: theLabel;		at: 3 put: (databaseStream fieldFromThisRecord: #Icon);		at: 4 put: databaseIndex;		at: 5 put: theRecord;		at: 6 put: (databaseStream fieldFromThisRecord: #lat);		at: 7 put: (databaseStream fieldFromThisRecord: #lon);		at: 8 put: (self saveThisAreaUnder: theLabel at: labelPt).	displayedItems add: keepStuff.	self showThePointAt: labelPt withIcon: (keepStuff at: 3) withLabel: theLabel usingScanner: fastTextScanner!getHisPoint	"see if the user is pointing to one of the displayed targets. Return the target if 	true nil if not."	| place targetPoint nearestDistance dist counter |	Cursor crossHair showWhile: [[sensor redButtonPressed]			whileFalse: [targetPoint _ sensor cursorPoint]].	[sensor redButtonPressed] whileTrue.	targetPoint _ targetPoint - (view insetDisplayBox origin).	nearestDistance _ 10@10.	counter _ 0.	displayedItems do:		[:each | counter _ counter + 1.		(dist _ (targetPoint - (each at: 1)) abs) < nearestDistance			 ifTrue: [nearestDistance _ dist. place _ (counter)]].	nearestDistance < (10@10) ifFalse: [^nil].	^place!makeNewMapDatabase	| mySuitcase returnArray names lengths types | 	mySuitcase _ view topView suitcase.	returnArray _ InformationCenter fileNameData: #database defaultSuitcase: (Suitcase new packTheSuitcaseFrom: mySuitcase centerName forItem: (DataItem type: #Item  label: 'database name' atIndex: 0)) defaultKeys: String new askMethod: false askClass: false.	(returnArray at: 1) == nil ifTrue: [^nil].	names _ OrderedCollection new.	names add: #Label; add: #Icon ; add: #lat ; add: #lon ; add: #key; add: #Date; add: #Time.	lengths _ OrderedCollection new.	lengths add: 20 ; add: 1 ; add: 10 ; add: 10 ; add: 20; add: 18; add: 12.	types _ OrderedCollection new.	types add: #string ; add: #string ; add: #number ; add: #number ; add: #string; add: #date; add: #time.	ClassifiedFixedFileStream newOn: (returnArray at: 1) filename withHeaderFor: (returnArray at: 1) withFieldNames: names fieldLengths: lengths fieldTypes: types.	InformationCenter putFileNameAway: returnArray.	mySuitcase dataItem addFPointer: (returnArray at: 1) centerIndex type: (mySuitcase center linkTypeFor: #database).	(returnArray at: 1) addBPointer: mySuitcase dataItem centerIndex type: (mySuitcase center linkTypeFor: #database).	self initializeMapDatabaseSubmenuWithSuitcase: mySuitcase!modifyDatabaseLinks	| mySuitcase | 	mySuitcase _ view topView suitcase.	mySuitcase dataItem centerIndex = 0 ifTrue: [^self booboo: 'This map needs to be filed in an information center first'].	mySuitcase center makeDatabaseConnectionTo: mySuitcase dataItem.	self initializeMapDatabaseSubmenuWithSuitcase: mySuitcase!redisplayAllPoints	| scanner | 	scanner _ FastTextDisplayScanner new.	displayedItems do:		[:thePlace |		self showThePointAt: ((thePlace at: 1) + (view insetDisplayBox origin))			withIcon: (thePlace at: 3)			withLabel: (thePlace at: 2)			usingScanner: scanner]!redisplayAllPoints: theCollection	| scanner aPoint thePoint keepStuff | 	theCollection isEmpty ifTrue:[^self].	scanner _ FastTextDisplayScanner new.	theCollection do:		[:thePlace |		aPoint _ Point x: (thePlace at: 7 ) y: (thePlace at: 6 ).		[model latLonBox right < aPoint x] whileTrue:[ aPoint x: aPoint x - 360].		thePoint _ view latLonDisplayTransform: aPoint.		(view insetDisplayBox containsPoint: thePoint) ifTrue:			[keepStuff _ Array new: 8.			keepStuff at: 8 put: (self saveThisAreaUnder: (thePlace at: 2) at: thePoint).			self showThePointAt: thePoint withIcon: (thePlace at: 3 ) withLabel: (thePlace at: 2) usingScanner: scanner.			keepStuff				at: 1 put: (thePoint - (view insetDisplayBox origin));				at: 2 put: (thePlace at: 2);				at: 3 put: (thePlace at: 3);				at: 4 put: (thePlace at: 4);				at: 5 put: (thePlace at: 5);				at: 6 put: (thePlace at: 6);				at: 7 put: (thePlace at: 7).			displayedItems add: keepStuff]]!removePlace	| temp fcUser removePlace place hisRectangle theCollection count theirRectangle removePlaceHere theRedisplayCollection |		removePlace _ self getHisPoint.	removePlace == nil ifTrue: [^nil].	place _ displayedItems at: removePlace.	hisRectangle _ ((place at: 8) boundingBox) translateBy: (place at: 1).	theCollection _ OrderedCollection new.	count _ 0.	displayedItems do: [:each |		theirRectangle _ ((each at: 8) boundingBox) translateBy: (each at: 1).		count _ count + 1.		(hisRectangle intersects: theirRectangle)			 ifTrue: [theCollection addFirst: count]].	theCollection do: [:each | ((displayedItems at: each) at: 8) displayAt: ((displayedItems at: each) at: 1) - (6@9) + (view insetDisplayBox origin).].	(theCollection size = 1)		ifTrue:[displayedItems removeObjectAt: removePlace]		ifFalse: [theRedisplayCollection _ OrderedCollection new.		theCollection do: [:each | each = removePlace			ifFalse: [theRedisplayCollection add: (displayedItems  at: each)]].		theCollection do: [:each | displayedItems removeObjectAt: each].		self redisplayAllPoints: theRedisplayCollection]!saveThisAreaUnder: aLabel at: aPoint	"save this area that the label is going to cover up"	| length |	length _ ((TextStyle default fontAt: LabelFontNumber) widthOfString: aLabel)+ 16.		^Form new fromDisplay: (Rectangle origin: (aPoint - (6@9)) extent: length@16)!selectPlace	| place temp label center |	place _ self getHisPoint.	place == nil ifFalse:		[Cursor execute show.		place _ displayedItems at: place.		center _ view topView suitcase center.		label _ (place at: 2).		temp _ label findString: (DataMaster giveMe: #suffixString for: #map asString) startingAt: 1.		temp = 0			ifFalse: [self getMap: place]			ifTrue:			[temp _ InformationCenter lookForLabel: label andKeys: nil dataType: #Folder fileName: nil inUser: center name.			temp == nil				ifFalse:					[(ContainerModel createForIndexOrItem: temp inCenter: center) scheduleTheFolder: temp label usingMenu: 1 width: 1 helpMessage: #Folder]				ifTrue:					[center makeHolderOfDataType: (Array with: #Folder with: #Item) target: label.					(self confirm: 'There are no references to this place. Shall I make a new folder?')						ifTrue:							[temp _ center addFolder: (DataItem type: #Folder label: label atIndex: 0).							(ContainerModel createForIndexOrItem: temp inCenter: center) scheduleTheFolder: temp label usingMenu: 1 width: 1 helpMessage: #Folder]]]]!showRecord	| place temp fcUser label databaseStream theRecord theFields contents databaseStreamName theClass |	(mapDatabases at: 2) isEmpty ifTrue: [^self booboo: 'Sorry, I have no database links.You must save me in a center and then link me to the database.'].	place _ self getHisPoint.	place == nil ifFalse:		[Cursor execute show.		place _ displayedItems at: place.		databaseStreamName _ ((mapDatabases at: 2) at: (place at: 4)) filename.		ClassifiedFixedFileStream allInstances do:		[:one | ((FileDirectory decomposeName: one name) at: 'Name-Body') = databaseStreamName ifTrue: [databaseStream _ one]].	databaseStream == nil ifTrue: [databaseStream _ (ClassifiedFixedFileStream fileNamed: databaseStreamName)].	theRecord _ databaseStream record: (place at: 5).	theClass _ databaseStream classificationFromThisRecord.	theFields _ databaseStream fieldNames.	contents _ Array with: (place at: 2) with: theFields with: (OrderedCollection new: theFields size).	theFields do: [:each | contents last add: (databaseStream fieldFromThisRecord: each)].	databaseStream close.	(Smalltalk includesKey: #FormsModel)		ifTrue: [self showRecordForm: contents inDatabase: databaseStreamName classification: theClass recordNumber: (place at: 5)]		ifFalse: [textPaneController			deselect;			closeTypeIn;			replaceSelectionWith: theRecord asText;			selectAndScroll.			textPaneController model show: (String with: Character cr)]]!showRecordForm: contents inDatabase: databaseStreamName classification: theClass recordNumber: recordNumber	| aFormModel textHeight height topY fieldValue lines fieldLabels labelSize valueStart theSuitcase title | 	title _ (contents at: 1) stripLeadingAndTrailingSpaces.	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: DatabaseFormsModel)			and: [(each view suitcase spare at: 2)  = recordNumber and: [(each view label)  = title]]].	aFormModel _ DatabaseFormsModel named: 'Full Record'.	textHeight _ 25.	height _ 15.	topY _ 40. 	aFormModel add: ((ExecuteElement named: 'edit')			box: (20@10 corner: 160@30);			label: (Text string: 'Replace record' runs: (RunArray runs: #(14 ) values: #(2 )));			initialValue: #editDatabaseRecord;			bordered: true;			alignment: #centered;			yourself).	fieldLabels _ (contents at: 2).	labelSize _ 40.	1 to: fieldLabels size do: [:each|		((fieldLabels at: each) size * 9) > labelSize ifTrue: [labelSize _ (fieldLabels at: each) size * 9]].	valueStart _ labelSize + 30. 	1 to: fieldLabels size do: [:each |		aFormModel add:		((LabelElement named: each printString )			box: (20@topY corner: (labelSize + 20) @(topY + height));			label: ((fieldLabels at: each) printString asText);			bordered: false;			alignment: #rightFlush;			yourself).		fieldValue _ (contents at: 3) at: each.		lines _ ((fieldValue size // 40) + 1) min: 5.		aFormModel add:		((FillElement named: (fieldLabels at: each))			box: (valueStart@topY corner: (valueStart + 300)@(topY + (textHeight * lines)));			initialValue: ((fieldValue isKindOf: String) ifTrue: [fieldValue stripLeadingAndTrailingSpaces] ifFalse:[fieldValue printString]) asText;			yourself). 	topY _ topY + (textHeight * lines) + 5.].	theSuitcase _ (Suitcase new packTheSuitcaseFrom: nil forItem: ((DataItem type: #Item label: (contents at: 1) atIndex: 0) + theClass)).	theSuitcase spare: (Array with: databaseStreamName with: recordNumber).	DatabaseFormsModel openOn: aFormModel label: title suitcase: theSuitcase!showThePointAt: labelPt withIcon: theIcon withLabel: theLabel usingScanner: fastTextScanner	fastTextScanner		displayString: theIcon		emphasis: IconFontNumber		on: Display		at: labelPt - (6@12)		clippingBox: view insetDisplayBox		rule: 7 "Form under "		mask: nil.	fastTextScanner		displayString: theLabel		emphasis: LabelFontNumber		on: Display		at: labelPt + (10@-11)		clippingBox: view insetDisplayBox		rule: 7 "Form under "		mask: nil.	locked _ #yes! !!MapEditor methodsFor: 'animation'!animate	"Will animate from a database"	| index databaseStream a clockPt msg |	(Smalltalk includesKey: #Animation)		ifFalse: [^self booboo: 'Animation has not been filed in!!'].	index _ (mapDatabases at: 1) startUp.	index = 0		ifFalse: 			[Cursor read show.			ClassifiedFixedFileStream allInstances do: [:one | ((FileDirectory decomposeName: one name)					at: 'Name-Body') = ((mapDatabases at: 2) at: index) filename ifTrue: [databaseStream _ one]].			databaseStream == nil ifTrue: [databaseStream _ ClassifiedFixedFileStream fileNamed: ((mapDatabases at: 2) at: index) filename].			(a _ Animation new) initialize				ifFalse: 					[databaseStream close.					^self].			clockPt _ view insetDisplayBox origin - (0 @ 50).			a clock: clockPt.			a window: view insetDisplayBox.			msg _ 'Reading in data, please wait!!' asForm.			msg displayAt: clockPt.			((self confirm: 'Single Event - Group by icon?')				ifTrue: [self groupByIcon: databaseStream in: a]				ifFalse: [self groupByLabel: databaseStream in: a]) ifFalse: [^self].			msg				displayOn: Display				at: clockPt				clippingBox: Display boundingBox				rule: Form reverse				mask: Form black.			a checkTime.			a alterParameter ifFalse: [^self].			Cursor normal show.			a start]!getForm: asciiVal	| iconFontNumber tempFont rect tempForm |	tempFont _ (TextConstants at: #DefaultTextStyle)				fontAt: IconFontNumber.	rect _ (tempFont xTable at: asciiVal + 1)				@ 0 corner: (tempFont xTable at: asciiVal + 2)					@ tempFont height.	(tempForm _ Form new extent: rect extent)		copyBits: rect		from: tempFont glyphs		at: 0 @ 0		clippingBox: (0@0 extent: tempFont glyphs extent)		rule: Form over		mask: Form black.	^tempForm!groupByIcon: aDB in: anAnimation 	| recordList theList tempIcon object eventList locatList labelList aPoint theLabel index |	recordList _ OrderedCollection new.	locatList _ OrderedCollection new.	eventList _ OrderedCollection new.	labelList _ OrderedCollection new.	1 to: aDB numberOfRecords do: [:i | recordList add: i].	theList _ aDB sortedFieldAndRecordNumbers: #Time from: recordList.	theList _ aDB sortedFieldAndRecordNumbers: #Date from: (theList at: 2).	theList _ aDB sortedFieldAndRecordNumbers: #Icon from: (theList at: 2).	(theList at: 2) isEmpty ifTrue: [^false].	tempIcon _ aDB record: (theList at: 2) first field: #Icon.	i _ 0.	(theList at: 2)		do: [:eachRecord | (aDB isDeleted: eachRecord)				ifFalse: 					[i _ i + 1.					((theList at: 1) at: i) = tempIcon						ifFalse: 							[object _ self getForm: tempIcon first asciiValue.							anAnimation								addObject: object								withEvents: eventList								withLocation: locatList								labels: labelList.							tempIcon _ aDB fieldFromThisRecord: #Icon.							eventList _ OrderedCollection new.							locatList _ OrderedCollection new.							labelList _ OrderedCollection new].					aPoint _ Point x: (aDB fieldFromThisRecord: #lon)								y: (aDB fieldFromThisRecord: #lat).					[model latLonBox right < aPoint x]						whileTrue: [aPoint x: aPoint x - 360].					locatList add: (view latLonDisplayTransform: aPoint).					eventList add: (UTime time: (aDB fieldFromThisRecord: #Time)							date: (aDB fieldFromThisRecord: #Date)).					theLabel _ aDB fieldFromThisRecord: #Label.					index _ theLabel findLast: [:ch | ch ~= Character space].					theLabel _ theLabel copyFrom: 1 to: index.					labelList add: theLabel]].	aDB close.	object _ self getForm: tempIcon first asciiValue.	anAnimation		addObject: object		withEvents: eventList		withLocation: locatList		labels: labelList.	^true!groupByLabel: aDB in: anAnimation 	| recordList theList tempLabel tempIcon object eventList locatList labelList aPoint theLabel index |	recordList _ OrderedCollection new.	locatList _ OrderedCollection new.	eventList _ OrderedCollection new.	labelList _ OrderedCollection new.	1 to: aDB numberOfRecords do: [:i | recordList add: i].	theList _ aDB sortedFieldAndRecordNumbers: #Time from: recordList.	theList _ aDB sortedFieldAndRecordNumbers: #Date from: (theList at: 2).	theList _ aDB sortedFieldAndRecordNumbers: #Icon from: (theList at: 2).	theList _ aDB sortedFieldAndRecordNumbers: #Label from: (theList at: 2).	(theList at: 1) isEmpty ifTrue: [^false].	tempLabel _ (theList at: 1) first.	tempIcon _ aDB record: (theList at: 2) first field: #Icon.	i _ 0.	(theList at: 2)		do: [:eachRecord | (aDB isDeleted: eachRecord)				ifFalse: 					[i _ i + 1.					((theList at: 1) at: i) = tempLabel						ifFalse: 							[object _ self getForm: tempIcon first asciiValue.							anAnimation								addObject: object								withEvents: eventList								withLocation: locatList								labels: labelList.							tempIcon _ aDB fieldFromThisRecord: #Icon.							tempLabel _ (theList at: 1)										at: i.							eventList _ OrderedCollection new.							locatList _ OrderedCollection new.							labelList _ OrderedCollection new].					aPoint _ Point x: (aDB fieldFromThisRecord: #lon)								y: (aDB fieldFromThisRecord: #lat).					[model latLonBox right < aPoint x]						whileTrue: [aPoint x: aPoint x - 360].					locatList add: (view latLonDisplayTransform: aPoint).					eventList add: (UTime time: (aDB fieldFromThisRecord: #Time)							date: (aDB fieldFromThisRecord: #Date)).					theLabel _ aDB fieldFromThisRecord: #Label.					index _ theLabel findLast: [:ch | ch ~= Character space].					theLabel _ theLabel copyFrom: 1 to: index.					labelList add: theLabel]].	aDB close.	object _ self getForm: tempIcon first asciiValue.	anAnimation		addObject: object		withEvents: eventList		withLocation: locatList		labels: labelList.	^true! !ChartEditor comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation.  All rights reserved.'!!ChartEditor methodsFor: 'control defaults'!controlInitialize	| aSuitcase | 	super controlInitialize.	aSuitcase _ view topView suitcase.	aSuitcase classification classAndWords = view topView classifyLabel		ifFalse:[view topView classifyLabel: aSuitcase classification; deEmphasizeView.		(aSuitcase classification classificationIndex = 1 and: [aSuitcase classification modifierCount = 0]) ifTrue: [view topView  displayClassification].			view topView display].	(dataArray == nil or: [dataArray isEmpty]) 		ifTrue: [self makeNew]		ifFalse: [firstTime ifTrue: [self chartDataNow]]!yellowButtonActivity	| answer |	yellowButtonMenu == nil		ifTrue: [super controlActivity]		ifFalse: 			[answer _ yellowButtonMenu startUpYellowButton. 			answer == nil ifFalse: [self menuMessageReceiver perform: answer]]! !!ChartEditor methodsFor: 'initialize/release'!firstTime: aBoolean	firstTime _ aBoolean!initialize	super initialize.	title _ 'Untitled'.	(theChart _ BarChart new) isLabeled: true; isLegended: true; isFilled: true; labeledByPercent: false; isAutoScaled: true.	firstTime _ true.!initializeYellowButtonMenu 	self yellowButtonMenu: ChartEditorYellowButtonMenu yellowButtonMessages: TreeMenu!release	child == nil ifFalse: [child breakDependent]! !!ChartEditor methodsFor: 'menu messages'!chartData	Cursor wait showWhile: [		(dataArray == nil or: [dataArray isEmpty]) ifTrue: [^self errorNoData].		firstTime ifFalse: [self changeDefaults ifFalse: [^self]].		locked _ #yes.		firstTime _ false.		theChart _ self assignChartParameter: theChart.		(theChart isKindOf: ClusteredBarChart) | (theChart isKindOf: StackedBarChart) | (theChart isKindOf: StackedLineChart)			ifTrue: [theChart labelsInStack: stackLabels].		(theChart isKindOf: ClusteredBarChart)			ifTrue: [theChart _ self checkCBar: theChart].		(theChart isKindOf: XYChart)			ifTrue: [theChart dot: form].		self displayChart: theChart]!chartDataNow	Cursor wait showWhile: [		(dataArray == nil or: [dataArray isEmpty]) ifTrue: [^self errorNoData].		firstTime _ false.		locked _ #yes.		theChart _ self assignChartParameter: theChart.		(theChart isKindOf: ClusteredBarChart) | (theChart isKindOf: StackedBarChart) | (theChart isKindOf: StackedLineChart)			ifTrue: [theChart labelsInStack: stackLabels].		(theChart isKindOf: ClusteredBarChart)			ifTrue: [theChart _ self checkCBar: theChart].		self displayChart: theChart]!compressData	| tempLabelArray tempDataArray eachLabel where temp |	dataArray == nil ifTrue: [ ^self errorNoData ]. 	tempLabelArray _ OrderedCollection new.	tempDataArray _ OrderedCollection new.	1 to: labelArray size do: 		[:each | 		eachLabel _ labelArray at: each.		(tempLabelArray includes: eachLabel)			ifTrue: 				[where _ tempLabelArray find:eachLabel.				temp _ tempDataArray basicAt: where.				(temp isKindOf:OrderedCollection)				"stacked data"				ifTrue: [ 1 to: temp size do: [:index | temp at: index put: (temp at: index)+ ((dataArray at: each) at: index)]]				"single data"				ifFalse: 					[temp _ temp + (dataArray at:each)].			tempDataArray basicAt: where put:temp]			ifFalse: 				[tempLabelArray add: eachLabel.				tempDataArray add: (dataArray at: each)]]. 	dataArray _ tempDataArray.	labelArray _ tempLabelArray.	child == nil ifFalse: [child view topView controller closeAndUnschedule. view topView display].	self chartDataNow!copy	super copy.	self assignChartParameter: theChart.	Clipboard last propertyAt: #chart put: theChart.!cut	super cut.	self assignChartParameter: theChart.	Clipboard last propertyAt: #chart put: theChart!label	dataArray == nil | (theChart isKindOf: XYChart) ifTrue: [^self].	Cursor wait showWhile: [theChart			labelOn: Display			at: view insetDisplayBox origin			clippingBox: view insetDisplayBox.			locked _ #yes]!legend	| aForm |	dataArray == nil | (labelArray size = 0) ifTrue: [^self].	Cursor wait showWhile: [(theChart isKindOf: XYChart)		ifFalse: 			[(aForm _ Form fromDisplay: view insetDisplayBox) offset: view insetDisplayBox origin.			theChart legendOn: aForm.			aForm				displayOn: Display				at: 0 @ 0				clippingBox: view insetDisplayBox				rule: Form over				mask: Form black].			locked _ #yes]!makeNew	| answers content theRightOne | 	child == nil		ifFalse: [theRightOne _ child view topView controller.			theRightOne centerCursorInView.			ScheduledControllers activeController under.			ScheduledControllers unschedule: theRightOne.			^ScheduledControllers scheduleActive: theRightOne].	answers _ DBoxView				openFor: #(fill select )				title: 'Make new chart'				labels: #((Title: ) ('Type of chart' Bar Line Pie StackedBar ClusteredBar StackedLine XY ))				defaults: #(Title Bar).	answers == nil ifTrue: [^nil].	content _ answers at: 1.	dataType _ (#(Bar Line Pie) includes: (answers at: 2)) ifTrue: [#single] ifFalse: [(answers at: 2) = #XY ifTrue: [#xyPlot] ifFalse: [#stacked]].	(self assignChart: (dataType = #stacked ifTrue: [#(Bar Cluster Line) at: (#(StackedBar ClusteredBar StackedLine) indexOf: (answers at: 2))] ifFalse: [(answers at: 2)])) ifFalse:[^nil].	dataArray _ OrderedCollection new.	labelArray _ OrderedCollection new.	stackLabels _ OrderedCollection new.	CreateController		editOpen: (StringHolder new contents: content)		label: 'Making new chart data'		from: self		type: dataType		data: dataArray		label: labelArray		stack: stackLabels!modify	| editor | 	super accept.	dataArray == nil ifTrue: [^self errorNoData].	child ==nil		ifFalse:[editor _ child view topView controller.			editor centerCursorInView.			ScheduledControllers unschedule: editor.			ScheduledControllers scheduleActive: editor].	CreateController		editOpen: (StringHolder new contents: title)		label: 'Editing Chart Data'		from: self		type: dataType 		data: dataArray		label: labelArray		stack: stackLabels!paste	| type entry chart |	type _ Clipboard nextClass.	((type == Form) or: [type inheritsFrom: Form])		ifTrue: 			[entry _ Clipboard retrieveEntry.			entry contents displayOn: view workingForm white.			(Smalltalk includesKey: #Suitcase)				ifTrue: [view topView changeClassification: (entry propertyAt: #classification)].			chart _ entry propertyAt: #chart.			chart == nil				ifTrue: [^view display]				ifFalse: 					[theChart _ chart.					dataArray _ chart dataArray.					title _ chart title.					labelArray _ chart labelArray.					^self displayChart: theChart]].	super paste!resize	| aSuitcase packedData | 	self controlTerminate.	aSuitcase _ view topView suitcase.	packedData _ self packData.	(view topView controller closeAndUnschedule) ifFalse: [^self controlInitialize]..	Cursor normal show.	ChartEditor createNewImageOnForm: Form fromUser white withSuitcase: aSuitcase andData: packedData! !!ChartEditor methodsFor: 'private'!assignChart: aSymbol 	aSymbol = #Bar ifTrue: [dataType = #single | (dataType = #xyPlot)		ifTrue: [(theChart _ BarChart new) isLabeled: true;			isFilled: true.			^true]		ifFalse: [(theChart _ StackedBarChart new) isLabeled: true;			isLegended: true;			isFilled: true.			^true]].	aSymbol = #Cluster ifTrue: [dataType = #single | (dataType = #xyPlot)		ifTrue: [self booboo: 'Single Cluster is invalid chart type'. ^false]		ifFalse: [(theChart _ ClusteredBarChart new) isLabeled: true;			isLegended: true;			isFilled: true.			^true]].	aSymbol = #Line ifTrue: [dataType = #single | (dataType = #xyPlot)		ifTrue: [(theChart _ LineChart new) isLabeled: true.			^true]		ifFalse: [(theChart _ StackedLineChart new) isLabeled: true;			isLegended: true;			isFilled: true.			^true]].	aSymbol = #Pie ifTrue: [dataType = #single | (dataType = #xyPlot)		ifTrue: [(theChart _ PieChart new) isLegended: true;			isFilled: true.			^true]		ifFalse: [self booboo: 'Stacked Pie is invalid chart type!!'. ^false]].	aSymbol = #XY ifTrue: [dataType = #single | (dataType = #xyPlot)		ifTrue:[theChart _ XYChart new.			^true]		ifFalse: [self booboo: 'Stacked XY is invalid chart type'. ^false]]!assignChartParameter: aChart 	aChart labelArray: labelArray;		dataArray: dataArray;		title: title;		isFilled: theChart areYouFilled;		isLabeled: theChart areYouLabeled;		isLegended: theChart areYouLegended;		labeledByPercent: theChart labeledByPercent;		isAutoScaled: theChart areYouAutoScaled.	^aChart!changeDefaults	| answers defaultString class chart labelSize emp | 	dataArray == nil ifTrue: [^self errorNoData].	class _ theChart class printString asSymbol.	class = #PieChart		ifTrue: [chart _ #Pie]		ifFalse: [class = #XYChart				ifTrue: [chart _ #XY]				ifFalse: [class = #StackedLineChart | (class = #LineChart)						ifTrue: [chart _ #Line]						ifFalse: [class = #ClusteredBarChart								ifTrue: [chart _ #Cluster]								ifFalse: [class = #BarChart | (class = #StackedBarChart) ifTrue: [chart _ #Bar]]]]].	emp _ #medium.	theChart emphasis = 10 ifTrue: [emp _ #small].	theChart emphasis = 16 ifTrue: [emp _ #large].	theChart emphasis = 22 ifTrue: [emp _ #tiny].	Cursor wait showWhile: 			[(defaultString _ OrderedCollection new) add: chart; add: title; add: theChart areYouLabeled printString asSymbol; add: theChart areYouLegended printString asSymbol; add: theChart areYouFilled printString asSymbol; add: theChart areYouLabeledByPercent printString asSymbol; add: theChart areYouAutoScaled printString asSymbol; add: emp.			answers _ DBoxView						openFor: #(select fill select select select select select select)						title: 'Change set up'						labels: #(('Chart Type' Bar Cluster Line Pie XY ) ('Title : ' ) ('Label : ' true false ) ('Legend : ' true false ) ('Fill : ' true false ) ('Label by Percent' true false ) ( 'Automatic Scaling' true false ) ('Label size' tiny small medium large))						defaults: defaultString. 			answers = nil ifTrue: [^false].			(self assignChart: (answers at: 1)) ifFalse: [^false].			(title _ answers at: 2) = nil ifTrue: [title _ String new].			labelSize _ answers at: 8.			theChart emphasis: 10.			labelSize = #tiny ifTrue:[theChart emphasis: 22].			labelSize = #medium ifTrue:[theChart emphasis: 13].			labelSize = #small ifTrue:[theChart emphasis: 10].			labelSize = #large ifTrue:[theChart emphasis: 16].			theChart				title: (answers at: 2);				isLabeled: (answers at: 3) = #true;				isLegended: (answers at: 4) = #true;				isFilled: (answers at: 5) = #true;				labeledByPercent: (answers at: 6) = #true;				isAutoScaled: (answers at: 7) = #true].	^true!checkCBar: aCBar	| temp labels answers cBar |	cBar _ aCBar.	stackLabels size = 2		ifTrue: 			[(temp _ OrderedCollection new) add: 'Sub Label Field'; add: #none; addAllLast: stackLabels.			(labels _ OrderedCollection new) add: temp.			answers _ DBoxView						openFor: #(select )						title: 'Cluster SubField Select'						labels: labels						defaults: #(none ).			answers == nil ifTrue: [(answers _ OrderedCollection new) add: #none].			(answers at: 1)				= #none				ifFalse: [cBar _ self convertToCBar: (answers at: 1)]].	^cBar!child: aChild	"you can only bring one edit chart data up at a time"	child _ aChild!convertToCBar: aField 	| index aCbar tempStackLabels tempLabelArray subStackDictionary labelDictionary temp tempDataArray subArray |	Cursor wait		showWhile: 			[(stackLabels at: 1)				= aField				ifTrue: [index _ 1]				ifFalse: [index _ 2].			tempStackLabels _ Set new.			tempLabelArray _ Set new.			dataArray do: [:each | tempStackLabels add: (each at: index) printString].			tempStackLabels asSortedCollection.			subStackDictionary _ OopConservingDictionary new.			tempStackLabels do: [:each | subStackDictionary at: each put: 0].			labelArray do: [:each | tempLabelArray add: each].			labelDictionary _ Dictionary new.			tempLabelArray do: [:each | labelDictionary at: each put: subStackDictionary deepCopy].			1 to: dataArray size do: 				[:i | 				temp _ (labelDictionary at: (labelArray at: i)) deepCopy.				temp at: ((dataArray at: i)						at: index) printString put: ((dataArray at: i)						at: 3 - index).				labelDictionary at: (labelArray at: i)					put: temp].			tempDataArray _ OrderedCollection new.			tempLabelArray do: 				[:each | 				subArray _ OrderedCollection new.				tempStackLabels do: [:eachLabel | subArray add: ((labelDictionary at: each)							at: eachLabel)].				tempDataArray add: subArray]].	^(aCbar _ ClusteredBarChart new) labelArray: labelDictionary keys asOrderedCollection; labelsInStack: tempStackLabels asOrderedCollection; dataArray: tempDataArray; title: title; isFilled: true; isLegended: true; isLabeled: theChart areYouLabeled; labeledByPercent: theChart labeledByPercent; isAutoScaled: theChart areYouAutoScaled!dataArray: anOrderedCollection	"sets the dataArray instance variable to contain the contents of anOrderedCollection which will contain the datas of the various categories."	dataArray _ anOrderedCollection!displayChart: aChart 	view workingForm white.	view display.	theChart _ aChart displayOn: Display		at: view insetDisplayBox origin		clippingBox: view insetDisplayBox		rule: Form over		mask: Form black!errorNoData	self booboo: 'I have no data to chart'.	self makeNew!labelArray: anOrderedCollection	"sets the labelArray instance variable to contain the contents of anOrderedCollection which will contain the labels of the various categories."	labelArray _ anOrderedCollection!packData	| temp |	dataArray == nil		ifTrue: [^nil]		ifFalse: 			[(temp _ OrderedCollection new) add: title copy; add: dataArray copy; add: labelArray copy; add: stackLabels copy; add: theChart copy; add: whatFile copy; add: dataType copy].	^temp!setChartData: theData labels: theLabels stack: theStack title: theTitle type: theType	dataArray _theData.	labelArray _ theLabels.	stackLabels _ theStack.	self title: theTitle. 	dataType _ theType.	firstTime _ true!setTitleAndDraw: theTitle	self title: theTitle.	firstTime _ true!stackedLabels: anOrderedCollection	"sets the stackedLabels instance variable to contain the contents of anOrderedCollection which will contain the labels of the various sub-categories."	stackLabels _ anOrderedCollection!title: aString	"sets the title instance variable to contain the contents of aString"	title _ aString!unpackData: packedData 	packedData == nil		ifFalse: 			[title _ packedData at: 1.			dataArray _ packedData at: 2.			labelArray _ packedData at: 3.			stackLabels _ packedData at: 4.			theChart _ packedData at: 5.			whatFile _ packedData at: 6.			dataType _ packedData at: 7.			firstTime _ true]! !!ChartEditor methodsFor: 'save/restore'!loadFromFile: aFileName 	"load the instance variables describing the data used in the present chart from 	a formatted file."	| readStream type |	Cursor read		showWhile: 			[(readStream _ self openOldFile: aFileName) == nil				ifTrue: 					[self booboo: 'Cannot find file named ' , aFileName.					^false].			readStream readOnly.			dataArray _ OrderedCollection new.			labelArray _ OrderedCollection new.			stackLabels _ OrderedCollection new.			self title: (readStream upTo: Character cr).			type _ (readStream upTo: Character cr) asSymbol.			((type = #stacked) | (type = #single) | (type = #xyPlot))				ifTrue: 					[dataType _ type.					self loadFromOldFile: readStream]				ifFalse: [theChart _ (Smalltalk at: type) new.						dataType _ (readStream upTo: Character cr) asSymbol.						self loadFromNewFile: readStream]].	^true!loadFromNewFile: readStream	"load the instance variables describing the data used in the present chart from a formatted file."	| typeOfData nextline index oldIndex tempArray |		oldIndex _ 0.		dataType = #stacked ifTrue:				[nextline _ readStream upTo: Character cr.				 [(index _ nextline findString: (String with: $,) startingAt: oldIndex + 1) = 0]					whileFalse:						[stackLabels add: (nextline copyFrom: oldIndex + 1 to: index - 1).						 oldIndex _ index].				 stackLabels add: (nextline copyFrom: oldIndex + 1 to: nextline size)].		"now strip the data elements"		oldIndex _ 0.		[readStream peek = (Character value: 255)] whileFalse:			[dataType = #stacked				ifTrue:					[oldIndex _ 0.					nextline _ readStream upTo: Character cr.					index _ nextline findString: (String with: $,) startingAt: oldIndex + 1.					labelArray add: (nextline copyFrom: oldIndex + 1 to: index - 1).					oldIndex _ index.					tempArray _ OrderedCollection new.					[(index _ nextline findString: (String with: $,) startingAt: oldIndex + 1) = 0]						whileFalse:							[tempArray add: (nextline copyFrom: oldIndex + 1 to: index - 1) asNumber.							 oldIndex _ index].					tempArray add: (nextline copyFrom: oldIndex + 1 to: nextline size) asNumber.					dataArray add: tempArray deepCopy]				ifFalse: "dataType = #single"					[labelArray add: (readStream upTo: $,).					dataArray add: (readStream upTo: Character cr) asNumber]].	readStream next.	theChart emphasis: (readStream upTo: Character cr) asNumber.	theChart isLabeled: ((readStream upTo: Character cr) = #true asString).	theChart isLegended: ((readStream upTo: Character cr) = #true asString).	theChart isFilled: ((readStream upTo: Character cr) = #true asString).	theChart labeledByPercent: ((readStream upTo: Character cr) = #true asString).	theChart isAutoScaled: ((readStream upTo: Character cr) = #true asString).	theChart class == PieChart ifFalse:		[theChart class == XYChart			ifFalse:				[theChart theMaximum: (readStream upTo: Character cr) asNumber.				theChart theMinimum: (readStream upTo: Character cr) asNumber.				theChart theInterval: (readStream upTo: Character cr) asNumber.				theChart zeroOffset: (readStream upTo: Character cr) asNumber]			ifTrue:				[theChart theMaximum: (Point x: (readStream upTo: $@) asNumber y: (readStream upTo: Character cr) asNumber).				theChart theMinimum: (Point x: (readStream upTo: $@) asNumber y: (readStream upTo: Character cr) asNumber).				theChart theInterval: (Point x: (readStream upTo: $@) asNumber y: (readStream upTo: Character cr) asNumber).				theChart zeroOffset: (readStream upTo: Character cr) asNumber.				theChart type: (readStream upTo: Character cr) asSymbol]].	readStream close.	^true!loadFromOldFile: readStream	| oldIndex nextline index tempArray | 	"load the instance variables describing the data used in the present chart from a formatted file."		self assignChart: #Bar.		oldIndex _ 0.		dataType = #stacked ifTrue:				[nextline _ readStream upTo: Character cr.				 [(index _ nextline findString: (String with: $,) startingAt: oldIndex + 1) = 0]					whileFalse:						[stackLabels add: (nextline copyFrom: oldIndex + 1 to: index - 1).						 oldIndex _ index].				 stackLabels add: (nextline copyFrom: oldIndex + 1 to: nextline size)].		"now strip the data elements"		oldIndex _ 0.		[readStream atEnd] whileFalse:			[dataType = #stacked				ifTrue:					[oldIndex _ 0.					nextline _ readStream upTo: Character cr.					index _ nextline findString: (String with: $,) startingAt: oldIndex + 1.					labelArray add: (nextline copyFrom: oldIndex + 1 to: index - 1).					oldIndex _ index.					tempArray _ OrderedCollection new.					[(index _ nextline findString: (String with: $,) startingAt: oldIndex + 1) = 0]						whileFalse:							[tempArray add: (nextline copyFrom: oldIndex + 1 to: index - 1) asNumber.							 oldIndex _ index].					tempArray add: (nextline copyFrom: oldIndex + 1 to: nextline size) asNumber.					dataArray add: tempArray deepCopy]				ifFalse: "dataType = #single"					[labelArray add: (readStream upTo: $,).					dataArray add: (readStream upTo: Character cr) asNumber]].		readStream close.		theChart _ self assignChartParameter: theChart.	^true!putMap	"Ask the user for a file name and then save the currently 	displayed image under that name into the information center."	| chartLabelArray aSuitcase keys defaultSuitcase |	aSuitcase _ view topView suitcase.	aSuitcase accept.	self accept.	(whatFile ~= nil and: [self confirm: 'overwrite ', aSuitcase dataItem label, (String with: $?)])		ifTrue:			[view workingForm writeAsDataItem: aSuitcase dataItem.			self saveDataInFile: whatFile, (DataMaster giveMe: #specialSuffixString for: #chart asString).			locked _ #no]		ifFalse:			[defaultSuitcase _ Suitcase new packTheSuitcaseFrom: aSuitcase center forItem: aSuitcase dataItem copy.			defaultSuitcase dataItem label: title. "don't smash title of guy not overwriting"			keys _ (aSuitcase dataItem centerIndex = 0						ifTrue: [String new]						ifFalse: [aSuitcase center keywordStringFor: aSuitcase dataItem]).			chartLabelArray _ InformationCenter fileNameData: #chart defaultSuitcase: defaultSuitcase defaultKeys: keys askMethod: true askClass: true.			((chartLabelArray at: 1) == nil) ifTrue: [^nil].			Cursor wait showWhile: [			view workingForm writeAsDataItem: (chartLabelArray at: 1).			self saveDataInFile: (chartLabelArray at: 1) filename, (DataMaster giveMe: #specialSuffixString for: #chart asString).			whatFile == nil ifTrue:					[whatFile _ (chartLabelArray at: 1) filename.					aSuitcase packTheSuitcaseFrom: ((chartLabelArray at: 4) at: 1) forItem: (chartLabelArray at: 1).					view topView erase.					view topView label: (chartLabelArray at: 1) label.					view topView classifyLabel: aSuitcase classification.					view topView display].			locked _ #no].			InformationCenter putFileNameAway: chartLabelArray]!saveDataInFile: fileName	"this method takes the present data set in the chart and writes it out to the file specified in fileName."	| outFile comma |	comma _ String with: $,.	outFile _ (FileStream fileNamed: fileName) writeShorten.	outFile nextPutAll: title; cr.	outFile nextPutAll: theChart class printString;cr.	outFile nextPutAll: dataType printString;cr.	((dataArray at:1) isKindOf: Number)		ifFalse:			[ outFile nextPutAll: (stackLabels at: 1).			 2 to: stackLabels size do: [:i | outFile nextPutAll: (comma, (stackLabels at: i))].			 outFile cr.			 1 to: labelArray size do:				[:i |					outFile nextPutAll: (labelArray at: i).					1 to: stackLabels size do: [:j | outFile nextPutAll: comma, ((dataArray at: i) at: j) printString].					outFile cr.]]		ifTrue:			[1 to: labelArray size do:				[:i |					outFile nextPutAll: (labelArray at: i).					outFile nextPutAll: comma, (dataArray at: i) printString.					outFile cr]].	outFile nextPut: (Character value: 255);		nextPutAll: theChart emphasis printString; cr;		nextPutAll: theChart areYouLabeled printString; cr;		nextPutAll: theChart areYouLegended printString; cr;		nextPutAll: theChart areYouFilled printString; cr;		nextPutAll: theChart areYouLabeledByPercent printString; cr;		nextPutAll: theChart areYouAutoScaled printString.	theChart class == PieChart ifFalse:		[outFile cr;			nextPutAll: theChart theMaximum printString; cr;			nextPutAll: theChart theMinimum printString; cr;			nextPutAll: theChart theInterval printString; cr;	 		nextPutAll: theChart zeroOffset printString.		theChart class == XYChart ifTrue: [outFile cr; nextPutAll: theChart type printString]].	outFile close! !FormsEditController comment:'Copyright (c) 1986, 1987 Xerox Corporation.  All rights reserved.'!!FormsEditController methodsFor: 'initialize-release'!initialize	super initialize.	swappedOut _ false.	self yellowButtonMenu: FEYellowButtonMenu 		yellowButtonMessages: FEYellowButtonMessages! !!FormsEditController methodsFor: 'accessing'!selectedElement	^selectedElement! !!FormsEditController methodsFor: 'control activity'!controlInitialize	super controlInitialize.	selectedElement == nil ifFalse:[view reverse: selectedElement].!controlTerminate	selectedElement == nil ifFalse:[view reverse: selectedElement].	super controlTerminate!isControlActive	swappedOut ifTrue:[model _ nil. view _ nil. ^false].	^(view containsPoint: sensor cursorPoint) & sensor blueButtonPressed not!redButtonActivity	| point element |	[sensor redButtonPressed]		whileTrue: 			[point _ sensor cursorPoint.			element _ view elementForPoint: point.			element == selectedElement				ifFalse: 					[selectedElement == nil ifFalse: [view reverse: selectedElement].					selectedElement _ element.					selectedElement == nil ifFalse: [view reverse: selectedElement]]]! !!FormsEditController methodsFor: 'menu messages'!clipCode	Cursor execute showWhile: [Clipboard clip: model codeString asText].!deleteElement	selectedElement == nil ifTrue:[^view flash].	(self confirm: 'Delete ', selectedElement name, '?') ifFalse:[^nil].	view reverse: selectedElement.	view erase: selectedElement.	view resetDisplayCache.	model removeElementNamed: selectedElement name.	selectedElement _ nil.!duplicate	| answers newElement box value elName defaults |	selectedElement == nil ifTrue:[^view flash].	view reverse: selectedElement.	box _ (Rectangle				fromUser: 5 @ 5				gridOrigin: view insetDisplayBox origin				withExtent: selectedElement box deepCopy extent)				translateBy: view insetDisplayBox origin * -1.	elName _ 'Element' , model elements size printString.	newElement _ selectedElement copy.	newElement name: elName.	newElement box: box.	model add: newElement.	selectedElement _ nil.	view display: newElement!editAnElementOfType: elementClassName	| answers |	selectedElement == nil ifTrue: [^view flash].	answers _ self queryElement: selectedElement ofType: elementClassName.	answers == nil ifTrue: [^self].	model removeElementNamed: selectedElement name.	selectedElement name: (answers at: answers size).	selectedElement setValuesFromAnswers: answers.	model add: selectedElement.	view display: selectedElement.	view reverse: selectedElement.!editElement	selectedElement== nil ifTrue:[^view flash].	self editAnElementOfType: selectedElement class name!endEdit	| t1 t2 |	Cursor execute		showWhile: 			[t1 _ FormsController new.			view controller: t1.			model updateControllers: t1.			selectedElement == nil				ifFalse: 					[view reverse: selectedElement.					selectedElement _ nil].			model elements do: [:t2 | (t2 isKindOf: ExecuteElement)					ifTrue: [t2 targetController == self ifTrue: [t2 targetController: t1]]].			swappedOut _ true]!makeAnElementOfType: elementClassName	| answers newElement box |	box _ (Rectangle fromUser: 5 @ 5 gridOrigin: view insetDisplayBox origin)				translateBy: view insetDisplayBox origin * -1.	answers _ self queryElement: nil ofType: elementClassName.	answers == nil ifTrue: [^self].	newElement _ (Smalltalk at: elementClassName) named: (answers at: answers size).	newElement		box: box;		controller: self;		setValuesFromAnswers: answers.	model add: newElement.	view display: newElement!moveElement	| box |	selectedElement == nil ifTrue: [^view flash].	box _ (Rectangle				fromUser: 5 @ 5				gridOrigin: view insetDisplayBox origin				withExtent: selectedElement box extent)				translateBy: view insetDisplayBox origin * -1.	view reverse: selectedElement.	view erase: selectedElement.	model removeElementNamed: selectedElement name.	selectedElement box: box.	model add: selectedElement.	view display: selectedElement.	view updateDisplayCache.	view reverse: selectedElement!queryElement: anElement ofType: elementClassName	| answers elName definArray defaults title i |	elName _ #Element asString, model elements size printString.	definArray _ (Smalltalk at: elementClassName) defineNeedsFor: anElement.	defaults _ definArray at: 4.	(defaults at: defaults size) == nil ifTrue: [defaults at: defaults size put: elName].	title _ definArray at: 1.	title == nil ifTrue: [title _ elementClassName asString copyFrom: 1 to: ((i _ elementClassName asString findString: #Element asString startingAt: 1) = 0 ifTrue: [elementClassName asString size] ifFalse: [i - 1])].	answers _ DBoxView				openFor: (definArray at: 3)				title: ((#($a $e $i $o $u) indexOf: (title at: 1)) = 0 ifTrue: ['Define a '] ifFalse: ['Define an ']), title				labels: (definArray at: 2)				defaults: defaults.	answers == nil ifTrue: [^nil].	(model elemNames includesKey: (answers at: defaults size)) ifTrue:		[(anElement == nil or: [((model elementNamed: (answers at: defaults size)) == anElement) not])			ifTrue: [self booboo: 'That name has already been used, think of another'. ^nil]].	^answers!redisplay	selectedElement == nil ifFalse: [view reverse: selectedElement].	view resetDisplayCache.	view displayView.	selectedElement == nil ifFalse: [view reverse: selectedElement]!rename	| name | 	name _ FillInTheBlank request: 'What should this form be called?' initialAnswer: model name.	model name: name!reshapeElement	| box |	selectedElement == nil ifTrue: [^view flash].	box _ (Rectangle fromUser: 5 @ 5 gridOrigin: view insetDisplayBox origin)				translateBy: view insetDisplayBox origin * -1.	view reverse: selectedElement.	view erase: selectedElement.	model removeElementNamed: selectedElement name.	selectedElement box: box.	model add: selectedElement.	view display: selectedElement.	view updateDisplayCache.	view reverse: selectedElement!save	model save! !DatabaseFormsEditController comment:'Copyright (c) 1987 Xerox Corporation.  All rights reserved.'!!DatabaseFormsEditController methodsFor: 'menu messages'!endEdit	| t1 t2 |	Cursor execute		showWhile: 			[t1 _ DatabaseFormsController new.			view controller: t1.			model updateControllers: t1.			selectedElement == nil				ifFalse: 					[view reverse: selectedElement.					selectedElement _ nil].			model elements do: [:t2 | (t2 isKindOf: ExecuteElement)					ifTrue: [t2 targetController == self ifTrue: [t2 targetController: t1]]].			swappedOut _ true]! !!ScreenController methodsFor: 'initialize-release'!initialize	super initialize.	previousAnswers _ Dictionary new.	self initializeYellowButtonMenu.	self initializeBlueButtonMenu! !!ScreenController methodsFor: 'control defaults'!isControlActive	^super isControlActive and: [sensor yellowButtonPressed | sensor blueButtonPressed]!isControlWanted	UserName == nil ifTrue:[LogInOut logMeIn].	^super isControlWanted and: [sensor yellowButtonPressed | sensor blueButtonPressed]! !!ScreenController methodsFor: 'private'!initializeBlueButtonMenu 	self blueButtonMenu: ScreenBlueButtonMenu 		blueButtonMessages: ScreenBlueButtonMessages!request: promptString for: aKey default: defaultString	| answer initialAnswer |	initialAnswer _ previousAnswers at: aKey ifAbsent: [previousAnswers at: aKey put: defaultString].	answer _ FillInTheBlank request: promptString initialAnswer: initialAnswer.	^previousAnswers at: aKey put: answer! !!ScreenController methodsFor: 'menu messages - windows'!openBrowser	BrowserView openOn: SystemOrganization.!openChangeList	ChangeListView open.!openCommandBar	DataMaster findTheOneByEvaluating: [:each | (each model isKindOf: FormsModel) and: [each model name ='Smalltalk Controls']].	FormsView openControlPanel!openFileList	"Create and schedule a FileList view for specifying files to access."	FileList open.!openSystemWorkspace	StringHolderView openSystemWorkspace.!openTranscript	(Transcript isKindOf: TextCollector)		ifFalse: [Smalltalk at:#Transcript put: TextCollector new.].	TextCollectorView open: Transcript label: 'System Transcript'.!openWorkspace	StringHolderView open.!openWorkspaceOnFile	(FileStream fileNamed: (FillInTheBlank request: 'Please specify a file name.			')) edit.!openXDECenter	(Smalltalk includesKey: #XDEInterfaceModel)		ifTrue: [XDEInterfaceModel open]! !!ScreenController methodsFor: 'menu messages - session'!browseRecover	ChangeListView recover.!crashRecover	Smalltalk recover: (Number readFromString: (self request: 'Number of characters to recover:' for: #crashRecover default: '5000')).!defer	(Smalltalk respondsTo: #defer)		ifTrue:			[(self confirm: 'Are you sure you want to suspend?')				ifTrue: [Smalltalk defer.].			]		ifFalse:			[(self respondsTo: #suspend) ifTrue: [self suspend.].].!fileOutChanges	(FileStream fileNamed: (self request: 'Please specify a file name.' for: #fileOutChanges default: 'Changes.st')) fileOutChanges.!inspectChanges	Smalltalk changes inspect.!noChanges	(self confirm: 'Are you sure about resetting changes?') ifTrue: [Smalltalk noChanges.]!quit	((self confirm:'Do you really want to quit (without saving!!)?') and: [(Smalltalk includesKey:#RS232Model) ifTrue: [(RS232Model checkRS232Connections)] ifFalse: [true]])	ifTrue: [Smalltalk quit]!saveThenQuit 	Smalltalk saveAs: Smalltalk getImagePrefix thenQuit: ((Smalltalk includesKey:#RS232Model) ifTrue: [(RS232Model checkRS232Connections)] ifFalse: [true])! !!ScreenController methodsFor: 'menu messages - remote disk'!connect	UserProfile current connect.!fileServer	UserProfile current selectFileServer.!releaseExternalViews	Smalltalk releaseExternalViews.!remoteLogin	UserProfile current login == nil ifFalse:		[(Smalltalk includesKey: #XDEInterfaceModel) ifTrue:			[(XDEInterfaceModel giveMeOne: false) networkLogin]]! !!ScreenController methodsFor: 'menu messages - printing'!printAuditor	Auditor hardcopy!printEntireScreen	(Smalltalk includesKey: #BackgroundPrinter) ifFalse: [^self booboo: 'Printing not installed'].	BackgroundPrinter printForm: Display!printFramedArea	(Smalltalk includesKey: #BackgroundPrinter) ifFalse: [^self booboo: 'Printing not installed'].	BackgroundPrinter printForm: Form fromUser! !!ScreenController methodsFor: 'menu messages - third button'!collapseDisplay	"Stack the collapsed windows on the display"	ScheduledControllers collapse!editTimeZonesMenu	"Edit and reinstall the current user's time zone pop up menu."	| contents | 	(Smalltalk includesKey: #ClockView) ifTrue:		[(contents _ ConfigFile currentUserConfig getSection: #TimeZones) == nil ifTrue:			[contents _'"This is the list of time zones. It consists of one or more time zone entries. The format of an entry is an asterisk followed by the desired name of the time zone, then a comma and a number specifying the difference from Greenwich Mean Time in hours. Each entry must end in a carriage return. To install time zones, edit the list below, then select accept on the middle button menu."*EasternTimeZone,-5*CentralTimeZone,-6*MountainTimeZone,-7*PacificTimeZone,-8'].			EditStringHolder new				openEditorOn: contents				blockOnAccept:					[:newList :sN |					ConfigFile currentUserConfig writeSection: sN with: newList.					ClockView timeZonePopUpFromConfigFile]				withArgs: #TimeZones				withLabel: 'Editing Time Zones']!findOne	"Set up a pop-up menu of other views to close."	| aCollection aString aView | 	aCollection _ OrderedCollection new.	aString _ String new.	(ScheduledControllers scheduledControllers) do:		[:each |		(each isMemberOf: ScreenController)			ifFalse: [(each == self)				ifFalse:	[aString _ aString, (each view label), (String with: $\).						aCollection add: each]]].	aCollection isEmpty ifTrue: [^self booboo: 'There are no active windows.'].	aView _ (TreeMenu labels: aString withCRs)			answers: aCollection;			selectBlock: [:menu | 4 timesRepeat: [menu answer view displayTextReverse]];			startUp: nil.	(aView = 0 or: [aView == nil]) ifTrue: [^nil].	aView == self ifTrue: [^self centerCursorInView].	aView centerCursorInView.	ScheduledControllers promote: aView!garbageCollect	"Reclaim the core and oops occupied by unused objects."	| startCore startOops aString aForm aRectangle | 	(SystemDictionary canUnderstand: #garbageCollect) ifFalse: [^self booboo: 'Sorry, I don''t know how to garbage collect.'].	(self confirm: 'Are you sure you want to garbage collect') ifTrue:		[Cursor garbage showWhile:			[startCore _ Smalltalk coreLeft.			startOops _ Smalltalk oopsLeft.			Smalltalk garbageCollect.			aString _	' core recovered: ' , (Smalltalk coreLeft - startCore) printString,						' words    oops recovered: ' , (Smalltalk oopsLeft - startOops) printString.			aForm _ aString asParagraph asForm.			aRectangle _ aForm boundingBox.			aRectangle _  aRectangle align: aRectangle topCenter with: (Display boundingBox topCenter + (0@4)).			aForm displayOn: Display at: aRectangle topLeft]]!idleStart	| select |  	((Smalltalk includesKey: #Idle) and: [(select _ self getLastSelectionIn: blueButtonMenu) ~= nil])		ifTrue:			[select  = $F				ifTrue: [Idle secondTimeout: 0. Idle start]				ifFalse: [Idle start]]!openClock	"This method will open a analog clock window for the user"	(Smalltalk includesKey: #ClockView) ifTrue: [ClockView open]!openDigitalClock	"This method will open a digital clock window for the user"	(Smalltalk includesKey: #DigitalClockView) ifTrue: [DigitalClockView open]!restoreDisplay	ScheduledControllers restore!selectAndClose	"Set up a pop-up menu of other views to close. Close all views selected by the user."	| refresh closeSelf aCollection aString index theSet |	refresh _ closeSelf _ false.	aCollection _ OrderedCollection new.	aString _ String new.	(ScheduledControllers scheduledControllers) do:		[:each |		(each isMemberOf: ScreenController)			ifFalse: [(each  == self)				ifFalse:	[aString _ aString, (each view label), (String with: $\).						aCollection add: each]]].	aCollection isEmpty ifTrue: [^self booboo: 'There are no active windows.'].	theSet _ (TreeMenu labels: aString withCRs)				answers: aCollection;				selectBlock: [:menu | 4 timesRepeat: [menu answer view displayTextReverse]];				multipleStartUp: nil.	theSet isEmpty ifTrue: [^nil].	theSet do:		[:each |		refresh _ ((each view displayBox) intersects: (view displayBox)) | refresh.		each closeAndUnschedule]!showCoreAndOopsLeft	"Display the amount of remaining core and oops at the top of the screen."	|  aForm aString aRectangle |	aString _ ' Core left: ' , Smalltalk coreLeft printString, ' words    Oops left: ' , Smalltalk oopsLeft printString, (String with: $ ).	aForm _ aString asParagraph asForm.	aRectangle _ aForm boundingBox.	aRectangle _ aRectangle align: aRectangle topCenter with: (Display boundingBox topCenter + (0@4)).	aForm displayOn: Display at: aRectangle topLeft!showDateAndTime	"Display today's date and the time of day at the top right corner of the screen."	| aForm aRectangle |	aForm _ ((String with: $ ), Date today printString, (String with: $  with: $  with: $ ), Time now printString, (String with: $ )) asForm.	aRectangle _ aForm boundingBox.	aRectangle _ aRectangle align: aRectangle topRight with: (Display boundingBox topRight - (4@-4)).	aForm displayOn: Display at: aRectangle topLeft!showDiskSpace	"Display the amount of remaining disk space at the top of the screen."	|  aForm aString aRectangle |	aString _ ' Disk space: ' , Disk freePages printString , ' free pages '.	aForm _ aString asParagraph asForm.	aRectangle _ aForm boundingBox.	aRectangle _ aRectangle align: aRectangle topCenter with: (Display boundingBox topCenter + (220@4)).	aForm displayOn: Display at: aRectangle topLeft!showResources	self showCoreAndOopsLeft.	self showDiskSpace! !!ScreenController methodsFor: 'menu messages - user profile'!accelerateCursorPlace: aBoolean	aBoolean == nil ifFalse:		[TreeMenu accelerateCursorPlace: aBoolean.		ConfigFile currentUserConfig writeSection: #TreeMenuMoveCursor with: aBoolean printString]!autoMenuShow: aBoolean	aBoolean == nil ifFalse:		[TreeMenu popUpChildren: aBoolean.		ConfigFile currentUserConfig writeSection: #TreeMenuPopUpChildren with: aBoolean printString]!backupUser: whichWay	| theFiles | 	(Smalltalk includesKey: #XDEInterfaceModel) ifFalse: [^self booboo: 'Sorry, I cannot do that'].	theFiles _ UserName,'-configFile ',UserName,'-FunctionKeyDefs ',UserName,'.idleImage'.	ConfigFile clearCurrentUserFile.	whichWay		ifTrue:			[XDEInterfaceModel storeThese: theFiles inDirectory: UserName,'>BackupUser']		ifFalse:			[XDEInterfaceModel				retrieveThese: theFiles				fromDirectory: UserName,'>BackupUser'				doAfter: [:showObject :unusedArgs |						showObject show: 'Reinitializing, please wait . . . '.						LogInOut initializeCurrentUser.						showObject show: 'done']				withArgs: nil]!backupUserMenuChoice	self backupUser: true!clipboardFunction: arg	arg == nil		ifTrue: [ClipBuffer openCommandBar]		ifFalse: [Clipboard perform: arg]!editOIT	| newList menuString selectionIndex userList | 	(Smalltalk includesKey: #FunctionKeyEditor) ifFalse: [^self booboo: 'Tool not installed'].		Cursor execute showWhile:		[userList _ LogInOut userList.		newList _ OrderedCollection new.		userList do: [:user | (Disk includesKey: user, '-FunctionKeyDefs') ifTrue: [newList add: user]].		menuString _ 'new file'.		newList reverseDo: [:fn | menuString _ fn, (String with: Character cr), menuString]].	(selectionIndex _ (PopUpMenu labels: menuString) startUp: #anyButton) = 0 ifTrue: [^self].	selectionIndex > newList size		ifTrue:			[Wheel ifFalse: [^self booboo: 'Please consult your system administrator'].			 Cursor execute showWhile:				[newList _ userList.				 menuString _ newList at: 1.				 2 to: newList size do: [:i | menuString _ menuString, (String with: Character cr), (newList at: i)]].			 (selectionIndex _ (PopUpMenu labels: menuString) startUpYellowButton) = 0 ifTrue: [^self]].	FunctionKeyEditor openOnUser: (newList at: selectionIndex)!idleForm	LogInOut setIdleFormWithChange: true!printerName	| aString printerName |	printerName _ UserProfile current printerName.	aString _ UserProfile current selectPrinter.	aString = printerName ifFalse:		[((Smalltalk includesKey: #ConfigFile) and: [(Smalltalk at: #PressOrInterpress) ~~ nil]) ifTrue:			[ConfigFile currentUserConfig writeSection: (Smalltalk at: #PressOrInterpress) with: aString]]!restoreUserMenuChoice	self backupUser: false!screenColor: color	"set the screen background"	color == nil		ifFalse: [self class makeScreenColor: color logChange: true]!scrollMenuSpeed	| answer default | 	answer _ FillInTheBlank		request: 'Enter slowest speed for scroll menus in milliseconds'		default: ((default _ ConfigFile currentUserConfig getSection: #ScrollMenuScrollMsec) == nil					ifTrue: [String with: $8 with: $0] ifFalse: [default]).	answer isNumeric ifTrue:		[answer _ answer asNumber asInteger.		ScrollMenu scrollMsec: answer.		ConfigFile currentUserConfig writeSection: #ScrollMenuScrollMsec with: answer printString]!setSystemFont: fontIndex	"Change the fonting for new windows in the system"	fontIndex == nil ifFalse:		[UserFont _ fontIndex.		ConfigFile currentUserConfig writeSection: #SystemUserFont with: UserFont printString]! !!ScreenController methodsFor: 'menu messages - Analyst'!analystVersionInfo	"display whatever version information is available"	(SystemDictionary canUnderstand: #analystVersionInfo) ifTrue:		[User booboo: Smalltalk analystVersionInfo align: #leftFlush.		Transcript cr; show: Smalltalk analystVersionInfo]!auditOn	Auditor auditOn!editUsersFile	LogInOut editUsersFile!logOut 	LogInOut logOut!makeNewChartOrGraphicPad	"show the user the sizes of chart editors available"	| answer labels types defaults linkArray |	labels _ OrderedCollection new.	types _ OrderedCollection new.	defaults _ OrderedCollection new.	linkArray _ OrderedCollection new.	(Smalltalk includesKey: #ChartEditor) ifTrue:		[labels add: #('Pad Type:' Chart Sketch).		types add: #select.		defaults add: #Sketch.		linkArray add: (Array with: 1@1 with: 2@-6)].	labels add: #('Size:'  Standard FullPage Landscape InputSize FrameSize FromScreen).	types add: #select.	defaults add: #Standard.	answer _ DBoxView		openFor: types		title: 'What sort of Graphics pad?'		labels: labels		defaults: defaults		commands: (Array with: #accept with: #cancel with: #bailOut)		autoAccept: false		links: linkArray.	answer == nil ifTrue: [^nil].	((Smalltalk includesKey: #ChartEditor) and: [(answer at: 1) = #Chart])		ifTrue: [ChartEditor createNewEditor: (answer at: 2) title: 'New Chart Editor']		ifFalse: [ImageEditor createNewEditor: (answer at: ((Smalltalk includesKey: #ChartEditor) ifTrue: [2] ifFalse: [1])) title: 'New Sketch Editor']!openAutoBook	(Smalltalk includesKey: #AutoBook)		ifTrue: [AutoBook open: 'The World Atlas' onData: 'WorldAtlas'].	self booboo: 'World Atlas tool is not installed'!openInfoCenter	InformationCenter openCenterChoiceBar!openOIT"open a rs232 window with the selected auto log in "	(OITMenu answer  == nil) ifTrue: [^self].	(RS232Collector == nil)		ifTrue:			[(OITMenu answer at: 2) = $D				ifTrue:					[(Smalltalk includesKey: #TigerRS232TextModel) ifFalse: [^self booboo: 'Sorry, the necessary code is not in this system'].					TigerRS232TextModel						rs232OpenWithLabel: (OITMenu answer at: 1)						logIn: (OITMenu answer at: 3)]				ifFalse:					[(Smalltalk includesKey: #TekModel) ifFalse: [^self booboo: 'Sorry, the necessary code is not in this system'].					TekModel rs232OpenTekWithLabel: (OITMenu answer at: 1) logIn: (OITMenu answer at: 3)]]		ifFalse:			[self booboo: 'Sorry, OIT connection already in use.']!openTextWindow	AnnotationModel openTextWorkspace!openUserGuide	(Smalltalk includesKey: #OutlineView) ifTrue:		[OutlineView openUserGuideWithKey: nil].	self booboo: 'The necessary tool is not installed'!wipeOut	Auditor wipeOut! !RemoteMenuController comment:'Copyright (c) Xerox Corporation, 1983. All rights reserved.'!!RemoteMenuController methodsFor: 'initialize-release'!release	super release.	menuMessageReceiver _ nil."	(redButtonMessages isKindOf: FakeCollection) ifTrue: [redButtonMessages release].	redButtonMessages _ nil.	(yellowButtonMessages isKindOf: FakeCollection) ifTrue: [yellowButtonMessages release].	yellowButtonMessages _ nil.	(blueButtonMessages isKindOf: FakeCollection) ifTrue: [blueButtonMessages release].	blueButtonMessages _ nil.	redButtonMenu _ nil.	yellowButtonMenu _ nil.	blueButtonMenu _ nil"! !!RemoteMenuController methodsFor: 'menu messages'!blueButtonActivity	"Determine which item in the blue button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	| index |	blueButtonMenu ~~ nil		ifTrue: 			[index _ blueButtonMenu startUpBlueButton.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(blueButtonMessages at: index) with: self]]		ifFalse: [super controlActivity]!redButtonActivity	"Determine which item in the red button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUpRedButton.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(redButtonMessages at: index) with: self]]		ifFalse: [super controlActivity]!yellowButtonActivity	"Determine which item in the yellow button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	| index |	yellowButtonMenu ~~ nil		ifTrue: 			[index _ yellowButtonMenu startUpYellowButton.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(yellowButtonMessages at: index) with: self]]		ifFalse: [super controlActivity]! !!RemoteMenuController methodsFor: 'menu accessing'!blueButtonMenu	^blueButtonMenu!blueButtonMessages	^blueButtonMessages!menuMessageReceiver	^menuMessageReceiver!menuMessageReceiver: anObject	menuMessageReceiver _ anObject!redButtonMenu	^redButtonMenu!redButtonMessages	^redButtonMessages!yellowButtonMenu	^yellowButtonMenu!yellowButtonMessages	^yellowButtonMessages! !QuerierController comment:'Copyright (c) Xerox Corporation, 1985, 1986.  All rights reserved.I am a controller for a Querier.  I am a customized MouseMenuController which implements only a yellow-button menu.  I request this menu from my model, and return the index of the selection to it.'!!QuerierController methodsFor: 'menu messages'!menuMessageReceiver	^model!yellowButtonActivity	"I send the selection number, not a message determined by the selection."	| index yellowMenu |	yellowMenu _ (self menuMessageReceiver menu).	yellowMenu ~~ nil		ifTrue:			[index _ yellowMenu startUp.			index ~= 0				ifTrue:					[self centerCursorInView.					self menuMessageReceiver perform: #menuSelection: with: index] ]		ifFalse: [super controlActivity]! !!QuerierController methodsFor: 'basic control sequence'!controlTerminate	| topController |	super controlTerminate.	model actionTaken ifFalse: [^self].	topController _ view topView controller.	(topController notNil & (topController isKindOf: StandardSystemController))		ifTrue: [topController close]!startUp	Cursor mouse showWhile: [super startUp]! !!QuerierController methodsFor: 'control defaults'!isControlActive	model actionTaken ifTrue: [^false].	^super isControlActive!isControlWanted	model actionTaken ifTrue: [^false].	^super isControlActive! !DBoxQueryController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DBoxQueryController methodsFor: 'control activity'!controlTerminate	^self!isControlActive	^self viewHasCursor!isControlWanted	^self viewHasCursor! !ABFormController comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ABFormController methodsFor: 'initialize'!initialize	super initialize.	self initializeYellowButtonMenu!initializeYellowButtonMenu	self 		yellowButtonMenu: ABFormYellowButtonMenu		yellowButtonMessages: ABFormYellowButtonMessages! !!ABFormController methodsFor: 'control'!controlInitialize	super controlInitialize.	Cursor crossHair show.!controlTerminate	super controlTerminate.	Cursor normal show!isControlActive	^super isControlActive & sensor blueButtonPressed not!redButtonActivity	"Determine which item in the red button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."|thePoint x y xWid yWid location|	(self view superView subViews at: 2) model isLocked		ifTrue:[view flash]		ifFalse:[(self view superView subViews at: 2) model changedFlag = true			ifTrue:[(self view superView subViews at: 2) model writeCountryData.].	thePoint _ (sensor cursorPoint) - view insetDisplayBox origin.	xWid _ (view insetDisplayBox width/6) rounded.	yWid _ (view insetDisplayBox height/3) rounded.	x _ (thePoint x/ xWid) asInteger + 1.	y _ (thePoint y/ yWid) asInteger + 1.	location _ y-1*6+x.	location = lastLocation	ifFalse:[lastLocation _ location.		(self view superView subViews at: 2) model setFirstList: location]]! !!ABFormController methodsFor: 'menu messages'!compressChanges	"Determine which item in the red button pop-up menu is selected.	If one is selected, then send the corresponding message to the object	designated as the menu message receiver."	self controlTerminate.	(self view superView subViews at: 2) model isLocked		ifTrue:[view flash]		ifFalse:[(self view superView subViews at: 2) model changedFlag = true			ifTrue:[(self view superView subViews at: 2) model writeCountryData.]].	(self view superView subViews at: 2) model compressChanges.	self controlInitialize.!rewriteSources	"take the sources file and changes file and write new sources"	self controlTerminate.	(self view superView subViews at: 2) model isLocked		ifTrue:[view flash]		ifFalse:[(self view superView subViews at: 2) model changedFlag = true			ifTrue:[(self view superView subViews at: 2) model writeCountryData.]].	(self view superView subViews at: 2) model rewriteSources.	self controlInitialize.! !LabelSwitchController comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!LabelSwitchController methodsFor: 'initialize-release'!initialize	super initialize.	yellowButtonMenu _ nil.	yellowButtonMessages _ nil.! !!LabelSwitchController methodsFor: 'control defaults'!isControlActive	^self viewHasCursor & (sensor redButtonPressed | sensor yellowButtonPressed)!isControlWanted	^self viewHasCursor & (sensor redButtonPressed | sensor yellowButtonPressed)! !!LabelSwitchController methodsFor: 'menu messages'!redButtonActivity	Sensor waitNoButton.  	self viewHasCursor ifTrue:[model switch]!yellowButtonActivity	| selector |	menu == nil ifTrue:[self makePopup].	selector _ menu startUp.	selector = 0 ifFalse: [model switchToSelector: (model selectors at: selector)]! !!LabelSwitchController methodsFor: 'private'!makePopup	"build a pop-up menu for this controller."	| aStream index realCollection |	model labels isEmpty ifTrue: [^nil].	aStream _ WriteStream on: (String new: 200).	model labels do: [:each | aStream nextPutAll: each text string; cr].	aStream skip: -1.	menu _ (PopUpMenu labels: aStream contents)! !PilotCalls comment:'Copyright (c) 1986 Xerox Corporation. All rights reserved.	This class is the (system specific) interface between Smalltalk and	an underlying Operating System - in this case Pilot/Mesa - via Molasses.	The operation numbers are totally arbitrary, but must track	the table systemCallTable in Molasses/ST80PilotFileImplA -	(which should eventually be moved to a better place).'!Tables comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.	Tables is a tool to make suitable tables for hardcopying.  The user may specify number the of columns and the width of each column.  The program will then produce a text corresponding to the users'' specification.  Since the user specifies the width of each column, the program allows wrap around on the field of the table.<Instance Variable>[delimiter]	This variable is used to break text into different fields.  If it is not set, its default is a carriage return; therefore, it will parse text up to carrriage returns as fields.  Please note that there are two ways to parse a piece of text.  The message ''parse:'' will use carriage return as the delimiter when parsing unless otherwise specified; however, the message ''format:'' will use tab as field delimiter and the instance variable delimiter as the record delimiter.[table]	As a table is generated, table is the text that will eventually be returned to the user with the correct tabbings.[widthArray]	This is an array.  The size corresponds to the number of columns in the table.  Each element in the widthArray corresponds to the width in the present printer scale of the column.<Class Variable>[FontIndex]	This is the default font for the table if the user pass in a string.  It is currently being set to the Gacha 10.[MinWidth]	This stores the minimum width of the column in inches.  Currently it is set to 0.5 inch.[Style]	This is an array of two. The first one is #Press or #Interpress. The second is the style for the scanning process.  In press, it is set to TextStyle and in interpress, it is set to PrintStyle.'!!Tables methodsFor: 'accessing'!delimiter: aDelimiter	delimiter _ aDelimiter!tabsArray	| tabsArray total scale | 	tabsArray _ Array new: widthArray size - 1.	total _ 0.	scale _ (PressOrInterpress == #Press				ifTrue: [PressFile pressScale] ifFalse: [PrintStyle pressScale]) * 79.375.	1 to: tabsArray size do: [:i |		total _ total + ((widthArray at: i)/scale).		tabsArray at: i put: total].	^tabsArray!widthArray: aWidthArray	widthArray _ aWidthArray!widthInquiry: labels	| typeCollection defaultCollection labelCollection answers scale | 	widthArray  == nil ifTrue: [self columnInquiry == nil ifTrue: [^nil]].	widthArray size = 0 ifTrue: [^nil].	typeCollection _ Array new: widthArray size withAll: #fill.	defaultCollection _ Array new: widthArray size withAll: 1 printString.	(labels == nil or: [labels isEmpty])		ifTrue: [labelCollection _ Array new: widthArray size.				1 to: widthArray size do: [:i | labelCollection at: i put: (Array with: 'Column ' , i printString, (String with: $: with: $ ))]]		ifFalse: [labelCollection _ labels].	answers _ DBoxView				openFor: typeCollection				title: 'Enter Column Widths in Inches'				labels: labelCollection				defaults: defaultCollection				autoAccept: false.	answers == nil ifTrue: [^nil].	PressOrInterpress == #Press		ifTrue: [scale _ PressFile pressScale * 79.375]		ifFalse: [scale _ PrintStyle pressScale * 79.375].	1 to: widthArray size do: [:each | widthArray at: each put: ((answers at: each) asNumber max: MinWidth) * scale].! !!Tables methodsFor: 'private'!columnInquiry	FillInTheBlank		request: 'How many columns?'		displayAt: Sensor cursorPoint		centered: true		action: [:answer | answer]		initialAnswer: 2 printString.	(answer == nil or: [(answer _ answer asNumber) < 1]) ifTrue: [^nil].	widthArray _ Array new: answer!compose: aText width: aWidth 	| lines lineIndex startIndex stopIndex aParagraph compositionScanner temp |	lines _ OrderedCollection new.	"maximumLine _ 10."	lineIndex _ 1.	startIndex _ 1.	stopIndex _ aText size.	aParagraph _ Paragraph withText: aText style: self class style.	compositionScanner _ TablesCompositionScanner new in: aParagraph.	["lineIndex > maximumLine |" (startIndex > stopIndex)]		whileFalse: 			[temp _ compositionScanner						composeLine: lineIndex						fromCharacterIndex: startIndex						inParagraph: aParagraph						width: aWidth.			lines add: temp.			startIndex _ temp last + 1.			lineIndex _ lineIndex + 1].	^lines!doText: theFieldCollection 	"It wil receive either string or text!!"	| temp max field aText theCollection tab cr |	tab _ Text string: (String with: Character tab) runs: (RunArray new: 1 withAll: FontIndex).	cr _ Text string: (String with: Character cr) runs: (RunArray new: 1 withAll: FontIndex).	theCollection _ theFieldCollection.	temp _ OrderedCollection new.	max _ 0.	1 to: theFieldCollection size do: 		[:i | 		field _ theCollection at: i.		temp add: (self compose: field width: (widthArray at: i) asInteger).		max _ max max: (temp at: i) size].	1 to: max do: 		[:j | 		1 to: theFieldCollection size do: 			[:i | 			j > (temp at: i) size				ifFalse: 					[aText _ (theFieldCollection at: i)								copyFrom: ((temp at: i)										at: j) first to: ((temp at: i)									at: j) last.					table _ table, aText].			i = theFieldCollection size ifFalse: [table _ table, tab]].		table _ table, cr]!format: aText 	| newText theCollection inStream end begin temp fieldCollection newStream element fields field t |	Cursor wait showWhile: [	newText _ self initialize: aText.	theCollection _ OrderedCollection new.	inStream _ ReadStream on: newText.	end _ field _ fields _ 0.	[inStream atEnd]		whileFalse: 			[begin _ end + 1.			newStream _ WriteStream on: (Text new: 64).			[inStream atEnd or: [(element _ inStream next) = delimiter | (element = Character tab)]]				whileFalse: [newStream nextPut: element].			temp _ newStream contents.			fields == 0 ifTrue: "still need to know how many fields there are"				[element = Character tab					ifTrue: [field _ field + 1]					ifFalse: [element = delimiter ifTrue: [fields _ field + 1]]].			inStream atEnd				ifTrue: [end _ inStream position + 1]				ifFalse: [end _ inStream position].			t _ end > begin				ifFalse: [Text new]				ifTrue:					[((newText at: end - 1) asciiValue = 13						ifTrue: [newText copyFrom: begin to: end - 2]						ifFalse: [newText copyFrom: begin to: end - 1])].			theCollection add: t].	fields = 0 ifFalse: [widthArray _ Array new: (field + 1 max: fields)]].	(self widthInquiry: #()) == nil ifTrue: [^nil].	Cursor execute showWhile: 		[1 to: theCollection size by: widthArray size do: 			[:i | 			fieldCollection _ OrderedCollection new.			i to: (i + widthArray size - 1 min: theCollection size)				do: [:j | fieldCollection add: (theCollection at: j)].			self doText: fieldCollection]].	^table!initialize: aText	table _ Text new.	delimiter == nil ifTrue: [delimiter _ Character cr].	(aText isKindOf: String)		ifTrue: [^Text string: aText runs: (RunArray new: aText size withAll: FontIndex)]		ifFalse: [^aText].!parse: aText 	| newText theCollection inStream end begin temp fieldCollection t |	widthArray == nil ifTrue: [(self widthInquiry: #()) == nil ifTrue: [^nil]].	newText _ self initialize: aText.	theCollection _ OrderedCollection new.	inStream _ ReadStream on: newText.	end _ 0.	[inStream atEnd]		whileFalse: 			[begin _ end + 1.			temp _ inStream upTo: delimiter.			inStream atEnd				ifTrue: [end _ inStream position + 1]				ifFalse: [end _ inStream position].			begin >= end ifFalse:				[t _ ((newText at: end - 1) asciiValue = 13					ifTrue: [newText copyFrom: begin to: end - 2]					ifFalse: [t _ newText copyFrom: begin to: end - 1]).				 theCollection add: t]].	1 to: theCollection size by: widthArray size do: 			[:i | 			fieldCollection _ OrderedCollection new.			i to: (i + widthArray size - 1 min: theCollection size)				do: [:j | fieldCollection add: (theCollection at: j)].			self doText: fieldCollection].	^table!widthsFromTabs: anArray	"anArray contains tabs in printer unit"	| prev x wArr | 	prev _ 0.	x _ PressOrInterpress == #Press ifTrue: [16608] ifFalse: [8304].	wArr _ anArray last >= x ifTrue: [Array new: anArray size] ifFalse: [Array new: anArray size + 1].	1 to: anArray size do: [:i |		wArr at: i put: ((anArray at: i) - prev).		prev _ anArray at: i].	wArr size > anArray size ifTrue: [wArr at: wArr size put: (x - prev)].	^wArr! !ClickBuffer comment:'Copyright (c) 1986 Xerox Corporation.  All rights reserved.'!!ClickBuffer methodsFor: 'accessing'!hasClick	^(lastClick == nil) not!lastClick	| thePoint | 	thePoint _ lastClick.	lastClick _ nil.	^thePoint!rememberClickAt: aPoint	lastClick _ aPoint! !PrintFont comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation.  All rights reserved.I mainly provide a set of widths of characters in the ASCII character set, corresponding to each width-file''s  name and point size.Instance Variables: xTable<Array>  Of left x-coordinate of character in virtual glyphs. Although there is no actual glyphis for PrintFont, the structure similar to the Strike Font is adopted. Imagine a set of printing Forms corresponding to characters in the ASCII character set.  All the forms are placed side by side in a large form(glyphis) whose height is the font height, and whose width is the sum of all the character widths.  The xTable gives the left-x coordinates of the subForms corresponding to the characters. stopConditions<Array>  Of selectors to be performed in scanning text. minAscii, maxAscii<Integer>  Giving range supported by this font. fontName<String>  Xerox standard name for this font. Here they are all pull out from their corresponding width file name. 			example:	If designated width file is ''Modern10b.width'', fontName is to be ''Modern-Bold''. fontSize<Integer>  Point size of this font.			example:	If designated width file is ''Modern10b.width'', fontSize is to be 10.'!!PrintFont methodsFor: 'accessing'!emphasis	^0!fontName	^fontName!fontSize	^fontSize!maxAscii	"Answer the integer that is the last Ascii character value of the receiver."	^maxAscii!minAscii	"Answer the integer that is the first Ascii character value of the receiver."	^minAscii!name	^fontName, fontSize printString!stopConditions	"Answer the array of selectors to be performed in scanning text made	up of the receiver's characters."	^stopConditions!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ (aCharacter asciiValue min: maxAscii) max: minAscii.	^(xTable at: ascii + 2) - (xTable at: ascii + 1)!xTable	^xTable! !!PrintFont methodsFor: 'private'!newFromWidth: fileName 	"Build an instance from the font width file. The '.width'  	extension is optional."	| name width i |	name _ (fileName copyUpTo: $.)				, '.'.	"assume extension (if any) is 'width'"	width _ FileStream oldFileNamed: name , 'width'.	width binary.	width readOnly.	"strip off directory name if any"	i _ name size.	[i > 0 and: [(name at: i)			~= $> & ((name at: i)				~= $])]]		whileTrue: [i _ i - 1].	name _ name copyFrom: i + 1 to: name size.	i _ 0.	[(name at: i + 1) isDigit]		whileFalse: [i _ i + 1].	fontName _ (name copyFrom: 1 to: i) asLowercase.	fontName at: 1 put: (name at: 1) asUppercase.	i _ i + 1.	fontSize _ (name at: i) digitValue.	[(name at: i + 1) isDigit]		whileTrue: 			[i _ i + 1.			fontSize _ fontSize * 10 + (name at: i) digitValue].	i _ i + 1.	[i > name size]		whileFalse: 			[(name at: i) asLowercase = $i ifTrue: [fontName _ fontName , '-Italic'].			(name at: i) asLowercase = $b ifTrue: [fontName _ fontName , '-Bold'].			i _ i + 1].	width nextWord.	"skip one word"	minAscii _ width nextWord.	maxAscii _ width nextWord.	xTable _ (Array new: maxAscii + 3)				atAllPut: 0.	(minAscii + 1 to: maxAscii + 3)		do: [:index | xTable at: index put: width nextWord // 2].	"scaling unit conversion from mica to 2 micas"	width close.	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	1 to: minAscii - 1 do: [:index | stopConditions at: index + 1 put: #characterNotInFont].	maxAscii + 1 to: stopConditions size - 1 do: [:index | stopConditions at: index + 1 put: #characterNotInFont].	minAscii to: maxAscii do: [:index | (self widthOf: index asCharacter)			= 0 ifTrue: [stopConditions at: index + 1 put: #characterNotInFont]]!setStopConditions	"This has to do with scanning characters, not with the font.  Make a clean set"	stopConditions _ Array new: 258.	1 to: minAscii - 1 do:		[:index | stopConditions at: index + 1 put: #characterNotInFont].	maxAscii + 1 to: stopConditions size - 1 do:		[:index | stopConditions at: index + 1 put: #characterNotInFont].	minAscii to: maxAscii do:		[:index |		(self widthOf: index asCharacter) = 0			ifTrue: [stopConditions at: index + 1 put: #characterNotInFont]]! !!PrintFont methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self class name, ' (', self fontName, self fontSize printString, ')'! !!PrintFont methodsFor: 'converting'!asPrinterWidthsFont	^self! !DisplayPrintFont comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!DisplayPrintFont methodsFor: 'accessing'!emphasis	^strikeFont emphasis!glyphs	^strikeFont glyphs!height	^strikeFont height!strikeFont	^strikeFont!strikeFont: aStrikeFont	strikeFont _ aStrikeFont! !!DisplayPrintFont methodsFor: 'font accessing'!widthFor: chAscii 	"Answer the width of the argument as a character in the receiver."	| ascii |	chAscii > maxAscii		ifTrue: [ascii _ maxAscii]		ifFalse: [chAscii < minAscii					ifTrue: [ascii _ minAscii] ifFalse: [ascii _ chAscii]]."	ascii _ (chAscii min: maxAscii) max: minAscii."	^(xTable at: ascii + 2) - (xTable at: ascii + 1)! !SharedDeque comment:'Copyright (c) 1983, 1984, 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!SharedDeque methodsFor: 'accessing'!addBlockFirst: aBlock	"add the new element at the front and signal waiters."	accessProtect critical:		[deque addFirst: aBlock fixTemps].	readSynch signal!addBlockLast: aBlock	"add the new element at the front and signal waiters."	accessProtect critical:		[deque addLast: aBlock fixTemps].	readSynch signal!addFirst: anObject	"add the new element at the front and signal waiters."	accessProtect critical:		[deque addFirst: anObject].	readSynch signal!addLast: anObject	"add the new element at the front and signal waiters."	accessProtect critical:		[deque addLast: anObject].	readSynch signal!at: index	| item |	accessProtect critical:		[item _ deque at: index].	^item!ifEmptyDo: aBlock	"if deque is empty then do aBlock"	accessProtect critical:		[deque isEmpty ifTrue: [aBlock value]]!removeFirst	"Insure that something is in the deque, then remove	the first element."	| aBlock |	readSynch wait.	accessProtect critical:		[aBlock _ deque removeFirst].	^aBlock!removeLast	"Insure that something is in the deque, then remove	the last element."	| aBlock |	readSynch wait.	accessProtect critical:		[aBlock _ deque removeLast].	^aBlock!removeObjectAt: aValidInteger	"Assume that there is at least aValidInteger items in the deque. Remove and return the aValidInteger'th element"	"go through the protection to keep the count correct"	| anObject |	readSynch wait.	accessProtect critical:		[anObject _ deque removeObjectAt: aValidInteger].	^anObject!size	| size | 	accessProtect critical:		[size _ deque size].	^size! !!SharedDeque methodsFor: 'initialize-release'!release	deque _ nil! !!SharedDeque methodsFor: 'private'!init: size	deque _ OrderedCollection new: size.	accessProtect _ Semaphore forMutualExclusion.	readSynch _ Semaphore new! !ConfigFile comment:'Copyright (c) 1987 Xerox Corporation. All rights reserved.fileStream	a MixedFileStream on a file.  The file format is any number of repetitions of:	sectionNameLength - the length of sectionName stored as one binary word	sectionName - stored as the characters of the symbol	dataLength - the length of the data stored as one binary word	data - dataLength bytes of datasectionLocator	an OopConservingDictionary with the section name symbols as keys, and the position in fileStream of the corresponding dataLength field as the values.compressable	a Boolean, indicates whether there are any redundant sections that could be compressed out of the file.CurrentUserConfig	an instance of ConfigFile for the current user'!!ConfigFile methodsFor: 'initialize/release'!close	fileStream close!convertFromOldConfigStyle	| fileName newFileStream sectionName defsLength sectionContents | 	fileName _ fileStream name.	newFileStream _ (MixedFileStream fileNamed: 'CNVRTXXX.TMP') readWrite text.	[fileStream atEnd] whileFalse:		[fileStream next = ${			ifTrue:				[sectionName _ fileStream upTo: $|.				 [fileStream peek = $|] whileFalse: [sectionName _ sectionName, (fileStream upTo: $|)].				 fileStream next. "eat |"				 defsLength _ Integer readFrom: fileStream.				 fileStream skipTo: Character cr.				 sectionContents _ fileStream next: defsLength.				 newFileStream nextWordPut: sectionName size; nextPutAll: sectionName.				 sectionLocator at: sectionName asSymbol put: newFileStream position.				 newFileStream nextWordPut: sectionContents size; nextPutAll: sectionContents]			ifFalse: [fileStream skipTo: Character cr]].	fileStream close.	newFileStream close.	Disk removeKey: fileName ifAbsent: [nil].	Disk renameKey: newFileStream name newName: fileName.	fileStream _ (MixedFileStream fileNamed: fileName) readOnly text!fileName	^(FileDirectory decomposeName: fileStream name) at: 'Name-Body'!initialize: fileName	| sectionName | 	sectionLocator _ OopConservingDictionary new.	compressable _ false.	fileStream _ (MixedFileStream fileNamed: fileName) readOnly text.	fileStream peek = ${		ifTrue: [self convertFromOldConfigStyle]		ifFalse:			[[fileStream atEnd] whileFalse:				[sectionName _ (fileStream next: fileStream nextWord) asSymbol.				(sectionLocator includesKey: sectionName) ifTrue: [compressable _ true].				sectionLocator at: sectionName put: fileStream position.				fileStream skip: fileStream nextWord]]!release	fileStream close.	sectionLocator release! !!ConfigFile methodsFor: 'reading/writing'!compressFile	"assume the sectionLocator is correct, and write the new file"	| sectionName newSectionLocator newFileStream fileName sectionContents |	compressable ifFalse: [^self].	Cursor execute showWhile: [	newSectionLocator _ OopConservingDictionary new.	fileName _ fileStream name.	newFileStream _ (MixedFileStream fileNamed: fileName, (String with: $$)) readWrite binary.	fileStream reopen; binary.	sectionLocator keysDo:		[:sectionName |		fileStream position: (sectionLocator at: sectionName).		sectionContents _ fileStream next: fileStream nextWord.		newFileStream text.		newFileStream nextWordPut: sectionName size; nextPutAll: sectionName.		newSectionLocator at: sectionName put: newFileStream position.		newFileStream binary.		newFileStream nextWordPut: sectionContents size; nextPutAll: sectionContents].	fileStream close.	newFileStream close.	Disk removeKey: fileName ifAbsent: [nil].	Disk renameKey: newFileStream name newName: fileName.	fileStream _ (MixedFileStream fileNamed: fileName) readOnly text.	sectionLocator _ newSectionLocator.	compressable _ false]!deleteSection: sectionName	"this is for cleaning up.  When the file is compressed after this, the section will truly be gone"	"ConfigFile currentUserConfig deleteSection: #timezones"	sectionLocator removeKey: sectionName ifAbsent: [sectionLocator removeKey: sectionName asLowercase asSymbol ifAbsent: []].	compressable _ true!getSection: sectionName	"return the contents of section sectionName as a String"	| sectionLoc contents | 	sectionLoc _ sectionLocator at: sectionName ifAbsent: [sectionLocator at: sectionName asLowercase asSymbol ifAbsent: [nil]].	sectionLoc == nil ifTrue: [^nil].	Cursor wait showWhile: [	fileStream reopen; text.	fileStream position: sectionLoc.	contents _ (fileStream next: fileStream nextWord)].	^contents!getSection: sectionName accordingToBlock: readBlock withArgs: readBlockArgs	"read section sectionName by using the value of readBlock with readBlockArgs as the first argument, the fileStream as the second argument, and the section length as the third argument. Return the result"	| sectionLoc contents | 	sectionLoc _ sectionLocator at: sectionName ifAbsent: [sectionLocator at: sectionName asLowercase asSymbol ifAbsent: [nil]].	sectionLoc == nil ifTrue: [^nil].	Cursor wait showWhile: [	fileStream reopen; position: sectionLoc.	contents _ readBlock value: readBlockArgs value: fileStream value: fileStream nextWord].	^contents!writeSection: sectionName accordingToBlock: writeBlock withArgs: writeBlockArgs	"a new section sectionName will be written to the file using the value of writeBlock (with writeBlockArgs as the first argument and the fileStream as the second argument) as the instructions for writing the actual data of the section.	return whatever value the writeBlock returns"	| startPos result endPos |	Cursor wait showWhile: [	fileStream reopen; readWrite; setToEnd.	fileStream nextWordPut: sectionName size; nextPutAll: sectionName.	(sectionLocator includesKey: sectionName) ifTrue: [compressable _ true].	sectionLocator at: sectionName put: (startPos _ fileStream position).	fileStream nextWordPut: 0. "place mark for now"	result _ writeBlock value: writeBlockArgs value: fileStream.	endPos _ fileStream position.	fileStream position: startPos.	fileStream nextWordPut: endPos - startPos - 2]. "startPos is word before data start"	^result!writeSection: sectionName with: aString	"write aString as the contents of section sectionName"	Cursor wait showWhile: [	fileStream reopen; readWrite; setToEnd.	fileStream text.	fileStream nextWordPut: sectionName size; nextPutAll: sectionName.	(sectionLocator includesKey: sectionName) ifTrue: [compressable _ true].	sectionLocator at: sectionName put: fileStream position.	fileStream nextWordPut: aString size; nextPutAll: aString]! !BoxView comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!BoxView methodsFor: 'accessing'!addBox: aRectangle	boxList add: aRectangle!borderFlag	^borderFlag!boxList	^boxList!boxList: anOrderedCollection	boxList _ anOrderedCollection!cancelBorders	"set the view to show borders for all of its elements"	borderFlag _ false!changeBoxAt: aSpot to: aRectangle	boxList at: aSpot put:aRectangle!font	^font!font: anInteger	font _ anInteger!form	^form!form: aForm	form _ aForm!labelList	^labelList!labelList: anOrderedCollection	labelList _ anOrderedCollection!map	^map!map: anObject	map _ anObject!mapChanged	^mapChanged!mapChanged: aBoolean	mapChanged _ aBoolean.!offsetPoint	^offsetPoint!offsetPoint: aPoint	offsetPoint _ aPoint!oldElement ^oldElement!oldElement: aNumber	oldElement _ aNumber!setBorders	"set the view to show borders for all of its elements"	borderFlag _ true!setSelectionFor: aPoint to: anObject 	"check aPoint to determine which box it lies in.  If the 	model at that box has a shape greater than 1 by 1, this 	routine will further calculate which internal box is being 	pointed at."	| rowIndex colIndex |	1 to: boxList size do: [:box | ((boxList at: box)			containsPoint: aPoint- (self insetDisplayBox origin))			ifTrue: [((model at: box)					isKindOf: Matrix)					ifTrue: 						[colIndex _ (aPoint x - ((boxList at: box) left + self insetDisplayBox origin x) / ((boxList at: box) width / (model at: box) xysize x)) asInteger + 1.						rowIndex _ (aPoint y - ((boxList at: box) top + self insetDisplayBox origin y) / ((boxList at: box) height / (model at: box) xysize y)) asInteger + 1.						(model at: box)							atRow: rowIndex column: colIndex put: anObject.						((model at: box)							atRow: rowIndex column: colIndex) changed]					ifFalse: [model at: box put: anObject.						(model at: box) changed]]].	^nil!xSize	^xSize!xSize: anInteger	xSize _ anInteger!ySize	^ySize!ySize: anInteger	ySize _ anInteger! !!BoxView methodsFor: 'displaying'!bound: aRectangle	"produce a boundary for a rectangle on the display"	Display fill: aRectangle  rule: Form reverse mask: Form black.		Display fill: (aRectangle origin + 1 extent: (aRectangle width - 2) @ (aRectangle height - 2)) rule: Form reverse mask: Form black.!deEmphasize: aRectangle	"deemphasize the selected rectangle on the display"	aRectangle == nil 		ifFalse:[Display fill: (aRectangle intersect: insetDisplayBox) rule: Form reverse mask: Form black]!displayEmphasized 	self displayView.!displayView	"this method displays all of the boxes and their contents in   	the prescribed area on the display"	| innerWidth innerHeight elementRect modelElem listElem modelElemSize baseOrigin baseCorner label mapFlag|	form == nil		ifTrue: 			[elementRect _ Rectangle new.			map == nil 				ifTrue:[map _ Form extent: (xSize max: insetDisplayBox extent x) // 10 + 1 @ ((xSize max: insetDisplayBox extent x) // 10 + 1).					mapFlag _ true]				ifFalse:[mapFlag _ false].			1 to: boxList size do: 				[:box | 				modelElem _ model at: box.				listElem _ boxList at: box.				label _ labelList at: box.				baseOrigin _ listElem origin + self insetDisplayBox origin + offsetPoint.				baseCorner _ listElem corner + self insetDisplayBox origin + offsetPoint.				map 					fill: (listElem origin // 10 extent: (listElem extent // 10)) 					rule: Form over 					mask: Form black.				elementRect origin: baseOrigin corner: baseCorner.				(elementRect intersects: insetDisplayBox)					ifTrue:[						borderFlag ifTrue: [self bound: (elementRect intersect: insetDisplayBox)].						label							displayOn: Display							at: (elementRect insetBy: 2 @ 2) origin							clippingBox: ((elementRect insetBy: 1 @ 1) intersect: insetDisplayBox)							rule: Form over							mask: Form black].			form _ Form fromDisplay: self insetDisplayBox]]		ifFalse: 			[form				displayOn: Display				at: self insetDisplayBox origin				clippingBox: self insetDisplayBox				rule: Form over				mask: Form black.]!doubleBound: aRectangle	"produce a boundary for a rectangle on the display"	Display fill: (aRectangle intersect: insetDisplayBox) rule: Form reverse mask: Form black.		Display fill: ((aRectangle origin + 2 extent: (aRectangle width - 4) @ (aRectangle height - 4)) intersect: insetDisplayBox) rule: Form reverse mask: Form black.!erase	form _ nil.	super clearInside.!scrollForm	| fullRectangle windowRectangle oldOffset savedForm |	fullRectangle _ ((0 @ 0 extent: (xSize max: insetDisplayBox extent x)					// 10 + 1 @ ((ySize max: insetDisplayBox extent y)						// 10 + 1)) expandBy: 4@4)				translateBy: insetDisplayBox origin + 4.	savedForm _ Form fromDisplay: fullRectangle.	windowRectangle _ 0 @ 0 extent: insetDisplayBox extent // 10 + 1. 	Display fill: fullRectangle rule: Form over mask: Form white.	map 		displayOn: Display		at: fullRectangle origin		clippingBox: fullRectangle		rule: Form over		mask: Form black.	self bound: fullRectangle.	self bound: (windowRectangle translateBy: offsetPoint // -10 + insetDisplayBox origin + 1).	oldOffset _ Sensor waitButton.	Sensor yellowButtonPressed | Sensor blueButtonPressed 		ifTrue:[savedForm displayOn: Display at: fullRectangle origin.			^nil].	[Sensor redButtonPressed]		whileTrue: 			[oldOffset _ offsetPoint.			offsetPoint _ Sensor cursorPoint - insetDisplayBox origin + 2 * -10.			offsetPoint x: ((offsetPoint x min: 0)					max: -40 - (xSize max: insetDisplayBox extent x) + insetDisplayBox width).			offsetPoint y: ((offsetPoint y min: 0)					max: -40 - (ySize max: insetDisplayBox extent y) + insetDisplayBox height).			self bound: (windowRectangle translateBy: oldOffset // -10 + insetDisplayBox origin + 1).			self bound: (windowRectangle translateBy: offsetPoint // -10 + insetDisplayBox origin + 1)].	savedForm displayOn: Display at: fullRectangle origin.	Cursor wait		showWhile: 			[self erase.			"MessageTally spyOn:["			self displayView			"]"]!update: selection inRectangle: elementRect	"redisplay the box with the updated contents"	| baseOrigin baseCorner selectionSize innerWidth innerHeight|	baseOrigin _ elementRect origin.	baseCorner _ elementRect corner.	selection		displayOn: Display		at: elementRect origin		clippingBox: insetDisplayBox		rule: Form over		mask: Form black.! !!BoxView methodsFor: 'selecting'!getBoxFor: aPoint 	"check aPoint to determine which box it lies in.  If the  	model at that box has a shape greater than 1 by 1, this  	routine will further calculate which internal box is being  	pointed at."	| rowIndex colIndex innerWidth innerHeight baseOrigin baseCorner boxListElem modelElem modelElemSize dispOrigin listSize adjustedBox|	dispOrigin _ self insetDisplayBox origin.	listSize _ boxList size.	1 to: listSize do: [:box | adjustedBox _ (box + oldElement -1) \\ listSize.		adjustedBox = 0 ifTrue: [adjustedBox _ listSize].		boxListElem _ boxList at: adjustedBox.		modelElem _ model at: adjustedBox.		(boxListElem			containsPoint: aPoint -dispOrigin - offsetPoint)			ifTrue: 				[baseOrigin _ boxListElem origin + dispOrigin.				baseCorner _ boxListElem corner + dispOrigin.				(modelElem					isKindOf: Matrix)					ifTrue: 						[modelElemSize _ modelElem xysize.						colIndex _ (aPoint x - (boxListElem left + dispOrigin x) 								// (boxListElem width // modelElemSize x)) + 1.						rowIndex _ (aPoint y - (boxListElem top + dispOrigin y) 								// (boxListElem height // modelElemSize y)) + 1.						innerWidth _ (boxListElem width // modelElemSize x).						innerHeight _ (boxListElem height // modelElemSize y).						oldElement _ adjustedBox.						^(Rectangle new 								origin: baseOrigin + (innerWidth * (colIndex - 1) 										@ (innerHeight * (rowIndex - 1))) 								corner: baseOrigin + (innerWidth * colIndex @ (innerHeight * rowIndex)))]					ifFalse: [oldElement _ adjustedBox.							^Rectangle new origin: baseOrigin corner: baseCorner]]].	oldElement _ 0.	 ^nil!getFormFor: aPoint 	"check aPoint to determine which box it lies in.  If the 	model at that box has a shape greater than 1 by 1, this 	routine will further calculate which internal box is being 	pointed at."	| rowIndex colIndex modelElem boxListElem dispOrigin modelElemSize listSize adjustedBox label |	dispOrigin _ self insetDisplayBox origin.	listSize _ boxList size.	1 to: listSize do: [:box |adjustedBox _ (box + oldElement -1) \\ listSize.		adjustedBox = 0 ifTrue: [adjustedBox _ listSize].		boxListElem _ boxList at: adjustedBox.		modelElem _ model at: adjustedBox.		label _ labelList at: adjustedBox.		(boxListElem			containsPoint: aPoint - dispOrigin - offsetPoint)			ifTrue: [(modelElem					isKindOf: Matrix)					ifTrue: 						[modelElemSize _ modelElem xysize.						colIndex _ (aPoint x - (boxListElem left + dispOrigin x) // (boxListElem width // modelElemSize x))  + 1.						rowIndex _ (aPoint y - (boxListElem top + dispOrigin y) // (boxListElem height // modelElemSize y))  + 1.						oldElement _ adjustedBox.						^label							atRow: rowIndex column: colIndex]					ifFalse: [oldElement _ adjustedBox.						^label]]].	^nil!getSelectionFor: aPoint 	"check aPoint to determine which box it lies in.  If the 	model at that box has a shape greater than 1 by 1, this 	routine will further calculate which internal box is being 	pointed at."	| rowIndex colIndex modelElem boxListElem dispOrigin modelElemSize listSize adjustedBox |	dispOrigin _ self insetDisplayBox origin.	listSize _ boxList size.	1 to: listSize do: [:box |adjustedBox _ (box + oldElement -1) \\ listSize.		adjustedBox = 0 ifTrue: [adjustedBox _ listSize].		boxListElem _ boxList at: adjustedBox.		modelElem _ model at: adjustedBox.		(boxListElem			containsPoint: aPoint - dispOrigin - offsetPoint)			ifTrue: [(modelElem					isKindOf: Matrix)					ifTrue: 						[modelElemSize _ modelElem xysize.						colIndex _ (aPoint x - (boxListElem left + dispOrigin x) // (boxListElem width // modelElemSize x))  + 1.						rowIndex _ (aPoint y - (boxListElem top + dispOrigin y) // (boxListElem height // modelElemSize y))  + 1.						oldElement _ adjustedBox.						^modelElem							atRow: rowIndex column: colIndex]					ifFalse: [oldElement _ adjustedBox.						^model at: adjustedBox]]].	^nil! !DBoxView comment:'Copyright (c) Xerox Corporation, 1984, 1985, 1986, 1987. All rights reserved.'!!DBoxView methodsFor: 'updating'!deselectMe: modelAti	modelAti deselected.	self updateMeAndMyAssociates: modelAti!pertains: linkByArray"see whether the selection states are as described by linkByArray"	linkByArray do: [:j | j > 0		ifTrue: [(model at: j) isSelected ifFalse: [^ false]]		ifFalse: [(model at: 0 - j) isSelected ifTrue: [^ false]]].	^ true!selectMe: modelAti	modelAti selected.	self updateMeAndMyAssociates: modelAti!shouldIBeDisabled: modelAti by: anIndex	^ true!shouldIBeDisabled: modelAti bypass: anIndex	modelAti linkBy do: [:arr | (self pertains: arr) ifTrue: [^ false]].	^ true!shouldIBeEnabled: modelAti by: anIndex	modelAti linkBy do: [:arr |		(arr includes: anIndex)			ifTrue: [(self pertains: arr) ifFalse: [^ false]]].	^ true!shouldIBeEnabled: modelAti bypass: anIndex	modelAti linkBy do: [:arr | (self pertains: arr)  ifFalse: [^ false]].	 ^ true!updateGroup: anInterval	"anInterval should be an interval within the boxList. The color of the boxes will change to reflect the state of the boxes."	anInterval do: [:i | self updateMeAndMyAssociates: (model at: i)]!updateMeAndMyAssociates: modelAti	|  modelAtj thisIndex wasSelected | 	"Change the color of the boxes to reflect the state of the boxes."	thisIndex _ model indexOf: modelAti.	modelAti linkTo do: [:j |		modelAtj _ model at: j abs.		wasSelected _ modelAtj isSelected.		j > 0 ifTrue: [modelAti isSelected						ifTrue: [(self shouldIBeEnabled: modelAtj by: thisIndex)									ifTrue: [self colorNormalAt: j. modelAtj enable]									ifFalse: [self colorGrayAt: j. modelAtj disable]]						ifFalse: [(self shouldIBeDisabled: modelAtj bypass: thisIndex)									ifTrue: [self colorGrayAt: j. modelAtj disable]									ifFalse: [self colorNormalAt: j. modelAtj enable]]]			ifFalse: [modelAti isSelected						ifTrue: [(self shouldIBeDisabled: modelAtj by: thisIndex)									ifTrue: [self colorGrayAt: (0 - j). modelAtj disable]									ifFalse: [self colorNormalAt: (0 - j). modelAtj enable]]						ifFalse: [(self shouldIBeEnabled: modelAtj bypass: thisIndex)									ifTrue: [self colorNormalAt: (0- j). modelAtj enable]									ifFalse: [self colorGrayAt: (0 - j). modelAtj disable]]].		self updateMeAndMyAssociates: modelAtj]! !!DBoxView methodsFor: 'utilities'!boxIndexContains: aPoint 	"Answers the box in which aPoint lies. "	| aBox pt |	pt _ aPoint translateBy: (0 - self insetDisplayBox origin).	1 to: boxList size do: 		[:i | ((boxList at: i) containsPoint: pt) ifTrue: [^i]].	^0!getAnswer	"Answer an array of updated values of the variables"		| answer last col |	last _ (model at: 1) group last + 2.	answer _ OrderedCollection new.	[last > model size] whileFalse: 		[col _ OrderedCollection new.  		(model at: last) group do: 			[:i | ((model at: i) enabled and: [(model at: i) variable ~~ nil])					ifTrue: [col add: (model at: i) variable]].		col isEmpty			ifTrue: [answer add: nil]			ifFalse: [(col size > 1 or: [(model at: last) type == #multipleSelect])						ifTrue: [answer add: col asArray]						ifFalse: [answer add: (((col at: 1) sameAs: 'nil') ifTrue: [nil] ifFalse: [col at: 1])]].		last _ (model at: last) group last +2].	^answer!getBoxIndexed: anIndex 	"Answers the box in which aPoint lies. "	oldElement _ anIndex.	^(anIndex > 0 and: [anIndex <= boxList size])		ifTrue: [(boxList at: anIndex) translateBy: (self insetDisplayBox origin)]		ifFalse: [oldElement _ 0. nil]! !!DBoxView methodsFor: 'box construction'!addExecute: commands at: aPoint autoAccept: aBoolean	"Add a set of execute boxes to the boxList and a set of	execute elements to the model of self. Return the total width of the command strings"	| group execWidth w pt |	execWidth _ 0.	pt _ aPoint.	group _ Interval from: 1 to: commands size.	commands do: [:s |		model add: (DBox type: #execute description: s variable: aBoolean group: group query: nil).		boxList add:			(Rectangle new origin: pt 				extent: (w _ (MyCharacterScanner widthOfString: s emphasis: EmphasisFontNum) +15)@20).		execWidth _ execWidth + w.		pt _ boxList last topRight].	^execWidth + w!addFill: aStringCollection type: aType default: default at: aPoint from: anInteger messageWidth: messageWidth selectionWidth: selectionWidth height: height	"Add a set of input boxes to the boxList and a set ofinput elements to the model of self."	| anInterval temp |	temp _ default.	default == nil ifTrue: [temp _ String new].	aType = #paragraph ifTrue: [temp _ temp asText].	anInterval _ Interval from: anInteger to: anInteger.	model add: (DBox type: nil description: (aStringCollection at: 1) 		variable: nil group:nil query: nil);	add: (DBox type: aType description: temp 		variable: temp group: anInterval query: nil).	boxList add: (Rectangle new origin: aPoint+(0@0) 		extent: messageWidth@height);	add: (Rectangle new origin: (boxList last topRight) extent:selectionWidth@height)!addMultiple: aStringCollection default: default at: aPoint from: anInteger messageWidth: messageWidth selectionWidth: selectionWidth height: height	"Add a multiple choice type to the model and boxList"	| anInterval | 	anInterval _ Interval from: anInteger to: anInteger.	model add: (DBox type: nil description: (aStringCollection at: 1) 		variable: nil group:nil query: nil);	add: (DBox type: #multiple description: default 		variable: nil group: anInterval query:(DBoxQuerier new initializeWithFields: default)).	boxList add: (Rectangle new origin: aPoint+(0@0) 		extent: messageWidth@height);	add: (Rectangle new origin: (boxList last topRight) 		extent: selectionWidth@height)!addSelect: aStringCollection default: default at: aPoint from: anInteger messageWidth: messageWidth selectionWidth: selectionWidth height: height type: aSymbol	"Add a set of selection boxes to the boxList and a set of selection elements 	to the model."	| anInterval size aString w noPerRow averageWidth rows totalHeight index origin upperBound pt rightBound defaultCol |	size _ aStringCollection size.	w _ 0.	2 to: size		do: [:i | w _ w max: (MyCharacterScanner widthOfString: (aStringCollection at: i) emphasis: EmphasisFontNum)].	noPerRow _ (selectionWidth // (w + 10)) min: (size - 1).	averageWidth _ selectionWidth // noPerRow.	rows _ size - 2 // noPerRow + 1.	totalHeight _ height * rows.	anInterval _ Interval from: anInteger to: (anInteger+size-2).	model add: (DBox new description: (aStringCollection at: 1)).	defaultCol _ default.	((default isKindOf: Array) or: [default isKindOf: OrderedCollection])		ifFalse: [defaultCol _ Array with: default].	2 to: size do:	[:i | aString _ aStringCollection at: i.		model add: (DBox type: aSymbol description: aString						variable: ((defaultCol includes: aString) ifTrue: [aString] ifFalse: [nil])						group: anInterval query: nil)].	boxList add: (aPoint copy extent: messageWidth@totalHeight).	origin _ boxList last topRight.	upperBound _ anInterval size.	index _ 0.	rightBound _ aPoint x + messageWidth + selectionWidth.	1 to: rows do: [:ithRow |		pt _ origin x @ (origin y + ((ithRow - 1)*height)).		1 to: noPerRow - 1 do:		 	[:i | index _ index + 1.				index > upperBound					ifFalse: [boxList add: (pt extent: averageWidth@height).							pt _ boxList last topRight]].		index _ index + 1.		index > upperBound			ifFalse: [ (pt x+ averageWidth - rightBound) abs <= noPerRow						ifTrue: [boxList add: (pt corner: rightBound@(pt y + height))]						ifFalse: [boxList add: (pt extent: averageWidth@height)]]]!linkBy: linkCollection	"Elements of linkCollection is a collection of: (ith@jth kth@lth mth@-nth ... rth@sth). First element is the effectee and the rest elements are the effectors. Indicating the jth element in the ith group is linked by <the lth element in the kth group> and <the nth element in the mth group> and <...> etc"		| ith hostGroup thisElement element thisIndex nextIndex col |	linkCollection do: [:arr |		ith _ 1.		hostGroup _ arr first x.		hostGroup timesRepeat: [ith _ (model at: ith) group last +2].		thisElement _ model at: (thisIndex _ ith + (arr first y) - 1).		col _ OrderedCollection new.		2 to: arr size do: [:index |	 		element _ arr at: index.			ith _ 1.			element x timesRepeat: [ith _ (model at: ith) group last + 2].			nextIndex _ ith + element y abs - 1.			col add: (element y > 0 ifTrue: [nextIndex] ifFalse: [nextIndex negated]).			(model at: nextIndex) addLinkTo: (element y > 0 ifTrue: [thisIndex] ifFalse: [thisIndex negated])].		thisElement addLinkBy: col asArray]!linkTo: linkCollection	"Elements of linkCollection is a collection of: (ith@jth kth@lth mth@-nth ... rth@sth). First element is the effector and the rest elements are the effectees. Indicating the jth element in the ith group is linked to <the lth element in the kth group>, <the nth element in the mth group> etc"		| ith hostGroup thisElement element thisIndex nextIndex |	linkCollection do: [:arr |		ith _ 1.		hostGroup _ arr first x.		hostGroup timesRepeat: [ith _ (model at: ith) group last +2].		thisElement _ model at: (thisIndex _ ith + (arr first y) - 1).		2 to: arr size do: [:index |	 		element _ arr at: index.			ith _ 1.			element x timesRepeat: [ith _ (model at: ith) group last + 2].			nextIndex _ ith + element y abs - 1.			thisElement addLinkTo: (element y > 0 ifTrue: [nextIndex] ifFalse: [nextIndex negated]).			(model at: nextIndex) addLinkBy: (Array with: (element y > 0 ifTrue: [thisIndex] ifFalse: [thisIndex negated]))]]! !!DBoxView methodsFor: 'displaying'!colorGrayAt: anIndex	| aBox modelAti | 	"Reverse the color of aBox"	aBox _ ((boxList at: anIndex) translateBy: self insetDisplayBox origin) insetBy: 2@2.	modelAti _ model at: anIndex.	modelAti enabled		ifTrue: [((modelAti type == #select or: [modelAti type == #multipleSelect]) and: [modelAti variable ~= nil])					ifTrue: [Display fill: aBox								rule: Form reverse								mask: Form black].				Display fill: aBox						rule: Form reverse						mask: Form lightGray].	^aBox!colorNormalAt: anIndex	| aBox modelAti | 	"Reverse the color of aBox"	aBox _ ((boxList at: anIndex) translateBy: self insetDisplayBox origin) insetBy: 2@2.	modelAti _ model at: anIndex.	modelAti enabled		ifFalse: [Display fill: aBox						rule: Form reverse						mask: Form lightGray.				((modelAti type == #select or: [modelAti type == #multipleSelect]) and: [modelAti variable ~= nil])					ifTrue: [Display fill: aBox									rule: Form reverse									mask: Form black]].	^aBox!colorReverseBoxIndexed: anIndex	| aBox | 	"Reverse the color of aBox"	aBox _ ((boxList at: anIndex) translateBy: self insetDisplayBox origin) insetBy: 2@2.	Display fill: aBox		rule: Form reverse		mask: Form black.	^aBox!displayView	"Displays all the boxes in the boxList and descriptions of the model."	| rectangle modelAti type cachedBitBlt rectangleExtent cachedForm bitBltToReverse listSize textOffset boxOffset tempX tempY destOrigin i passOne |"MessageTally spyOn: ["		self displayBorder.	textOffset _ (boxOffset _ insetDisplayBox origin) + (6@0).	bitBltToReverse _ BitBlt new		mask: Form black;		combinationRule: Form reverse;		sourceX: 0; sourceY: 0;		clipX: 0; clipY: 0;		clipWidth: (tempX _ insetDisplayBox width);		clipHeight: (tempY _ insetDisplayBox height).	cachedBitBlt _ BitBlt new		destForm: Display;		combinationRule: Form over;		sourceX: 0; sourceY: 0;		clipX: 0; clipY: 0;		clipWidth: tempX + boxOffset x;		clipHeight: tempY + boxOffset y.	(title == nil or: [title isEmpty]) ifFalse:		[MyCharacterScanner			displayString: title			emphasis: EmphasisFontNum			on: Display			at: (insetDisplayBox width - (MyCharacterScanner widthOfString: title emphasis: EmphasisFontNum) // 2) @ 0 + boxOffset			clippingBox: insetDisplayBox].	tempX _ nil.	i _ 0.	passOne _ true.	listSize _ boxList size.	[[listSize >= (i _ i + 2)] whileTrue: 		[(rectangleExtent _ (rectangle _ boxList at: i) extent) x = tempX & (rectangleExtent y = tempY) ifFalse:			[bitBltToReverse				destForm: (cachedForm _ Form extent: rectangleExtent);				destX: 0; destY: 0;				width: (tempX _ rectangleExtent x);				height: (tempY _ rectangleExtent y);				copyBits;				destX: 1; destY: 1;				width: tempX - 2;				height: tempY - 2;				copyBits.			cachedBitBlt				sourceForm: cachedForm;				width: tempX;				height: tempY].		cachedBitBlt destOrigin: rectangle origin + boxOffset; copyBits.		type _ (modelAti _ model at: i) type.		(#(#select #execute #multipleSelect) includes: type)			ifTrue: [destOrigin _ rectangle origin + boxOffset + ((rectangle width - (MyCharacterScanner widthOfString: modelAti description emphasis: EmphasisFontNum))//2@0).					MyCharacterScanner					displayString: modelAti description					emphasis: EmphasisFontNum					on: Display					at: destOrigin					clippingBox: (destOrigin extent: (rectangle extent - (4@0))).					(type = #execute or: [modelAti variable == nil])						ifFalse: [Display								fill: ((rectangle translateBy: boxOffset) insetBy: 2)								rule: Form reverse								mask: Form black]]			ifFalse: [(type == #password or: [type == #multiple]) ifFalse:						[type = #paragraph							ifTrue: 								[MyCharacterScanner									displayText: modelAti description									on: Display									at: (destOrigin _ rectangle origin + textOffset)									clippingBox: (destOrigin extent: (rectangle extent - (4@0)))]							ifFalse:								[MyCharacterScanner									displayString: modelAti description									emphasis: (type = nil ifTrue: [EmphasisFontNum] ifFalse: [1])									on: Display									at: (destOrigin _ rectangle origin + textOffset)									clippingBox: (destOrigin extent: (rectangle extent - (4@0)))]]]].	passOne] whileTrue: [i _ -1. passOne _ false]."	] to: 'exmpl-displayView-919-1915-15.spy'	"!displayWidth: width height: height	"Translate and display the view so that its insetDisplayBox is completely inside the screen boundingBox."	self window: (Rectangle new origin:0@0 extent: width@height)		viewport: (Rectangle new origin: Sensor cursorPoint extent: width@height);		translateBy: (self displayBox amountToTranslateWithin: Display boundingBox);		form: (Form fromDisplay: self displayBox);		displayView;		resetView!resetView	"reset view."		| last aGroup aBag |	last _ 1.	aBag _ Bag new.	[last _ (model at: last) group last +2.	last < model size] whileTrue:		[aGroup _ (model at: last) group.		self updateGroup: aGroup].! !!DBoxView methodsFor: 'accessing'!answerArray	^ answerArray!answerArray: anOrderedCollection	answerArray _ anOrderedCollection!title: aString	title _ aString! !ConnectedBoxView comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!ConnectedBoxView methodsFor: 'accessing'!addBox: aRectangle	| anotherRow |	boxList add: aRectangle.	connections addNode!addConnectionFrom: anInteger to: anotherInteger	"add a connection"	connections connect: anInteger to: anotherInteger!connections	^connections!connections: anOrderedCollection	connections _ anOrderedCollection.!makesACircularityWith: anInteger from: theOriginalElement	"makes a check by looking forwards through all the hierarchy.  This will never terminate if the network being searched is not a tree."	| aBoolean |	anInteger = theOriginalElement ifTrue:[^true].	(connections atPoint: anInteger @ theOriginalElement) = 1		ifTrue:[^true]		ifFalse:[1 to: connections size do: [:each |			(connections atPoint: anInteger @ each) = 1				ifTrue:[aBoolean _ self makesACircularityWith: each from: theOriginalElement.					aBoolean ifTrue:[^true]]]].	^false!removeConnectionFrom: anInteger to: anotherInteger	"remove a connection"	connections disconnect: anInteger from: anotherInteger! !!ConnectedBoxView methodsFor: 'displaying'!displayView	"this method displays all of the boxes and their contents in   	the prescribed area on the display"	| innerWidth innerHeight elementRect modelElem listElem modelElemSize baseOrigin baseCorner label theBlt |	form == nil		ifTrue: 			[elementRect _ Rectangle new.			theBlt _ BitBlt				destForm: Display				sourceForm: (Form extent: 1@1) black				halftoneForm: Form black				combinationRule: Form over				destOrigin: 0@0				sourceOrigin: 0 @ 0				extent: 1@1				clipRect: insetDisplayBox.			mapChanged 				ifTrue:[map _ Form extent: (xSize max: insetDisplayBox extent x) // 10 + 1 @ ((xSize max: insetDisplayBox extent x) // 10 + 1)].			1 to: boxList size do: 				[:box | 				modelElem _ model at: box.				listElem _ boxList at: box.				label _ labelList at: box.				baseOrigin _ listElem origin + self insetDisplayBox origin + offsetPoint.				baseCorner _ listElem corner + self insetDisplayBox origin + offsetPoint.				mapChanged ifTrue:[map fill: (listElem origin // 10 extent: (listElem extent // 10)) rule: Form over mask: Form black].				"model element is a single entity, use it 				directly "				elementRect origin: baseOrigin corner: baseCorner.				(elementRect intersects: insetDisplayBox)					ifTrue:[						label							displayOn: Display							at: baseOrigin							clippingBox: insetDisplayBox							rule: Form over							mask: Form black.						self drawConnectionsFrom: box blt: theBlt flag: mapChanged]].			mapChanged _ false.			form _ Form fromDisplay: self insetDisplayBox]		ifFalse: 			[form				displayOn: Display				at: self insetDisplayBox origin				clippingBox: self insetDisplayBox				rule: Form over				mask: Form black.]!drawArrowFrom: beginPoint to: endPoint withBlt: blt flag: flag 	"draw a vector and arrowhead"	| y x r midPoint vect1 vect2 midx midy |	self		drawLineFrom: beginPoint		to: endPoint		withBlt: blt		flag: flag.	y _ endPoint y - beginPoint y.	x _ endPoint x - beginPoint x.	r _ (x * x + (y * y)) sqrt rounded.	midx _ beginPoint x + (x / 2) rounded.	midy _ beginPoint y + (y / 2) rounded.	midPoint _ midx @ midy.	vect1 _ midx + (-6 * x - (3 * y) quo: r) @ (midy + (-6 * y + (3 * x) quo: r)).	self		drawVectorFrom: vect1		to: midPoint		withBlt: blt		flag: flag.	vect2 _ midx + (-6 * x - (-3 * y) quo: r) @ (midy + (-6 * y + (-3 * x) quo: r)).	self		drawVectorFrom: vect2		to: midPoint		withBlt: blt		flag: flag!drawConnectionFrom: aRectangle to: anotherRectangle	"draw an appropriate connection from one rectangle to another on the form"	| offset theBlt |	theBlt _ BitBlt		destForm: Display		sourceForm: nil		halftoneForm: nil		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: 0 @ 0		extent: 1@1		clipRect: insetDisplayBox. 	self drawConnectionFrom: aRectangle to: anotherRectangle blt: theBlt flag: true!drawConnectionFrom: aRectangle to: anotherRectangle blt: theBlt flag: theFlag 	"draw an appropriate connection from one rectangle to another on the blt"	| offset beginPoint endPoint deltX deltY trueOffset |	offset _ insetDisplayBox origin.	trueOffset _ offset + offsetPoint.	(((aRectangle merge: anotherRectangle) translateBy: trueOffset) intersects: insetDisplayBox) ifFalse:[^nil].	aRectangle right < anotherRectangle left		ifTrue: 			[beginPoint _ aRectangle rightCenter + trueOffset.			endPoint _ anotherRectangle leftCenter + trueOffset.			self				drawFasterArrowFrom: beginPoint				to: endPoint				withBlt: theBlt				flag: theFlag.			^true].	anotherRectangle right < aRectangle left		ifTrue: 			[endPoint _ anotherRectangle rightCenter + trueOffset.			beginPoint _ aRectangle leftCenter + trueOffset.			self				drawFasterArrowFrom: beginPoint				to: endPoint				withBlt: theBlt				flag: theFlag.			^true].	aRectangle top < anotherRectangle bottom		ifTrue: 			[endPoint _ anotherRectangle topCenter + trueOffset.			beginPoint _ aRectangle bottomCenter + trueOffset.			self				drawFasterArrowFrom: beginPoint				to: endPoint				withBlt: theBlt				flag: theFlag.			^true].	beginPoint _ aRectangle topCenter + trueOffset.	endPoint _ anotherRectangle bottomCenter + trueOffset.		self			drawFasterArrowFrom: beginPoint			to: endPoint			withBlt: theBlt			flag: theFlag.	^true!drawConnectionsFrom: theBox blt: theBlt flag: theFlag	"Draw all of the set connections for a given box"	| theCol |	theCol _(connections at: theBox ifAbsent: [OopConservingDictionary new]). 	theCol keysDo:		[:each | (theCol at: each) > 0 ifTrue:[self drawConnectionFrom: (boxList at: theBox) to: (boxList at: each) blt: theBlt flag: theFlag]]!drawConnectionsOn: theBox 	"Draw all of the set connections for a given box"	| theBlt thisCol thisBox links |	(connections includesKey: theBox) ifFalse: [^self].	theBlt _ BitBlt				destForm: Display				sourceForm: nil				halftoneForm: nil				combinationRule: Form over				destOrigin: 0 @ 0				sourceOrigin: 0 @ 0				extent: 1 @ 1				clipRect: insetDisplayBox.	(links _ connections at: theBox) keysDo: [:each | 		(links at: each) >= 1			ifTrue: [self					drawConnectionFrom: (boxList at: theBox)					to: (boxList at: each)					blt: theBlt					flag: true]			ifFalse: [self					drawConnectionFrom: (boxList at: each)					to: (boxList at: theBox)					blt: theBlt					flag: true]]!drawFastArrowFrom: beginPoint to: endPoint withBlt: blt flag: flag 	"draw a vector and arrowhead"	| r midPoint vect1 vect2 theta phi1 phi2 |	theta _ (beginPoint - endPoint) theta.	phi1 _ theta + 0.5.	phi2 _ theta - 0.5.	midPoint _ beginPoint + endPoint // 2.	vect1 _ midPoint + ((phi1 cos  * 6.0) truncated @ (phi1 sin * 6.0) truncated).	vect2 _ midPoint + ((phi2 cos  * 6.0) truncated @ (phi2 sin * 6.0) truncated).	self		drawVectorFrom: beginPoint		to: endPoint		withBlt: blt		flag: flag.	self		drawVectorFrom: vect1		to: midPoint		withBlt: blt		flag: flag.	self		drawVectorFrom: vect2		to: midPoint		withBlt: blt		flag: flag!drawFasterArrowFrom: beginPoint to: endPoint withBlt: blt flag: flag 	"draw a vector and arrowhead"	| y yDir x xDir midPoint vect1 vect2 ratio |	self		drawLineFrom: beginPoint		to: endPoint		withBlt: blt		flag: flag.	y _ endPoint y - beginPoint y.	x _ endPoint x - beginPoint x.	xDir _ x sign.	xDir = 0 ifTrue:[xDir _ 1].	yDir _ y sign.	yDir = 0 ifTrue:[yDir _ 1].	x = 0 ifTrue:[ratio _ 99999] ifFalse:[ratio _y abs asFloat / x abs asFloat].	ratio < (0.25)		ifTrue:			[vect1 _ -3 * xDir @ (-3 * yDir).			vect2 _ -3 * xDir @ (3 * yDir)].		(ratio >= (0.25) and:[ratio < (0.75)])		ifTrue:			[vect1 _ -3 * xDir @ (-4 * yDir).			vect2 _ -4 * xDir @ (3 * yDir)].		(ratio >= (0.75) and:[ratio < (1.3333)])		ifTrue:			[vect1 _ -5 * xDir @ 0.			vect2 _0 @ (-5 * yDir)].		(ratio >= (1.3333) and:[ratio < 4.0])		ifTrue:			[vect1 _ -4 * xDir @ (-3 * yDir).			vect2 _ 3 * xDir @ (-4 * yDir)].		ratio >= 4.0		ifTrue:			[vect1 _ -3 * xDir @ (-3 * yDir).			vect2 _ 3 * xDir @ (-3 * yDir)].		midPoint _ beginPoint + endPoint // 2.	self		drawVectorFrom: midPoint + vect1		to: midPoint		withBlt: blt		flag: flag.	self		drawVectorFrom: midPoint + vect2		to: midPoint		withBlt: blt		flag: flag!drawLineFrom: beginPoint to: endPoint withBlt: theBlt flag: theFlag 	| mapBegin mapEnd |	(((beginPoint x min: endPoint x)		@ (beginPoint y min: endPoint y) extent: ((endPoint- beginPoint) abs + 1))				intersects: insetDisplayBox)		ifTrue: 			[theBlt destForm: Display.			theBlt destOrigin: beginPoint.			theBlt clipRect: insetDisplayBox.			theBlt drawLoopX: endPoint x - beginPoint x Y: endPoint y - beginPoint y].	theFlag		ifTrue: 			[mapBegin _ beginPoint - insetDisplayBox origin - offsetPoint // 10.			mapEnd _ endPoint - insetDisplayBox origin - offsetPoint // 10.			theBlt destForm: map.			theBlt destOrigin: mapBegin.			theBlt clipRect: (0 @ 0 extent: map width @ map height).			theBlt drawLoopX: mapEnd x - mapBegin x Y: mapEnd y - mapBegin y]!drawVectorFrom: beginPoint to: endPoint withBlt: theBlt flag: theFlag 	| mapBegin mapEnd |	theBlt destForm: Display.	theBlt destOrigin: beginPoint.	theBlt clipRect: insetDisplayBox.	theBlt drawLoopX: endPoint x - beginPoint x Y: endPoint y - beginPoint y!eraseConnectionFrom: aRectangle to: anotherRectangle	"draw an appropriate connection from one rectangle to another on the form"	| offset theBlt |	theBlt _ BitBlt		destForm: Display		sourceForm: nil		halftoneForm: nil		combinationRule: Form erase		destOrigin: 0@0		sourceOrigin: 0 @ 0		extent: 1@1		clipRect: insetDisplayBox. 	self drawConnectionFrom: aRectangle to: anotherRectangle blt: theBlt flag: true!eraseConnectionsOn: theBox	"Draw all of the set connections for a given box"	| theBlt links |	(connections includesKey: theBox) ifFalse: [^self].	theBlt _ BitBlt		destForm: Display		sourceForm: nil		halftoneForm: nil		combinationRule: Form erase		destOrigin: 0@0		sourceOrigin: 0 @ 0		extent: 1@1		clipRect: insetDisplayBox.	(links _ connections at: theBox) keysDo: [:each | 		(links at: each) > 1			ifTrue: [self					drawConnectionFrom: (boxList at: theBox)					to: (boxList at: each)					blt: theBlt					flag: true]			ifFalse: [self					drawConnectionFrom: (boxList at: each)					to: (boxList at: theBox)					blt: theBlt					flag: true]]! !InfoCenterGraphView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!InfoCenterGraphView methodsFor: 'initialize-release'!release	ContainerModel removeDependent: self.	super release.! !!InfoCenterGraphView methodsFor: 'accessing'!addBox: aRectangle label: aString	| anotherRow |	boxList add: aRectangle.	connections addNode.	infoCentLabelList add: aString!center	^center!center: anInfoCenter	center _ anInfoCenter!centerName	^center name!hasChanged: aBoolean	hasChanged _ aBoolean!infoCentLabelList	^infoCentLabelList!infoCentLabelList: anObject	infoCentLabelList _ anObject!linkType	^linkType!linkType: anObject	linkType _ anObject!orientation: aSymbol	orientation _ aSymbol! !!InfoCenterGraphView methodsFor: 'displaying'!deEmphasize: aRectangle	"deemphasize the selected rectangle on the display"	aRectangle = nil 		ifFalse:[Display fill: (aRectangle intersect: insetDisplayBox) rule: Form reverse mask: Form black]!displayView	"this method displays all of the boxes and their contents in   	the prescribed area on the display"	| innerWidth innerHeight elementRect modelElem listElem modelElemSize baseOrigin baseCorner aBoxModel theBlt |	hasChanged ifTrue:		[self resetDisplay].	theBlt _ BitBlt		destForm: Display		sourceForm: nil		halftoneForm: nil		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: 0 @ 0		extent: 1@1		clipRect: insetDisplayBox.	mapChanged 		ifTrue:[map _ Form extent: (xSize max: insetDisplayBox extent x) // 10 + 1 @ ((ySize max: insetDisplayBox extent y) // 10 + 1)].	"form = nil		ifTrue: 			["elementRect _ Rectangle new.			1 to: boxList size do: 				[:box | 				modelElem _ model at: box.				listElem _ boxList at: box.				baseOrigin _ listElem origin + self insetDisplayBox origin + offsetPoint.				baseCorner _ listElem corner + self insetDisplayBox origin + offsetPoint.				elementRect origin: baseOrigin corner: baseCorner.				mapChanged 					ifTrue:[						map fill: (listElem origin // 10 extent: (listElem extent // 10)) 							rule: Form over 							mask: Form black].				(elementRect intersects: insetDisplayBox)					ifTrue:[(labelList at: box)						displayOn: Display						at: elementRect  origin						clippingBox: insetDisplayBox						rule: Form under						mask: Form black].			self drawConnectionsFrom: box blt: theBlt flag: mapChanged].			"form _ Form fromDisplay: self insetDisplayBox]		ifFalse: 			[form				displayOn: Display				at: self insetDisplayBox origin				clippingBox: self insetDisplayBox				rule: Form over				mask: Form black.]".	mapChanged _ false!drawConnectionFrom: aRectangle to: anotherRectangle blt: theBlt flag: theFlag 	"draw an appropriate connection from one rectangle to another on the blt"	| offset beginPoint endPoint deltX deltY trueOffset |	offset _ insetDisplayBox origin.	trueOffset _ offset + offsetPoint.	(((aRectangle merge: anotherRectangle)		translateBy: trueOffset)		intersects: insetDisplayBox)		ifFalse: [^nil].	orientation = #vertical		ifTrue: 			[aRectangle right < anotherRectangle left				ifTrue: 					[beginPoint _ aRectangle rightCenter + trueOffset.					endPoint _ anotherRectangle leftCenter + trueOffset.					self						drawFasterArrowFrom: beginPoint						to: endPoint						withBlt: theBlt						flag: theFlag.					^true].			anotherRectangle right < aRectangle left				ifTrue: 					[endPoint _ anotherRectangle rightCenter + trueOffset.					beginPoint _ aRectangle leftCenter + trueOffset.					self						drawFasterArrowFrom: beginPoint						to: endPoint						withBlt: theBlt						flag: theFlag.					^true].			aRectangle top < anotherRectangle bottom				ifTrue: 					[endPoint _ anotherRectangle topCenter + trueOffset.					beginPoint _ aRectangle bottomCenter + trueOffset.					self						drawFasterArrowFrom: beginPoint						to: endPoint						withBlt: theBlt						flag: theFlag.					^true].			beginPoint _ aRectangle topCenter + trueOffset.			endPoint _ anotherRectangle bottomCenter + trueOffset.			self				drawFasterArrowFrom: beginPoint				to: endPoint				withBlt: theBlt				flag: theFlag.			^true]		ifFalse: 			[nil.			aRectangle top < anotherRectangle bottom				ifTrue: 					[endPoint _ anotherRectangle topCenter + trueOffset.					beginPoint _ aRectangle bottomCenter + trueOffset.					self						drawFasterArrowFrom: beginPoint						to: endPoint						withBlt: theBlt						flag: theFlag.					^true].			anotherRectangle top < aRectangle bottom				ifTrue: 					[beginPoint _ aRectangle topCenter + trueOffset.					endPoint _ anotherRectangle bottomCenter + trueOffset.					self						drawFasterArrowFrom: beginPoint						to: endPoint						withBlt: theBlt						flag: theFlag.					^true].			aRectangle right < anotherRectangle left				ifTrue: 					[beginPoint _ aRectangle rightCenter + trueOffset.					endPoint _ anotherRectangle leftCenter + trueOffset.					self						drawFasterArrowFrom: beginPoint						to: endPoint						withBlt: theBlt						flag: theFlag.					^true].			endPoint _ anotherRectangle rightCenter + trueOffset.			beginPoint _ aRectangle leftCenter + trueOffset.			self				drawFasterArrowFrom: beginPoint				to: endPoint				withBlt: theBlt				flag: theFlag.			^true]!resetDisplay	"set up the display once again, since data has changed"	| maxClass theNewKey theForm theRealForm aBoxModel |	hasChanged _ false.	controller deselect.	Display		fill: insetDisplayBox		rule: Form under		mask: Form lightGray.	theForm _ 'Recomputing...' asForm.	infoCentLabelList _ OrderedCollection new.	theRealForm _ Form extent: theForm extent + 10.	theForm displayOn: theRealForm at: 5 @ 0.	theRealForm borderWidth: 2.	theRealForm displayOn: Display at: insetDisplayBox center - (theRealForm extent // 2).	boxList _ OrderedCollection new.	labelList _ OrderedCollection new.	aBoxModel _ OrderedCollection new.	connections _ AdjacencyMatrix new.	center clearFlags.	orientation == #vertical		ifTrue: [self class				setUpViewForElement: (model at: 1)				followingForward: (linkType at: 1)				backward: (linkType at: 2)				inCenter: center				with: 10				and: 10				in: self				on: aBoxModel				connectTo: 0]		ifFalse: [self class				setAcrossViewForElement: (model at: 1)				followingForward: (linkType at: 1)				backward: (linkType at: 2)				inCenter: center				with: 10				and: 10				in: self				on: aBoxModel				connectTo: 0].	self model: aBoxModel.	self topView classifyLabel: (model at: 1).	self topView displayClassification.	hasChanged _ false.	Display		fill: insetDisplayBox		rule: Form over		mask: Form white.	form _ nil! !!InfoCenterGraphView methodsFor: 'updating'!update: aSymbol 	(aSymbol == #all)		ifTrue: [hasChanged _ true].	(aSymbol isKindOf: DataItem)		ifTrue: [(model includes: aSymbol) ifTrue: [hasChanged _ true]]! !LabelSwitchView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!LabelSwitchView methodsFor: 'initialize-release'!initialize	super initialize.	insideColor _ Form white!release	model release.	model _ nil.	super release! !!LabelSwitchView methodsFor: 'accessing'!label	^model label!selector	^model selector! !!LabelSwitchView methodsFor: 'controller access'!defaultControllerClass	^LabelSwitchController! !!LabelSwitchView methodsFor: 'window access'!defaultWindow	| default |	default _ 0@0.	model labels do: [:label |		default _ default max: label boundingBox corner].	^(0@0 corner: default) expandBy: 6! !!LabelSwitchView methodsFor: 'displaying'!displayView	self clearInside.	model label		displayOn: Display		transformation: self displayTransformation		clippingBox: self insetDisplayBox		align: model label boundingBox center		with: self getWindow center		rule: Form over		mask: Form black! !!LabelSwitchView methodsFor: 'updating'!update: aParameter	self display! !PreviewTabView comment:'Copyright (c) Xerox Corporation, 1986, 1987. All rights reserved.'!!PreviewTabView methodsFor: 'controller access'!defaultControllerClass	^PreviewTabController! !!PreviewTabView methodsFor: 'displaying'!createTabs	"tabs is in micas units. rulerUnit is either inch or centimeters or picas."	| origin pos cachedBitBlt roundTo basicUnit w tabNo rect aTabBar newForm |	newForm _ Form extent: viewport extent x @ 70.	cachedBitBlt _ (Rulers at: unitIndex) copy.	cachedBitBlt destForm: newForm.	cachedBitBlt		clipX: 0; clipY: 0;		clipWidth: viewport width;		clipHeight: 70;		destOrigin: 0@0; copyBits.	origin _ 6@52.	basicUnit _ #(72 28 12 1) at: unitIndex.	roundTo _ #(0.01 0.1 0.1 1) at: unitIndex.	w _ window width - 6.	1 to: tabs size do: [:i |		(pos _ (tabs at: i)//scale) > w ifTrue: [^true].		(aTabBar _ (TabBarArray at: (tabTypes at: i)) copy) destForm: newForm.		aTabBar destOrigin: (origin x+ pos @ origin y + TabCursor offset); copyBits.		"tabNo _ (pos/basicUnit roundTo: roundTo) printString.		rect _ self tabNoRect: tabNo at: pos.		MyCharacterScanner			destOrigin: rect origin;			clipRect: self insetDisplayBox;			quickDisplayString: tabNo"].	^newForm!display	Display white: viewport.	self displayTabs.	self displayTabSelection!displayTabs	"tabs is in micas units. rulerUnit is either inch or centimeters or picas."	| origin pos cachedBitBlt roundTo basicUnit w tabNo rect aTabBar | 	cachedBitBlt _ Rulers at: unitIndex.	cachedBitBlt		clipX: viewport left; clipY: viewport top;		clipWidth: viewport width;		clipHeight: viewport height;		destOrigin: viewport origin; copyBits.	origin _ viewport origin + (6@52).	basicUnit _ #(72 28 12 1) at: unitIndex.	roundTo _ #(0.01 0.1 0.1 1) at: unitIndex.	w _ window width - 6.	1 to: tabs size do: [:i |		(pos _ (tabs at: i)//scale) > w ifTrue: [^true].		aTabBar _ TabBarArray at: (tabTypes at: i).		aTabBar destOrigin: (origin x+ pos @ origin y + TabCursor offset); copyBits.		tabNo _ (pos/basicUnit roundTo: roundTo) printString.		rect _ self tabNoRect: tabNo at: pos.		MyCharacterScanner			displayString: tabNo			emphasis: 1			on: Display			at: rect origin			clippingBox: self insetDisplayBox].	^true!displayTabSelection	| origin w h rect bitBltToReverse cachedForm cachedBitBlt choices | 	rect _ self tabSelectRect.	origin _ rect origin.	w _ rect width.	h _ rect height.	rect _ origin extent: w@h.	bitBltToReverse _ BitBlt new		mask: Form black;		combinationRule: Form reverse;		sourceX: 0; sourceY: 0;		clipX: 0; clipY: 0;		clipWidth: self insetDisplayBox width;		clipHeight: insetDisplayBox height;		destForm: (cachedForm _ Form extent: rect extent);		destX: 0; destY: 0;		width: w; height: h;		copyBits;		destX: 1; destY: 1;		width: w - 2; height: h - 2;		copyBits.	cachedBitBlt _ BitBlt new		destForm: Display;		combinationRule: Form over;		sourceX: 0; sourceY: 0;		clipX: viewport left; clipY: viewport top;		clipWidth: viewport width;		clipHeight: viewport height;		sourceForm: cachedForm;		width: w; height: h.	(choices _ #('Left' 'Center' 'Right' 'Decimal')) do: [:title |		cachedBitBlt destOrigin: rect origin; copyBits.		MyCharacterScanner			displayString: title			emphasis: 1			on: Display			at: ((w - (MyCharacterScanner widthOfString: title emphasis: 1) // 2) @ 0) + rect origin			clippingBox: insetDisplayBox.		TabIndex = (choices indexOf: title)			ifTrue: [Display						fill: (rect insetBy: 1)						rule: Form reverse						mask: Form black].		rect _ rect origin +(w@0) extent: rect extent]! !!PreviewTabView methodsFor: 'accessing'!returnTabs	^returnTabs!returnTabs: anArray	returnTabs _ anArray!scale: aScale	scale _ aScale!tabCursor	^TabCursor!tabs	^tabs!tabs: anArray	tabs _ anArray!tabSelectRect	^viewport origin + (0@98) extent: 60@20!tabTypes: anArray	tabTypes _ anArray!unitIndex: anInteger	unitIndex _ anInteger! !!PreviewTabView methodsFor: 'tab manipulation'!displayTabAt: aPoint	"tabs is in micas units. rulerUnit is either inch or centimeters or picas."	| aTab |  	aTab _ aPoint x - (viewport origin x + 6).	self displayTabPositionOf: aTab.	self setTabAt: aTab * scale!displayTabPositionOf: aTab	"display the numerical tab position of aTab"	| rect tabNo |  	tabNo _ self numericalTabPositionAt: aTab.	tabNo == nil ifTrue: [^self].	tabNo _ tabNo printString.	rect _ self tabNoRect: tabNo at: aTab.	MyCharacterScanner		displayString: tabNo		emphasis: 1		on: Display		at: rect origin		clippingBox: self insetDisplayBox.	TabBar destOrigin: (viewport origin x + 6 + aTab @ (viewport top + 52) + TabCursor offset); copyBits.!eraseTab: someTab	"tabs is in micas units. rulerUnit is either inch or centimeters or picas."	| origin rect1 rect2 tabNo aTab rect anIndex |  	origin _ viewport origin + (6@52).	tabNo _ self numericalTabPositionAt: (aTab _ someTab//scale).	tabNo == nil ifTrue: [^self].	rect1 _ (origin x+ aTab @ origin y + TabCursor offset) extent: 16@12.	"TabBar extent"	rect2 _ self tabNoRect: tabNo printString at: aTab.	rect _ rect1 merge: rect2.	Display fill: rect rule: Form over mask: Form white."	Display fill: rect rule: Form reverse mask: Form black.	Display fill: rect rule: Form erase mask: Form black."	anIndex _ tabs indexOf: someTab.	anIndex > 1		ifTrue: [self refreshTabPositionOf: anIndex - 1].	anIndex < tabs size		ifTrue: [self refreshTabPositionOf: anIndex + 1].	tabs _ tabs copyWithout: someTab.	tabTypes _ (tabTypes copyFrom: 1 to: anIndex - 1), (tabTypes copyFrom: anIndex + 1 to: tabTypes size)!highlightTab: someTab	"highlight tab indexed anIndex"	| origin rect1 rect2 tabNo aTab |  	tabNo _ self numericalTabPositionAt: (aTab _ someTab//scale).	tabNo == nil ifTrue: [^self].	origin _ viewport origin + (6@52).	rect1 _ (origin x+ aTab @ origin y + TabCursor offset) extent: 16@12.	"TabBar extent"	rect2 _ self tabNoRect: tabNo printString at: aTab.	Display fill: (rect1 merge: rect2) rule: Form reverse mask: Form black.!numericalTabPositionAt: aTab	"return the numerical value of aTab"	| basicUnit roundTo |  	(aTab > (window width - 6)	or: [aTab < 0]) ifTrue: [^nil].	basicUnit _ #(72 28 12 1) at: unitIndex.	roundTo _ #(0.01 0.1 0.1 1) at: unitIndex.	^aTab/basicUnit roundTo: roundTo!refreshTabPositionOf: anIndex	"display the numerical tab position of aTab"	| rect tabNo aTab |  	aTab _ (tabs at: anIndex)//scale.	tabNo _ self numericalTabPositionAt: aTab.	tabNo == nil ifTrue: [^self].	tabNo _ tabNo printString.	rect _ self tabNoRect: tabNo at: aTab.	MyCharacterScanner		displayString: tabNo		emphasis: 1		on: Display		at: rect origin		clippingBox: self insetDisplayBox.	(TabBarArray at: (tabTypes at: anIndex))		destOrigin: (viewport origin x + 6 + aTab @ (viewport top + 52) + TabCursor offset); copyBits.!selectTab: anIndex	| rect origin | 	anIndex = TabIndex ifTrue: [^self].	rect _ self tabSelectRect.	origin _ rect origin.	TabIndex - 1 timesRepeat:		[origin _ origin + (rect width@0)].	Display fill: ((origin extent: rect extent) insetBy: 1@1) rule: Form reverse mask: Form black.	TabIndex _ anIndex.	TabBar _ TabBarArray at: TabIndex.	TabCursor _ TabCursorArray at: TabIndex.	origin _ rect origin.	TabIndex - 1 timesRepeat:		[origin _ origin + (rect width@0)].	Display fill: ((origin extent: rect extent) insetBy: 1@1) rule: Form reverse mask: Form black.!setTabAt: aTab	"adding tab to tabs."	| newTabs newTabTypes someTab |  	(aTab < 0 or: [aTab//scale > (window width - 6)])		ifTrue: [^self].	newTabs _ OrderedCollection new: tabs size + 1.	newTabTypes _ OrderedCollection new: tabs size + 1.	1 to: tabs size		do: [:i | (someTab _ tabs at: i) < aTab				ifTrue: [newTabs add: someTab.						newTabTypes add: (tabTypes at: i)]].	newTabs add: aTab.	newTabTypes add: TabIndex.	1 to: tabs size		do: [:i | (someTab _ tabs at: i) > aTab				ifTrue: [newTabs add: someTab.						newTabTypes add: (tabTypes at: i)]].	tabs _ newTabs asArray.	tabTypes _ newTabTypes asArray!showTabPositionAt: aPoint	"display the numerical tab position at aPoint"	| aTab rect savedForm tabNo |  	aPoint == nil ifTrue: [^self].	aTab _ aPoint x - (viewport origin x + 6).	tabNo _ self numericalTabPositionAt: aTab.	tabNo == nil ifTrue: [^self].	tabNo _ tabNo printString.	rect _ self tabNoRect: tabNo at: aTab.	savedForm _ Form fromDisplay: rect.	MyCharacterScanner		displayString: tabNo		emphasis: 1		on: Display		at: rect origin		clippingBox: self insetDisplayBox.	(Delay forMilliseconds: 100) wait.	Display fill: rect rule: Form erase mask: Form black.	savedForm displayOn: Display at: rect origin.!tabAt: aPoint	| aTab s i | 	aTab _ (aPoint x - (viewport origin x + 6)) * scale.	s _ tabs size.	s = 0 ifTrue: [^nil].	i _ 1.	[i <= s and: [(tabs at: i) < aTab]]		whileTrue: [i _ i + 1].	i > s ifTrue: [i _ s].	((tabs at: i) - aTab) abs //scale <= 5		ifTrue: [^(tabs at: i)]		ifFalse: [i > 1 ifTrue: [i _ i - 1.							((tabs at: i) - aTab) abs //scale <= 5 ifTrue: [^(tabs at: i)]].				^nil]!tabNoRect: tabNoString at: aTab	"returns the composition rectangle of tabNoString positioned at aTab relative to viewport"	| origin destOrg width |  	width _ MyCharacterScanner widthOfString: tabNoString emphasis: 1.	origin _ viewport origin + (6@52).	destOrg _ origin x+ aTab @ origin y + TabCursor offset.	^ (destOrg + (7@16) - ((width // 2) @ 0)) extent: width@19!updateTabs	returnTabs _ Array with: tabs with: tabTypes!updateTabs: stat	returnTabs _ Array with: tabs with: tabTypes with: stat! !!PreviewTabView methodsFor: 'testing'!tabSelectionAt: aPoint	| origin rect | 	rect _ self tabSelectRect.	origin _ rect origin.	1 to: 4 do: [:i |		(rect containsPoint: aPoint) ifTrue: [^i].		rect _ rect origin + (rect width@0) extent: rect extent].	^0! !!StringHolderView methodsFor: 'initialize-release'!initialize	super initialize.	displayContents _ BigParagraph withText: Text new.	self insideColor: Form white! !!StringHolderView methodsFor: 'updating'!updateRequest	^ model isUnlocked or: 			[(self confirm: self topView label , '''s contents have not been saved.  Are youcertain that you want to close?')				ifTrue: [model unlock. ^true]				ifFalse: [^false]]! !!StringHolderView methodsFor: 'controller access'!defaultControllerClass	^BigStringHolderController! !!StringHolderView methodsFor: 'model access'!editString: aString 	"The paragraph to be displayed is created from the characters in aString."	(self controller isKindOf: BigParagraphEditor)		ifTrue:			[displayContents _ BigParagraph				withText: aString asText				style: TextStyle default copy				compositionRectangle: (self insetDisplayBox insetBy: self paragraphInset)				clippingRectangle: self insetDisplayBox]		ifFalse:			[displayContents _ Paragraph				withText: aString asText				style: TextStyle default copy				compositionRectangle: (self insetDisplayBox insetBy: self paragraphInset)				clippingRectangle: self insetDisplayBox].	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]! !StructureView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!StructureView methodsFor: 'updating'!update: aSymbol	| firstItem |  	(aSymbol == #all)		ifTrue:[hasChanged _ true].	(aSymbol isKindOf: DataItem)		ifTrue:[(controller indexCollection includes: aSymbol centerIndex)			ifTrue:[hasChanged _ true]]! !!StructureView methodsFor: 'model access'!centerName	^model centerName!displayView	| returnArray | 	hasChanged		ifTrue:[Cursor execute show.			returnArray _ model updateStructureText.			displayContents _ returnArray at: 1.			controller changeParagraph: displayContents.			controller indexCollection: (returnArray at: 2).			self positionDisplayContents.			hasChanged _ false.			superView classifyLabel = model folder classification ifFalse: 					[superView classifyLabel: model folder.					superView displayClassification]].	Cursor normal show.	super displayView.	controller displaySelected!editString: aString 	"The paragraph to be displayed is created from the characters in aString."	displayContents _ StructureParagraph				withText: aString asText				style: TextStyle default copy				compositionRectangle: (self insetDisplayBox insetBy: self paragraphInset)				clippingRectangle: self insetDisplayBox.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]!hasChanged: aBoolean	^hasChanged _ aBoolean!release	ContainerModel removeDependent: self.	super release.! !FieldStringView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.I am a type of StringHolderView that displays a FieldParagraph.  Since FieldParagraphsneed more information than regular Paragraphs, the instance variable <contents> hasa different usage.  It is assumed to be either nil, implying empty contents, or an Array of two elements.  The first element is either nil (empty contents) or a collection ofStrings/Symbols representing the names of the protected fields.  (These fields willbe displayed in boldface, one per line, padded with tabs to make the entries line up.)The second element is a collection of Strings which are the contents of the fields.FieldStringView needs more than just a StringHolderController; a DBTextController (in XSIS-DataBase) will do just fine.'!!FieldStringView methodsFor: 'initialize-release'!initialize	"first 4 lines should be same as View>>initialize"	self resetSubViews.	transformation _ WindowingTransformation identity.	self borderWidth: 0.	self borderColor: Form black.	displayContents _ FieldParagraph withText: Text new.	self insideColor: Form white! !!FieldStringView methodsFor: 'controller access'!defaultControllerClass	^ DBTextController! !!FieldStringView methodsFor: 'model access'!editContents: contents	"The FieldParagraph to be displayed is created from the values in contents.	I assume that <contents> is either nil, or an OrderedCollection with two elements."	(contents isNil or: [contents first isNil])	ifTrue:		[displayContents _ FieldParagraph			withText: Text new			style: TextStyle default copy			compositionRectangle:				(self insetDisplayBox insetBy: self paragraphInset)			clippingRectangle: self insetDisplayBox ]	ifFalse:		[displayContents _ FieldParagraph			withFields: contents first  values: contents last			emphasis: 2			style: TextStyle default copy			compositionRectangle:				(self insetDisplayBox insetBy: self paragraphInset)			clippingRectangle: self insetDisplayBox ].	(self controller isKindOf: ParagraphEditor)		  ifTrue:				[controller changeParagraph: displayContents.				controller initialText: contents]!editString: aString	(aString isKindOf: String) ifTrue:		[self shouldNotImplement].	self editContents: aString.!model: aLockedModel	super model: aLockedModel.	self editContents: self getContents!update: aSymbol 	aSymbol == #hitSelectionChanged		ifTrue: 			[controller classification: model recordClassif. 			classView model contents: controller classification displayString.			classView updateDisplayContents.			self updateDisplayContents.			^self].	aSymbol == #classifChanged		ifTrue: 			[classView model contents: controller classification displayString.			classView updateDisplayContents.			^self].!updateClassification 	classView model contents: controller classification displayString.	classView updateDisplayContents!updateDisplayContents	"Make the paragraph correspond to the contents of the receiver's model."	| contents |	contents _ self getContents.	controller classification: model selectedRecordClassification.	self updateClassification.	(contents isNil or: [displayContents valueList ~= contents last])		ifTrue: 			[self editContents: contents.			self displayView]! !!FieldStringView methodsFor: 'view access'!classView	^classView!classView: aView	classView _ aView! !AutoBookTextView comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!AutoBookTextView methodsFor: 'updating'!update: aSymbol	self updateDisplayContents! !PreviewPageView comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!PreviewPageView methodsFor: 'initialize-release'!setPreview: aSuitcase	self model: aSuitcase controller: controller.	displayContents _ PreviewPage newFrom: aSuitcase.	displayContents retrieve"; initializeFirstPage".! !!PreviewPageView methodsFor: 'controller access'!defaultControllerClass	"My controller is a PreviewPageController."	^ PreviewPageController! !!PreviewPageView methodsFor: 'model access'!updateRequest	| temp theModel |	theModel _ controller paragraph.	(controller isUnlocked and: [model dataItem centerIndex ~= 0])		ifTrue: 			[^theModel release]		ifFalse: 			[temp _ self confirm: 'Contents have not been saved!!Do you really want to close ' , self topView label , (String with: $?).			^temp and: [theModel restoreThenRelease]]! !!PreviewPageView methodsFor: 'displaying'!deEmphasize	super deEmphasize.	self saveForm!display	self displayBorder.	displayContents setRect: self insetDisplayBox.	savedForm == nil		ifTrue: 			[self displayView.			self displaySubViews]		ifFalse: 			[savedForm displayAt: self insetDisplayBox origin].	self controller recomputeSelection!saveForm	savedForm == nil		ifTrue: [savedForm _ Form new extent: self insetDisplayBox extent].	savedForm		copyBits: self insetDisplayBox		from: Display		at: 0 @ 0		clippingBox: Display boundingBox		rule: Form over		mask: Form black!updateTopView	superView classifyLabel ~= superView suitcase classification classAndWords		ifTrue:			[superView classifyLabel: superView suitcase classification.			superView displayClassification].	superView label ~= superView suitcase dataItem label		ifTrue:			[self saveForm.			superView erase.			superView label: superView suitcase dataItem label.			superView display]! !QuerierView comment:'Copyright (c) Xerox Corporation, 1985, 1986.  All rights reserved.I am a specialized StringHolderView, although, due to the miracle of cut-and-paste, I look much like a FillInTheBlankView.I build a DisplayTextView for the title, a QuerierView for the string entry, and a View with a BinaryChoiceController to contain them.Apart from instance creation, I behave almost exactly like a StringHolderView.'!!QuerierView methodsFor: 'controller access'!defaultController	"Return to the standard version as implemented in View."	^self defaultControllerClass new!defaultControllerClass	^QuerierController! !!FillInTheBlankView methodsFor: 'controller access'!editString: aString linegrid: linegrid baseline: baseline	"The paragraph to be displayed is created from the characters in aString. "	| style |	style _ TextStyle default copy.	linegrid == nil ifFalse: [style lineGrid: linegrid].	linegrid == nil ifFalse: [style baseline: baseline].	displayContents _ Paragraph				withText: aString asText				style: style				compositionRectangle: (self insetDisplayBox insetBy: self paragraphInset)				clippingRectangle: self insetDisplayBox.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]!initialize	super initialize.	displayContents _ Paragraph withText: Text new! !RS232TextView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!RS232TextView methodsFor: 'various'!defaultControllerClass	^RS232Controller!display	(model transmitState)		ifTrue:			[self displayBorder.			model checkWindowLocation]		ifFalse: [super display]!editString: aString 	"The paragraph to be displayed is created from the characters in aString. "	| textStyle |	textStyle _ TextStyle default copy.	textStyle lineGrid: RS232DisplayMem height; baseline: RS232DisplayMem height - 4.	displayContents _ BigParagraph				withText: aString asText				style: textStyle				compositionRectangle: (self insetDisplayBox insetBy: self paragraphInset)				clippingRectangle: self insetDisplayBox.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]! !!FormHolderView methodsFor: 'displaying'!updateRequest	^controller fieldThis! !MapView comment:'Copyright (c) 1983, 1984 Xerox Corporation.  All Rights Reserved.'!!MapView methodsFor: 'lock access'!unlock	self isUnlocked ifTrue: [^self].	super unlock.	latLonDisplayTransformation _ nil! !!MapView methodsFor: 'display transformation'!inverseLatLonDisplayTransform: anObject 	"Answer a point that is obtained from anObject by applying to it the inverse of the	receiver's lat-lon display transformation.  It is typically used by the Controller of the	receiver in order to convert a point in display coordinates, such as the cursor point,	to latitude-longitude coordinates."	^self latLonDisplayTransformation applyInverseTo: anObject!latLonDisplayTransform: anObject 	"Apply the lat-lon display transformation of the receiver to anObject (see 	View|latLonDisplayTransformation) and answer the resulting scaled, translated 	object. It is normally applied to Rectangles, Points, and other objects with 	coordinates defined in the latitude-longitude coordinate system in order to get a 	corresponding object in display coordinates."	^(self latLonDisplayTransformation applyTo: anObject) rounded!latLonDisplayTransformation	"Answer a WindowingTransformation that transforms objects in the 	latitude-longitude coordinate system into objects in the display screen	coordinate system. "	latLonDisplayTransformation == nil		ifTrue: [latLonDisplayTransformation _ self computeLatLonDisplayTransformation].	^latLonDisplayTransformation! !!MapView methodsFor: 'updating'!update: anObject	anObject = #latLonBox		ifTrue: [latLonDisplayTransformation _ nil]		ifFalse: [^super update: anObject]! !!MapView methodsFor: 'private'!computeLatLonDisplayTransformation	"Returns a WindowingTransformation that transforms the latitude-longitude	coordinate system into that of the display screen.	It is sent by MapView|latLonDisplayTransformation when the MapView is	unlocked (see MapView|unlock)."	^WindowingTransformation window: (model latLonBox bottomLeft corner: model latLonBox topRight) viewport: self insetDisplayBox! !MessageView comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987. All rights reserved.'!!MessageView methodsFor: 'As yet unclassified'!contents: aString	displayContents _ aString!displayView	Display fill: insetDisplayBox rule: Form over mask: Form white.	myCharacterScanner		displayString: displayContents		emphasis: myEmphasis		on: Display		at: insetDisplayBox origin + (3@1)		clippingBox: insetDisplayBox!updateDisplayTo: aString	displayContents _ aString.	self displayView!withEmphasis: emphasis	myCharacterScanner _ FastTextDisplayScanner new.	myEmphasis _ emphasis.	displayContents _ String new! !SpreadsheetView comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!SpreadsheetView methodsFor: 'initialize-release'!release	Cursor wait		showWhile: 			[model release.			model _ nil.			super release]! !!SpreadsheetView methodsFor: 'accessing'!form	^form!form: aForm	^form _ aForm!offsetPoint	^offsetPoint!offsetPoint: aPoint	offsetPoint _ aPoint!scrollMap	scrollMap == nil		ifTrue: 			[scrollMap _ Form extent: (model xGrid at: model xGrid size)							@ (model yGrid at: model yGrid size) // 15.			scrollMap borderWidth: 2].	^scrollMap!scrollMap: aForm	scrollMap _ aForm! !!SpreadsheetView methodsFor: 'displaying'!displayEmphasized 	self displayView.!displayView	"this method displays all of the boxes and their contents in  	the prescribed area on the display"	| allRows allCols |	form == nil		ifTrue:			[self erase.			allRows _ self rowsToDisplay.			allCols _ self columnsToDisplay.			self blacken: ((allCols x @ allRows x) corner: (allCols y @ allRows y)).			self displayArrows.			self displayColumnAxis.			self displayRowAxis.			self displayLines.			allCols x to: allCols y do: [:column |				allRows x to: allRows y do: [:row |					(model atRow: row column: column) displayAt: (column @ row)]]]		ifFalse:			[form extent = self insetDisplayBox extent				ifTrue: [form displayOn: Display				at: self insetDisplayBox origin				clippingBox: self insetDisplayBox]				ifFalse: 					[form_nil.					^self displayView]].	model cellsToUpdate size = 0 		ifFalse:[model displayUpdates].	self setHighlight: highlitPoint! !!SpreadsheetView methodsFor: 'deEmphasizing'!deEmphasizeView	self flipHighlight: highlitPoint.	self setForm! !!SpreadsheetView methodsFor: 'scrolling'!columnsToDisplay	"return a point containing the starting column displayed in the window as x and the ending column as y"	| xGrid returnedPoint baseX |	xGrid _ model xGrid.	returnedPoint _ Point new.	returnedPoint x: offsetPoint x.	baseX _ insetDisplayBox  width - 30 + (offsetPoint x = 1 ifTrue:[0] ifFalse:[xGrid at: offsetPoint x - 1]).	offsetPoint x to: xGrid size do: [:each |		(each = 1 ifTrue:[0] ifFalse:[xGrid at: each]) > baseX			ifTrue:[returnedPoint y: each.				^returnedPoint]].	returnedPoint y: xGrid size.	^returnedPoint!rowsToDisplay	"return a point containing the starting row displayed in the window as x and the ending row as y"	| yGrid returnedPoint baseY |	yGrid _ model yGrid.	returnedPoint _ Point new.	returnedPoint x: offsetPoint y.	baseY _ insetDisplayBox height - 30 + (offsetPoint y = 1 ifTrue:[0] ifFalse:[yGrid at: offsetPoint y - 1]).	offsetPoint y to: yGrid size do: [:each |		(each = 1 ifTrue:[0] ifFalse:[yGrid at: each]) > baseY			ifTrue:[returnedPoint y: each.				^returnedPoint]].	returnedPoint y: yGrid size.	^returnedPoint!scrollDown	| oldOrigin oldRows oldForm newRows newColumns sourceRect |	offsetPoint y >= model yGrid size ifTrue: [^model yGrid size].	oldOrigin _ model originOf: offsetPoint.	oldRows _ self rowsToDisplay.	offsetPoint y: offsetPoint y + 1.	sourceRect _ insetDisplayBox origin + (0 @ 30) corner: insetDisplayBox corner.	newRows _ self rowsToDisplay.	newColumns _ self columnsToDisplay.	(BitBlt 		destForm: Display		sourceForm: Display		halftoneForm: Form black		combinationRule: Form over		destOrigin: insetDisplayBox origin + (0 @ 30) - (0 @ ((model originOf: offsetPoint) y - oldOrigin y))		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: (insetDisplayBox origin + (0 @ 30) corner: insetDisplayBox corner)) copyBits.	Display		fill: (insetDisplayBox origin x @ (insetDisplayBox corner y - ((model originOf: offsetPoint) y - oldOrigin y)) corner: insetDisplayBox corner)		rule: Form over		mask: Form white.	self blacken: (newColumns x @ oldRows y corner: newColumns y @ newRows y).	newColumns x to: newColumns y do: [:each |  self displayColumnLineFor: each].	(oldRows y max: 1)		to: newRows y do: 		[:eachRow | 		self displayRowLabelFor: eachRow.		self displayRowLineFor: eachRow.		newColumns x to: newColumns y do: [:each | (model atPoint: each @ eachRow)				displayAt: each @ eachRow]].	^newRows y!scrollRight	| oldOrigin oldColumns oldForm newRows newColumns  xOffsetDelta sourceRect |	offsetPoint x >= model xGrid size ifTrue: [^model xGrid size].	oldOrigin _ model originOf: offsetPoint.	oldColumns _ self columnsToDisplay. 	offsetPoint x: offsetPoint x + 1.	xOffsetDelta _ (model originOf: offsetPoint) x - oldOrigin x.	newRows _ self rowsToDisplay.	newColumns _ self columnsToDisplay.	sourceRect  _ (insetDisplayBox origin + (30 @ 0) corner: insetDisplayBox corner).	(BitBlt 		destForm: Display		sourceForm: Display		halftoneForm: Form black		combinationRule: Form over		destOrigin: insetDisplayBox origin + (30 @ 0) - (xOffsetDelta @ 0)		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: (insetDisplayBox origin + (30 @ 0) corner: insetDisplayBox corner)) copyBits.	Display		fill: ((insetDisplayBox corner x - xOffsetDelta) @ insetDisplayBox origin y corner: insetDisplayBox corner)		rule: Form over		mask: Form white.	self blacken: (oldColumns y @ newRows x corner: newColumns y @ newRows y).	newRows x to: newRows y do: [:each |  self displayRowLineFor: each].	(oldColumns y max: 1)		to: newColumns y do: 		[:eachColumn | 		self displayColumnLabelFor: eachColumn.		self displayColumnLineFor: eachColumn.		newRows x to: newRows y do: [:each | (model atPoint: eachColumn @ each)				displayAt: eachColumn @ each]].	^newColumns y! !!SpreadsheetView methodsFor: 'clearing'!blacken: aRegion	"black out the specfied rectangle/cell"	(aRegion isKindOf: Point)		ifTrue:			[^Display				fill: (((model nilCell boxAt: aRegion) intersect: insetDisplayBox) insetBy: 1@1)				rule: Form over				mask: Form lightGray].	(aRegion isKindOf: Rectangle)		ifTrue:			[Display				fill: (((((model nilCell boxAt: aRegion origin) origin)					corner: ((model nilCell boxAt: aRegion corner) corner)) intersect: insetDisplayBox) insetBy: 1@1)				rule: Form over				mask: Form lightGray].!clear: aRegion	"white out the specfied rectangle/cell"	(aRegion isKindOf: Point)		ifTrue:			[^Display				fill: ((model nilCell boxAt: aRegion) intersect: insetDisplayBox)				rule: Form over				mask: Form white].	(aRegion isKindOf: Rectangle)		ifTrue:			[Display				fill: ((((model nilCell boxAt: aRegion origin) origin)					corner: ((model nilCell boxAt: aRegion corner) corner)) intersect: insetDisplayBox)				rule: Form over				mask: Form white].! !!SpreadsheetView methodsFor: 'indicating'!clearHighlight: oldPoint	"Reverse rectangle of cell at oldPoint."	self flipHighlight: oldPoint.	highlitPoint _ nil!clearMapCell: aPoint	| xGrid yGrid origin |	xGrid _ model xGrid.	yGrid _ model yGrid.	origin _ Point new.	scrollMap == nil 		ifTrue:[scrollMap _ Form extent: ((xGrid at: xGrid size) // 15 @ ((yGrid at: yGrid size) // 15)) + 4.			scrollMap borderWidth: 2].	aPoint x = 1		ifTrue:[origin x: 0]		ifFalse:[origin x: (xGrid at: aPoint x - 1) // 15 + 2].	aPoint y = 1		ifTrue:[origin y: 0]		ifFalse:[origin y: (yGrid at: aPoint y - 1) // 15 + 2].	scrollMap fill: (origin corner: (xGrid at: aPoint x) // 15 @ ((yGrid at: aPoint y) // 15) + 2)		rule: Form over		mask: Form white!fillMapCell: aPoint	| xGrid yGrid origin |	xGrid _ model xGrid.	yGrid _ model yGrid.	origin _ Point new.	scrollMap == nil 		ifTrue:[scrollMap _ Form extent: ((xGrid at: xGrid size) // 15 @ ((yGrid at: yGrid size) // 15)) + 4.			scrollMap borderWidth: 2].	aPoint x = 1		ifTrue:[origin x: 0]		ifFalse:[origin x: (xGrid at: aPoint x - 1) // 15 + 2].	aPoint y = 1		ifTrue:[origin y: 0]		ifFalse:[origin y: (yGrid at: aPoint y - 1) // 15 + 2].	scrollMap fill: (origin corner: (xGrid at: aPoint x) // 15 @ ((yGrid at: aPoint y) // 15) + 2)		rule: Form over		mask: Form black!flipHighlight: aRegion	"highlight the specfied rectangle/cell"	| viewBox |	viewBox _ insetDisplayBox origin + 30 corner: insetDisplayBox corner.	(aRegion isKindOf: Point)		ifTrue:			[^Display				fill: ((model nilCell boxAt: aRegion) intersect: viewBox)				rule: Form reverse				mask: Form black].	(aRegion isKindOf: Rectangle)		ifTrue:			[Display				fill: ((((model nilCell boxAt: aRegion origin) origin)					corner: ((model nilCell boxAt: aRegion corner) corner)) intersect: viewBox)				rule: Form reverse				mask: Form black].!grayMapCell: aPoint	| xGrid yGrid origin |	xGrid _ model xGrid.	yGrid _ model yGrid.	origin _ Point new.	scrollMap == nil 		ifTrue:[scrollMap _ Form extent: ((xGrid at: xGrid size) // 15 @ ((yGrid at: yGrid size) // 15)) + 4.			scrollMap borderWidth: 2].	aPoint x = 1		ifTrue:[origin x: 0]		ifFalse:[origin x: (xGrid at: aPoint x - 1) // 15 + 2].	aPoint y = 1		ifTrue:[origin y: 0]		ifFalse:[origin y: (yGrid at: aPoint y - 1) // 15 + 2].	scrollMap fill: (origin corner: (xGrid at: aPoint x) // 15 @ ((yGrid at: aPoint y) // 15) + 2)		rule: Form over		mask: Form gray!moveHighlight: newPoint	"Move reversed rectangle from highlitPoint to newPoint."	highlitPoint = newPoint		ifFalse:			[self flipHighlight: highlitPoint.			self flipHighlight: newPoint].	highlitPoint _ newPoint!setHighlight: newPoint	"Reverse rectangle of cell at newPoint."	self flipHighlight: newPoint.	highlitPoint _ newPoint! !!SpreadsheetView methodsFor: 'private'!displayArrows	"display the arrows designating the scrolling region"		ArrowForm				displayOn: Display				at: insetDisplayBox origin				clippingBox: insetDisplayBox				rule: Form under				mask: Form black.!displayColumnAxis	"Display the column labels above the sheet."	| theColumns xGrid xOffset |	theColumns _ self columnsToDisplay.	xOffset _ insetDisplayBox origin x + 30.	xGrid _ model xGrid.	theColumns x to: theColumns y do: 		[:row | self displayColumnLabelFor: row]!displayColumnLabelFor: aColumnNumber 	"Display the column labels above the sheet."	| xGrid rect labelString font offset |	xGrid _ model xGrid.	rect _ insetDisplayBox origin + (29 @ 0) corner: insetDisplayBox corner x @ (insetDisplayBox origin y + 30).	font _ TextStyle default fontAt: 2.	offsetPoint x = 1		ifTrue: [offset _ 30]		ifFalse: [offset _ 30+ (xGrid at: offsetPoint x - 1) negated].	aColumnNumber = 1		ifTrue: [rect left:  insetDisplayBox origin x + offset]		ifFalse: [rect left: insetDisplayBox origin x + (xGrid at: aColumnNumber - 1) + offset].	rect right: insetDisplayBox origin x + (xGrid at: aColumnNumber) + offset.	Display		fill: (rect intersect: insetDisplayBox)		rule: Form over		mask: Form black.	Display		fill: ((rect origin + 1 corner:rect corner - 1) intersect: insetDisplayBox)		rule: Form over		mask: Form white.	rowColLabels == nil ifTrue:[rowColLabels _ Array new: (model xGrid size max: model yGrid size)].	(rowColLabels at: aColumnNumber) = nil ifTrue:[rowColLabels at: aColumnNumber put:  aColumnNumber printString asForm].	labelString _ rowColLabels at: aColumnNumber.	labelString		displayOn: Display		at: rect center - (labelString width // 2 @ labelString height // 2) - 3		clippingBox: (insetDisplayBox origin + (29 @ 0) corner: insetDisplayBox corner x @ (insetDisplayBox origin y + 30))		rule: Form under		mask: Form black!displayColumnLineFor: aColumnNumber 	"Display the column labels above the sheet."	| xGrid rect labelString font offset |	xGrid _ model xGrid.	rect _ insetDisplayBox origin + (29 @ 0) corner: insetDisplayBox corner x @ (insetDisplayBox origin y + 30).	font _ TextStyle default fontAt: 2.	offsetPoint x = 1		ifTrue: [offset _ 30]		ifFalse: [offset _ 30+ (xGrid at: offsetPoint x - 1) negated].	aColumnNumber = 1		ifTrue: [rect left:  insetDisplayBox origin x + offset]		ifFalse: [rect left: insetDisplayBox origin x + (xGrid at: aColumnNumber - 1) + offset].	rect right: insetDisplayBox origin x + (xGrid at: aColumnNumber) + offset.	Display		fill: ((rect corner x - 1 @ rect origin y extent: 2 @ insetDisplayBox height ) intersect: insetDisplayBox)		rule: Form over		mask: Form black.!displayLines	| theColumns theRows | 	"Display the column labels above the sheet."	theColumns _ self columnsToDisplay.	theRows _ self rowsToDisplay.	theColumns x to: theColumns y do: 		[:row | self displayColumnLineFor: row].	theRows x to: theRows y do: 		[:row | self displayRowLineFor: row]!displayRowAxis	"Display the column labels above the sheet."	| theRows yGrid yOffset |	theRows _ self rowsToDisplay.	yOffset _ insetDisplayBox origin y + 30.	yGrid _ model yGrid.	theRows x to: theRows y do: 		[:row | self displayRowLabelFor: row]!displayRowLabelFor: aRowNumber 	"Display the column labels above the sheet."	| yGrid rect labelString font offset |	yGrid _ model yGrid.	rect _ insetDisplayBox origin + (0@29) corner: insetDisplayBox origin x + 30 @ insetDisplayBox corner y .	font _ TextStyle default fontAt: 2.	offsetPoint y = 1		ifTrue: [offset _ 30]		ifFalse: [offset _ 30+ (yGrid at: offsetPoint y - 1) negated].	aRowNumber = 1		ifTrue: [rect top:  insetDisplayBox origin y + offset]		ifFalse: [rect top: insetDisplayBox origin y + (yGrid at: aRowNumber - 1) + offset].	rect bottom: insetDisplayBox origin y + (yGrid at: aRowNumber) + offset.	Display		fill: (rect intersect: insetDisplayBox)		rule: Form over		mask: Form black.	Display		fill: ((rect origin + 1 corner:rect corner - 1) intersect: insetDisplayBox)		rule: Form over		mask: Form white.	rowColLabels == nil ifTrue:[rowColLabels _ Array new: (model xGrid size max: model yGrid size)].	(rowColLabels at: aRowNumber) = nil ifTrue:[rowColLabels at: aRowNumber put:  aRowNumber printString asForm].	labelString _ rowColLabels at: aRowNumber.	labelString		displayOn: Display		at: rect center - (labelString width // 2 @ labelString height // 2) - 3		clippingBox: (insetDisplayBox origin + (0@29) corner: insetDisplayBox origin x + 30 @ insetDisplayBox corner y)		rule: Form under		mask: Form black!displayRowLineFor: aRowNumber 	"Display the column labels above the sheet."	| yGrid rect labelString font offset |	yGrid _ model yGrid.	rect _ insetDisplayBox origin + (0@29) corner: insetDisplayBox origin x + 30 @ insetDisplayBox corner y .	font _ TextStyle default fontAt: 2.	offsetPoint y = 1		ifTrue: [offset _ 30]		ifFalse: [offset _ 30+ (yGrid at: offsetPoint y - 1) negated].	aRowNumber = 1		ifTrue: [rect top:  insetDisplayBox origin y + offset]		ifFalse: [rect top: insetDisplayBox origin y + (yGrid at: aRowNumber - 1) + offset].	rect bottom: insetDisplayBox origin y + (yGrid at: aRowNumber) + offset.	Display		fill: ((rect origin x @ rect corner y - 1 extent: insetDisplayBox width @ 2) intersect: insetDisplayBox)		rule: Form over		mask: Form black.!erase	form _ nil.	Display fill: insetDisplayBox		rule: Form over		mask: Form white!setForm	form _ nil.	^form _ Form fromDisplay: self insetDisplayBox! !!TextView methodsFor: 'controller access'!defaultControllerClass	^ BigTextController! !!CodeView methodsFor: 'controller access'!defaultControllerClass	^ BigCodeController! !!CodeView methodsFor: 'updating'!update: aSymbol	| range |	aSymbol == #pc ifTrue:		[range _ model pcRange.		self controller selectAndScrollFrom: range first to: range last + 1"yuckky + 1 is for BigParas"].	super update: aSymbol! !!OnlyWhenSelectedCodeView methodsFor: 'controller access'!defaultControllerClass	^BigOnlyWhenSelectedCodeController! !!StandardSystemView methodsFor: 'initialize-release'!release	self expand.	self dependents do:[:i|i release].	super release! !!StandardSystemView methodsFor: 'testing'!containsPoint: aPoint 	^((classifiedText isNil) | (self isCollapsed) ifFalse:[(self displayBox expandBy: 0@20) containsPoint: aPoint]ifTrue:[(self displayBox containsPoint: aPoint)])		| (self labelDisplayBox containsPoint: aPoint)! !!StandardSystemView methodsFor: 'label access'!accept	"tells the suitcase if there is one to save the last accepted classification"	| theSuitcase | 	theSuitcase _ self suitcase.	theSuitcase == nil ifFalse: [theSuitcase accept]!cancel	"tells the suitcase if there is one to revert to the last accepted classification"	| theSuitcase theClassification | 	theSuitcase _ self suitcase.	theClassification _ (theSuitcase == nil ifFalse: [theSuitcase cancel] ifTrue: [String new]).	self classifyLabel = theClassification classification ifFalse:		[self erase.		self classifyLabel: theClassification.		self display]!changeClassification: aClassification	| newClass mySuitcase | 	aClassification == nil ifTrue: [^self].	(mySuitcase _ self suitcase) == nil ifTrue: [^self].	(self suitcase classification ~= aClassification) ifTrue:		[newClass _ aClassification + mySuitcase classification.		 newClass = mySuitcase classification ifFalse:			[self classifyLabel: newClass.			self deEmphasizeLabel.			self displayEmphasized.			self suitcase changeClassification: newClass]]!classifyLabel	"Answer the string that appears in the receiver's label."	^classifiedText == nil		ifTrue: [String new]		ifFalse: [classifiedText asString]!classifyLabel: aClassLabel 	"Set aClassLabel to be the window tab label."	(aClassLabel == nil or: [aClassLabel classificationIndex = 1 and: [aClassLabel modifierCount = 0]])		ifTrue: [classifiedText _ nil]		ifFalse: 			[(aClassLabel isKindOf: Classification)				ifTrue: [classifiedText _ (Text string: aClassLabel classAndWords emphasis: 4) asParagraph]				ifFalse: [classifiedText _ (Text string: aClassLabel emphasis: 4) asParagraph]]!displayClassification	| clippingBox labelDisplayBox displayBox r |	self isCollapsed ifTrue: [^self].	clippingBox _ self clippingBox.	labelDisplayBox _ self labelDisplayBox.	displayBox _ self displayBox.	r _ labelFrame		align: labelFrame bottomLeft + (0 @ 20)		with: displayBox topLeft.	Display fill: ((insetDisplayBox topLeft - (0@(r height + 1))) extent: r extent) rule: Form over mask: Form screen.	classifiedText == nil	ifTrue:	[Display fill: r rule: Form over mask: Form screen.	Display fill: (((displayBox origin - (0@20)) extent: (displayBox width @ 20)) intersect: Display boundingBox) rule: Form over mask: Form screen.	Display fill: ((displayBox bottomLeft extent: (displayBox width @ 20)) intersect: Display boundingBox) rule: Form over mask: Form screen]	ifFalse:	[Display fill: r rule: Form over mask: Form black.	Display fill: (((displayBox origin - (0@20)) extent: (displayBox width @ 20)) intersect: Display boundingBox) rule: Form over mask: Form black.	Display fill: ((displayBox bottomLeft extent: (displayBox width @ 20)) intersect: Display boundingBox) rule: Form over mask: Form black.	classifiedText displayOn: Display at: (insetDisplayBox center x - (classifiedText width // 2))@(insetDisplayBox top - 20) clippingBox: (insetDisplayBox expandBy: 0@20) rule: Form reverse mask: Form black.	classifiedText displayOn: Display at: (insetDisplayBox center x - (classifiedText width // 2))@(insetDisplayBox bottom ) clippingBox: (insetDisplayBox expandBy: 0@20) rule: Form reverse mask: Form black].	(r _ labelDisplayBox intersect: clippingBox) displayOn: Display.	labelText == nil		ifFalse:			[labelText				displayOn: Display				at: (labelDisplayBox center -						(labelText boundingBox center -							labelText boundingBox topLeft))				clippingBox: clippingBox				rule: Form reverse				mask: Form black.			Display reverse: r inside]!label: aString 	"Set aString to be the window tab label."	aString == nil 		ifTrue: 			[labelFrame region: (0 @ 0 extent: 0 @ 0)]		ifFalse:			[labelText _ (Text string: (LabelTag isNil ifTrue: [aString] ifFalse: [aString, LabelTag]) emphasis: 7) asParagraph.	labelFrame region: (0 @ 0 extent: labelText boundingBox width + 8 @ 28)]!labelDisplayBox	"Answer the rectangle that borders the visible parts of the receiver's label on 	the display screen."	^labelFrame align: (self isCollapsed			ifTrue: [labelFrame topLeft]			ifFalse: [classifiedText isNil					ifTrue: [labelFrame bottomLeft]					ifFalse: [labelFrame bottomLeft + (0 @ 20)]])		with: self displayBox topLeft!lastLabelLocation	^lastLabelLocation!lastLabelLocation: loc	lastLabelLocation _ loc!suitcase 	"returns the suitcase from this view if it has one nil if not"	^self dependents detect: [:dep | dep isKindOf: Suitcase] ifNone:[nil]! !!StandardSystemView methodsFor: 'size'!minimumSize: aPoint 	"Set the argument, aPoint, to be the minimum width and height of the receiver."	classifiedText isNil		ifTrue:[minimumSize _ aPoint]		ifFalse:[minimumSize _ (aPoint x max: classifiedText width + 5)@aPoint y]! !!StandardSystemView methodsFor: 'framing'!collapse	"If the receiver is not already collapsed, change its view to be that of its label only"	self isCollapsed		ifFalse:			[lastFullFrame _ self displayBox.			savedSubViews _ subViews.			savedInsideColor _ insideColor.			savedBorderWidth _ borderWidth.			self resetSubViews.			savedWindow_ window.			labelText isNil ifTrue: [self label: 'No Label'].			self window: (self inverseDisplayTransform: self labelDisplayBox region).			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2]!erase	"Clear the display box of the receiver to be gray, as in the screen 	background. "	self clear: Form screen.	(classifiedText isNil) | (self isCollapsed)		ifFalse:[Display fill: (self displayBox expandBy: (0@20)) rule: Form over mask: Form screen.].	Display fill: self labelDisplayBox region mask: Form screen.	isLabelComplemented _ false!expand	"If the receiver is collapsed, change its view to be that of all of its subviews, not its label alone."	self isCollapsed		ifTrue:			[self window: savedWindow.			subViews _ savedSubViews.			insideColor _ savedInsideColor.			borderWidth _ savedBorderWidth.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 0.			savedSubViews _ savedInsideColor _ savedBorderWidth _ savedWindow _ nil]!expand2self isCollapsed		ifTrue:			[subViews _ savedSubViews.			self window: self defaultWindow.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 0.			savedSubViews _ nil]!getFrame	"Ask the user to designate a rectangular area in which the receiver should be displayed."	^(Rectangle		fromUserMinExtent: minimumSize		maxExtent: maximumSize		outlineColor: Form gray) expandBy: 2!lastFullFrame	^lastFullFrame!resize	"Determine the rectangular area for the receiver, adjusted to the minimum and maximum sizes."	| aRectangle |	aRectangle _ self getFrame.	aRectangle _ aRectangle origin extent:					((aRectangle extent max: minimumSize) min: maximumSize).	self window: self window viewport: aRectangle.!restoreFullView	"The receiver was collapsed;  open it again to original size or 	user's selection."	| oldFrame |	self erase.	oldFrame _ self displayBox.	self expand.	lastFullFrame == nil		ifTrue: [self resize]		ifFalse: 			[Display				zoom: oldFrame				to: lastFullFrame				speed: 1000.			self window: self window viewport: self lastFullFrame].	self displayEmphasized! !!StandardSystemView methodsFor: 'displaying'!displayBorder	"Display the  receiver's border (using the receiver's borderColor)."	(classifiedText isNil) | (self isCollapsed) ifTrue:[^super displayBorder].	borderWidth = 0		ifTrue:			[insideColor == nil				ifFalse: 					[Display fill: self displayBox mask: insideColor]]		ifFalse:			[insideColor == nil				ifTrue: 					[superView isNil						ifTrue:	[Display								border: (self displayBox expandBy: (0@20))								widthRectangle: borderWidth								mask: borderColor]						ifFalse:	[Display								border: (self displayBox expandBy: (0@20))								widthRectangle: borderWidth								mask: borderColor								clippingBox: superView insetDisplayBox]]				ifFalse:					[Display fill: (self displayBox expandBy: (0@20)) mask: borderColor.					Display fill: self insetDisplayBox mask: insideColor]]!displayTextReverse	"This is for the SmashOne controller option "	labelText isNil		ifFalse:			[labelText				displayOn: Display				at: (self labelDisplayBox center -						(labelText boundingBox center -							labelText boundingBox topLeft))				clippingBox: self clippingBox				rule: Form reverse				mask: Form gray reverse]!displayView	| clippingBox labelDisplayBox  |	clippingBox _ self clippingBox.	labelDisplayBox _ self labelDisplayBox.	(labelDisplayBox intersect: clippingBox) displayOn: Display.	(classifiedText isNil) | (self isCollapsed)		ifFalse:			[Display fill: (((insetDisplayBox origin - (0@20)) extent: (insetDisplayBox width @ 20)) intersect: Display boundingBox) rule: Form over mask: Form black.			Display fill: ((insetDisplayBox bottomLeft extent: (insetDisplayBox width @ 20)) intersect: Display boundingBox) rule: Form over mask: Form black.			classifiedText displayOn:Display at: (insetDisplayBox center x - (classifiedText width // 2))@(insetDisplayBox top - 20) clippingBox: (insetDisplayBox expandBy: 0@20) rule: Form reverse mask: Form black.			classifiedText displayOn:Display at: (insetDisplayBox center x - (classifiedText width // 2))@(insetDisplayBox bottom ) clippingBox: (insetDisplayBox expandBy: 0@20) rule: Form reverse mask: Form black].	labelText isNil		ifFalse:			[labelText				displayOn: Display				at: (labelDisplayBox center -						(labelText boundingBox center -							labelText boundingBox topLeft))				clippingBox: clippingBox.			self emphasizeLabel]! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView	self deEmphasizeLabel.	(classifiedText isNil) | (self isCollapsed)		ifFalse: [Display fill: (((insetDisplayBox origin - (-1@19)) extent: ((insetDisplayBox width)-2 @ 18)) intersect: Display boundingBox) rule: Form reverse mask: Form black.			Display fill: (((insetDisplayBox bottomLeft - (-1@-1)) extent: ((insetDisplayBox width)-2 @ 18)) intersect: Display boundingBox) rule: Form reverse mask: Form black.]! !!StandardSystemView methodsFor: 'private'!nearestVertexTo: aPoint 	"Return the name of the receiver's corner that is closest to 	aPoint "	| center |	center _ self displayBox center.	aPoint x < center x		ifTrue: [aPoint y < center y				ifTrue: [^#origin]				ifFalse: [^#bottomLeft]]		ifFalse: [aPoint y < center y				ifTrue: [^#topRight]				ifFalse: [^#corner]]! !!StandardSystemView methodsFor: 'help access'!helpIndex	^ helpIndex!helpIndex: anInteger	helpIndex _ anInteger! !ClockView comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!ClockView methodsFor: 'displaying'!clockLabel: aText	label _ aText!deEmphasizeLabel	self isCollapsed ifTrue: [super deEmphasizeLabel]!defaultControllerClass	^ClockController!displayClockLabel	"Puts label on clock"	QuickScanner		displayString: label		emphasis: FontNum		on: Display		at: (self insetDisplayBox topCenter - (Point x: (QuickScanner widthOfString: label emphasis: FontNum) // 2 y: 0))		clippingBox: self insetDisplayBox.	self label: label!displayDateString	"puts literal date on clock"	|currentDate dateString|    	currentDate _ ZonedTime todayAtZone: timeZone.	dateString _  currentDate dayOfMonth printString, (String with: $ ), currentDate monthName, (String with: $ ), currentDate year printString.	QuickScanner		displayString: dateString		emphasis: FontNum		on: Display		at: (self insetDisplayBox bottomCenter - (Point x: (QuickScanner widthOfString: dateString emphasis: FontNum) // 2 y: 20))		clippingBox: self insetDisplayBox!displayFace	"Decide whether to re-display the whole clock face by checking to see if the date has changed.  If not, then just redisplay the stored image on faceForm."	(dateToDisplay = (ZonedTime todayAtZone: timeZone))		ifFalse: [faceForm _ nil].	faceForm isNil		ifTrue: [self reallyDisplayFace]		ifFalse: [faceForm displayOn: Display at: self insetDisplayBox origin clippingBox: self insetDisplayBox rule: Form over mask: Form black]!displayHands	| x y radius center extent time hour minute |	extent _ (self insetDisplayBox extent) + (0@ -30).	center _ self insetDisplayBox center.	radius _ (extent x min: extent y) // 2 - 20.	time _ ZonedTime nowAtZone: timeZone.	minute _ time minutes.	hour _ time hours * 5 + (minute / 12) asFloat.	handsPen defaultNib: 4.	x _ (hour * 6 - 90) asFloat degreesToRadians cos.	y _ (hour * 6 - 90) asFloat degreesToRadians sin.	handsPen place: center + (x@y * radius // 2).	handsPen goto: center.	handsPen defaultNib: 2.	x _ (minute * 6 - 90) degreesToRadians cos.	y _ (minute * 6 - 90) degreesToRadians sin.	handsPen goto: center + (x@y * (radius-6))!displayTimeString	"puts literal time on clock"	| currentTime timeString minuteHolder |		currentTime _ ZonedTime nowAtZone: timeZone.	currentTime minutes < 10			ifTrue: [minuteHolder _ (String with: $0), currentTime minutes printString]			ifFalse: [minuteHolder _ currentTime minutes printString].	timeString _ currentTime hours printString, (String with: $:), minuteHolder.	QuickScanner		displayString: timeString		emphasis: FontNum		on: Display		at: (self insetDisplayBox bottomCenter - (Point x: (QuickScanner widthOfString: timeString emphasis: FontNum) // 2 y: 36))		clippingBox: self insetDisplayBox!displayView	(self isCollapsed)		ifTrue: [self displayClockLabel.				self controller stop.]  		ifFalse: [(self controller runFlag) ifFalse:[self controller start].			(self isKindOf: DigitalClockView)				ifTrue: [self displayFace; displayTimeString.]				ifFalse: [self displayFace; displayHands]]!emphasizeLabel	self isCollapsed ifTrue: [super emphasizeLabel]!label	^label!reallyDisplayFace	| degree radius center direction form extent |	center _ self insetDisplayBox center.	extent _ (self insetDisplayBox extent) + (Point x: 0 y: -30).	handsPen _ Pen new.	handsPen combinationRule: Form under.	radius _ (extent x min: extent y) // 2 - 12.	1 to: 12 do:					[:number |					degree _ number-3 * 30.					direction _ (degree degreesToRadians cos @ degree degreesToRadians sin).					form _ NumberForms at: number.					form displayAt: center+1 + (direction*radius) - (form extent // 2).					Display black: (center + (direction*(radius-11)) extent: 2@2)].	self displayClockLabel.	self displayDateString.	dateToDisplay _ ZonedTime todayAtZone: timeZone.	faceForm _ Form fromDisplay: self insetDisplayBox!timeZone: aSmallInteger	"Puts timeZone into receiver"	timeZone _ aSmallInteger! !DigitalClockView comment:'Copyright (c) 1984, 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!DigitalClockView methodsFor: 'displaying'!reallyDisplayFace	self displayClockLabel.	self displayDateString.	dateToDisplay _ ZonedTime todayAtZone: timeZone.	faceForm _ Form fromDisplay: self insetDisplayBox! !!ListView methodsFor: 'list access'!list: itemCollection 	"Create the textList corresponding to the items in itemCollection."	isEmpty _ itemCollection isNil.	list _ FastTextList onList: (topDelimiter == nil					ifTrue: [itemCollection]					ifFalse: [listTitle == nil							ifTrue: [(OrderedCollection with: topDelimiter)									, itemCollection , (OrderedCollection with: bottomDelimiter)]							ifFalse: [(OrderedCollection with: listTitle with: topDelimiter)									, itemCollection , (OrderedCollection with: bottomDelimiter)]]).	selection _ 0.	self positionList!listTitle: aString	listTitle _ aString! !!ListView methodsFor: 'delimiters'!topDelimiter: aString 	"Set the string used to indicate the top of the list."	topDelimiter _ aString! !!ListView methodsFor: 'selecting'!deselect	"If the receiver  has a selection, then it is highlighted.  Remove the highlighting."	selection ~= 0 ifTrue: [Display reverse: (self selectionBox intersect: self clippingBox).Display reverse: (self insideSelectionBox intersect: self clippingBox)]!displaySelectionBox	"If the receiver has a selection and that selection is visible on the display	screen, then highlight it."	(selection ~= 0 and: [self selectionBox intersects: self clippingBox])		ifTrue: [Display reverse: (self selectionBox intersect: self clippingBox).Display reverse: (self insideSelectionBox intersect: self clippingBox)]!findSelection: aPoint 	"Determine which selection is displayed in an area containing the point,	aPoint.  Answer the selection if one contains the point, answer nil otherwise."	| selectPoint listBox trialSelection |	selectPoint _ aPoint.	listBox _ self clippingBox.	(selectPoint x >= listBox left) & (selectPoint x <= listBox right) ifFalse: [^nil].	(selectPoint y < listBox top) ifTrue:		[self moveSelectionBox: 0.		[(Sensor redButtonPressed) & (Sensor mousePoint y < listBox top)] whileTrue:			[self controller scrollView:((listBox top) - (Sensor mousePoint y)) // 2.			self controller moveMarker].			selectPoint _ Sensor cursorPoint.			(listBox containsPoint: selectPoint) ifFalse:[^0]].	(selectPoint y > listBox bottom) ifTrue:		[self moveSelectionBox: 0. 		[(Sensor redButtonPressed) & (Sensor mousePoint y > listBox bottom)] whileTrue:			[self controller scrollView:((listBox bottom) - (Sensor mousePoint y)) // 2.			self controller moveMarker].			selectPoint _ Sensor cursorPoint.			(listBox containsPoint: selectPoint) ifFalse:[^0]].	trialSelection _ selectPoint y - list compositionRectangle top // list lineGrid + 1.	trialSelection < self minimumSelection | (trialSelection > self maximumSelection)		ifTrue: [^nil]		ifFalse: [^trialSelection - self minimumSelection + 1]!insideSelectionBox	"Answer the rectangle in which the current selection insert is displayed."	^(self insetDisplayBox left @ (list compositionRectangle top + self selectionBoxOffset) 		extent: self insetDisplayBox width @ list lineGrid)		insetBy: (Rectangle left: 1 right: 1 top: 0 bottom: 2)!minimumSelection	"Answer which selection is the first possible one."	topDelimiter == nil		ifTrue: [^1]		ifFalse: [listTitle == nil ifTrue:[^2] ifFalse:[^3]]!selectionBox	"Answer the rectangle in  which the current selection is displayed."	^(self insetDisplayBox left @ (list compositionRectangle top + self selectionBoxOffset) 		extent: self insetDisplayBox width @ list lineGrid)		insetBy: (Rectangle left: -1 right: -1 top: -2 bottom: 0)! !ContainerListView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!ContainerListView methodsFor: 'accessing'!centerName	^model centerName!hasChanged: aBoolean	^hasChanged _ aBoolean! !!ContainerListView methodsFor: 'displaying'!displayView	hasChanged ifTrue: 		[model refreshContainerListNoCheck.		self getListAndUpdateView.		self checkClassification].	super displayView!upDateMyView	hasChanged ifTrue: 			[model setFolderLists.			self getListAndUpdateView.			selection _ model listIndex.			self checkClassification].	super displayView! !!ContainerListView methodsFor: 'updating'!checkClassification	superView classifyLabel = model folder classification		ifFalse: [superView classifyLabel: model folder.						superView displayClassification].!getListAndDisplayView	"Display the list of items."	self getListAndUpdateView.	superView erase.	superView classifyLabel: model folder.	superView display!getListAndUpdateView	"Display the list of items."	| newList |	hasChanged _ false.	newList _ model viewList.	isEmpty & newList isEmpty		ifTrue: [^self]		ifFalse: [self list: newList.]!selection: anInteger 	selection _ anInteger!update: aSymbol 	(aSymbol isKindOf: DataItem)		ifTrue:[model folder == aSymbol			ifTrue:[hasChanged _ true]].	aSymbol == #holderChanged		ifTrue: [model holderChanged].	aSymbol == #all		ifTrue:[hasChanged _ true].	aSymbol == #deSelect		ifTrue:[self moveSelectionBox: 0].	aSymbol == #listHasChanged		ifTrue:[hasChanged _ true].	aSymbol == #mainViewSelectionChanged		ifTrue:[self moveSelectionBox: model listIndex].	aSymbol == #leaveWindow		ifTrue:[controller  controlTerminate].! !!ContainerListView methodsFor: 'model access'!list: itemCollection	| newList |  	"Create the textList corresponding to the items in itemCollection."	isEmpty _ itemCollection isNil.	newList _ itemCollection copy.	newList addFirst: topDelimiter.	newList addLast: bottomDelimiter.	list _ FastTextList onList: newList.	selection _ 0.	self positionList!model: aFolder	super model: aFolder.	self list: model viewList!model: aFolder controller: aController 	super model: aFolder controller: aController.	(model isKindOf: ContainerModel)		ifTrue: [self list: model viewList]! !!ContainerListView methodsFor: 'initialize-release'!release	model release.	ContainerModel removeDependent: self.	super release.! !!ContainerListView methodsFor: 'list handling'!atCurrentSelectionAdd: newName 	| index |	hasChanged		ifTrue: [self upDateMyView]		ifFalse: 			[selection = 0 ifTrue: [ selection _ list list size -1].			index _ selection + 1.			list list add: newName atIndex: index.			list gainedALine: self clippingBox.			Display fill: ((self selectionBox origin corner: self insetDisplayBox corner) intersect: self clippingBox) mask: insideColor.			list displayLines: index to: list list size.			self checkClassification.			self displaySelectionBox]!removeCurrentSelection	list list removeObjectAt: selection + 1.	(list lostALine)		ifTrue: [Display fill: self clippingBox mask: insideColor.				list displayLines: list topLine to: list list size]		ifFalse: [Display fill: ((self selectionBox origin corner: self insetDisplayBox corner) intersect: self clippingBox) mask: insideColor.			list displayLines: selection to: list list size].	self checkClassification.	selection _ 0.	self hasChanged: false!renameSelectionTo: newName 	| index |	hasChanged		ifTrue: [self upDateMyView]		ifFalse: 			[index _ selection + 1.			list list at: index put: newName.			Display fill: (self selectionBox intersect: self clippingBox) mask: insideColor.			list displayLines: index to: index.			self checkClassification.			self displaySelectionBox]! !DReportListView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DReportListView methodsFor: 'accessing'!model: aDB	super model: aDB.	self list: self getList!model: aDB controller: aController	super model: aDB controller: aController.	(model isKindOf: DataBase) ifTrue: [self list: self getList].!updateRequest	^model saveQueries! !!DReportListView methodsFor: 'list creation'!getList	^model reportList! !!DReportListView methodsFor: 'displaying'!getListAndDisplayView	"Display the list of items."	self list: self getList.	selection _ model reportListIndex.	self displayView! !RS232FunctionKeysView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!RS232FunctionKeysView methodsFor: 'everything'!initialize	super initialize.	resetNeeded _ false!list: itemCollection 	"Create the textList corresponding to the items in itemCollection."	| newList |	isEmpty _ itemCollection isNil.	newList _ (topDelimiter == nil					ifTrue: [itemCollection]					ifFalse: [listTitle == nil							ifTrue: [(OrderedCollection with: topDelimiter)									, itemCollection , (OrderedCollection with: bottomDelimiter)]							ifFalse: [(OrderedCollection with: listTitle with: topDelimiter)									, itemCollection , (OrderedCollection with: bottomDelimiter)]]).	(list ~~ nil and: [list list = newList]) ifTrue: [^false "no change"].	list _ FastTextList onList: newList.	selection _ 0.	self positionList.	^true!model: aFunctionKeysModel controller: aController	super model: aFunctionKeysModel controller: aController.	(model isKindOf: RS232FunctionKeys) ifTrue: [self list: model viewList].!resetIfNeeded	"if resetNeeded is true then update the view to correspond to internal list"	resetNeeded		ifTrue: [self resetView]!resetNeeded: aBoolean	"when true it means the internal list does not correspond to what is shown in the view"	resetNeeded _ aBoolean!resetView	(self list: model viewList) ifFalse: [^self].	self selection: (model viewListIndex); displayView.	[self isSelectionBoxClipped] whileTrue: [controller scrollUpSome].	resetNeeded _ false!selection: anInteger	selection _ anInteger!statusView	^ statusView!statusView: aView	statusView _ aView!update: aSymbol(aSymbol == #viewSelectionChanged)		ifTrue: [self moveSelectionBox: model viewListIndex. ^self]!updateRequest	controller checkAndPutLabelDefs.	^true! !DataListView comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation. All rights reserved.'!!DataListView methodsFor: 'accessing'!list: itemCollection 	"Create the textList corresponding to the items in itemCollection."	| newList |  	isEmpty _ itemCollection == nil.  	isEmpty		ifTrue: [newList _ OrderedCollection new]		ifFalse: [newList _ itemCollection copy].	topDelimiter == nil		ifFalse: [newList addFirst: topDelimiter.			newList addLast: bottomDelimiter].	list _ FastTextList onList: newList fontAt: 37.	selection _ 0.	self positionList!update: aSymbol 	aSymbol == #list		ifTrue: 			[self list: model list.			self displayView].	aSymbol == #stackList		ifTrue: 			[self list: model stackList.			self displayView].! !!DataListView methodsFor: 'list handling'!addNew: newName 	| index |	self deselect.	selection _ list list size -1.	index _ list list size.	list list add: newName atIndex: index.	list gainedALine: self clippingBox.	Display fill: ((self selectionBox origin corner: self insetDisplayBox corner) intersect: self clippingBox) mask: insideColor.	list displayLines: index to: list list size.	selection _ 0.!atCurrentSelectionAdd: newName 	| index |	selection = 0 ifTrue: [ selection _ list list size -1].	index _ selection + 1.	list list add: newName atIndex: index.	list gainedALine: self clippingBox.	Display fill: ((self selectionBox origin corner: self insetDisplayBox corner) intersect: self clippingBox) mask: insideColor.	list displayLines: index to: list list size.	self displaySelectionBox!model: aModel	super model: aModel.	self list: model labelList!removeCurrentSelection	list list removeObjectAt: selection + 1.	(list lostALine)		ifTrue: [Display fill: self clippingBox mask: insideColor.				list displayLines: list topLine to: list list size]		ifFalse: [Display fill: ((self selectionBox origin corner: self insetDisplayBox corner) intersect: self clippingBox) mask: insideColor.			list displayLines: selection to: list list size].	selection _ 0!renameSelectionTo: newName 	| index |	index _ selection + 1.	list list at: index put: newName.	Display fill: (self selectionBox intersect: self clippingBox) mask: insideColor.	list displayLines: index to: index.	self displaySelectionBox! !OutlineView comment:'Copyright (c) 1985, 1986, 1987 Xerox Corporation. All rights reserved.'!!OutlineView methodsFor: 'structure manipulations'!addEntry: op at: nextIndex	"Create the textList corresponding to the items in aHeadline."	| oldList oldCol newList newCol here initString |	oldList _ OrderedCollection new.	2 to: list list size - 1 do: [:i | oldList add: (list list at: i)].	oldCol _ model collection.	newList _ OrderedCollection new.	newCol _ OrderedCollection new.	initString _ self currentInitString.	op == #after		ifTrue: [here _ self selectionAfterCurrent - 1].	op == #before		ifTrue: [here _ selection - 1].	op == #under		ifTrue: [here _ selection.				oldList size > 0 ifTrue: [initString _ initString, (String new: 5 withAll: Character space)]]. 	1 to: here		do: [:i | newList add: (oldList at: i).				newCol add: (oldCol at: i)].	model treeListStartAt: nextIndex			addTo: newList			recCol: newCol			initString: initString			showHides: false.	oldList size > 0		ifTrue: [here + 1 to: oldList size				do: [:i | newList add: (oldList at: i).						newCol add: (oldCol at: i)]].	newList add: list list last; addFirst: list list first.	model collection: newCol.	list _ FastTextList onList: newList.	selection _ here + 1 max: 1.	self positionList.	model listIndex: selection; hasChanged: true.	self display.	self changeEditViewDisplaying: true.!changeClassification	superView suitcase changeClassification: model root.	superView classifyLabel = model root classification		ifFalse: [superView classifyLabel: model root.				superView displayClassification]!cut 	"Create the textList corresponding to the items in aHeadline."	| oldList newList oldCol newCol |	oldList _ OrderedCollection new.	oldCol _ model collection.	2 to: list list size - 1 do: [:i | oldList add: (list list at: i)].	newList _ OrderedCollection new. 	newCol _ OrderedCollection new.	1 to: selection - 1		do: [:i | newList add: (oldList at: i). newCol add: (oldCol at: i)].	selection + 1 + (self skipBeforeNext) to: oldList size		do: [:i | newList add: (oldList at: i). newCol add: (oldCol at: i)].	newList add: list list last; addFirst: list list first.	model collection: newCol.	list _ FastTextList onList: newList.	self deselect.	selection _ 0.	self positionList.	model listIndex: selection; hasChanged: true.	self display. self changeEditViewDisplaying: true!hasText	| old sz |	old _ list list at: selection + 1.	sz _ self currentInitString size + 1.	(old at: sz) = $:		ifTrue: [old at: sz put: $ .				Display fill: (self selectionBox intersect: self clippingBox) mask: insideColor.				list displayLines: selection + 1 to: selection + 1.				self displaySelectionBox].!hideSubs 	| old oldList oldCol newList newCol |	oldList _ OrderedCollection new.	2 to: list list size - 1 do: [:i | oldList add: (list list at: i)].	oldCol _ model collection.	newList _ OrderedCollection new.	newCol _ OrderedCollection new. 	1 to: selection - 1		do: [:i | newList add: (oldList at: i).				newCol add: (oldCol at: i)].	old _ oldList at: selection.	newList add: (String with: $-), (old copyFrom: 2 to: old size).	newCol add: (oldCol at: selection).	selection + 1 + (self skipBeforeNext) to: oldList size		do: [:i | newList add: (oldList at: i).				newCol add: (oldCol at: i)].	newList add: list list last; addFirst: list list first.	model collection: newCol.	list _ FastTextList onList: newList.	self positionList.	self displayView!listIndex: anInteger	self moveSelectionBox: anInteger.	self changeEditViewDisplaying: true.!rename: newName	| old new |	old _ list list at: selection + 1.	new _ self currentInitString.	new _ new, (String with: (old at: new size + 1)), newName.	(old at: 1) = $-		ifTrue: [new at: 1 put: $-].	list list at: selection + 1 put: new.	Display fill: (self selectionBox intersect: self clippingBox) mask: insideColor.	list displayLines: selection + 1 to: selection + 1.	self displaySelectionBox."	self changeClassification"!rename: newName at: aSelection	| old new index savedSelection |	selection = 0 ifFalse: [self deselect].	savedSelection _ selection.	selection _ aSelection.	old _ list list at: (index _ aSelection + 1).	new _ self currentInitString.	new _ new, (String with: (old at: new size + 1)), newName.	(old at: 1) = $-		ifTrue: [new at: 1 put: $-].	list list at: index put: new.	Display fill: (self selectionBox intersect: self clippingBox) mask: insideColor.	list displayLines: index to: index.	selection _ savedSelection.	selection = 0 ifFalse: [self displaySelectionBox]!selectKey 	"Create the textList corresponding to the items in aHeadline."	| top index recordCollection s |	selection _ 0.	recordCollection _ list list.	((s _ model key) ~= nil and: [s isEmpty not])		ifTrue:  [index _ 1.				top _ recordCollection size - 1.				[index < top & (selection = 0)]					whileTrue: 						[index _ index + 1.						(model does: (recordCollection at: index) contains: s) ifTrue: [selection _ index - 1]]].	self positionList.	model listIndex: selection.	superView == nil ifFalse: [self changeEditViewDisplaying: false]!showSubs 	"Create the textList corresponding to the items in aHeadline."	| oldList oldCol newList newCol isUG next |	oldList _ OrderedCollection new.	2 to: list list size - 1 do: [:i | oldList add: (list list at: i)].	oldCol _ model collection.	newList _ OrderedCollection new.	newCol _ OrderedCollection new.	1 to: selection - 1		do: [:i | newList add: (oldList at: i).				newCol add: (oldCol at: i)].	isUG _ model isUserGuide.	next _ isUG ifTrue: [self selectionAfterCurrent] ifFalse: [selection + 1].	model treeListStartAt: (oldCol at: selection)			addTo: newList			recCol: newCol			initString: self currentInitString			showHides: isUG.	next to: oldList size		do: [:i | newList add: (oldList at: i).				newCol add: (oldCol at: i)].	newList add: list list last; addFirst: list list first.	model collection: newCol.	list _ FastTextList onList: newList.	self positionList.	self displayView! !!OutlineView methodsFor: 'displaying'!addOrRemoveEditSubview	| aStringHolder aStringHolderView aController | 	^superView subViews size > 1		ifTrue: [aStringHolderView _ superView subViews at: 2.				(model isUserGuide				or: [(aStringHolderView model isUnlocked or: [selection = 0])				or: [(self confirm: 'Contents have not been saved. Are you certain that you want to close?')					ifTrue: [self rename: (model fullNameOf: model thisDataItem).							aStringHolderView model unlock. true] ifFalse: [false]]])					ifTrue: [superView erase.							superView releaseSubView: aStringHolderView.							superView setWindow: superView defaultWindow.							self topView display]]		ifFalse: [aStringHolder _ StringHolder new contents: String new.				aStringHolderView _ StringHolderView container: aStringHolder.				(aController _ OutlineEditController new) theOutline: model.				aStringHolderView borderWidth: 1;					insideColor: Form white;					controller: aController.				superView addSubView: aStringHolderView toRightOf: self.				superView setWindow: superView defaultWindow.				self topView display; reverseLabel. false]!changeEditViewDisplaying: displayIfTrue	| v |  	superView subViews size > 1		ifTrue: [v _ superView subViews at: 2.				v controller workingClass: model thisDataItem.				v model contents: model currentText.				displayIfTrue ifTrue: [v model changed] ifFalse: [v editString: v model contents].				v model unlock]! !!OutlineView methodsFor: 'utilities'!currentInitString 	"returns string of leading spaces"	| old s realStart |	s _ String new: 4 withAll: Character space.	realStart _ 6.	old _ list list at: selection + 1.	[(old findString: s startingAt: realStart) = realStart] whileTrue: [realStart _ realStart + 5].	^String new: (realStart - 2) withAll: Character space!okToChange: oldSelection change: aBoolean	| v goAhead anItem |  	goAhead _ true.	(oldSelection > 0 and: [superView subViews size > 1])		ifTrue: [v _ superView subViews at: 2.				goAhead _					v model isUnlocked						or: [(self confirm: 'Contents of ''', (self selectionLabel: oldSelection), ''' have not been saved.Do you want to discard changes?')								ifTrue: [(anItem _ model itemAt: oldSelection) = v controller workingClass											ifFalse: [self rename: (model fullNameOf: anItem) at: oldSelection].										aBoolean ifTrue: [v model contents: model currentText; changed].										v model unlock.										true]								ifFalse: [false]]].		^goAhead!scrollAmount: oldSelectionBoxOffset	"find the next reference for the given key"	^self isSelectionBoxClipped		ifTrue: [oldSelectionBoxOffset - self selectionBoxOffset - list lineGrid]		ifFalse: [0]!selectionAfterCurrent 	"Return the next selection of the same level after the current selection"	| old oldList skipIndex s realStart |	oldList _ list list.	old _ oldList at: selection + 1.	(old at: 1) = $-		ifTrue: [skipIndex _ 1]		ifFalse: [s _ String new: 4 withAll: Character space.				realStart _ 6.				[(old findString: s startingAt: realStart) = realStart] whileTrue: [realStart _ realStart + 5].				skipIndex _ 1.				[((oldList at: (selection + 1 + skipIndex)) findString: s startingAt: realStart) = realStart]					whileTrue: [skipIndex _ skipIndex + 1]].	^selection + skipIndex!selectionLabel: aSelection	| old new classStart oldSel |	old _ list list at: aSelection + 1.	oldSel _ selection.	selection _ aSelection.	new _ self currentInitString.	classStart _ (old indexOf: ${) - 1.	classStart < 0		ifTrue: [classStart _ old size].	new _ old copyFrom: new size + 2 to: classStart.	selection _ oldSel.	^new!setupList: recordCollection 	"Create the textList corresponding to the items in aHeadline."	Cursor wait show.	list _ FastTextList onList: (topDelimiter == nil			ifTrue: [recordCollection]			ifFalse: [(Array with: topDelimiter)						, recordCollection , (Array with: bottomDelimiter)]).	self selectKey.	Cursor normal show.!skipBeforeNext 	"Return the next selection of the same level after the current selection"	| old oldList skipIndex s realStart newSel |	oldList _ list list.	old _ oldList at: selection + 1.	(old at: 1) = $-		ifTrue: [skipIndex _ 0]		ifFalse: [s _ String new: 4 withAll: Character space.				realStart _ 6.				[(old findString: s startingAt: realStart) = realStart] whileTrue: [realStart _ realStart + 5].				skipIndex _ 0.				[((oldList at: (selection + 2 + skipIndex)) findString: s startingAt: realStart) = realStart]					whileTrue: [skipIndex _ skipIndex + 1]].	^skipIndex! !!OutlineView methodsFor: 'defaults'!defaultControllerClass	^OutlineController! !!OutlineView methodsFor: 'selecting'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger.  Deselect the	previous selection and display the new one, highlighted."	(anInteger ~= 0 and: [selection ~= 0])		ifTrue: [selection ~= anInteger					ifTrue: [self deselect.							selection _ anInteger.							self displaySelectionBox]]		ifFalse: [selection ~= 0					ifTrue: [self deselect].				selection _ anInteger.				selection = 0					ifFalse: [self displaySelectionBox]]! !!OutlineView methodsFor: 'list access'!list: recordCollection 	"Create the textList corresponding to the items in aHeadline."	| top index |	Cursor wait show.	list _ FastTextList onList: (topDelimiter == nil			ifTrue: [recordCollection]			ifFalse: [(Array with: topDelimiter)						, recordCollection , (Array with: bottomDelimiter)]).	selection = nil	ifTrue: [model key = nil			ifTrue: [selection _ 0]			ifFalse: 				[index _ 0.				top _ recordCollection size.				[index <= top & (selection = nil)]					whileTrue: 						[index _ index + 1.						(self does: (recordCollection at: index) contains: model key)							ifTrue:[selection _ index]]]]		ifFalse: [selection _ 0].	self positionList.	Cursor normal show.	self display.	self changeEditViewDisplaying: true! !!OutlineView methodsFor: 'initialize-release'!release	model release.	super release! !!OutlineView methodsFor: 'UG specials'!showTopSubs 	"Create the textList corresponding to the items in aHeadline."	| oldList oldCol newList newCol next |	oldList _ OrderedCollection new.	2 to: list list size - 1 do: [:i | oldList add: (list list at: i)].	oldCol _ model collection.	newList _ OrderedCollection new.	newCol _ OrderedCollection new.	1 to: selection - 1		do: [:i | newList add: (oldList at: i).				newCol add: (oldCol at: i)].	next _ self selectionAfterCurrent.	model treeTopListStartAt: (oldCol at: selection)			addTo: newList			recCol: newCol			initString: self currentInitString.	next"selection + 1" to: oldList size		do: [:i | newList add: (oldList at: i).				newCol add: (oldCol at: i)].	newList add: list list last; addFirst: list list first.	model collection: newCol.	list _ FastTextList onList: newList.	self positionList.	self displayView! !!OutlineView methodsFor: 'updating'!update: aSymbolOrArray	(aSymbolOrArray isKindOf: Array)		ifTrue: [self perform: aSymbolOrArray first withArguments: aSymbolOrArray last]		ifFalse: [self perform: aSymbolOrArray]!updateContents: oldSelection	| v |  	superView subViews size > 1		ifTrue: [v _ superView subViews at: 2.				v model isUnlocked					or: [(self confirm: 'Contents of ', (self selectionLabel: oldSelection), ' have not been saved.Do you want to save contents?')							ifTrue: [v controller accept.] ifFalse: [v model unlock]]].! !DQueryListView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DQueryListView methodsFor: 'accessing'!model: aDB	super model: aDB.	self list: self getList!model: aDB controller: aController	super model: aDB controller: aController.	(model isKindOf: DataBase) ifTrue: [self list: self getList].! !!DQueryListView methodsFor: 'list creation'!getList	^model queryList! !!DQueryListView methodsFor: 'displaying'!getListAndDisplayView	"Display the list of items."	self list: self getList.	selection _ model queryListIndex.	self displayView! !DFieldListView comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.'!!DFieldListView methodsFor: 'accessing'!model: aDB	super model: aDB.	self list: self getList!model: aDB controller: aController	super model: aDB controller: aController.	(model isKindOf: DataBase) ifTrue: [self list: self getList].! !!DFieldListView methodsFor: 'list creation'!getList	^model fieldList! !!DFieldListView methodsFor: 'displaying'!getListAndDisplayView	"Display the list of items."	self list: self getList.	self displayView! !DHitListView comment:'Copyright (c) Xerox Corporation, 1985, 1986, 1987.  All rights reserved.'!!DHitListView methodsFor: 'accessing'!atEndAdd: newItem 	| index scrollAmount |	index _ model hitList size + 3.	index = 3		ifTrue: [list list at: index  put: newItem.  numberOfAddedLines _ 0.]		ifFalse: 			[list list add: newItem atIndex: index.			list gainedALine: self clippingBox].	self deselect.		Display fill:		((self insetDisplayBox left @ (index - list topLine * list lineGrid + insetDisplayBox top)			corner: insetDisplayBox corner) intersect: self clippingBox)		mask: insideColor.	selection _ list numberOfLines - 3 - numberOfAddedLines.	scrollAmount _ self scrollAmount.	scrollAmount ~= 0		ifTrue: [controller scrollView: scrollAmount]		ifFalse: [list displayLines: list topLine to: list list size.			self displaySelectionBox.]!model: aDB	super model: aDB.	self list: self getList!model: aDB controller: aController	super model: aDB controller: aController.	(model isKindOf: DataBase) ifTrue: [self list: self getList].!removeCurrentSelection	list list removeObjectAt: selection + 2.	list lostALine.	Display fill:  self clippingBox mask: insideColor.	list displayLines: list topLine to: list list size.	selection _ 0.	self displaySelectionBox!renameSelectionTo: newName for: newNameObject	"newName is the string representation of newNameObject, which may be a number, date or time"	| index |	index _ selection + 2.	list list at: index put: newName.	model hitList at: selection put: newNameObject.	Display fill: (self selectionBox intersect: self clippingBox) mask: insideColor.	list displayLines: index to: index.	self displaySelectionBox! !!DHitListView methodsFor: 'list creation'!getList	| newList fieldType sum max min hitList |	newList _ OrderedCollection new.	hitList _ model hitList.	hitList isEmpty		ifFalse: 			[min _ max _ hitList first.			fieldType _ model file fieldTypes at: model selectedFieldIndex.			fieldType == #number			ifTrue: [	sum _ 0.				hitList do: 				[:content | 				sum _ sum + content.				content > max ifTrue: [max _ content].				content < min ifTrue: [min _ content].				newList add: content printString]]			ifFalse: [hitList do: 				[:content | 				content > max ifTrue: [max _ content].				content < min ifTrue: [min _ content].				content class == String					ifTrue: [newList add: content] ifFalse: [newList add: content printString]]]].	self		addSummaryTo: newList type: fieldType forMin: min max: max sum: sum.	^newList! !!DHitListView methodsFor: 'displaying'!changeListAndDisplayView	"Display the list of items."	| newList oldSelection scrollAmount |	oldSelection _ selection.	newList _ self getList.	newList isEmpty		ifTrue: [^self]		ifFalse: [self list: newList.			selection _ oldSelection.			scrollAmount _ self scrollAmount.			scrollAmount ~= 0 ifTrue: [self positionList].			self displayView]!getListAndDisplayView	"Display the list of items."	| newList |	newList _ self getList.	newList isEmpty		ifTrue: [^self]		ifFalse: 			[self list: newList.			self displayView]!maximumSelection	"Answer which selection is the last possible one."	topDelimiter == nil		ifTrue: [^list numberOfLines]		ifFalse: [^list numberOfLines - 1 - numberOfAddedLines]!scrollAmount	"find how much to scroll to keep the current selection in the view"	^self isSelectionBoxClipped		ifTrue: [ (selection+1) * list lineGrid negated]		ifFalse: [0]! !!DHitListView methodsFor: 'private'!addSummaryTo: aList type: fieldType forMin: min max: max sum: sum	| totalDays outString diffTime | 	aList size = 0		ifTrue: 			[numberOfAddedLines _ 1.			^aList add: 'no hits'].	numberOfAddedLines _ 5.	aList add: ((String new: 12)			atAllPut: $-).	aList add: (aList size - 1) printString , ' hits'.	min = max		ifTrue: 			[numberOfAddedLines _ numberOfAddedLines - 2.			aList add: 'all: ' , min printString]		ifFalse: 			[aList add: 'running from'.			aList add: '     ' , min printString , ' to'.			aList add: '     ' , max printString].	sum == nil		ifFalse: 			[numberOfAddedLines _ numberOfAddedLines + 1.			aList add: 'Total: ' , sum printString].	(max ~= UnknownDate new) & (min ~=UnknownDate new) & (fieldType == #date)		ifTrue: 			[numberOfAddedLines _ numberOfAddedLines + 1.			totalDays _ ((max subtractDate: min) + 1).			totalDays > 365 				ifTrue: [outString _ (totalDays // 365) printString, ' yrs., ', (totalDays \\ 365) printString, ' days.' ]				ifFalse: [outString _ totalDays printString, ' days.'].			aList add: 'spanning ' , outString].	(max ~= UnknownTime new) & (min ~=UnknownTime new) & (fieldType == #time)		ifTrue: 			[numberOfAddedLines _ numberOfAddedLines + 1.			diffTime _ (max subtractTime: min).			outString _ diffTime hours printString, ' hrs. ',diffTime minutes printString, ' mins. ', diffTime seconds printString, ' secs.'.			aList add: 'Total time: ' , outString].	^numberOfAddedLines! !AutoBookListView comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!AutoBookListView methodsFor: 'up dating'!getList	"Answer an Array of the items in the list."	self subclassResponsibility!getListAndDisplayView	"Display the list of items."	| newList |	newList _ self getList.	isEmpty & newList isEmpty		ifTrue: [^self]		ifFalse: 			[self list: newList.			self displayView]! !!AutoBookListView methodsFor: 'model access'!model: aAutoBook	super model: aAutoBook.	self list: self getList!model: aAutoBook controller: aController	super model: aAutoBook controller: aController.	(model isKindOf: AutoBook) ifTrue: [self list: self getList].! !SecondABListView comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!SecondABListView methodsFor: 'updating'!getList	^model secondViewList!update: aSymbol	(aSymbol == #countrySelectionChanged)		ifTrue: [self getListAndDisplayView].	(aSymbol == #firstViewSelectionChanged)		ifTrue: [self getListAndDisplayView].	(aSymbol == #firstViewSelectionChanged) |	(aSymbol == #secondViewSelectionChanged)		ifTrue: [self moveSelectionBox: model secondListIndex]! !ThirdABListView comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!ThirdABListView methodsFor: 'As yet unclassified'!getList	^model thirdViewList!update: aSymbol	(aSymbol == #firstViewSelectionChanged)		ifTrue: [self getListAndDisplayView].	(aSymbol == #secondViewSelectionChanged)		ifTrue: [self getListAndDisplayView].	(aSymbol == #countrySelectionChanged)		ifTrue: [self getListAndDisplayView].	(aSymbol == #secondViewSelectionChanged) |	(aSymbol == #thirdViewSelectionChanged)		ifTrue: [self moveSelectionBox: model thirdListIndex]! !FirstABListView comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.'!!FirstABListView methodsFor: 'updating'!getList^model firstViewList!update: aSymbol	(aSymbol == #countrySelectionChanged)		ifTrue: [self getListAndDisplayView].(aSymbol == #firstViewSelectionChanged)		ifTrue: [self moveSelectionBox: model firstListIndex. ^self].! !!FirstABListView methodsFor: 'accessing'!selection: anInteger	selection _ anInteger.! !FormsView comment:'Copyright (c) 1986, 1987 Xerox Corporation.  All rights reserved.'!!FormsView methodsFor: 'accessing'!boxForElement: element	| offset |	offset _ insetDisplayBox origin.	^element box translateBy: offset!displayCache	^displayCache!elementForPoint: aPoint 	| offset |	offset _ insetDisplayBox origin.	model elements do:		[:element | ((element box translateBy: offset) containsPoint: aPoint) ifTrue: [^element]].	^nil! !!FormsView methodsFor: 'displaying'!deEmphasizeView	self updateDisplayCache.	super deEmphasizeView!display: anElement 	"Display one of the elements and its value in the prescribed area on the 	display. "	anElement		displayOn: Display		at: self insetDisplayBox origin		clippingBox: insetDisplayBox		rule: Form over		mask: Form black.	self updateDisplayCache!displayEmphasized	self displayView.	controller class == FormsEditController ifTrue: [controller selectedElement == nil ifFalse: [self reverse: controller selectedElement]]!displayView	"Display all of the elements and their values in the prescribed area on the 	display. "	displayCache == nil		ifTrue: 			[model elements do: [:element | element					displayOn: Display					at: self insetDisplayBox origin					clippingBox: insetDisplayBox					rule: Form over					mask: Form black].			self updateDisplayCache]		ifFalse: [displayCache extent = self insetDisplayBox extent				ifTrue: [displayCache displayAt: insetDisplayBox origin]				ifFalse: 					[self resetDisplayCache.					self displayView]]!erase: anElement	"Display all of the elements and their values in the prescribed area on the display."	Display fill: ((anElement box translateBy: insetDisplayBox origin) intersect: insetDisplayBox)						rule: Form erase						mask: Form black!fastDisplay: anElement 	"Display one of the elements and its value in the prescribed area on the 	display. "	anElement		displayOn: Display		at: self insetDisplayBox origin		clippingBox: insetDisplayBox		rule: Form over		mask: Form black!resetDisplayCache	displayCache _ nil!reverse: anElement	"Display all of the elements and their values in the prescribed area on the display."	Display fill: ((anElement box translateBy: insetDisplayBox origin) intersect: insetDisplayBox)						rule: Form reverse						mask: Form black!updateDisplayCache	displayCache == nil		ifTrue: [displayCache _ Form fromDisplay: self insetDisplayBox]		ifFalse:			[displayCache				copyBits: self insetDisplayBox				from: Display				at: 0 @ 0				clippingBox: displayCache computeBoundingBox				rule: Form over				mask: Form black.			displayCache offset: 0 @ 0]! !!FormsView methodsFor: 'initialize-release'!release	model release.	super release! !RS232MemoryBuffer comment:'Copyright (c) Xerox Corporation, 1986. All rights reserved.These buffers are linked together to form the memory of the characters which have been displayed on the RS232 window.collection	a StringlastUsed	the index of the last valid character put in the collectionnextBuffer 	the next buffer in the chain'!!RS232MemoryBuffer methodsFor: 'access'!addString: aString startingAt: start endingAt: end	"add the string aString from start to end to the current and succeeding buffers. Return the last buffer used"	| leftInString inThisBuffer | 	leftInString _ end - start + 1.	inThisBuffer _ leftInString min: collection size - lastUsed.	inThisBuffer > 0 ifTrue:		[collection replaceFrom: lastUsed + 1 to: (lastUsed _ lastUsed + inThisBuffer) with: aString startingAt: start].	leftInString > inThisBuffer ifTrue: "we need to add another buffer to ourselves"		[nextBuffer == nil ifFalse: [nextBuffer releaseAll].		nextBuffer _ self class ofSize: collection size.		^nextBuffer addString: aString startingAt: start + inThisBuffer endingAt: end]!getStringStartingAt: start endingIn: endBuf at: endPos	"return the string starting at start in this buffer, and ending at endPos in buffer endBuf. endPos may be nil to get whatever is lastUsed in endBuf"	start > lastUsed ifTrue: [^String new].	(self == endBuf or: [nextBuffer == nil])		ifTrue: [^collection copyFrom: start to: (endPos == nil ifTrue: [lastUsed] ifFalse: [endPos])]		ifFalse: [^(collection copyFrom: start to: lastUsed), (nextBuffer getStringStartingAt: 1 endingIn: endBuf at: endPos)]!getStringStartingAt: start ofLength: stringLength	"return the string of size stringLength starting at start in this buffer"	| inThisBuffer |	start > lastUsed ifTrue: [^String new].	inThisBuffer _ stringLength min: lastUsed - start + 1.	(stringLength <= inThisBuffer or: [nextBuffer == nil])		ifTrue: [^collection copyFrom: start to: start + inThisBuffer - 1]		ifFalse: [^(collection copyFrom: start to: lastUsed), (nextBuffer getStringStartingAt: 1 ofLength: stringLength - inThisBuffer)]!lastUsed	^lastUsed!nextBuffer	^nextBuffer!resetTo: numCharsFromStart startingAt: start	"for some reason (probably browsing) the user needs to backtrack to a former state, known only as numCharsFromStart from start location in the buffer. Returns the new last buffer"	| proposedStart | 	proposedStart _ start + numCharsFromStart - 1.	(proposedStart > lastUsed and: [nextBuffer ~= nil])		ifTrue: "we need to go to the next buffer"			[^nextBuffer resetTo: proposedStart - lastUsed startingAt: 1]		ifFalse: "we have found the new end, reset appropriately"			[lastUsed _ proposedStart min: lastUsed.			nextBuffer == nil ifFalse: [nextBuffer releaseAll]]! !!RS232MemoryBuffer methodsFor: 'initialize/release'!on: aCollection 	collection _ aCollection.	lastUsed _ 0.	nextBuffer _ nil!release	nextBuffer _ nil!releaseAll	nextBuffer == nil ifFalse: [nextBuffer releaseAll].	nextBuffer _ nil.	collection _ nil! !RS232DisplayMem comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.<TTYFont>	a StrikeFont. The font all text in the window will be displayed in. Should be fixed width font.<Height>	an Integer. The height of TTYFont plus a line led.<Width>	an Integer. The width of $a.<Stops>	an Array of 258, all nil. For use as the stop conditions.<windowRect>	a Rectangle. The display area relative to Display origin.<blt>	a DisplayScanner. It is set up with one composed line, the contents of which are changed to display what is wanted.<maxLines>	an Integer. The number of lines that will fit in windowRect.<lines>	an OrderedCollection RS232DisplayLine corresponding to lines 1 thru maxLines on the screen.<theCurLine>	a RS232DisplayLine. The line in lines corresponding to curLine.  Only need for small improvement in access time.<curLine>	an Integer. The number of the current line.<curCol>	an Integer. The number of the current column.<lineLength>	an Integer. The maximum number of columns (eg. characters that will fit in a line).<combRule>		Form over or Form under. Which way characters are to be blted.<contentsStream>	a PagedTextCircularStream.  The memory of things past, used for browsing.'!!RS232DisplayMem methodsFor: 'access'!containsCursor	^(windowRect containsPoint: Sensor cursorPoint)!contentsStream	^contentsStream!crStringFrom: startColAtLine for: numChars 	"return a string containing the contents of the memory from startColAtLine    	for numChars"	| stream line lineNum start char |	stream _ WriteStream on: (String new: numChars).	line _ lines at: (lineNum _ startColAtLine y).	start _ startColAtLine x.	numChars		timesRepeat: 			[start > lineLength				ifTrue: 					[start _ 1.					line _ lines at: (lineNum _ lineNum + 1).					stream cr].			start > line lastLoc				ifTrue: [start _ start + 1]				ifFalse: 					[(char _ line at: start) = Character cr ifFalse: [stream nextPut: char].					start _ start + 1]].	^stream contents!currentLoc	^curCol@curLine!lineLength	^ lineLength!locForPoint: aPoint	^(((aPoint x - windowRect left) // Width + 1) @ ((aPoint y - windowRect top) // Height + 1) max: 1@1) min: (lineLength @ maxLines)!maxLines	^maxLines!stringFrom: startColAtLine for: numChars	"return a string containing the contents of the memory from startColAtLine for numChars"	| line stream lineNum start chr |	stream _ WriteStream on: (String new: numChars).	line _ lines at: (lineNum _ startColAtLine y).	start _ startColAtLine x.	numChars timesRepeat:		[start > lineLength ifTrue:			[start _ 1.			 line _ lines at: (lineNum _ lineNum + 1)].		 chr _ line at: start.		 (start = lineLength and: [chr = Character cr])			ifTrue: [stream nextPut: $ ]			ifFalse: [stream nextPut: chr].		 start _ start + 1].	^ stream contents! !!RS232DisplayMem methodsFor: 'initialize/release'!combRule: rule	combRule _ rule!initialize	combRule _ Form under.	curLine _ 1.	curCol _ 1.	contentsStream _ RS232Memory new!initialSetUp: w	maxLines _ (w height // Height) - 1. "- 1 is to leave room for scrolling"	lineLength _ (w width // Width) - 2.	lines _ OrderedCollection new: maxLines.	maxLines timesRepeat: [lines add: (RS232DisplayLine emptyLine: lineLength)].	theCurLine _ lines at: curLine!release	contentsStream release!updateForBrowse	contentsStream setPreBrowseState.	lines do: [:l | contentsStream addLine: l]!updateWindowLoc: w	| para |	w = windowRect ifFalse:		[windowRect = nil ifTrue: [self initialSetUp: w].		windowRect _ w.		para _ Paragraph				withText: (String new: lineLength withAll: $ ) asText				style: (TextStyle fontArray: (Array with: TTYFont))				compositionRectangle: w				clippingRectangle: w.		blt _ DisplayScanner new.		blt displayLines: (1 to: 1) in: para clippedBy: w;				combinationRule: combRule;	"Tek should be Form under, other Form over"				destX: w left;				destY: w top.		^true].	^false! !!RS232DisplayMem methodsFor: 'highlights'!doHighlights	"check and do any highlights on current line"	| highlights pend |	theCurLine highlightColl do: [:h | self highlightChars: h onLine: curLine].	pend _ theCurLine pendingHighlightUpto: theCurLine lastLoc.	pend == nil ifFalse: [self highlightChars: pend onLine: curLine]!endHighlight	theCurLine endHighlightAt: curCol - 1!highlightChars: anArray onLine: lineNum	"if (anArray at: 3) is $H then highlight with reverse video the characters		indexed by start is (anArray at: 1), and stop is (anArray at: 2) on line number lineNum;		otherwise, underline those characters"	(anArray at: 3) = $H		ifTrue:			[Display				fill: (((anArray at: 1) - 1 * Width + windowRect left) @ (windowRect top + (lineNum - 1 * Height))					extent: ((anArray at: 2) - (anArray at: 1) + 1 * Width) @ TTYFont height)				rule: Form reverse				mask: Form black]		ifFalse:			[Display				fill: (((anArray at: 1) - 1 * Width + windowRect left)@(windowRect top + (lineNum - 1 * Height) + TTYFont height)					extent: ((anArray at: 2) - (anArray at: 1) + 1 * Width)@1)				rule: Form over				mask: Form black]!highlightFrom: startColAtLine for: numChars with: type permanent: permanent	"highlight numChars (including blanks) starting with startColAtLine. If permanent is true, put highlight(s) in the lines, else just draw on display.	 Return the location beyond the end of the highlight (or the last possible location), but leave self set to the same location as entered with"	| remLength theX theY theLine |	remLength _ numChars.	theX _ startColAtLine x.	theY _ startColAtLine y.	theLine _ lines at: theY.	[(theX + remLength) > lineLength]			whileTrue:			[permanent				ifTrue: [theLine startHighlight: type at: theX; endHighlightAt: lineLength. self paintCurLine].			self highlightChars: (Array with: theX with: lineLength with: type) onLine: theY.			remLength _ remLength - (lineLength - theX + 1).			theX _ 1.			theY _ theY + 1.			theY > lines size				ifTrue: [theY _ lines size. remLength _ 0]				ifFalse: [theLine _ lines at: theY]].	remLength > 0 ifTrue:		[permanent			ifTrue: [theLine startHighlight: type at: theX; endHighlightAt: theX + remLength - 1. self paintCurLine]			ifFalse: [self highlightChars: (Array with: theX with: theX + remLength - 1 with: type) onLine: theY]].	theX _ theX + remLength.	^theX@theY	"now use for return result"!startHighlight	theCurLine startHighlight: $H at: curCol!underline: aSymbol	theCurLine startHighlight: $U at: (aSymbol = #last ifTrue: [curCol - 1] ifFalse: [curCol])! !!RS232DisplayMem methodsFor: 'As yet unclassified'!backSpace	theCurLine lastLoc = curCol ifTrue: [theCurLine backSpace].	curCol _ curCol - 1 max: 1!clearLineFrom: col	theCurLine clearLineFrom: col.	Display		fill: (windowRect left + (col - 1 * Width) @ (windowRect top + (curLine - 1 *Height))		corner: (windowRect right @ (windowRect top + (curLine * Height - 1)))) rule: Form over mask: Form white.!clearLines: startLine to: endLine	startLine to: endLine do: [:i | (lines at: i) clearLine "put: (RS232DisplayLine emptyLine: lineLength)"].	Display		fill: (windowRect left @ (windowRect top + (startLine - 1 *Height))		corner: (windowRect right @ (windowRect top + (endLine * Height - 1)))) rule: Form over mask: Form white.	startLine > endLine ifFalse:		[curLine _ startLine.		theCurLine _ lines at: curLine]!clearMemory	"this just resets the memory of things past. The splits must command what to clear on the screen"	contentsStream clearMemory; setPreBrowseState!clearPage	"white out window, reset to line 1, col 1"	Display fill: windowRect rule: Form over mask: Form white.	lines do: [:l | l clearLine].	curLine _ curCol _ 1.	theCurLine _ lines at: curLine.	self setBltDestAtLine: curLine col: curCol!clearRemainderOfLine	self clearLineFrom: curCol + 1!cr	self paint: Character cr!endLinesNeatlyFrom: startLine to: endLine	| l realLine lastLoc | 	realLine _ false.	(endLine to: startLine by: -1) do:		[:i |		 l _ lines at: i.		 (lastLoc _ l lastLoc min: lineLength) > 0 ifTrue: [realLine _ true].		 (realLine and: [lastLoc = 0 or: [(l at: lastLoc) ~= Character cr]])			ifTrue: [l at: (lastLoc + 1 min: lineLength) put: Character cr]]!nextPage	"contents of the lines must be written out to contentsStream, white out window, reset to line 1, col 1"	lines do: [:l | contentsStream addLine: l].	contentsStream newPage.	self clearPage!paint: c	| a |	a _ c asciiValue.	curCol > lineLength ifTrue: [self paintLine. a = 13 ifTrue: [^self]].	a = 9"tab" ifTrue: [5 timesRepeat: [self paint: $ ]. ^self].	theCurLine at: curCol put: c.	curCol _ curCol + 1.	a = 13 ifTrue: [self paintLine]!paintAV: a	curCol > lineLength ifTrue: [self paintLine. a = 13 ifTrue: [^self]].	a = 9"tab" ifTrue: [5 timesRepeat: [self paint: $ ]. ^self].	theCurLine at: curCol put: (CharTable at: a +1).	curCol _ curCol + 1.	a = 13 ifTrue: [self paintLine]!paintCurLine	theCurLine lastLoc > 0 ifTrue:		[self setBltDestAtLine: curLine col: 1.		blt scanCharactersFrom: 1			to: theCurLine lastLoc			in: theCurLine string			rightX: windowRect right			stopConditions: Stops			displaying: true.		self doHighlights]!paintLine	"finish off the current line, then move to next line, or if off bottom of page either go to next page or scroll up one line.	 If the current line had a highlight pending when it ended, start it up on the new line"	| oldLine |	self paintCurLine.	oldLine _ theCurLine.	(curLine + 1 > maxLines)		ifFalse:			[curLine _ curLine + 1.			 theCurLine _ lines at: curLine.			 (oldLine endHighlightAt: oldLine lastLoc) "end any pending highlight, and if there was one carry it to next line"				ifTrue: [theCurLine startHighlight: (oldLine highlightColl last at: 3) at: 1]]		ifTrue:			[contentsStream addLine: lines removeFirst.					theCurLine _ RS232DisplayLine emptyLine: lineLength.					lines addLast: theCurLine.					(oldLine endHighlightAt: oldLine lastLoc) "end any pending highlight, and if there was one carry it to next line"						ifTrue: [theCurLine startHighlight: (oldLine highlightColl last at: 3) at: 1].					Display						copyBits: (windowRect origin + (0@Height)									 corner: windowRect corner)						from: Display						at: windowRect origin						clippingBox: windowRect						rule: Form over						mask: Form black].	curCol _ 1.	self setBltDestAtLine: curLine col: curCol!paintString: aString	| a |	aString do:		[:c |		 a _ c asciiValue.		 curCol > lineLength ifTrue: [self paintLine].		 a = 9"tab"			ifTrue: [5 timesRepeat: [self paint: $ ]]			ifFalse:				[theCurLine at: curCol put: c.				curCol _ curCol + 1.				a = 13 ifTrue: [self paintLine]]].	self paintCurLine!paintStringAsLine: aString	self paintString: aString.	self paint: Character cr!selectFromRedButton	"return the characters from a selection in the display memory"	| beginLoc hereLoc startLoc stopLoc num returnString |	beginLoc _ self locForPoint: Sensor cursorPoint.	[Sensor redButtonPressed]		whileTrue: 			[hereLoc _ self locForPoint: Sensor cursorPoint.			"find start and stop of selected area"			hereLoc y < beginLoc y				ifTrue: 					[startLoc _ hereLoc.					stopLoc _ beginLoc]				ifFalse: [hereLoc y = beginLoc y						ifTrue: [hereLoc x < beginLoc x								ifTrue: 									[startLoc _ hereLoc.									stopLoc _ beginLoc]								ifFalse: 									[stopLoc _ hereLoc.									startLoc _ beginLoc]]						ifFalse: 							[stopLoc _ hereLoc.							startLoc _ beginLoc]].			stopLoc y > startLoc y 				ifTrue: [num _ lineLength - startLoc x + 1 "end of first line" 							+ stopLoc x "beginning of last line" 							+ (stopLoc y - startLoc y - 1 * lineLength) "intervening lines"]				ifFalse: [num _ stopLoc x - startLoc x].			self highlightFrom: startLoc for: num with: $H permanent: false.			self highlightFrom: startLoc for: num with: $H permanent: false].	returnString _ (startLoc == nil ifFalse: [self crStringFrom: startLoc for: num] ifTrue: [String new]).	Sensor leftShiftDown ifTrue: [ParagraphEditor copyText: returnString asText].	^returnString!setBltDestAtLine: line col: col	blt destX: windowRect left + (col - 1 * Width).	blt destY: windowRect top + (line - 1 * Height)!setToColAtLine: colAtLine	curLine _ colAtLine y.	theCurLine _ lines at: curLine.	curCol _ colAtLine x!show: aString	self paintString: aString! !RS232GraphicsDisplayMem comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.<currY>		the current destY<textOnGraphics>	when true, the text is actually in or over the graphics window, and therefore the text form should not be saved.'!!RS232GraphicsDisplayMem methodsFor: 'As yet unclassified'!clearMemory	super clearMemory.	self clearPage!clearPage	Display fill: windowRect rule: Form over mask: Form white.	curLine _ curCol _ 1.	theCurLine lastLoc: 0.	self setAtOffset: 0@0!initialSetUp: w	maxLines _ 1.	lineLength _ (w width // Width) - 2.	lines _ OrderedCollection new: maxLines.	maxLines timesRepeat: [lines add: (RS232DisplayLine emptyLine: lineLength)].	theCurLine _ lines at: curLine!paintCurLine	blt scanCharactersFrom: 1		to: theCurLine lastLoc		in: theCurLine string		rightX: windowRect right		stopConditions: Stops		displaying: true.	contentsStream addLine: theCurLine.	theCurLine lastLoc: 0.	curCol _ 1!paintLine	"paint the current line, then move down for next line, or if off bottom of page either go to next page or scroll up one line."	self paintCurLine.	(currY  >= (windowRect bottom - (3*Height)))		ifFalse:			[blt destY: (currY _ currY + Height)]		ifTrue:			[Display						copyBits: (windowRect origin + (0@Height) corner: windowRect corner)						from: Display						at: windowRect origin						clippingBox: windowRect						rule: Form over						mask: Form black.					 blt destY: (currY _ windowRect bottom - (2*Height))].	blt destX: windowRect left!setAtOffset: offsetPoint 	| xOffset yOffset |	yOffset _ (offsetPoint y - TTYFont height) max: 0.	xOffset _ offsetPoint x.	(windowRect top + yOffset + Height >= windowRect bottom)		ifTrue: [yOffset _ 0].	blt destY: (currY _ windowRect top + yOffset).	(windowRect left + xOffset + Width > windowRect right)		ifTrue: [xOffset _ 0].	blt destX: windowRect left + xOffset!textOnGraphics	^textOnGraphics!textOnGraphics: aBoolean	textOnGraphics _ aBoolean!updateForBrowse	super updateForBrowse.	Display fill: windowRect rule: Form over mask: Form white!updateWindowLoc: w	w = windowRect ifFalse: [currY _ w top].	^super updateWindowLoc: w! !UTime comment:'Copyright (c) Xerox Corporation, 1985, 1986.UTime stands for Universal Time.  It is a combination of the class Time and the class Date.  Each instance variable holds the corresponding class.  The user then may compare, and do arithmetic on two universal time.  It is mainly used in the Animation package to figure out the time for simulation.Instance Variables========time	it should be an instance of the class Time which keeps track of the time.date		it should be an instance of the class Date which keeps track of the date.'!!UTime methodsFor: 'accessing'!date	^date!date: aDate	date _ aDate!time	^time!time: aTime	time _ aTime! !!UTime methodsFor: 'comparing'!< aUTime	"return true if the object is not a date, as a default behavior to handle unknown dates and times"	self species = aUTime species ifFalse: [^true].	date = aUTime date ifTrue: [^time < aUTime time].	^date < aUTime date!<= aUTime	"return true if the object is not a date, as a default behavior to handle unknown dates and times"	self species = aUTime species ifFalse: [^true].	date = aUTime date ifTrue: [^time <= aUTime time].	^date <= aUTime date!= aUTime	"Answer whether aUTime is the same as the receiver."	self species = aUTime species		ifTrue: [^(date = aUTime date and: [time = aUTime time])]		ifFalse: [^false]!> aUTime	"return true if the object is not a date, as a default behavior to handle unknown dates and times"	self species = aUTime species ifFalse: [^true].	date = aUTime date ifTrue: [^time > aUTime time].	^date > aUTime date!>= aUTime	"return true if the object is not a date, as a default behavior to handle unknown dates and times"	self species = aUTime species ifFalse: [^true].	date = aUTime date ifTrue: [^time >= aUTime time].	^date >= aUTime date! !!UTime methodsFor: 'arithmetic'!addDays: dayCount 	"Answer a new Date that is dayCount more days than the receiver."	date _ date addDays: dayCount!addMinutes: timeAmount 	| total |	timeAmount < 0		ifTrue: [self subtractMinutes: timeAmount]		ifFalse: 			[total _ time asSeconds + (timeAmount * 60).			[total >= 86400]				whileTrue: 					[self addDays: 1.					total _ total - 86400].			time _ Time fromSeconds: total]!addTime: timeAmount 	| total |	total _ time asSeconds + timeAmount asSeconds.	[total >= 86400]		whileTrue: 			[self addDays: 1.			total _ total - 86400].	time _ Time fromSeconds: total!subtractBy: aUTime 	"it will return the interval in minutes"	self > aUTime		ifTrue: [date = aUTime date				ifTrue: [^time asSeconds - aUTime time asSeconds / 60]				ifFalse: [^(date subtractDate: aUTime date)						- 1 * 1440 + (time asSeconds + (86400 - aUTime time asSeconds) / 60)]]		ifFalse: [date = aUTime date				ifTrue: [^aUTime time asSeconds - time asSeconds / 60]				ifFalse: [^(aUTime date subtractDate: date)						- 1 * 1440 + (aUTime time asSeconds + (86400 - time asSeconds) / 60)]]!subtractDate: aUTime 	"Answer the number of days between the receiver and aDate."	^date subtractDate: aUTime date!subtractDays: dayCount 	"Answer a new Date that is dayCount more days than the receiver."	date _ date subtractDays: dayCount!subtractMinutes: timeAmount 	| total |	total _ time asSeconds - (timeAmount * 60).	[total < 0]		whileTrue: 			[self subtractDays: 1.			total _ total + 86400].	time _ Time fromSeconds: total! !!UTime methodsFor: 'printing'!printOn: aStream	time printOn: aStream.	aStream nextPutAll: ' on '.	date printOn: aStream!storeOn: aStream	time storeOn: aStream.	aStream nextPutAll: ' on '.	date storeOn: aStream! !!UserProfile methodsFor: 'accessing'!connectName	"Answer the user's current connect name, without any registry extension."	connectName isNil ifTrue: [^String new].	^connectName!connectPassword	"Answer the user's current connect password."	connectPassword isNil ifTrue: [^String new].	^connectPassword!domain	domainAndOrg == nil ifTrue: [domainAndOrg _ Array with: String new with: String new].	^domainAndOrg at: 1!fileServerChoices	fileServerChoices == nil ifTrue: [fileServerChoices _ OrderedCollection new].	^fileServerChoices!organization	domainAndOrg == nil ifTrue: [domainAndOrg _ Array with: String new with: String new].	^domainAndOrg at: 2!printerChoices	printerChoices == nil ifTrue: [printerChoices _ OrderedCollection new].	^printerChoices!userPassword	"Answer the user's Grapevine password."	userPassword isNil ifTrue: [^String new].	^userPassword!userRName	"Answer the user's Grapevine name with the registry extension."	self registry notNil		ifTrue:	[^self userName, (String with: $.), self registry]		ifFalse:	[^self userName]! !!UserProfile methodsFor: 'altering'!addFileServer: aFSname	fileServerChoices == nil ifTrue: [fileServerChoices _ OrderedCollection new].	(fileServerChoices includes: aFSname) ifFalse: [fileServerChoices addLast: aFSname]!addPrinter: aPrinterName	"UserProfile current addPrinter: 'Idaho'"	printerChoices == nil ifTrue: [printerChoices _ OrderedCollection new].	(printerChoices includes: aPrinterName) ifFalse: [printerChoices addLast: aPrinterName]!clearItAll	userPassword _ connectPassword _ userName _ fileServerChoices _ printerChoices _ nil.!connect	"Prompt the user for a connect-name and password."	| pt name password |	FillInTheBlank		request: 'Connect name' 		displayAt: (pt _ Sensor cursorPoint)		centered: true		action: [:name] 		initialAnswer: self connectName.	FillInTheBlank		requestPassword: 'password for <', name, (String with: $>)		displayAt: pt		centered: true		action: [:password] 		initialAnswer: self connectPassword.	self connect: name password: password!connect: name	"Change the current connect name."	self connect: name password: String new!domain: domain organization: organization	domainAndOrg _ Array with: domain with: organization!login	| labels return defaults | 	labels _ #(#(Name:) #(Password: ) #(Domain:) #(Organization:)).	domainAndOrg == nil ifTrue: [domainAndOrg _ Array with: String new with: String new].	defaults _ Array with: self localUserName with: self userPassword with: (domainAndOrg at: 1) with: (domainAndOrg at: 2).	(Smalltalk includesKey: #DBoxView)		ifFalse:			[return _ Array new: 4.			1 to: 4 do: [:i |				FillInTheBlank					request: ((labels at: i) at: 1)					displayAt: Sensor cursorPoint					centered: true					action: [:answer] 					initialAnswer: (defaults at: i)					useCRController: true					style: (i = 2 ifTrue: [TextStyle passwordStyle] ifFalse: [TextStyle default]).				return at: i put: answer]]		ifTrue:			[return _ DBoxView				openFor: #(fill password fill fill)				title: ('Log in to remote host')				labels: labels				defaults: defaults				autoAccept: true.			return == nil ifTrue: [^nil]].	self domain: (return at: 3) organization: (return at: 4).	self login: (return at: 1) password: (return at: 2).	^return!selectFileServer	"UserProfile current selectFileServer"	| return labelString menu fsLabels defaultName | 	fsLabels _ OrderedCollection new.	fsLabels addAll: self fileServerChoices; addLast: #none; addLast: #other.	(Smalltalk includesKey: #DBoxView)		ifFalse:			[labelString _ fsLabels at: fsLabels size.			(fsLabels size - 1 to: 1 by: -1) do: [:i | labelString _ (fsLabels at: i), (String with: Character cr), labelString].			menu _ ActionMenu labels: labelString selectors: fsLabels asArray.			menu selectionIndex: (menu selectors indexOf: ifsName).			return _ Array new: 2.			return at: 1 put: (menu selectorAt: (menu startUp: #any withHeading: 'Set File Server Name')).			(return at: 1) = #other ifTrue:				[return at: 2 put: (FillInTheBlank request: 'Please type a fully qualified fileServer name' default: ifsName)]]		ifTrue:			[defaultName _ (ifsName == nil ifTrue: [fsLabels at: 1] ifFalse: [ifsName]).			fsLabels addFirst: 'File Server Name:'.			return _ DBoxView				openFor: #(select fill)				title: 'Set File Server Name'				labels: (Array with: fsLabels with: (Array with: 'Fully qualified name:'))				defaults: (Array with: (Array with: defaultName) with: 'other name')				commands: #(accept cancel bailOut)				autoAccept: true				links: (Array with: (Array with: 1@(fsLabels size - 1) with: 2@1)).			return == nil ifTrue: [^nil]].	((return at: 1) = #none or: [(return at: 1) = #other])		ifFalse: [^ifsName _ return at: 1].	(return at: 1) = #other ifTrue:		[(return at: 2) isEmpty ifFalse:			[self addFileServer: (ifsName _ return at: 2).			^ifsName]].	^ifsName _ nil!selectPrinter	"UserProfile current selectPrinter"	| printerLabels return labelString menu | 	printerLabels _ OrderedCollection new.	printerLabels addAll: self printerChoices; addLast: #none; addLast: #other.	(Smalltalk includesKey: #DBoxView)		ifFalse:			[labelString _ printerLabels at: printerLabels size.			(printerLabels size - 1 to: 1 by: -1) do: [:i | labelString _ (printerLabels at: i), (String with: Character cr), labelString].			menu _ ActionMenu labels: labelString selectors: printerLabels asArray.			menu selectionIndex: (menu selectors indexOf: self printerName).			return _ Array new: 2.			return at: 1 put: (menu selectorAt: (menu startUp: #any withHeading: 'Set Printer Name')).			(return at: 1) = #other ifTrue:				[return at: 2 put: (FillInTheBlank request: 'Please type a fully qualified printer name' default: self printerName)]]		ifTrue:			[printerLabels addFirst: 'Printer Name:'.			return _ DBoxView				openFor: #(select fill)				title: 'Set Printer Name'				labels: (Array with: printerLabels with: (Array with: 'Fully qualified name:'))				defaults: (Array with: (Array with: self printerName) with: 'other name')				commands: #(accept cancel bailOut)				autoAccept: true				links: (Array with: (Array with: 1@(printerLabels size - 1) with: 2@1)).			return == nil ifTrue: [^self printerName]].	((return at: 1) = #none or: [(return at: 1) = #other])		ifFalse: [^printerName _ return at: 1].	(return at: 1) = #other ifTrue:		[(return at: 2) isEmpty ifFalse:			[self addPrinter: (printerName _ return at: 2).			^printerName]].	^printerName _ nil!userName: name	"Change the user's Grapevine name. If name contains a '.' the registry will also be set."	self login: name password: self userPassword!userPassword: password	userPassword _ password! !User comment:'Copyright (c) 1987 Xerox Corporation.  All rights reserved.'!ClipEntry comment:'Copyright (c) 1986 Xerox Corporation.  All rights reserved.'!!ClipEntry methodsFor: 'initialize-release'!initialize! !!ClipEntry methodsFor: 'accessing'!contents	^contents!contents: anObject	contents _ anObject.	(anObject isKindOf: String)				ifTrue: [form _ (anObject contractTo: 40)								borderWidth: 1]				ifFalse: [(anObject isKindOf: Text)						ifTrue: [form _ (anObject string contractTo: 40) asForm 										borderWidth: 1]						ifFalse: [form _ (anObject printString contractTo: 40) asForm 										borderWidth: 1]]!form	^form!form: aForm	form _ aForm!printOn: aStream	(contents isKindOf: String)				ifTrue: [aStream nextPutAll: (contents contractTo: 40)]				ifFalse: [(contents isKindOf: Text)						ifTrue: [aStream nextPutAll: (contents string contractTo: 40)]						ifFalse: [aStream nextPutAll: (contents printString contractTo: 40)]]!properties	^properties!propertyAt: anObject	properties == nil ifTrue:[^nil].	^properties at: anObject ifAbsent: [^nil]!propertyAt: anObject put: anotherObject	properties == nil ifTrue:[properties _ OopConservingDictionary new].	properties at: anObject put: anotherObject! !!ClipEntry methodsFor: 'testing'!= anEntry	anEntry class == ClipEntry ifFalse:[^false].	^contents = anEntry contents & (properties = anEntry properties)! !!ClipEntry methodsFor: 'display'!display	form displayOn: Display!erase	Display fill: (form computeBoundingBox translateBy: form offset)		rule: Form over		mask: Form screen! !!NonprogrammerMessages methodsFor: 'initialize-release'!fullMessageList: anArrayedCollection	fullMessageList _ anArrayedCollection!restrictedMessageList: anArrayedCollection	restrictedMessageList _ anArrayedCollection! !!NonprogrammerMessages methodsFor: 'accessing'!at: aSymbol	^self appropriateMessageList at: aSymbol! !!NonprogrammerMessages methodsFor: 'private'!appropriateMessageList	^(NonprogrammerMenu inhibitProgramming)		ifTrue: [restrictedMessageList]		ifFalse: [fullMessageList]! !BackgroundPrinter comment:'Copyright (c) Xerox Corporation, 1985, 1986. All rights reserved.pressFileCreated - a Boolean that indicates if the press file has already been created - if it has then just send it to printer.sendToPrinter - can be either:		nil - in which case it is not supposed to be sent to the printer now, or		aString - in which case it is the name of the printer to send to.numCopies - an Integer which is the number of copies to send to the printer.pressFileName - can be either:		aString - in which case it is the name of the press file, or		anArray - in which case it is ContainerModel''s array for filing away.pressPrinter - an instance of PressPrinter on pressFileName.startPage - an Integer which is the number to make the first page in the file.applicData - data stored by the application to be used by it in creation of the press file.applicClass - the name of the class to send the message hardcopyUsingBP:  with this instance of BackgroundPrinter as an argument.applicAnswers - the answers resulting from whatever questions were requested to be asked by the instance creation method askQuestions:.BackgroundDeque - a SharedDeque - this is the queue of instances of BackgroundPrinter.BackgroundProcess - the process which goes through the queue, sending the message heresYourChance to each BP in it.CurrentInstance - the instance of BackgroundPrinter currently in execution.ImagePressRect - a Rectangle somewhat different from PressPrinter DefaultPageRectangle.MouseForm - a Form that represents the mouse with no keys pressed.OnButtonForm - a Form that represents one pressed key on the mouse.ProcessState - the state of the BackgroundProcess where dead = 0; active = 1; suspended = 2. Only keep here because seems to be no easy way to get this from the process.RunAsForeground - a Boolean, normally false but can set to true to cause it to go in foreground - not using the background process.DequeProtect - an Array of two, wherein 1 is a Boolean indicating whether protection is on or off, and 2 is a Semaphore for any process(s) to wait until protection is turned off.'!!BackgroundPrinter methodsFor: 'initialize'!askQuestions: questionArray	| default types labels answers class infoCenter | 	default _ OrderedCollection new.	types _ OrderedCollection new.	labels _ OrderedCollection new.	self standardDBoxBasicDefault: default types: types labels: labels.	default addAllLast: (questionArray at: 1).	types addAllLast: (questionArray at: 2).	labels addAllLast: (questionArray at: 3).	answers _ DBoxView openFor: types labels: labels defaults: default.	questionArray size > 3 ifTrue: [class _ questionArray at: 4. infoCenter _ questionArray at: 5].	answers _ self standardDBoxBasicDecodeAnswers: answers withDefaults: default fileAtClass: class in: infoCenter.	applicAnswers _ answers.	answers == nil		ifTrue: [^nil] "bailed out"		ifFalse: [^self]!queueData: aData callOnTurn: aClass	applicData _ aData.	applicClass _ aClass.		RunAsForeground		ifTrue: [self runAsForeground]		ifFalse: [self class putInBackground: self]!sendPressFile: aFileName toPrinter: aPrinterName numCopies: copies	pressFileName _ Array with: (DataItem type: #Item label: aFileName filename: aFileName atIndex: 0).	UserProfile current printerName: (sendToPrinter _ aPrinterName).	numCopies _ copies.	pressFileCreated _ true!standardDBoxBasicDecodeAnswers: answers withDefaults: defaults fileAtClass: class in: infoCenter	"make sure answers are legit for the basic stuff and store the results"	| temp aSuitcase |	answers == nil ifTrue: [^nil].	1 to: 5 do: [:i | (answers at: i) == nil ifTrue: [answers at: i put: (defaults at: i)]].	numCopies _ (answers at: 3) asString isNumeric ifTrue: [(answers at: 3) asNumber asInteger] ifFalse: [1].	numCopies = 0 ifTrue: [answers at: 1 put: #later. numCopies _ 1].	((answers at: 1) = #now) ifTrue:		[((answers at: 5) ~= nil and: [(answers at: 5) ~= String new])			ifTrue: [UserProfile current printerName: (sendToPrinter _ answers at: 5)]].	pressFileCreated _ false.	(((answers at: 2) = #no) and: [sendToPrinter ~= nil])		ifTrue: [pressFileName _ #Temp asString]		ifFalse:			[aSuitcase _ Suitcase new packTheSuitcaseFrom: infoCenter forItem: (DataItem locked: false classification: (class == nil ifTrue: [1] ifFalse: [class classification]) modifiers: (class == nil ifFalse: [class modifiers]) type: #Item label: 'HardcopyItem' filename: nil bPointers: nil fPointers: nil atIndex: 0).			((pressFileName _ InformationCenter fileNameData: nil defaultSuitcase: aSuitcase defaultKeys: PressOrInterpress asLowercase asString askMethod: false askClass: false) at: 1) == nil				ifTrue: [self booboo: 'Insufficient info - aborting print sequence'. ^nil]].	startPage _ (answers at: 4) asString isNumeric ifTrue: [(answers at: 4) asNumber asInteger] ifFalse: [1].	temp _ answers asOrderedCollection.	5 timesRepeat: [defaults removeFirst. temp removeFirst].	"shorten to what others added"	^temp!standardDBoxBasicDefault: default types: types labels: labels 	"pass in ordered collections to add to for defaults, types, and labels"	default		add: #now;		add: #no;		add: (String with: $1);		add: (String with: $1);		add: UserProfile current printerName.	types addAllLast: #(select select fill fill fill).	labels addAllLast:		#(#('Send to Printer' now later)		   #('File in an info center' yes no)		   #('Number Copies')		   #('Starting Page No.')		   #('Printer Name'))! !!BackgroundPrinter methodsFor: 'printing'!createPressFile	PressOrInterpress == #Press		ifTrue: [self pressFileCreation]		ifFalse: [self interpressFileCreation]!heresYourChance	| actualFileName fileStream |	actualFileName _ self pressFileName.	pressFileCreated ifFalse:		[actualFileName _ Disk makeNewFileName: actualFileName withSuffix: (DataMaster giveMe: #suffixString for: PressOrInterpress asLowercase).		 self class messenger show: 'Creating ', actualFileName.		 pressPrinter _ (FileStream fileNamed: actualFileName) asPressPrinter.		 pressPrinter startAtPageNo: startPage.		PressOrInterpress == #Interpress			ifTrue: [pressPrinter margins: ImagePressRect.					pressPrinter lineGrid: "TextStyle default lineGrid"16 * 16].		 applicClass hardcopyUsingBP: self.		 pressPrinter close.		 self pressFileName: actualFileName].	(pressFileCreated and: [sendToPrinter ~= nil]) ifTrue:		[pressPrinter _ applicData _ applicClass _ applicAnswers _ nil. "no longer needed"		 (sendToPrinter isKindOf: String)			ifTrue:				[fileStream _ FileStream fileNamed: actualFileName. 		 		sendToPrinter _ fileStream readOnly toPrinter: sendToPrinter numOfCopies: numCopies numTries: 2 sendMsgsTo: self class messenger]			ifFalse: "assume it's a print packet"				[sendToPrinter _ sendToPrinter checkProgressAndShowOn: self class messenger]. 		 (sendToPrinter isKindOf: Symbol)			ifTrue: [((pressFileName isKindOf: String) and: [sendToPrinter == #done])						ifTrue: [Disk removeKey: pressFileName]]			ifFalse: [BackgroundPrinter putInBackground: self]]		ifFalse: [self class messenger show: 'Done Creating ', actualFileName]!printFormOrFileName: formOrFileName withCaption: theCaption landscape: landscapeOrient fullSize: fSize border: brdr alignMark: align	| theForm landscape pressScale fullSize arr | 	"theForm is a form or name of a file containing a form;	  theCaption is a string or nil"	theForm _ (formOrFileName isKindOf: Form)				ifTrue: [formOrFileName]				ifFalse: [Form readFrom: (self class getFileName: formOrFileName)].	landscape _ landscapeOrient.	fullSize _ fSize.	pressScale _ PressOrInterpress == #Interpress		ifTrue: [fullSize ifTrue: [16] ifFalse: [8]]		ifFalse: [fullSize ifTrue: [32] ifFalse: [16]].	arr _ self class fittingOf: theForm extent boundedBy: self class defaultDoverRectangle fullSize: fSize.	(arr at: 1) = fSize ifFalse: [pressScale _ pressScale // 2].	(arr at: 2) ifTrue: [landscape _ true].	brdr ifTrue: [theForm borderWidth: 2].	PressOrInterpress == #Press		ifTrue: [self pressForm: theForm withCaption: theCaption landscape: landscapeOrient scale: pressScale alignMark: align]		ifFalse: [self interpressForm: theForm withCaption: theCaption landscape: landscapeOrient scale: pressScale alignMark: align]	"theForm is a form or name of a file containing a form;	  theCaption is a string or nil"!putAnnoText: aText withoutAnnoDict: aDictionary	"Search for annotation codes in aText, and omit those annotation codes from aText. Put the result in press file."	| sourceText stream character nextCharacter startAnnotation omitPosArray annoString |	aText isEmpty ifTrue: [^self].	sourceText _ aText copy. 	omitPosArray _ OrderedCollection new.	stream _ ReadStream on: sourceText.	[stream atEnd] whileFalse: "creates an array of pairs of annotation positions"		[character _ stream next.		 character = $: ifTrue: 			[nextCharacter _ stream next.	"search for ::"			 nextCharacter = $: ifTrue: 				[startAnnotation _ stream position - 1.				 stream skipTo: $:.				 stream skipTo: $:.				 omitPosArray add: (Array with: startAnnotation with: stream position)]]].	omitPosArray reverseDo: [:posPair |		annoString _ sourceText string copyFrom: posPair first to: posPair last.		(aDictionary includesKey: annoString) ifTrue:			[sourceText				replaceFrom: posPair first				to: posPair last				with: Text new]].	pressPrinter putText: sourceText!runAsForeground	BackgroundController backgroundAccess.	self heresYourChance.	self class cleanUpAfter! !!BackgroundPrinter methodsFor: 'user interface'!changeWhenOrWhere	| default answers |	default _ OrderedCollection new.	sendToPrinter == nil		ifTrue: [default add: #later; add: UserProfile current printerName]		ifFalse: [default add: #now; add: ((sendToPrinter isKindOf: String) ifTrue: [sendToPrinter] ifFalse: [sendToPrinter printerName])].	default add: numCopies printString.	answers _ DBoxView			openFor: #(select fill fill)			labels: #(#('Send to Printer' now later) 					  #('Printer Name')					  #('Number Copies'))			defaults: default.	answers == nil ifTrue: [^self].	1 to: 3 do: [:i | (answers at: i) == nil ifTrue: [answers at: i put: (default at: i)]].	(answers at: 3) asString isNumeric		ifTrue: [numCopies _ (answers at: 3) asNumber asInteger].	(((answers at: 1)  = #now) and: [(answers at: 2) ~= nil and: [(answers at: 2) ~= String new]])		ifTrue: [sendToPrinter _ ((sendToPrinter isKindOf: String)					ifTrue: [answers at: 2]					ifFalse: [sendToPrinter printerName: (answers at: 2) numCopies: numCopies])]		ifFalse: [sendToPrinter _ nil]	.!showSelf	self booboo:		'Press file name: ', self pressFileName,		(pressFileCreated ifTrue: [' has been created.'] ifFalse: [' not yet created.']),		(String with: Character cr),		((sendToPrinter isKindOf: String)			ifTrue: ['Will send to printer ', sendToPrinter]			ifFalse:				[sendToPrinter == nil					ifTrue: ['Will save in info center']					ifFalse: ['Sending to printer ', sendToPrinter printerName, (String with: $ ), sendToPrinter lastStatus]])! !!BackgroundPrinter methodsFor: 'access'!applicAnswers	^applicAnswers!applicData	^applicData!checkRemovalOfSending	((pressFileCreated and: [sendToPrinter ~= nil]) and: [sendToPrinter isKindOf: PrintFrom1108])		ifTrue: [sendToPrinter commitSuicide]!pressFileCreated: aBoolean	pressFileCreated _ aBoolean!pressFileName	(pressFileName isKindOf: String) ifTrue: [^pressFileName]	.	^(pressFileCreated		ifTrue: [(pressFileName at: 1) filename]		ifFalse: [(pressFileName at: 1) label])!pressFileName: actualFileName	(pressFileName isKindOf: String)		ifTrue: [pressFileName _ actualFileName]		ifFalse:			[(pressFileName at: 1) filename: actualFileName.			InformationCenter putFileNameAway: pressFileName]!pressPrinter	^pressPrinter!startPage	^startPage! !!BackgroundPrinter methodsFor: 'press printing'!pressAlignMarkForFormExtent: formExtent landscape: landscape	"put an alignment mark on the press file at the top middle of a rectangle of extent formExtent which is centered on the page;	 formExtent is in printer units already"	| thePoint |	thePoint _ ImagePressRect center.	thePoint y: thePoint y + (landscape ifTrue: [formExtent x//2] ifFalse: [formExtent y//2]).	pressPrinter pressFile		setPoint: thePoint;		showCharacters: 5;		nextPutAll: '<==<<'!pressAnnoText: theText withAnnoDict: annoDict	| annotation orderedKeys | 	pressPrinter putText: theText.	(annoDict == nil or: [annoDict isEmpty]) ifFalse: 		[pressPrinter			nextPage;	"new page for appendix"			emphasis: 4; cr;	"12 point bold" 			nextPutAll: 'APPENDIX';			emphasis: 1.	"10 point normal"		 orderedKeys _ annoDict keys asSortedCollection.		 orderedKeys do: [:key |			annotation _ (annoDict at: key).			(annotation isKindOf: Text) ifFalse:				[annoDict at: key put: (Object readFrom: (ReadStream on: annotation)).				 annotation _ annoDict at: key].			 pressPrinter				emphasis: 2; cr;				nextPutAll: key;				emphasis: 1;				putText: annotation]]!pressComment: aString outsideRect: usedExtent landscape: landscape	| commentText maxLength commentOrigin commentWidth thePressFile |	thePressFile _ pressPrinter pressFile.	maxLength _ landscape		ifTrue: [ImagePressRect height]		ifFalse: [ImagePressRect width].	commentText _ Text string: aString emphasis: 4.	[commentWidth _ (Paragraph usingPrinterWidthsText: commentText) width.	 commentWidth > maxLength] whileTrue:	"truncate it"			[commentText _ commentText copyFrom: 1 to: commentText size - 1].	commentOrigin _ ImagePressRect center.	landscape		ifTrue:			[commentOrigin x: commentOrigin x + (usedExtent y // 2) + 800.			 commentOrigin y: commentOrigin y - (commentWidth//2) rounded.			 thePressFile selectFontName: 'TimesRoman12' rotation: 5400]		ifFalse:			[commentOrigin x: commentOrigin x - (commentWidth//2) rounded.			 commentOrigin y: commentOrigin y - (usedExtent y // 2) - 800.			 thePressFile selectFontName: 'TimesRoman12' rotation: 0].		thePressFile		setPoint: commentOrigin;		printString: commentText string;		selectFontName: 'TimesRoman10' rotation: 0	"reset"!pressFileCreation	| nextPageNeeded | 	"this is essentially the old BackgroundPrinter. It expects applicData from: 2 to: ? to contain the values in order:2 - formsOrFileNames - an array containing forms, or fileNames of forms, or nil if none.3 - captionList - an array containing a string or nil for each item in formsOrFileNames.4 - fullSize - a Boolean which is true if all forms should try to print fullSize.5 - landscapeOrientation - a Boolean which is true if all forms should be printed landscape.6 - border - a Boolean which is true if all forms should be bordered.7 - alignMark - a Boolean which is true if all forms should be printed with an alignMark.8 - text - text to print or nil if none.9 - textAnnoDict - annotation dictionary, nil if none.10 - printAnnos - a Boolean which is true if the annoDictionary should be printed.11 - headingText - nil or an array of three containing the classification, major head, and minor head"	(applicData at: 11) == nil ifFalse: [pressPrinter useHeadings: (applicData at: 11)].	nextPageNeeded _ false.	(applicData at: 8) == nil		ifFalse:			[(applicData at: 10)				ifTrue: [self pressAnnoText: (applicData at: 8) withAnnoDict: (applicData at: 9)]				ifFalse: [self putAnnoText: (applicData at: 8) withoutAnnoDict: (applicData at: 9)].			nextPageNeeded _ true].	(applicData at: 2) == nil ifFalse:		[1 to: (applicData at: 2) size do: [:i |			nextPageNeeded ifTrue: [pressPrinter nextPage] ifFalse: [nextPageNeeded _ true].			self printFormOrFileName: ((applicData at: 2) at: i) withCaption: ((applicData at: 3) at: i) landscape: (applicData at: 5) fullSize: (applicData at: 4) border: (applicData at: 6) alignMark: (applicData at: 7)]].	pressFileCreated _ true!pressForm: theForm withCaption: theCaption landscape: landscape scale: pressScale alignMark: align	"theForm is a form or name of a file containing a form;	  theCaption is a string or nil"	pressPrinter pressFile		scale: pressScale;		setPoint: (ImagePressRect center - ((landscape ifTrue: [theForm extent transpose // 2] ifFalse: [theForm extent // 2]) * pressScale));		printForm: theForm opaque: false landscape: landscape.	(theCaption == nil or: [theCaption isEmpty])		ifFalse: [self pressComment: theCaption outsideRect: theForm extent * pressScale landscape: landscape].	align ifTrue: [self pressAlignMarkForFormExtent: theForm extent * pressScale landscape: landscape]! !!BackgroundPrinter methodsFor: 'interpress printing'!interpressAlignMarkForFormExtent: formExtent landscape: landscape	"put an alignment mark on the press file at the top middle of a rectangle of extent formExtent which is centered on the page;	 formExtent is in printer units already"	| thePoint |	thePoint _ ImagePressRect center.	landscape ifTrue: [thePoint _ thePoint transpose].	thePoint y: thePoint y - (formExtent y//2).	pressPrinter lineText: '<==<<' font: nil setPos: thePoint!interpressAnnoText: theText withAnnoDict: annoDict	| annotation orderedKeys annoText crText | 	pressPrinter putText: theText.	(annoDict == nil or: [annoDict isEmpty]) ifFalse: 		[orderedKeys _ annoDict keys asSortedCollection.		crText _ Text string: (String with: Character cr) emphasis: 1.		annoText _ Text fromString: String new.		orderedKeys do: [:key |			annotation _ annoDict at: key.			(annotation isKindOf: Text) ifFalse:				[annoDict at: key put: (Object readFrom: (ReadStream on: annotation)).				 annotation _ annoDict at: key].			annotation _ crText, annotation.			(annotation at: annotation size) = Character cr				ifFalse: [annotation _ annotation, crText].			annotation _ annotation, crText.			annoText _ annoText, (Text string: key emphasis: 2), annotation].		pressPrinter putText: annoText withHeading: 'APPENDIX'].!interpressComment: aString outsideRect: usedExtent landscape: landscape	| commentText maxLength commentOrigin commentWidth fontIndex |	maxLength _ landscape		ifTrue: [ImagePressRect height]		ifFalse: [ImagePressRect width].	commentText _ Text string: aString emphasis: 4.	[commentWidth _ (Paragraph usingPrinterWidthsText: commentText) width * 16.	 commentWidth > maxLength] whileTrue:	"truncate it"			[commentText _ commentText copyFrom: 1 to: commentText size - 1].	commentOrigin _ ImagePressRect center.	landscape ifTrue: [commentOrigin _ commentOrigin transpose].	commentOrigin x: commentOrigin x - (commentWidth//2) rounded.	commentOrigin y: commentOrigin y + (usedExtent y // 2) + 400.	fontIndex _ TextStyle getNumForStrikeFont: 'TimesRoman12'.	pressPrinter lineText: commentText string font: fontIndex setPos: commentOrigin.!interpressFileCreation	"For detail, see comments in pressFileCreation."	(applicData at: 11) == nil ifFalse: [pressPrinter heading: (applicData at: 11)].	pressPrinter beginPageBodies.	(applicData at: 8) == nil		ifFalse:			[(applicData at: 10)				ifTrue: [self interpressAnnoText: (applicData at: 8) withAnnoDict: (applicData at: 9)]				ifFalse: [self putAnnoText: (applicData at: 8) withoutAnnoDict: (applicData at: 9)]].	(applicData at: 2) == nil ifFalse:		[1 to: (applicData at: 2) size do: [:i |			self printFormOrFileName: ((applicData at: 2) at: i) withCaption: ((applicData at: 3) at: i) landscape: (applicData at: 5) fullSize: (applicData at: 4) border: (applicData at: 6) alignMark: (applicData at: 7)]].	pressPrinter endPageBodies.	pressFileCreated _ true!interpressForm: theForm withCaption: theCaption landscape: landscape scale: pressScale alignMark: align	| usedExtent formOrigin | 	"theForm is a form or name of a file containing a form;	  theCaption is a string or nil"	landscape ifTrue: [pressPrinter marginsTranspose].	pressPrinter beginOnePageBodyLandscape: landscape.	usedExtent _ theForm extent * pressScale.	formOrigin _ ImagePressRect center.	landscape ifTrue: [formOrigin _ formOrigin transpose].	formOrigin x: formOrigin x - (usedExtent x//2) rounded.	formOrigin y: formOrigin y - (usedExtent y // 2).	pressPrinter printFullForm: theForm				scale: pressScale@pressScale				setPos: formOrigin.	(theCaption == nil or: [theCaption isEmpty])		ifFalse: [self interpressComment: theCaption outsideRect: usedExtent landscape: landscape].	align ifTrue: [self interpressAlignMarkForFormExtent: usedExtent landscape: landscape].	pressPrinter endOnePageBody.! !RS232Kermit comment:'Copyright (c) Xerox Corporation, 1986.'!!RS232Kermit methodsFor: 'initialize-release'!defaultSettings	"Set the settings dictionary up with the standard Kermit defaults.  See the Kermit Protocol Manual for further information."	settings _ OopConservingDictionary new.	"maximum packet length"	settings at: #MyMaxL put: 94.	settings at: #YourMaxL put: 94.	"time out in seconds"	settings at: #MyTimeOut put: 13.	settings at: #YourTimeOut put: 13.	"number of pad characters"	settings at: #MyNPad put: 0.	settings at: #YourNPad put: 0.	"pad character"	settings at: #MyPadC put: 32.	settings at: #YourPadC put: 32.	"end of line character"	settings at: #MyEOL put: 13.			"Character cr asciiValue"	settings at: #YourEOL put: 13.	"control character prefix"	settings at: #MyQCtl put: 35. 			"$# asciiValue"	settings at: #YourQCtl put: 35.	"binary character prefix"	settings at: #MyQBin put: 38. 			"$& asciiValue"	settings at: #YourQBin put: 38.	"check type, defaults to standard one character check"	settings at: #MyChkt put: 49. 			"$1 asciiValue"	settings at: #YourChkt put: 49.	"repeat prefix, ignored so set to zero"	settings at: #MyRept put: 126. 	settings at: #YourRept put: 126.	"capability mask, not used on cms-kermit"	settings at: #MyCapas put: 0.	settings at: #YourCapas put: 0.!initialize	self defaultSettings.	timeout _ (settings at: #MyTimeOut) * 1000.!initWithSerialPort: aSerialPort displayMem: aDisplayMem	serialPort _ aSerialPort.	displayMem _ aDisplayMem.	seqNum _ 0.	lastPacketSent _ Array new: 3.	noData _ aSerialPort class NoData.	Cursor mouse show! !!RS232Kermit methodsFor: 'packet creation'!add: anInteger to: aByteArray at: anIndex 	anInteger > 127		ifTrue: 			["8 bit quoting"			aByteArray at: anIndex put: 38.			^self				add: anInteger - 128				to: aByteArray 				at: anIndex + 1]. 	(anInteger < 32 or:[(anInteger =35) | (anInteger =38) | (anInteger =126)]) ifTrue: [anInteger = 13			ifTrue: 				["charge CR to CRLF, as per Kermit standard"				aByteArray at: anIndex put: 35.				aByteArray at: anIndex+ 1 put: 77.				aByteArray at: anIndex+ 2 put: 35.				aByteArray at: anIndex + 3 put: 74.				^anIndex + 4]			ifFalse: 				["quote the control character"				aByteArray at: anIndex put: 35.				aByteArray at: anIndex + 1 put: (self ctl: anInteger).				^anIndex + 2]].	aByteArray at: anIndex put: anInteger.	^anIndex + 1!buildAckPacket	| packet |	packet _ self buildBasicPacketForLength: 0.	packet at: TypeLoc put: 89. "$Y asciiValue"	^packet!buildBasicPacketForLength: packetDataSize	"Return a blank packet with the header and trailer (except checksum) filled in"	| packet |	packet _ ByteArray new: packetDataSize + 6.	packet at: MarkLoc put: 1.	packet at: LenLoc put: (self charOf: packetDataSize + 3).	packet at: packet size put: 16r13. "xoff"	^packet!buildBinaryDataPacket	"load data into a data packet from ftpFileStream according to ftpFileType.     	  Return the packet"	| outStream nxt nVal packet aCollection remSize tempArray size patchByte |	remSize _ fileBytesRem min: 38.	aCollection _ fileStream next: remSize.	fileBytesRem _ fileBytesRem - remSize.	aCollection unpackBits: 4 into: (tempArray _ ByteArray new: (size _ remSize + 2 * 2)).	remSize even ifFalse: "then unpackBits missed the last byte"		[patchByte _ aCollection at: remSize.		tempArray at: remSize * 2 - 1 put: ((patchByte bitAnd: 16rF0) bitShift: -4).		tempArray at: remSize * 2 put: (patchByte bitAnd: 16r0F)].	1 to: tempArray size do: [:i | tempArray at: i put: (tempArray at: i) + 65].	tempArray at: size - 3 put: 35.	tempArray at: size - 2 put: 77.	tempArray at:size - 1 put: 35.	tempArray at: size put: 74.	packet _ self buildBasicPacketForLength: tempArray size.	packet at: TypeLoc put: 68.	"$D asciiValue"	packet		primReplaceFrom: TypeLoc + 1		to: TypeLoc + tempArray size		with: tempArray		startingAt: 1.	^packet!buildBreakPacket	| packet |	packet _ self buildBasicPacketForLength: 0.	packet at: TypeLoc put: 66. "$B asciiValue"	^packet!buildDataPacket	"load data into a data packet from ftpFileStream according to ftpFileType.     	 Return the packet"	| outStream nxt nVal packet aCollection n i |	aCollection _ ByteArray new: 100.	i _ 1.	n _ 0.	[i >= 88 or: [fileStream atEnd]]		whileFalse: 			[nxt _ fileStream next.			fileBytesRem _ fileBytesRem - 1.			fileStream peek = nxt				ifTrue: 					[n _ n + 1.					n > 93						ifTrue: 							[aCollection at: i put: 126.							aCollection at: i+1 put: (self charOf: n).							i _ self add: nxt to: aCollection at: i+2.							n _ 0]]				ifFalse: [n = 0						ifTrue: [i _ self add: nxt to: aCollection at: i]						ifFalse: 							[n < 4								ifTrue: [n + 1 timesRepeat: [i _ self add: nxt to: aCollection at: i]]								ifFalse: 									[aCollection at: i put: 126.									aCollection at: i+1 put: (self charOf: n).									i _ self add: nxt to: aCollection at: i+2.].							n _ 0]]].	i _ i - 1.	packet _ self buildBasicPacketForLength:  i.	packet at: TypeLoc put: 68.	"$D asciiValue"	packet		primReplaceFrom: TypeLoc + 1		to: TypeLoc + i		with: aCollection		startingAt: 1.	^packet!buildEOFPacket	| packet |	packet _ self buildBasicPacketForLength: 0.	packet at: TypeLoc put: 90. "$Z asciiValue"	^packet!buildErrorPacket: errorString 	| packet |	packet _ self buildBasicPacketForLength: errorString size.	packet at: TypeLoc put: 69. "$E asciiValue"	1 to: errorString size do: [:i | packet at: TypeLoc + i put: (errorString at: i) asciiValue].	^packet!buildFileHeaderPacket: fileName 	| packet |	packet _ self buildBasicPacketForLength: fileName size.	packet at: TypeLoc put: 70. "$F asciiValue 70"	1 to: fileName size do: [:i | packet at: TypeLoc + i put: (fileName at: i) asciiValue].	^packet!buildNackPacket	| packet |	packet _ self buildBasicPacketForLength: 0.	packet at: TypeLoc put: 78. "$N asciiValue"	^packet!buildSendAckPacket	| packet | 	packet _ self buildSendInitPacket.	packet at: TypeLoc put: $Y asciiValue.			"ack packet type"	^packet!buildSendInitPacket	| packet | 	packet _ self buildBasicPacketForLength: 9.	packet at: TypeLoc put: $S asciiValue.			"send initiate packet type"	packet at: TypeLoc+1 put: (self charOf: (settings at: #MyMaxL)).	packet at: TypeLoc+2 put: (self charOf: (settings at: #MyTimeOut)).	packet at: TypeLoc+3 put: (self charOf: (settings at: #MyNPad)).	packet at: TypeLoc+4 put: (self charOf: (settings at: #MyPadC)).	packet at: TypeLoc+5 put: (self charOf: (settings at: #MyEOL)).	packet at: TypeLoc+6 put: (settings at: #MyQCtl).	packet at: TypeLoc+7 put: (settings at: #MyQBin).	packet at: TypeLoc+8 put: (settings at: #MyChkt).	packet at: TypeLoc+9 put: (settings at: #MyRept).	^packet! !!RS232Kermit methodsFor: 'packet sending'!resendData: packet	"send a file data packet."	| response thisState |	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	self sendPacket: packet withSequence: seqNum.	thisState _ self readPacket.	thisState == $N ifTrue:			[seqNum = ((self sequenceOf: ReceivedPacket) - 1 \\ 64)	"NACK for next packet is like ACK for this one..."				ifTrue: [thisState _ $Y]						"so do stuff for Y"				ifFalse: [^$N]].								"NACK - resend packet"		thisState == $Y ifTrue:											"ACK"			[(self sequenceOf: ReceivedPacket) = seqNum ifFalse: [^state].	"wrong ACK, stay in S state and try again"			tries _ 0.												"reset counter"			seqNum _ seqNum + 1 \\ 64.							"advance packet count"			fileBytesRem = 0				ifTrue: [^$Z]										"EOF -- switch to Z"				ifFalse: [^$D]										"more data -- stay in D"			].		thisState == $E ifTrue:			[displayMem paintStringAsLine: (self dataOf: ReceivedPacket) asString.	"print the error message"			^$A].													"and abort"		thisState == false ifTrue: [^state].	"try again on timeout or mismatch checksum"		^$A!sendLastPacket	RetryLimit = (lastPacketSent at: 3)		ifTrue: [^self ftpError: 'None, lost, or bad connection' send: user not].	lastPacketSent at: 2 put: Time millisecondClockValue.	lastPacketSent at: 3 put: ((lastPacketSent at: 3) + 1).	"update retry count"	serialPort sendTextString: (lastPacketSent at: 1).!sendPacket: aPacket withSequence: anInteger	"put sequence num in aPacket, then send"	(XferCursors at: 2) show.	aPacket at: SeqLoc put: (self charOf: anInteger).	aPacket at: aPacket size - 1 put: (self checksumOfPacketToSend: aPacket).	lastPacketSent at: 1 put: aPacket.	lastPacketSent at: 3 put: 0.	self sendLastPacket! !!RS232Kermit methodsFor: 'packet reading'!clockByte: startTime	"Read a byte from the serialPort.  Answer the byte, or false in case of a timeout."	| byte |	[(byte _ serialPort nextByte) == noData]		whileTrue:			[Time millisecondClockValue - startTime > timeout ifTrue: [^false]].	"displayMem paint: (Character value: byte)."	^byte!doReadStart: startTime	"Read a packet from the serialPort into ReceivePacket.  Answer the packet type character, or false in case of timeout or invalid checksum."	"TODO -- here is where parity checking should probably happen"	| packet len num type cksum byte length |	(len _ self clockByte: startTime) == false ifTrue: [^false].		"fail on timeout"	len == 1 ifTrue: [^true].									"start over on mark"	length _ (self uncharOf: len) - 3.								"fix to length of data only"	length < 0 ifTrue:[self halt].	(num _ self clockByte: startTime) == false ifTrue: [^false].	"fail on timeout"	num == 1 ifTrue: [^true].									"start over on mark"	(type _ self clockByte: startTime) == false ifTrue: [^false].	"fail on timeout"	type == 1 ifTrue: [^true].									"start over on mark"	packet _ ByteArray new: length + 5.	packet at: 1 put: 1.				"mark byte"	packet at: 2 put: len.				"packet length"	packet at: 3 put: num.			"sequence number"	packet at: 4 put: type.			"packet type"	5 to: length + 4 do:		[:i |			(byte _ self clockByte: startTime) == false ifTrue: [^false].	"fail on timeout"			byte == 1 ifTrue: [^true].									"start over on mark"			packet at: i put: byte.		].	(cksum _ self clockByte: startTime) == false ifTrue: [^false].	"fail on timeout"	cksum == 1 ifTrue: [^true].									"start over on mark"	packet at: length + 5 put: cksum.	"checksum"	(self isValidPacket: packet) ifFalse: [^false].	ReceivedPacket _ packet.	^type asCharacter!readPacket	"Read a packet from the serialPort into ReceivePacket.  Answer the packet type character, or false in case of timeout or invalid checksum."	| startTime mark type |	startTime _ Time millisecondClockValue.			"reset timer"	(XferCursors at: 1) show.	[mark = 1] whileFalse:		[(mark _ self clockByte: startTime) == false ifTrue: [^false]].		"find packet start"	[(type _ self doReadStart: startTime) == true] whileTrue: [].	"start over at each mark"	type == false ifTrue: [^false].					"timeout or bogus checksum"	^type! !!RS232Kermit methodsFor: 'packet parsing'!dataOf: aPacket 	| inStream outStream nxt val n chr v |	inStream _ ReadStream on: (aPacket copyFrom: 5 to: aPacket size - 1).	outStream _ WriteStream on: (ByteArray new: aPacket size).	[inStream atEnd]		whileFalse: [inStream peek = 126				ifTrue: 					[inStream next.					n _ self uncharOf: inStream next.					chr _ self nextValFrom: inStream.					n timesRepeat: [outStream nextPut: chr]]				ifFalse: 					[v _ self nextValFrom: inStream.					v == nil ifFalse: [outStream nextPut: v]]].	inStream release.	state == $D & (fileType == $B)		ifTrue: [^self reconstruct: outStream contents]		ifFalse: [^(self stripLFs: outStream contents)]!isValidPacket: aPacket	^(self checksumOfPacket: aPacket) = (aPacket at: aPacket size)!nextValFrom: aStream 	| val nxt |	val _ aStream next.	val = 38		ifTrue: [val _ (self nextValFrom: aStream)						+ 128]		ifFalse: [val = 35				ifTrue: 					[nxt _ aStream next.					(nxt = 35 or: [nxt = 38 or: [nxt = 126]])						ifTrue: [val _ nxt]						ifFalse: [val _ self ctl: nxt]]].	^val!parseSendInitPacket: aPacket	settings at: #YourMaxL put: (self uncharOf: (aPacket at: TypeLoc+1)).	settings at: #YourTimeOut put: (self uncharOf: (aPacket at: TypeLoc+2)).	settings at: #YourNPad put: (self uncharOf: (aPacket at: TypeLoc+3)).	settings at: #YourPadC put: (self uncharOf: (aPacket at: TypeLoc+4)).	settings at: #YourEOL put: (self uncharOf: (aPacket at: TypeLoc+5)).	settings at: #YourQCtl put: (self uncharOf: (aPacket at: TypeLoc+6)).	settings at: #YourQBin put: (self uncharOf: (aPacket at: TypeLoc+7)).	settings at: #YourChkt put: (self uncharOf: (aPacket at: TypeLoc+8)).	settings at: #YourRept put: (self uncharOf: (aPacket at: TypeLoc+9)).	"settings at: #YourCapas put: (self uncharOf: (aPacket at: TypeLoc+1))."	"preceeding line for non-cms systems"!reconstruct: anArray 	| outStream i size val v2 carry |	outStream _ WriteStream on: (ByteArray new: anArray size // 2 + 1).	i _ 1.	size _ anArray size.	(carry _ carryByte == nil)		ifTrue: 			[val _ anArray at: i.			i _ i + 1]		ifFalse: 			[val _ carryByte.			carryByte _ nil].	[i <= size]		whileTrue: 			[val < 65				ifFalse: 					[v2 _ anArray at: i.					i _ i + 1.					outStream nextPut: val - 65 * 16 + v2 - 65].			i >= size ifFalse:[val _ anArray at: i].			i _ i + 1].	(size even & carry not) | (size even not & carry) ifTrue:[carryByte _ anArray last].	^outStream contents!sequenceOf: aPacket	^self uncharOf: (aPacket at: 3)!typeOf: aPacket	^Character value: (aPacket at: 4)! !!RS232Kermit methodsFor: 'send FSM'!sendBreak	"send a break (EOT) packet."	| response | 	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	self sendPacket: (self buildBreakPacket) withSequence: seqNum.	response _ self readPacket.	response = $N ifTrue: "NACK"		[seqNum == ((self sequenceOf: ReceivedPacket) - 1 \\ 64)	"NACK for next packet is like ACK for this one..."			ifTrue: [response _ $Y]									"so do stuff for Y"			ifFalse: [^state]].											"NACK -- stay in state"	response = $Y ifTrue: "ACK"		[(self sequenceOf: ReceivedPacket) = seqNum			"wrong ACK..."			ifFalse: [^state].											"...so stay in S state and try again"		tries _ 0.												"reset counter"		seqNum _ seqNum + 1 \\ 64.							"advance packet count"		^$C].													"switch to C"	response = $E ifTrue: "Error"		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.				"print the error message"		^$A].													"and abort"	response = false ifTrue:		[^state].									"try again on timeout or mismatch checksum"	^$A										"unknown response -- abort"!sendData	"send a file data packet."	| response packet |	fileType = $B ifTrue:[packet _ self buildBinaryDataPacket] ifFalse:[packet _ self buildDataPacket].	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	self sendPacket: packet withSequence: seqNum.	response _ self readPacket.	response = $N ifTrue: "NACK"		[seqNum = ((self sequenceOf: ReceivedPacket) - 1 \\ 64)	"NACK for next packet is like ACK for this one..."			ifTrue: [response _ $Y]									"...so do stuff for Y"			ifFalse: [^state]].										"NACK -- stay in state"	response = $Y ifTrue: "ACK"		[(self sequenceOf: ReceivedPacket) = seqNum			"wrong ACK..."			ifFalse: [^state].											"...so stay in S state and try again"		tries _ 0.												"reset counter"		seqNum _ seqNum + 1 \\ 64.							"advance packet count"		fileBytesRem = 0			ifTrue: [^$Z]										"EOF -- switch to Z"			ifFalse: [^$D]].										"more data -- stay in D"	response = $E ifTrue:		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.				"print the error message"		^$A].													"and abort"	response = false ifTrue:		[^state].										"try again on timeout or mismatch checksum"	[^$A]											"unknown response -- abort"!sendEOF	"send an End-Of-File packet."	| response | 	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	self sendPacket: (self buildEOFPacket) withSequence: seqNum.	response _ self readPacket.	response = $N ifTrue: "NACK"		[seqNum == ((self sequenceOf: ReceivedPacket) - 1 \\ 64)	"NACK for next packet is like ACK for this one..."			ifTrue: [response _ $Y]										"...so do stuff for Y"			ifFalse: [^state]].											"NACK -- stay in state"	response = $Y ifTrue: "ACK"										"ACK"		[(self sequenceOf: ReceivedPacket) = seqNum			"wrong ACK..."			ifFalse: [^state].											"...so stay in S state and try again"		tries _ 0.												"reset counter"		seqNum _ seqNum + 1 \\ 64.							"advance packet count"		false							"this could be changed to test if more files can be sent on this transfer"			ifTrue: [^$F]										"more files -- switch to F to send another"			ifFalse: [^$B]].										"no more files -- send break to end transfer"	response = $E ifTrue: "Error"		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.				"print the error message"		^$A].													"and abort"	response = false ifTrue:		[^state].									"try again on timeout or mismatch checksum"	^$A										"unknown response -- abort"!sendFileHeader	"send the file header packet."	| response | 	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	self sendPacket: (self buildFileHeaderPacket: remoteName"(fileStream name copyUpTo: $-)") withSequence: seqNum.	response _ self readPacket.	response = $N ifTrue: "NACK"		[seqNum == ((self sequenceOf: ReceivedPacket) - 1 \\ 64)	"NACK for next packet is like ACK for this one..."			ifTrue: [response _ $Y]										"...so do same stuff as for Y"			ifFalse: [^state]].											"NACK -- stay in state"	response = $Y ifTrue: "ACK"		[(self sequenceOf: ReceivedPacket) = seqNum			"Wrong ACK..."			ifFalse: [^state].											"...so stay in S state and try again"		tries _ 0.												"reset counter"		seqNum _ seqNum + 1 \\ 64.							"advance packet count"		^$D].													"success, switch to state F"	response = $E ifTrue: "Error"		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.				"print the error message"		^$A].													"and abort"	response = false ifTrue:		[^state].									"try again on timeout or mismatch checksum"	^$A										"unknown response -- abort"!sendFSM	"This is the finite state machine that controls a file send.	Send only one file at a time, and return to transferLoop to start next one."	| fsm return packet |	state _ $S.		"Send-Initiate is the start state"	seqNum _ 0.		"initialize packet sequence number"	tries _ 0.		"no tries yet"	return _ nil.	[return == nil] whileTrue:		[state == $S ifTrue: [state _ self sendInit. return _ nil] ifFalse:[		state == $F ifTrue: [state _ self sendFileHeader. return _ nil] ifFalse:[		state == $D ifTrue: [state _ self sendData. return _ nil] ifFalse:[		state == $N ifTrue: [state _ self resendData: (lastPacketSent at: 1). return _ nil] ifFalse:[		state == $Z ifTrue: [state _ self sendEOF. return _ nil] ifFalse:[		state == $B ifTrue: [state _ self sendBreak. return _ nil] ifFalse:[		state == $C ifTrue: [return _ true "complete"] ifFalse:[		state == $A ifTrue: [return _ false "aborted"] ifFalse:[		return _ false "unknown"]]]]]]]]].	^return!sendInit	"send this host's parameters and get other side's back"	| response |	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	self flushInputBuffer.	self sendPacket: (self buildSendInitPacket) withSequence: seqNum.	response _ self readPacket.	response = $N ifTrue: "NACK"		[^state].	response = $Y ifTrue: "ACK"		[(self sequenceOf: ReceivedPacket) = seqNum			"wrong ACK..."			ifFalse: [^state].										"...so stay in S state and try again"		self parseSendInitPacket: ReceivedPacket.						"get other side's init information"		tries _ 0.												"reset counter"		seqNum _ seqNum + 1 \\ 64.							"advance packet count"		^$F].													"success, switch to state F"	response = $E ifTrue: "Error"		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.				"print the error message"		^$A].													"and abort"	response = false ifTrue:		[self checkForUserAbort.		^state].									"try again on timeout or mismatch checksum"	^$A										"unknown response -- abort"! !!RS232Kermit methodsFor: 'receive FSM'!receiveData	"receive file data packet"	| pak |	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	pak _ self readPacket.	pak = $D ifTrue:  "Data packet"		[(self sequenceOf: ReceivedPacket) ~= seqNum			ifTrue:											"wrong packet"				[(oldTries _ oldTries + 1) > RetryLimit					ifTrue: [^$A].								"give up if too many tries"				(self sequenceOf: ReceivedPacket) = (seqNum - 1 \\ 64)		"previous packet?"					ifTrue:						[self sendPacket: (self buildAckPacket)	"prev packet -- ACK again"							withSequence: seqNum - 1 \\ 64.						tries _ 0.									"reset counter"						^state]										"stay in this state"					ifFalse: [^$A]									"not prev packet -- abort"				].		"I now have a data packet with correct sequence number."		fileStream nextPutAll: (self dataOf: ReceivedPacket).						"write data into file"		self sendPacket: (self buildAckPacket) withSequence: seqNum.	"ACK it"		oldTries _ tries.												"reset counters"		tries _ 0.		seqNum _ seqNum + 1 \\ 64.								"advance packet number"		^$D].														"more data -- yum, yum"	pak = $F ifTrue: "File Header, maybe my ACK got lost"		[(oldTries _ oldTries + 1) > RetryLimit			ifTrue: [^$A].									"give up if too many tries"		(self sequenceOf: ReceivedPacket) = (seqNum - 1 \\ 64)			"previous packet?"			ifTrue:				[self sendPacket: (self buildSendAckPacket)	"prev packet -- ACK again"					withSequence: seqNum - 1 \\ 64.				tries _ 0.									"reset counter"				^state]										"stay in this state"			ifFalse: [^$A]									"not prev packet -- abort"		].	pak = $Z ifTrue: "End-Of-File"		[(self sequenceOf: ReceivedPacket) = seqNum			ifFalse: [^$A].									"wrong packet -- abort"		self sendPacket: (self buildAckPacket)					"prev packet -- ACK again"			withSequence: seqNum" + 1 \\ 64".		displayMem paintString: 'complete'.		fileStream close.										"close the file"		^$F].												"return to receive file state"	pak = $E ifTrue: "Error"		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.			"print the error message"		^$A].												"and abort"	pak = false ifTrue:							"try again on timeout or mismatch checksum"		[self sendPacket: (self buildNackPacket) withSequence: seqNum.		^state].	^$A										"unknown packet type -- abort"!receiveFileHeader	"receive file header information"	| pak |	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	pak _ self readPacket.	pak = $S ifTrue: "Send-Init, maybe my ACK got lost"		[(oldTries _ oldTries + 1) > RetryLimit			ifTrue: [^$A].								"give up if too many tries"		(self sequenceOf: ReceivedPacket) = (seqNum - 1 \\ 64)		"previous packet?"			ifTrue:				[self sendPacket: (self buildSendAckPacket)	"prev packet -- ACK again with my parameters"					withSequence: seqNum - 1 \\ 64.				tries _ 0.									"reset counter"				^state]										"stay in this state"			ifFalse: [^$A]									"not prev packet -- abort"		].	pak = $Z ifTrue: "End-Of-File"		[(oldTries _ oldTries + 1) > RetryLimit			ifTrue: [^$A].								"give up if too many tries"		(self sequenceOf: ReceivedPacket) = (seqNum - 1 \\ 64)		"previous packet?"			ifTrue:				[self sendPacket: (self buildAckPacket)	"prev packet -- ACK again"					withSequence: seqNum - 1 \\ 64.				tries _ 0.									"new counter"				^state]										"stay in this state"			ifFalse: [^$A]									"not prev packet -- abort"		].	pak = $F ifTrue:	"File Header -- bingo"		[(self sequenceOf: ReceivedPacket) ~= seqNum ifTrue: [^$A].		"wrong packet number -- abort"		fileStream == nil ifTrue:										"open the file to receive into"			[fileStream _ self openFileForReceive: (self dataOf: ReceivedPacket) asString asFileName].		self sendPacket: (self buildAckPacket) withSequence: seqNum.	"ACK the file header packet"		oldTries _ tries.											"reset counters"		tries _ 0.		seqNum _ seqNum + 1 \\ 64.							"advance packet number"		^$D].													"switch to D"	pak = $B ifTrue:	"Break (EOT)"		[(self sequenceOf: ReceivedPacket) = (seqNum + 1 \\ 64) ifFalse: [^$A].			"wrong packet number -- abort"		self sendPacket: (self buildAckPacket) withSequence: (seqNum + 1 \\ 64).	"ACK it"		^$C].														"complete"	pak = $E ifTrue:		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.			"print the error message"		^$A].												"and abort"	pak = false ifTrue:							"try again on timeout or mismatch checksum"		[self sendPacket: (self buildNackPacket) withSequence: seqNum.		^state].	^$A										"unknown packet type -- abort"!receiveFSM	"This is the finite state machine that controls a file receive.	Receive only one file at a time, and return to transferLoop to start next one."	| return |	state _ $R.		"Receive-Initiate is the start state"	seqNum _ 0.		"initialize packet sequence number"	tries _ 0.		"no tries yet"	return _ nil.	[return == nil] whileTrue:		[state == $R ifTrue: [state _ self receiveInit. return _ nil] ifFalse:[		state == $F ifTrue: [state _ self receiveFileHeader. return _ nil] ifFalse:[		state == $D ifTrue: [state _ self receiveData. return _ nil] ifFalse:[		state == $C ifTrue: [return _ true"complete"] ifFalse:[		state == $A ifTrue: [return _ false"aborted"] ifFalse:[		return _ false"unknown"]]]]]].	^return!receiveInit	"receive other host's parameters and send mine back"	| pak |	(tries _ tries + 1) > RetryLimit		ifTrue: [^$A].	"give up if too many tries"	pak _ self readPacket.	pak = $S ifTrue: "Send-Init"		[self parseSendInitPacket: ReceivedPacket.				"get other side's init information"		self sendPacket: (self buildSendAckPacket) withSequence: seqNum.	"ACK with my parameters"		oldTries _ tries.											"save old try count"		tries _ 0.												"new counter"		seqNum _ seqNum + 1 \\ 64.							"advance packet count"		^$F].													"switch to state F"	pak = $E ifTrue: "Error"		[displayMem paintStringAsLine:			(self dataOf: ReceivedPacket) asString.				"print the error message"		^$A].													"and abort"	pak = false ifTrue:							"try again on timeout or mismatch checksum"		[self sendPacket: (self buildNackPacket) withSequence: seqNum.		^state].	$A											"unknown packet type -- abort"! !!RS232Kermit methodsFor: 'send/receive loop'!checkForUserAbort	"check for user abort"	Sensor yellowButtonPressed ifTrue:		[(PopUpMenu labels: 'abort ftp' lines: #()) startUpYellowButton = 1			ifTrue: [self sendPacket: (self buildBreakPacket) withSequence: seqNum.					state _ $A]]!serverLoop	"check for one of commands know and do the right thing"	| commandLine aByte command |	commandLine _ WriteStream on: (ByteArray new: 32).	[(aByte _ serialPort nextByte) = 16r13"xoff" or: [state = $A]]		whileFalse: [aByte = noData ifFalse: [commandLine nextPut: aByte] ifTrue: [self checkForUserAbort]].	state = $A ifTrue: [^self].	commandLine _ commandLine contents asString.	displayMem paintStringAsLine: commandLine.	commandLine size > 0 ifFalse: [^self].	command _ commandLine at: 1.	command = $R		ifTrue:			[self receiveFSM]		ifFalse:			[command = $S				ifTrue:					[fileStream _ self openFileForSend: (remoteName _ commandLine copyFrom: (commandLine indexOf: $ ) + 1 to: commandLine size) asFileName.					fileBytesRem _ fileStream size.					self sendFSM]				ifFalse:					["command = $Q ifTrue: [state _ $A]"					self checkForUserAbort]].	fileStream == nil ifFalse: [fileStream close. fileStream _ nil]!startUpServerOn: aSerialPort with: aDisplayMem	"this is going to be real stupid and non-robust - it's just so we can test between machines easier"	| aByte |	self initWithSerialPort: aSerialPort displayMem: aDisplayMem.	user _ false.	fileType _ $A. "as far as server is concerned, it will do no special translation - especially since it has no way of knowing whether the file is binary"	[(aByte _ serialPort nextByte) = 16r13"xoff" or: [state = $A]] "when get it, assume it is the end of the KERMIT command"		whileFalse: [aByte = noData ifFalse: [aDisplayMem paintAV: aByte] ifTrue: [self checkForUserAbort]].	[state = $A] whileFalse:		[serialPort sendTextString: (String with: $>).		self serverLoop].	serialPort sendTextString: (String with: $>).	self terminateFtp.	Cursor normal show!startUpTransferOn: aSerialPort with: aDisplayMem	"establish connection, sequentially take requests from FtpFilesInfo queue and process them"	| fakePacket retPacket |	FtpFilesInfo isEmpty ifTrue: [aDisplayMem paintStringAsLine: 'Nothing to transfer'. ^self].	self initWithSerialPort: aSerialPort displayMem: aDisplayMem.	user _ true.	self sendCommand: 'KERMIT'.	[state = $A] whileFalse: [self transferLoop. self checkForUserAbort].	"self sendPacket: self buildBreakPacket withSequence: (seqNum _ seqNum + 1 \\ 64)."	self waitForPrompt.	serialPort sendTextString: 'QUIT'.	self terminateFtp.	Cursor normal show!terminateFtp	fileStream == nil ifFalse: [fileStream close].	displayMem paintStringAsLine: 'Connection closed'.	displayMem _ nil.	serialPort _ nil.	ReceivedPacket _ nil!transferLoop	"While there are files in ftpFileInfo to be processed, this will pick the first  	one up and process it."	| fileInfo command |	FtpFilesInfo isEmpty		ifTrue: 			[state _ $A.			^self].	fileInfo _ FtpFilesInfo removeFirst.	remoteName _ (fileInfo at: 4).	(fileInfo at: 1) = $S		ifTrue: 			[fileStream _ self openFileForSend: (fileInfo at: 2).			fileType _ fileInfo at: 3.			fileBytesRem _ fileStream size.			command _ 'RECEIVE ', remoteName, (String with: Character cr)].	(fileInfo at: 1) = $R		ifTrue: 			[fileStream _ self openFileForReceive: (fileInfo at: 2).			fileType _ fileInfo at: 3.			command _ 'SEND ', remoteName, (String with: Character cr)].	serialPort sendTextString: command.	"displayMem paintStringAsLine: command."	(fileInfo at: 1)		= $S		ifTrue: 			[displayMem paintStringAsLine: 'Sending local file ' , (fileInfo at: 2) , ' to remote file ' , remoteName.			self sendFSM.			Cursor normal show]		ifFalse: 			[displayMem paintStringAsLine: 'Receiving local file ' , (fileInfo at: 2) , ' from remote file ' , remoteName.			self receiveFSM.			Cursor normal show].	fileStream == nil ifFalse: [fileStream close]! !!RS232Kermit methodsFor: 'kermit utilities'!charOf: anInteger	^anInteger + 32!checksumOfPacket: aPacket 	"this is a standard one character checksum as defined in the Kermit Protocol Document"	| s |	s _ 0.	2 to: aPacket size - 1 do: [:i | s _ s + (aPacket at: i)].	^self charOf: (s + ((s bitAnd: 192) bitShift: -6"// 64") bitAnd: 63)!checksumOfPacketToSend: aPacket 	"this is a standard one character checksum as defined in the Kermit Protocol Document - except that here aPacket is assumed to have one extra character on the end - which is the xOff"	| s |	s _ 0.	2 to: aPacket size - 2 do: [:i | s _ s + (aPacket at: i)].	^self charOf: (s + ((s bitAnd: 192) bitShift: -6"// 64") bitAnd: 63)!ctl: anInteger	^anInteger bitXor: 64!stripLFs: aByteArray	| inStream outStream chr |	inStream _ ReadStream on: aByteArray.	outStream _ WriteStream on: (ByteArray new: aByteArray size).	[inStream atEnd] whileFalse:		[(chr _ inStream next) = 10 "linefeed"			ifFalse: [outStream nextPut: chr]].	^outStream contents!uncharOf: anInteger	^anInteger - 32! !!RS232Kermit methodsFor: 'private'!flushInputBuffer	"flush the input buffer of all data"	[serialPort nextByte == noData] whileFalse: []!ftpError: errorMsg send: sendAsPacket	| aPacket |	sendAsPacket ifTrue:		[aPacket _ self buildErrorPacket: errorMsg.		 self sendPacket: aPacket withSequence: 0].	displayMem paintStringAsLine: 'Error: ', errorMsg.	state _ $E!openFileForReceive: fileName	"Open a file to receive into."	^(FileStream fileNamed: fileName) readWriteShorten binary!openFileForSend: fileName	"Open a file to send."	^(FileStream oldFileNamed: fileName) readOnly binary!sendCommand: aString 	serialPort sendTextString: aString.	[serialPort nextByte == 62 or: [state = $A]]		whileFalse: [self checkForUserAbort]!waitForPrompt	[serialPort nextByte == 62]		whileFalse: [self checkForUserAbort]! !InformationCenter comment:'Copyright (c) 1986, 1987 Xerox Corporation. All rights reserved.InformationCenter contains and controls all the information centers in the system.Instances of InformationCenter hold the stuff necessary to support an information center.Instance variables:linkTypes	The link types this information center knows about.owner		the name (String) of the information center''''s owner.password	the access password to this information center.freeList		a collection of free slots in the file cabinet.fileCabinet	the OrderedCollection which contains all the data items in this information center.Class Variables:CopyCenter	the information center for the item currently in the transfer buffer.CopyPointer	the pointer into CopyCenter of the item currently in the transfer buffer.DataStart	the Integer of the first non-special (eg. after the root, trash, in-box, and keywords) entry in a FileCabinet.ActiveCenters	an OopConservingDictionary where a key is the information centers name, and the value is an instance of information center.PossibleCenters	an OrderedCollection containing the names of all the information centers currently existing on the Disk and/or in memory.LastUsedCenterName	the name of the information center that was used last .'!!InformationCenter methodsFor: 'saving'!dumpDeadKeywords	| keywordPtrs | 	(keywordPtrs _ self keywords fPointers) == nil ifTrue: [^self].	keywordPtrs do:		[:kP | ((self fileCabinet at: (kP index)) == nil)				ifTrue:[self keywords removeFPointer: kP]				ifFalse:[(self fileCabinet at: (kP index))numberOfBPointers <= 1 ifTrue:			[ self keywords removeFPointer: kP.			 self removeOrphansOf: (self fileCabinet at: (kP index)).			 self freeList add: kP index.			 self fileCabinet at: kP index put: nil]]].!save	"save this information center structure as a text file"	| fileCabinetStream aDictionary aString aForm aRectangle savedForm |	aString _ '        Currently saving ' , self name,'         '.	aForm _  aString asForm.	aRectangle _ aForm boundingBox.	aRectangle _  aRectangle align: aRectangle topCenter with: (Display boundingBox topCenter + (20@6)).	savedForm _ Form fromDisplay: aRectangle.	aForm displayOn: Display at: aRectangle topLeft.	Cursor write showWhile: [		fileCabinetStream _ (self openFile: self name, self class centerSuffix) writeShorten.		fileCabinetStream reset.		self dumpDeadKeywords.		self saveControlInfoOn: fileCabinetStream.		DCM writeClassification: fileCabinetStream.		self saveFreeList: fileCabinetStream.		self saveLinkTypes: fileCabinetStream.		self saveStructure: fileCabinetStream.		fileCabinetStream close].	Auditor audit ifTrue: [self class auditThis: (Array with: #saveCenter: with: nil with: nil with: self name)].	savedForm displayOn: Display at: aRectangle topLeft.!saveControlInfoOn: aFileStream	"save the information center ownership and password"	(password) == nil ifFalse: [aFileStream nextPutAll: password].	aFileStream nextPut: $\;		nextPutAll: (owner == nil			ifTrue: [UserName == nil ifTrue: [String new] ifFalse: [UserName]]			ifFalse: [owner]);		nextPut: Character cr!saveFreeList: fileCabinetStream	| count | 	"get the current list of free slots in the data structure the center file"	count _ freeList size.	fileCabinetStream nextPutAll: count printString; cr.	count = 0 ifTrue:[^self].	freeList do: [:each | fileCabinetStream nextPutAll: each printString; cr]!saveLinkTypes: fileCabinetStream	| count | 	"save the current list data link types to the center file"	count _ linkTypes size.	fileCabinetStream nextPutAll: count printString; cr.	count = 0 ifTrue:[^self].	linkTypes do: [:each | fileCabinetStream nextPutAll: each ; cr]!saveStructure: fileCabinetStream	| count | .	"save this file cabinet"	count _ fileCabinet size.	fileCabinetStream nextPutAll: count printString; cr.	fileCabinet do:		[:each | each == nil			ifTrue: [fileCabinetStream nextPutAll: (String with: $0 with: $ )]			ifFalse: [each storeOn: fileCabinetStream]]! !!InformationCenter methodsFor: 'link access'!addLinkType: aSymbol	| linkTypeIndex | 	(linkTypes includes: aSymbol) ifTrue: [^self].		linkTypeIndex _ linkTypes indexOf: #unused.	linkTypeIndex = 0		ifTrue:[linkTypes add: aSymbol]		ifFalse: [linkTypes removeObjectAt: linkTypeIndex.			linkTypes add: aSymbol atIndex: linkTypeIndex]!chooseLinks: title default: theDefaults	| return links centerLinks| 	links _ OrderedCollection with: 'Link Types:'. 	centerLinks _ OrderedCollection new.	links add: #all.	1 to: linkTypes size do:		[:each| (linkTypes at: each) = #unused ifFalse: [centerLinks add: (linkTypes at: each)]].	links addAll: centerLinks asSortedCollection.	return _ DBoxView		openFor: #(multipleSelect)		title: title		labels: (Array with: links)		defaults: (Array with: theDefaults).	return == nil ifTrue: [^nil].	(return at: 1) == nil ifTrue: [^nil].	((return at: 1) includes: #all) ifTrue:[^centerLinks].	^return at: 1!chooseTheLinks: title default: theDefaults	| return fLinks bLinks centerLinks sLinks disables disable1 disable2 layouts | 	layouts _ Array with: 'Layout Style:' with: #horizontal with: #vertical.	fLinks _ OrderedCollection with: 'Forward Link Types:' with: #none with: #all. 	bLinks _ OrderedCollection with: 'Backward Link Types:' with: #none with: #all. 	centerLinks _ OrderedCollection new.	1 to: linkTypes size do:		[:each| (linkTypes at: each) = #unused ifFalse: [centerLinks add: (linkTypes at: each)]].	sLinks _ centerLinks asSortedCollection.	fLinks addAll: sLinks.	bLinks addAll: sLinks.	disables _ OrderedCollection new.	2 to: 3 do: [:line | 		disable1 _ OrderedCollection new.		disable1 add: line@1. 2 to: fLinks size - 1 do: [:elem | disable1 add: line@elem negated].		disable2 _ OrderedCollection new.		disable2 add: line@2. 3 to: fLinks size - 1 do: [:elem | disable2 add: line@elem negated].		disables add: disable1 asArray; add: disable2 asArray].	return _ DBoxView		openFor: #(select multipleSelect multipleSelect )		title: title		labels: (Array with: layouts with: fLinks with: bLinks)		defaults: theDefaults		commands: #(accept cancel bailOut)		autoAccept: false		links: disables.	return == nil ifTrue: [^nil].	(return at: 2) == nil ifTrue: [return at: 2 put: OrderedCollection new].	(return at: 3) == nil ifTrue: [return at: 3 put: OrderedCollection new].	((return at: 2) includes: #all) ifTrue:[return at: 2 put: centerLinks].	((return at: 3) includes: #all) ifTrue:[return at: 3 put: centerLinks].	((return at: 2) includes: #none) ifTrue:[return at: 2 put: OrderedCollection new].	((return at: 3) includes: #none) ifTrue:[return at: 3 put: OrderedCollection new].	^return!editLinkTypes	| return links | 	links _ OrderedCollection with: 'Remove Connection Type:'.	DataMaster numberOfSystemLinkTypes = linkTypes size		ifTrue:[ return _ DBoxView			openFor: #( 'fill')			title: 'Information Center Connections'			labels:  (Array with: #('Add Connection Type:'))			defaults: (Array with: String new)]		ifFalse: [DataMaster numberOfSystemLinkTypes + 1 to: linkTypes size do:				[:each| (linkTypes at: each) = #unused ifFalse: [links add: (linkTypes at: each)]].			return _ DBoxView			openFor: #( 'fill' 'multipleSelect')			title: 'Information Center Connections'			labels:  (Array with: #('Add Connection Type:') with: links) 			defaults: (Array with: String new with: Array new)].	return == nil ifTrue:[^nil].	self linkTypeMenuReset.	(return at: 1) isEmpty ifFalse:[self addLinkType: (return at: 1) asSymbol].	return size = 2 ifTrue:[(return at: 2) == nil ifFalse:[(return at: 2) do: [:each| self removeLinkType: each]]]!linkTypeFor: aSymbol 	^((linkTypes indexOf: aSymbol) max: 1)!linkTypes	^linkTypes!removeLinkType: aSymbol	| linkTypeIndex theItem theBPointers | 	(self confirm: 'Are you sure you want to remove all the ',aSymbol,' links') ifFalse:[^self].	linkTypeIndex _ linkTypes indexOf: aSymbol.	DataStart to: fileCabinet size do:		[:index | ((theItem _ fileCabinet at: index) == nil)			ifFalse: [theBPointers _ theItem bPointersOfType: linkTypeIndex.				theBPointers isEmpty ifFalse:[					theBPointers do: [:eachPointer | self removeLinkOfType: aSymbol from: (fileCabinet at: eachPointer index) to: theItem]]]].	linkTypeIndex = linkTypes size		ifTrue:[linkTypes removeObjectAt: linkTypeIndex]		ifFalse:[linkTypes removeObjectAt: linkTypeIndex.			linkTypes add: #unused atIndex: linkTypeIndex].	[(linkTypes at: linkTypes size) = #unused] whileTrue: [linkTypes removeObjectAt: linkTypes size]!selectTheLinkTypeFor: aLabel	| return theLinks centerLinks sLinks disables disable1 newLink | 	theLinks _ OrderedCollection with: 'Link Types :' with: 'new link type'. 	centerLinks _ OrderedCollection new.	1 to: linkTypes size do:		[:each| (linkTypes at: each) = #unused ifFalse: [centerLinks add: (linkTypes at: each)]].	sLinks _ centerLinks asSortedCollection.	theLinks addAll: sLinks.	disables _ OrderedCollection new.	disable1 _ OrderedCollection new.	disable1 add: 1@1.		1 to: sLinks size +1 do: [:elem | disable1 add: 2@elem negated].	disables add: disable1 asArray; add: (Array with: 2@1 with: 3@1).	return _ DBoxView		openFor: (Array with: #select with: #select with: #fill)		title: 'Create a link to ', aLabel		labels: (Array with: #(#Insert #contents 'data link') with: theLinks with: #('New link type' ))		defaults: (Array with: #contents with: theLinks last with: (String new))		commands: #(accept cancel bailOut )		autoAccept: false		links: disables.	return == nil ifTrue: [^nil].	(return at: 1) =  #contents ifTrue: [^0]. "get the contents of the data item"	((return at: 2) isKindOf: Symbol) ifTrue: [^self linkTypeFor: (return at: 2)].	((return at: 3) == nil or: [ (return at: 3) = String new]) ifTrue:[^nil].	newLink _ (return at: 3) asSymbol. 	self addLinkType: newLink.	^self linkTypeFor: newLink! !!InformationCenter methodsFor: 'access'!dataStart	^DataStart!fileCabinet	^fileCabinet!fileCabinetIndex	^1!freeList	^freeList!iconLabel 	^(fileCabinet at: 1) iconDisplayString!inbox	^fileCabinet at: 3!inboxIndex	^ 3!itemAtPointer: thePointer	^fileCabinet at: thePointer index!label 	^(fileCabinet at: 1) displayString!name 	^(fileCabinet at: 1) label!owner	^owner!password	^password!password: aNewPassword	password _ aNewPassword!trash	^fileCabinet at: 2!trashIndex	^2! !!InformationCenter methodsFor: 'properties access'!createKeywordMenu	| fPointers aStream centerKeywords | 	(fPointers _ self keywords fPointers) == nil ifTrue: [properties at: #keywordMenu put: nil. ^self].	centerKeywords _ SortedCollection new.	fPointers do: [:fp| centerKeywords add: ( self fileCabinet at: fp index) label].	aStream _ WriteStream on: (String new: 250).	centerKeywords do: [:each|  aStream space; nextPutAll: each ; space; cr ].	aStream _ aStream contents.	properties at: #keywordMenu put: (Array with: (ScrollMenu new: 7 on: (aStream copyFrom: 1 to: aStream size - 1)) with: centerKeywords)!keywordMenu	^properties at: #keywordMenu ifAbsent: [nil]!linkTypeMenu	| myLinkTypes selection | 	(properties includesKey: #linkTypeMenu)		ifFalse:[properties at: #linkTypeMenu put: nil].	(properties at: #linkTypeMenu) == nil		ifTrue: [myLinkTypes _ self linkTypes deepCopy asSortedCollection.			[myLinkTypes includes: #unused] whileTrue: [myLinkTypes remove: #unused].			properties at: #linkTypeMenu put: (Array with: (ScrollMenu new: 8 on: myLinkTypes) with: myLinkTypes)].	selection _ ((properties at: #linkTypeMenu) at: 1) startUp: #anyButton.	selection == nil ifTrue: [^nil].	^((properties at: #linkTypeMenu) at: 2 ) at: selection!linkTypeMenuReset	properties at: #linkTypeMenu put: nil! !!InformationCenter methodsFor: 'restoring'!readFreeListFrom: theStream	"get the current list of free slots in the data structure."	| count theCollection | 	count _ Integer readFrom: theStream.	theStream skip: 1.	count = 0 ifTrue:[^OrderedCollection new: 10].	theCollection _ OrderedCollection new: count.	count timesRepeat:[theCollection add: (Integer readFrom: theStream).	theStream skip: 1].	^theCollection!readLinkTypesFrom: theStream	"get the current list of free slots in the data structure."	| count theCollection shouldHave | 	count _ Integer readFrom: theStream.	theStream skip: 1.	count = 0 ifTrue:[^OrderedCollection new: 10].	theCollection _ OrderedCollection new: count.	count timesRepeat:[theCollection add: (theStream upTo: Character cr) asSymbol].	shouldHave _ DataMaster linkTypes.	1 to: shouldHave size do:	"only because new centers were created wrong for several months"		[:i | theCollection at: i put: (shouldHave at: i)].	^theCollection!readStructureFrom: theStream	"get the current data structure."	| count theCollection | 	count _ Integer readFrom: theStream.	theStream skip: 1.	theCollection _ OrderedCollection new: count.	count timesRepeat:[theCollection add: (DataItem readMeFrom: theStream)].	^theCollection!restore	"rebuild the indicated information center from its disk file "	| theStream theOldClassScheme  realName |	Cursor read showWhile: [	theStream _ self openFile: ((realName _ self name), self class centerSuffix).	theStream readOnly.	password _ theStream upTo:  $\.	owner_ theStream upTo: Character cr.	(theOldClassScheme _ ClassificationScheme new) setupFrom: theStream.	freeList _ self readFreeListFrom: theStream.	linkTypes _ self readLinkTypesFrom: theStream.	fileCabinet _ self readStructureFrom: theStream.	theStream close.	self createKeywordMenu.	theOldClassScheme id = DCM id ifFalse:		[Cursor execute showWhile: [		(fileCabinet) do: [:each | each == nil ifFalse: [each convertFrom: theOldClassScheme]].		((fileCabinet) at: 1) classification: (self folderClassificationFor: ((fileCabinet) at: 1))]]].	(fileCabinet at: 1) label: realName.	LastUsedCenterName _ realName.	ActiveCenters at: LastUsedCenterName put: self.	Auditor audit ifTrue:[self class auditThis: (Array with: #restore: with: nil with: nil with: LastUsedCenterName)].	^true! !!InformationCenter methodsFor: 'private'!checkForDataWindows	|  theSuitcase centerName | 	centerName _ self name.	DataMaster findTheOneByEvaluating:		[:each | (each isKindOf: StandardSystemController)				and: [theSuitcase _ each view suitcase.					(theSuitcase ~~ nil and: [theSuitcase centerName = centerName])						ifTrue: [self booboo: theSuitcase dataItem label,' belongs to ', centerName, (String with: Character cr), 'This window must be closed before ',centerName,' can be dealt with'.							true]						ifFalse: [false]]]!checkThisLabel: theLabelArray inFolder: folder	| item | 	(folder fPointersOfType: (self linkTypeFor: #contains)) do:		[:each | item _ fileCabinet at: (each index).		(item label = (theLabelArray at: 1))			ifTrue: [theLabelArray at: 1 put: ((String with: $+), (theLabelArray at: 1)).					self checkThisLabel: theLabelArray inFolder: folder]].	^ (theLabelArray at: 1)!clearFlags	"clear all FlagBytes for this center"	self fileCabinet do:[:each| each == nil ifFalse: [each clearFlag]]!convertDataTypes: dataTypes	"convert whatever is in dataTypes to an array of integers"	| returnArray dataTypesArray | 	dataTypes == nil ifTrue: [^nil].	dataTypesArray _ (dataTypes isKindOf: Array) ifTrue: [dataTypes] ifFalse: [Array with: dataTypes].	returnArray _ Array new: dataTypesArray size.	1 to: dataTypesArray size do:		[:i | ((dataTypesArray at: i) isKindOf: Integer)				ifTrue: [returnArray at: i put: (dataTypesArray at: i)]				ifFalse: [returnArray at: i put: (DataItem typeIndexFor: (dataTypesArray at: i) asSymbol)]].	^returnArray!okToFoolWith: thisOne	"Check if the receiver is protected." 	"InfoCenters at: fcUser ifAbsent: [^true]."	self owner = UserName ifTrue:[^true].	^(thisOne isUnlocked)!removeOrphansOf: theItem	| fPointers thisItem | 	(fPointers _ theItem fPointers) == nil ifFalse:		[fPointers do:			[:fP |			thisItem _ fileCabinet at: fP index.			thisItem removeBPointer: theItem centerIndex type: fP linkType.			thisItem numberOfBPointers = 0 ifTrue:				[self removeOrphansOf: thisItem.				freeList add: fP index.				fileCabinet at: fP index put: nil]]]!setFlagsDownFromDataItem: item	"set flags of 	every item in item's hierarchical structure, and of every keyword referenced"	item isFlagSet ifTrue: [^self].	item setFlag.	(item fPointersOfType: (self linkTypeFor: #keyword)) do: [:fp | (fileCabinet at: fp index) setFlag].	(item fPointersOfType: (self linkTypeFor: #contains)) do: [:fp | self setFlagsDownFromDataItem: (fileCabinet at: fp index)]! !!InformationCenter methodsFor: 'initialize'!initialize: aNameAndPassword	| aFileCabinet |	fileCabinet _ OrderedCollection new: 20.	fileCabinet		add: (DataItem type: #Folder label: (aNameAndPassword at: 1) atIndex: 1);		add: (DataItem type: #Folder label: 'TRASH' atIndex: 2);		add: (DataItem type: #Folder label: 'IN BOX' atIndex: 3);		add: (DataItem type: #Folder label: 'Key words' atIndex: 4).	(fileCabinet at: 1) addBPointer: (DataItemPointer index: 1).	properties _ OopConservingDictionary new.	password _ (aNameAndPassword at: 2).	freeList _ OrderedCollection new.	linkTypes _ DataMaster linkTypes copy.	owner _ UserName! !!InformationCenter methodsFor: 'searching'!askAboutSearch: aString	| linkArray textTypes |	(textTypes _ OrderedCollection new) add: 'Item types'; add: #text asString; add: #outline asString; add: #database asString; add: #report asString; add: #preview asString; add: #form asString.	linkArray _ OrderedCollection new.	linkArray add: 2@1; add: 3@-1; add: 3@-2; add: 3@-3; add: 3@-4; add: 3@-5; add: 3@-6.	^DBoxView				openFor: (Array with: #fill with: #select with: #multipleSelect)				title: 'Searching'				labels: (Array with: #('Search for' ) with: #('Search type' 'title only' 'full text' both ) with: textTypes asArray)				defaults: (Array with: aString with: 'title only' with: #(text))				commands: #(accept cancel bailOut )				autoAccept: false				links: (Array with: linkArray)!getAllFileRefsTo: aFilename putIn: aCollection "searching entire info center including trash and inbox"	| size eachItem filename |	size _ fileCabinet size.	self dataStart to: size do:		[:eachIndex |		(eachItem _ fileCabinet at: eachIndex) == nil ifFalse:			[(filename _ eachItem filename) == nil ifFalse:				[filename = aFilename ifTrue:					[(eachItem bPointersOfType: (self linkTypeFor: #contains)) do:						[:bPtr |						aCollection add: ((String with: $'), eachItem label, ''' is in folder ''', (fileCabinet at: bPtr index) label, ''' in center ''', self name, (String with: $'))]]]]]!getAllFilesStartingAt: theIndex putIn: aSet linkType: linkType extended: extended	"put all the filenames connected to the item at theIndex into aSet.  If extended is true, then include all the associated files as well.  If linkType is nil, then do all link types. If doing the entire information center, ignore linkType"	| size eachItem filename theItem | 	theIndex == self fileCabinetIndex		ifFalse: "search a particular folder hierarchically"			[self clearFlags.			theItem _ fileCabinet at: theIndex.			 (filename _ theItem filename) == nil ifFalse:				[aSet addAll: (DataMaster getFileNamesFor: filename extended: extended)].			 self getFilesFrom: theItem putIn: aSet linkType: linkType extended: extended]		ifTrue: "searching entire info center including trash and inbox"			[size _ fileCabinet size.			self dataStart to: size do:				[:eachIndex |				(eachItem _ fileCabinet at: eachIndex) == nil ifFalse:					[(filename _ eachItem filename) == nil ifFalse:						[aSet addAll: (DataMaster getFileNamesFor: filename extended: extended)]]]]!getAllTypesOfData	"find all the types of data in this information center, and return their English string equivalents"	| aSet filename | 	aSet _ Set new.	DataStart to: fileCabinet size do:		[:index |			((fileCabinet at: index) == nil or: [(filename _ (fileCabinet at: index) filename) == nil]) ifFalse:			[aSet add: (DataMaster giveMe: #englishString for: filename)]].	^aSet!getFileNamesForSelection: theSelectionIndex withMapSupport: aBoolean	"return a list with the name of every file associated with the selection"	| fileSet theList aFileName execList changeString index |	Cursor execute show.	fileSet _ Set new.	self getAllFilesStartingAt: theSelectionIndex putIn: fileSet linkType: (self linkTypeFor: #contains) extended: true.	aBoolean		ifTrue: [theList _ fileSet asSortedCollection]		ifFalse: [theList _ SortedCollection new.			fileSet do: [:fileName | aFileName _ fileName asLowercase.			((aFileName findString: '.mapdata' startingAt: 1) = 0 and: [(aFileName findString: '.maphints' startingAt: 1) = 0])				ifTrue: [theList add: fileName]]].	execList _ OrderedCollection new.	theList do:		[:fn | changeString _ fn.			  [(index _ changeString findString: '--' startingAt: 1) = 0]					whileFalse: [changeString _ changeString copyReplaceFrom: index to: index + 1 with: '-''-'].			execList addLast: changeString].	^execList!getFilesFrom: theItem putIn: aSet linkType: linkType extended: extended	"put all the filenames connected by linkType to the item into aSet.  If extended is true, then include all the associated files as well.  If linkType is nil, then do all link types"	| fPointers eachItem theName |	theItem isFlagSet ifTrue: [^self] ifFalse: [theItem setFlag].	linkType == nil		ifTrue: [(fPointers _ theItem fPointers) == nil ifTrue: [^self]]		ifFalse: [fPointers _ theItem fPointersOfType: linkType].	fPointers do: [:fPtr |		eachItem _ fileCabinet at: fPtr index.		(theName _ eachItem filename) == nil ifFalse:			[aSet addAll: (DataMaster getFileNamesFor: theName extended: extended)].		self getFilesFrom: eachItem putIn: aSet linkType: linkType extended: extended]!lookForThisString: aString startingWith: aFolder	"Generate a folder with items containing aString.	 Search for the items starting with aFolder.  If aFolder is nil, start at the top level of this center"	| theString thePointers lookAt aDict answer |	answer _ self askAboutSearch: aString.	answer == nil ifTrue: [^nil].	theString _ answer at: 1.	theString = String new ifTrue: [^nil].	lookAt _ (aFolder == nil ifTrue: [fileCabinet at: self fileCabinetIndex] ifFalse: [aFolder]).	thePointers _ Set new.	(answer at: 2) = 'full text' ifFalse:		[self clearFlags.		thePointers addAll:			(self				search: lookAt				dataType: #(#Item #Folder)				linkType: (self linkTypeFor: #contains)				target: theString asLowercase				checkLocked: (owner ~= UserName))].	(answer at: 2) = 'title only'		ifFalse: 			[(answer at: 3) == nil ifTrue: [^self booboo: 'You must select one or more item types to search'].			self clearFlags.			aDict _ OopConservingDictionary new.			self				fullSearch: lookAt				searchString: theString				hitDict: aDict				fileTypes: (answer at: 3)				checkLocked: (owner ~= UserName).			thePointers addAll: aDict keys].	thePointers isEmpty ifTrue: [^self booboo: 'I found no references to: ', theString].	self makeAHolderOn: thePointers withLabel: 'Items containing ~' , theString , '~ from ' , self label searchString: theString menuType: 5!makeHolderOfDataType: dataType target: aString	| center ptrDict thePointers theSet newFolder | 	thePointers _ self search: (fileCabinet at: 1) dataType: dataType linkType: (self linkTypeFor: #contains) target: aString asLowercase checkLocked: owner ~= UserName.	thePointers isEmpty ifTrue: [^nil].	newFolder _ DataItem type: #Folder label: 'Hits for: ', aString fPointers: thePointers atIndex: 0.	newFolder classification: (self folderClassificationFor: newFolder).	(ContainerModel createForIndexOrItem: newFolder inCenter: self) searchString: aString; scheduleTheFolder: newFolder label usingMenu: 5 width: 2 helpMessage: #Holder!search: theItem dataType: dataType linkType: linkType target: targetString checkLocked: huh 	"theItem is the starting folder; dataType, linkType, and targetString(a lowercase string or array of strings) are filters, if any are nil they aren't applied. Returns OrderedCollection of pointers"	| eachItem thePointers aDict size dataTypes |	dataTypes _ self convertDataTypes: dataType.	Cursor execute showWhile: [	thePointers _ OrderedCollection new.	self clearFlags.	theItem clearFlag.	aDict _ OopConservingDictionary new.	(dataTypes == nil or: [dataTypes includes: theItem type])		ifTrue:[targetString == nil			ifTrue: [aDict at: (DataItemPointer index: theItem centerIndex) put: nil]			ifFalse: [(self labelAndKeysFor: theItem includes: targetString) ifTrue: [aDict at: (DataItemPointer index: theItem centerIndex) put: nil]]].	self search: theItem dataTypes: dataTypes linkType: (self linkTypeFor: linkType) target: targetString putIn: aDict checkLocked: huh.	theItem == (fileCabinet at: 1)		ifTrue: "check the trash and inbox too"			[self search: self trash dataTypes: dataTypes linkType: (self linkTypeFor: linkType) target: targetString putIn: aDict checkLocked: huh.			self search: self inbox dataTypes: dataTypes linkType: (self linkTypeFor: linkType) target: targetString putIn: aDict checkLocked: huh].	aDict keysDo: [:theKey | theKey index > 1 ifTrue: [thePointers add: theKey]]].	^thePointers!search: theItem dataTypes: dataTypes linkType: linkType target: targetString putIn: theDict checkLocked: huh 	"theItem is the starting folder; dataTypes(array of integers), linkType(anInteger), and targetString(a lowercase string or array of strings) are filters, if any are nil they aren't applied. Callers of this method should use ContainerModel clearFlag before calling this."	| fPointers eachItem |	theItem isFlagSet ifTrue: [^self] ifFalse: [theItem setFlag].	(theItem fPointersOfType: linkType) do:		[:fPointer |		eachItem _ fileCabinet at: (fPointer index).		(huh ifTrue: [eachItem isUnlocked] ifFalse:[true])			ifTrue:[(dataTypes == nil or: [dataTypes includes: eachItem type]) ifTrue:			[targetString == nil				ifTrue: [theDict at: fPointer put: nil]				ifFalse: [(self labelAndKeysFor: eachItem includes: targetString) ifTrue: [theDict at: fPointer put: nil]]].		self search: eachItem dataTypes: dataTypes linkType: linkType target: targetString putIn: theDict checkLocked: huh]]!search: aDataItem fileType: fileType hitDict: aDict checkLocked: shouldICheckLocked	"fileType is aSymbol or an array of symbols"	| fileTypes theItem filename shouldILook | 	aDataItem isFlagSet ifTrue: [^self] ifFalse: [aDataItem setFlag].	fileTypes _ (fileType isKindOf: Collection) ifTrue: [fileType] ifFalse: [Array with: fileType].	(aDataItem fPointersOfType: (self linkTypeFor: #contains)) do:		[:each |		theItem _ fileCabinet at: (each index).		shouldILook _ true.		shouldICheckLocked ifTrue: [theItem isLocked ifTrue:[shouldILook _ false]].		shouldILook ifTrue: [theItem isFolder			ifTrue: [ self search: theItem fileType: fileType hitDict: aDict checkLocked: shouldICheckLocked]			ifFalse:				[(filename _ theItem filename) == nil ifFalse:					[fileTypes do: [:ft |						(DataMaster thisFile: filename isKindOf: ft)							ifTrue: [aDict at: each put: nil]]]]]]!searchTotalCenterFor: fileType hitDict: aDict checkLocked: shouldICheckLocked	"fileType is aSymbol or an array of symbols"	| fileTypes theItem filename shouldILook | 	fileTypes _ (fileType isKindOf: Collection) ifTrue: [fileType] ifFalse: [Array with: fileType].	self dataStart to: fileCabinet size do: [:index | theItem _ fileCabinet at: index.		theItem == nil			ifFalse:[(filename _ theItem filename) == nil				ifFalse: [shouldILook _ true.					shouldICheckLocked ifTrue: [theItem isLocked ifTrue:[shouldILook _ false]].					shouldILook ifTrue: [fileTypes do: [:ft |						(DataMaster thisFile: filename isKindOf: ft)							ifTrue: [aDict at: (DataItemPointer index: index) put: nil]]]]]]!showFolderList	"Create a holder holding only folders."	| thePointers aDataItem | 	thePointers _ self search: (fileCabinet at: self fileCabinetIndex) dataType: #Folder linkType: (self linkTypeFor: #contains) target: nil checkLocked: (self owner ~= UserName).	thePointers add: (DataItemPointer index: 1).	self makeAHolderOn: thePointers withLabel: 'Folders of ', self name searchString: nil menuType: 6!showFolderList: theItem	"Create a holder holding only folders."	| thePointers aDataItem | 	thePointers _ self search: (fileCabinet at: self fileCabinetIndex) dataType: #Folder linkType: (self linkTypeFor: #contains) target: nil checkLocked: (self owner ~= UserName).	thePointers add: (DataItemPointer index: 1).	self makeAHolderOn: thePointers withLabel: 'File ', theItem displayString,' into ...' searchString: theItem menuType: 6! !!InformationCenter methodsFor: 'full text search'!does: fileName contain: aString  	| aStream size index first found nextChar this upperFirst start |	(aStream _ self openOldFile: fileName) == nil ifTrue: [^false].	aStream readOnly.	size _ aString size.	first _ aString first.	start _ 2.	first = $* ifTrue: [aString size < 2			ifTrue: [^true]			ifFalse: 				[first _ aString at: 2.				start _ 3]].	upperFirst _ first asUppercase.	[aStream atEnd]		whileFalse: 			[found _ false.			[aStream atEnd or: [found]]				whileFalse: [((nextChar _ aStream next) = first or: [nextChar = upperFirst])						ifTrue: [found _ true]].			index _ start.			[found and: [index <= size]]				whileTrue: 					[this _ aString at: index.					this = $*						ifTrue: [index = size								ifTrue: 									[aStream close.									^true]								ifFalse: 									[index _ index + 1.									this _ aString at: index.									found _ aStream skipTo: this]]						ifFalse: [this = $#								ifTrue: [aStream next]								ifFalse: [(aStream atEnd or: [(nextChar _ aStream next) ~= this and: [nextChar ~= this asUppercase]])										ifTrue: [found _ false]]].					index _ index + 1].			found				ifTrue: 					[aStream close.					^true]].	aStream close.	^false!fullSearch: aDataItem searchString: aString hitDict: aDict fileTypes: fileTypes checkLocked: shouldICheckLocked 	"fileType is aSymbol or an array of symbols"	| theItem filename fileList shouldILook |	aDataItem isFlagSet ifTrue: [^self] ifFalse: [aDataItem setFlag].	(aDataItem fPointersOfType:  (self linkTypeFor: #contains)) do: [:each | 		theItem _ fileCabinet at: (each index).		shouldILook _ true.		shouldICheckLocked ifTrue: [theItem isLocked ifTrue:[shouldILook _ false]].		shouldILook ifTrue: 		[theItem isFolder			ifTrue: [self fullSearch: theItem searchString: aString hitDict: aDict fileTypes: fileTypes checkLocked: shouldICheckLocked]			ifFalse: [(filename _ theItem filename) == nil 				ifFalse: [fileTypes do: [:ft | (DataMaster thisFile: filename isKindOf: ft)					ifTrue: [fileList _ DataMaster allFilesFor: filename.						fileList do: [:eachFile | (self does: eachFile contain: aString asLowercase)								ifTrue: [aDict at: each put: nil]]]]]]]]! !!InformationCenter methodsFor: 'set classification'!folderClassificationFor: theItem	"an item has changed its classification in this folder check to see what its current classification is"	| theClass eachItem |	theClass _ 1.	(theItem fPointersOfType: (self linkTypeFor: #contains)) do:		[:fp | (fp index) ~= 0 ifTrue: [eachItem _ fileCabinet at: (fp index).		eachItem == nil ifFalse: [eachItem classificationIndex > theClass			ifTrue: [theClass _ eachItem classificationIndex]]]].	^theClass!modifyItemAt: itemIndex with: return at: theFolderIndex	"change the theItem for this guy and tell anybody who needs to know about it"	| oldDisplayString theItem oldLabel oldClass |	theItem _ fileCabinet at: itemIndex.	oldLabel _ theItem label.	oldDisplayString _ theItem displayString.	oldClass _ theItem classAndWords.	(self keywordStringFor: theItem) = (return at: 2)		ifFalse: [self setKeywordsForItemAt: itemIndex to: (return at: 2)].	theItem changeSelfWith: return.	oldDisplayString = theItem displayString ifTrue: [^false].	Auditor audit ifTrue:[self class auditThis: (Array with: #changeSelection with: oldDisplayString with: theItem displayString with: self name)].	oldLabel = theItem label ifFalse:		[(theItem bPointersOfType: (self linkTypeFor: #contains)) do: [:bp | (bp index) = theFolderIndex ifFalse: [self changed: (fileCabinet at: (bp index))]]].	oldClass = theItem classAndWords ifFalse:[self updateClassFor: theItem].	^true!totalCenterClass	"set the information center classification to include items in the inbox and trash"	| theClass eachItem |	theClass _ self folderClassificationFor: (fileCabinet at: 1).	(fileCabinet at: 2) classificationIndex > theClass			ifTrue: [theClass _ (fileCabinet at: 2) classificationIndex].	(fileCabinet at: 3) classificationIndex > theClass			ifTrue: [theClass _ (fileCabinet at: 3) classificationIndex].	(theClass = (fileCabinet at: 1) classificationIndex) ifFalse: [(fileCabinet at: 1) classification: theClass. ^true].	^false!updateClassFor: theItem	"the item has changed its classification so check its back pointer to see who cares"	| bPointers theClass eachItem newClass |	(bPointers _ theItem bPointers) == nil ifTrue:[^self]. 	bPointers do: [:theBackP | eachItem _ fileCabinet at: (theBackP index).		eachItem isFolder	 ifTrue:			[ContainerModel changed: eachItem.			eachItem = theItem ifFalse:				[eachItem < theItem					ifTrue: [eachItem classification: theItem classification "folders don't keep modifiers".							self updateClassFor: eachItem]					ifFalse: [newClass _ self folderClassificationFor: eachItem.							newClass = eachItem classificationIndex ifFalse:								[eachItem classification: newClass.								self updateClassFor: eachItem]]]]]! !!InformationCenter methodsFor: 'keyword access'!keywords	^fileCabinet at: 4!keywordsFor: thisItem	"return the keywords for this item as a collection"	| keywordItems keywordCollection |	keywordItems _ thisItem fPointersOfType: (self linkTypeFor: #keyword).	keywordCollection _ OrderedCollection new.	keywordItems do: [:each | keywordCollection add: (fileCabinet at: (each index)) label].	^keywordCollection!keywordStringFor: aDataItem	"return the keywords for this item as a string"	| theKeywords keywordString |	theKeywords _ self keywordsFor: aDataItem.	theKeywords isEmpty		ifTrue: [keywordString _ String new]		ifFalse:			[keywordString _ theKeywords at: 1.			 2 to: theKeywords size do: [:i | keywordString _ keywordString, (String with: $,), (theKeywords at: i)]].	^keywordString!labelAndKeysFor: dataItem includes: theString	"theString is either a string or an array of strings"	| labelAndKeys strings | 	labelAndKeys _ (dataItem label, (self keywordStringFor: dataItem)) asLowercase.	strings _ (theString isKindOf: String) ifTrue: [Array with: theString] ifFalse: [theString].	strings do: [:aString | (labelAndKeys findString: aString startingAt: 1) = 0 ifFalse: [^true]].	^false!removeKeyword: aKeywordPointer	| keywordPointers theKeyword theKeywordIndex theItem |	theKeywordIndex _ aKeywordPointer index.	theKeyword _ self fileCabinet at: theKeywordIndex.	keywordPointers _ theKeyword bPointersOfType: (self linkTypeFor: #keyword).	keywordPointers do: [:eachPointer | theItem _ self fileCabinet at: eachPointer index.		theItem == nil ifFalse: [theItem removeFPointer: theKeywordIndex type: (self linkTypeFor: #keyword)]].	(fileCabinet at: 4) removeFPointer: theKeywordIndex type: (self linkTypeFor: #contains).	fileCabinet at: theKeywordIndex put: nil.	freeList add: theKeywordIndex.	self createKeywordMenu.	^true!setKeywordsForItemAt: centerIndex to: keywords	"set the keywords for dataItem which lives in fcUser's center to be those in the string or collection keywords"	| keywordColl keyword newKeywordPtrs gotIt dataItemsKeywordIndices dataItem keyStream keywordLinkType addedOne |	keywordColl _ OrderedCollection new.	addedOne _ false.	keywordLinkType _ self linkTypeFor: #keyword.	(keywords isKindOf: String)		ifTrue: [keyStream _ ReadStream on: keywords.				[(keyword _ keyStream upTo: $,) isEmpty] whileFalse: [keywordColl add: keyword stripLeadingAndTrailingSpaces asLowercase]]		ifFalse: [keywords do: [:keyword | keywordColl add: keyword asLowercase]].	newKeywordPtrs _ OrderedCollection new.	keywordColl do:		[:chkKeyword |		 gotIt _ nil.		 ((self keywords) fPointersOfType: (self linkTypeFor: #contains)) do: [:existKwPtr | (fileCabinet at: (existKwPtr index)) label = chkKeyword ifTrue: [gotIt _ existKwPtr index]].		 gotIt == nil			ifTrue: "add keyword chkKeyword to center, and then add that dataItems pointer to newKeywordPtrs"				[addedOne _ true.					newKeywordPtrs add: (self					addThis: (dataItem _ DataItem type: #Keyword label: chkKeyword atIndex: 0)					linkType: (self linkTypeFor: #contains)					to: self keywords).				 dataItem addBPointer: (DataItemPointer index: 4)]			ifFalse: [newKeywordPtrs add: gotIt]].	dataItem _ fileCabinet at: centerIndex.	dataItemsKeywordIndices _ (dataItem fPointersOfType: keywordLinkType) collect: [:kp | kp index].	"add new keyword pointers"	newKeywordPtrs do: [:nKP |		(dataItemsKeywordIndices includes: nKP) ifFalse:			[dataItem addFPointer: nKP type: keywordLinkType.			 (fileCabinet at: nKP) addBPointer: centerIndex type: keywordLinkType ]].	"remove obsolete keyword pointers"	dataItemsKeywordIndices do: [:oKP |		(newKeywordPtrs includes: oKP) ifFalse:			[dataItem removeFPointer: oKP type: keywordLinkType.			 (fileCabinet at: oKP) removeBPointer: centerIndex type: keywordLinkType]].	addedOne ifTrue:[self createKeywordMenu]! !!InformationCenter methodsFor: 'copy utilities'!duplicateFile: oldFilename to: newNameKernal	"copy file oldFilename and any special associated files to new file(s) of the same type(s).	 Return an array with the new filename and the name kernal if successful, nil if not"	| newLabel theLabel newName didIt anotherSuffix suffixSymbol suffixString |	suffixSymbol _ DataMaster giveMe: #symbol for: oldFilename.	suffixSymbol = (DataMaster giveMe: #symbol for: #spreadsheet asString)		ifTrue:			[newLabel _ newNameKernal.			 [theLabel _ newLabel asFileName.	 		  (self getOldFileName: (newName _ theLabel, (DataMaster giveMe: #suffixString for: suffixSymbol))) == nil]				whileFalse:					[(newLabel _ FillInTheBlank request: 'Need NEW name for duplicateof spreadsheet ', newNameKernal default: 'newSSLabel') isEmpty						ifTrue: [self booboo: newNameKernal, ' has not been copied'. ^nil]]]		ifFalse:			[Cursor wait showWhile:			 [suffixString _ DataMaster giveMe: #suffixString for: suffixSymbol.			 newName _ Disk makeNewFileName: (theLabel _ newNameKernal) withSuffix: suffixString]].	didIt _ true.	(anotherSuffix _ DataMaster giveMe: #specialSuffixString for: suffixSymbol) == nil			ifFalse: [didIt _ self retrieveFrom: oldFilename, anotherSuffix copyTo: newName, anotherSuffix].	didIt ifTrue:		[(self retrieveFrom: oldFilename copyTo: newName) ifTrue: [^Array with: newName with: theLabel]].	^nil!duplicateThisFolder: sourceFolder sourceCenter: sourceCenter into: putInFolder keepItems: keepItems dupItems: dupItems	"Make a duplicate of sourceFolder which is in the sourceCenter and put it in to this information center.	If keepItems is false, don't copy any items.	If keepItems is true and dupItems is true, then not only create a new item but also duplicate its file.	Return the index of the duplicateFolder in fcUserTo's fileCabinet"	| newFolderDataItem newFolderIndex keywords theOldItem containsLink |	containsLink _ self linkTypeFor: #contains.	newFolderDataItem _ DataItem type: sourceFolder typeSymbol label: sourceFolder label atIndex: 0.	newFolderIndex _ self addThis: newFolderDataItem linkType: containsLink to: putInFolder.	newFolderDataItem addBPointer: putInFolder centerIndex type: containsLink.	keywords _ OrderedCollection new.	(sourceFolder fPointersOfType: (self linkTypeFor: #keyword)) do: [:i | keywords add: (sourceCenter fileCabinet at: (i index)) label].	self setKeywordsForItemAt: newFolderIndex to: keywords.	(sourceFolder fPointersOfType: containsLink) do: 		[:fpointer | 		theOldItem _ sourceCenter fileCabinet at: (fpointer index).		theOldItem typeSymbol = #Item			ifTrue: [keepItems				ifTrue: [ self duplicateThisItem: theOldItem sourceCenter: sourceCenter into: newFolderDataItem dupFileName: (dupItems ifTrue: [theOldItem label] ifFalse: [nil])]]			ifFalse: [self duplicateThisFolder: theOldItem sourceCenter: sourceCenter into: newFolderDataItem keepItems: keepItems dupItems: dupItems]].	newFolderDataItem classification: (self folderClassificationFor: newFolderDataItem).	self updateClassFor: newFolderDataItem.	^newFolderIndex!duplicateThisItem: theSourceItem sourceCenter: sourceCenter into: putInFolder dupFileName: dupFileKernal	"Make a duplicate of theOldItem which is in fcUserFrom's info center and put it in putInFolder in fcUserTo's info center. If dupFileKernal is non-nil, then actually duplicate the file using dupFileKernal as the kernal.  This means that if dupFileKernal is nil, this is probably just a copy from one info center to another.	Return the index of the duplicateItem in fcUserTo's fileCabinet. This index will be negative if the item was already in putInFolder"	| newDataItem newItemIndex keywords newFileName newItemLabel |	dupFileKernal == nil		ifFalse: [newFileName _ self duplicateFile: theSourceItem filename to: dupFileKernal.				newFileName == nil ifTrue: [^0].				newItemLabel _ newFileName at: 2.				newFileName _ newFileName at: 1]		ifTrue:			[newFileName _ theSourceItem filename.			newItemLabel _ theSourceItem label.			sourceCenter name = self name ifFalse: "check if this item might already be in this info center"				[(newDataItem _ self class lookForLabel: nil andKeys: nil dataType: theSourceItem type fileName: theSourceItem filename inUser: self name) == nil					ifFalse: [newDataItem label: newItemLabel.							(self putThisItem: newDataItem inThisFolder: putInFolder before: nil notifyError: true) == nil								ifTrue: [^0 - newDataItem centerIndex].							^newDataItem centerIndex]]].	newDataItem _ DataItem locked: theSourceItem isLocked classification: theSourceItem classification modifiers: theSourceItem modifiers type: theSourceItem type  label: newItemLabel filename: newFileName bPointers: nil fPointers: nil atIndex: 0.	newItemIndex _ self addThis: newDataItem linkType: (self linkTypeFor: #contains) to: putInFolder.	newDataItem addBPointer: putInFolder centerIndex type: (self linkTypeFor: #contains).	keywords _ OrderedCollection new.	(theSourceItem fPointersOfType: (self linkTypeFor: #keyword)) do: [:i | keywords add: (sourceCenter fileCabinet at: (i index)) label].	self setKeywordsForItemAt: newItemIndex to: keywords.	self updateClassFor: newDataItem.	^newItemIndex!retrieveFrom: aFileName1 copyTo: aFileName2 	"Copy file whose name is aFileName1 (usually from this receiver) to a file	whose name is aFileName2 (usually a local directory)."	| oldFile newFile leftOver |	Cursor read showWhile:		[oldFile _ self openOldFile: aFileName1].	oldFile == nil ifTrue: [^false].	Cursor write showWhile:	[oldFile binary; readOnly.	newFile _ (self openFile: aFileName2) binary; writeShorten.		leftOver _ oldFile size.	[leftOver > 4096] whileTrue:			[newFile nextPutAll: (oldFile next: 4096).			leftOver _ leftOver - 4096].	newFile nextPutAll: (oldFile next: leftOver).	newFile close.	oldFile close].	^true! !!InformationCenter methodsFor: 'trash management'!checkAndPerhapsTrash: anItem 	| itemPointer |	anItem bPointers == nil "not referenced anywhere else?"		ifTrue: 			[self trash addFPointer: (itemPointer _ DataItemPointer index: anItem centerIndex).			(fileCabinet at: itemPointer index)				addBPointer: self trashIndex type: (self linkTypeFor: #contains).			self trash classification: (self folderClassificationFor: self trash).			ContainerModel changed: self trash]!removeFromTrash: item 	| containsLink |	(self trash fPointersIncludes: item centerIndex type: (containsLink _ self linkTypeFor: #contains))		ifTrue: 			[self trash removeFPointer: (DataItemPointer index: item centerIndex).			item removeBPointer: self trashIndex type: containsLink.			self trash classification: (self folderClassificationFor: self trash).			ContainerModel changed: self trash]! !!InformationCenter methodsFor: 'make connections'!addFilesInList: theList toFolder: folder	| fs class endLabel newClass startLabel | 	Cursor wait showWhile: [	theList do:		[:aFileName |		fs _ (HeaderFileStream fileNamed: aFileName) readOnly.		fs hasHeader			ifTrue:				[class _ fs classAndModsFromHeader.				self addThis: (DataItem locked: false classification: (class at: 1) modifiers: (class at: 2) type: #Item label: fs labelFromHeader filename: aFileName bPointers: (Array with: (DataItemPointer index: folder centerIndex)) fPointers: nil atIndex: 0) linkType: (self linkTypeFor: #contains) to: folder]			ifFalse: "backwards compatibility"				[(endLabel _ (aFileName findLast: [:c | c = $.]) - 1) < 1 ifTrue: [endLabel _ aFileName size].				startLabel _ ((aFileName findLast: [:c | c = $>]) + 1) max: 1.				self addThis: (DataItem type: #Item label: (aFileName copyFrom: startLabel to: endLabel) filename: aFileName bPointers: (Array with: (DataItemPointer index: folder centerIndex)) atIndex: 0) linkType: (self linkTypeFor: #contains) to: folder].		fs close].	newClass _ self folderClassificationFor: folder.	newClass = folder classificationIndex ifFalse:		[folder classification: newClass.		self updateClassFor: folder]].	^true!addFolder: folderItem	"add a new folder to this center's in box"	| itemLoc |	self inbox fPointers == nil		ifFalse: [folderItem label: (self checkThisLabel: (Array with: folderItem label) inFolder: self inbox)].	itemLoc _ self addThis: folderItem linkType: (self linkTypeFor: #contains) to: self inbox.	folderItem addBPointer: self inboxIndex type: (self linkTypeFor: #contains).	ContainerModel changed: self inbox.	^ (fileCabinet at: itemLoc)!addLinkOfType: aSymbol from: fromItem to: toItem 	"given any two dataItems, add a link in the center of the specified symbolic 	type "	| linkType |	aSymbol = #database		ifTrue:[(DataMaster thisFile: toItem filename isKindOf: #database)			ifFalse:[self booboo: 'To make this a valid database connection this item must be a database'. ^nil]].	aSymbol = #keyword		ifTrue:[(toItem isKeyword)			ifFalse:[self booboo: 'To make this a valid keyword connection this item must be a keyword'. ^nil]].	aSymbol = #contains		ifTrue:[(fromItem isFolder)			ifFalse:[self booboo: 'To make this a valid contains connection the other item must be a folder'. ^nil]].	linkType _ self linkTypeFor: aSymbol.	(fromItem fPointersIncludes: toItem centerIndex type: linkType)		ifFalse: 			[fromItem addFPointer: (DataItemPointer type: linkType index: toItem centerIndex).			toItem addBPointer: fromItem centerIndex type: linkType.			self removeFromTrash: toItem]	ifTrue:[^nil]!connectionsForThisItem: theItem	| theTabLabel thePointers forwards backwards | 	theTabLabel _ 'Connections from ' , theItem label.	DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: ContainerModel) and: [each view label = theTabLabel]].	thePointers _ Set new.	forwards _ theItem fPointers.	forwards == nil ifFalse: [forwards do: [:each | each index >= self dataStart ifTrue:[thePointers add: each]]].	backwards _ theItem bPointers.	backwards == nil ifFalse: [backwards do: [:each | each index >= self dataStart ifTrue:[thePointers add: each]]].	thePointers do: [:each | (self okToFoolWith: (self fileCabinet at: each index))			ifFalse: [thePointers remove: each]].	thePointers isEmpty ifTrue: [^self booboo: 'There are no items linked to this one.'].	self makeAHolderOn: thePointers withLabel: theTabLabel searchString: nil menuType: 5!makeDatabaseConnectionTo: theMapItem	| theReturn dataBases eachItem filename databaseNames thePointers currentDbs dbItem dataBaseLinkType |	dataBases _ OopConservingDictionary new.	dataBaseLinkType _ self linkTypeFor: #database.	self dataStart to: fileCabinet size do: [:theIndex |		(eachItem _ fileCabinet at: theIndex) == nil ifFalse:			[(filename _ eachItem filename) == nil ifFalse:				[(DataMaster thisFile: filename isKindOf: #database)					ifTrue: [dataBases at: eachItem label put: eachItem]]]].	dataBases isEmpty ifTrue: [^self booboo: 'there are no databases in this information center'].	(thePointers _ theMapItem fPointersOfType: dataBaseLinkType) isEmpty		ifFalse:			[currentDbs _ OrderedCollection new.			thePointers do: [:each | currentDbs add: (fileCabinet at: (each index)) label]].	databaseNames _ OrderedCollection new.	dataBases keysDo: [:key | databaseNames add: key].	theReturn _ DBoxView		openFor: #(multipleSelect)		title: 'Database links to ', theMapItem label		labels: (Array with: (#('databases:'), databaseNames))		defaults: (Array with: currentDbs)		commands: #(accept cancel bailOut)		autoAccept: false.	theReturn == nil ifTrue: [^false].	(theReturn at: 1) == nil ifTrue: [theReturn at: 1 put: OrderedCollection new].	databaseNames do:		[:dbName |		dbItem _ dataBases at: dbName.		((theReturn at: 1) includes: dbName)			ifTrue: "make sure there is a link here"				[(theMapItem fPointersIncludes: dbItem centerIndex type: dataBaseLinkType) ifFalse:					[theMapItem addFPointer: (DataItemPointer type: dataBaseLinkType index: dbItem centerIndex).					dbItem addBPointer: theMapItem centerIndex type: dataBaseLinkType.					self removeFromTrash: dbItem]]			ifFalse:	"make sure there is not a link here"				[(theMapItem fPointersIncludes: dbItem centerIndex type: dataBaseLinkType) ifTrue:					[theMapItem removeFPointer: dbItem centerIndex type: dataBaseLinkType.					dbItem removeBPointer: theMapItem centerIndex type: dataBaseLinkType.					self checkAndPerhapsTrash: dbItem]]]!match: aString withLinksFrom: theItem	| thePointers forwards thisItem | 	thePointers _ Set new.	forwards _ theItem fPointers.	forwards == nil ifFalse: [forwards do: [:each | each index >= self dataStart ifTrue:[thePointers add: each]]].	thePointers do: [:each | (self okToFoolWith: (thisItem _ self fileCabinet at: each index))			ifTrue:[thisItem label = aString ifTrue:[^thisItem]]			ifFalse: [thePointers remove: each]].	^nil!pasteFromBufferIntoFolder: folder before: aPointer	"take the reference in the move buffer and add it to folder before the indicated pointer"	| theItem newIndex clipItem fromCenter | 	Clipboard isEmpty | (Clipboard nextClass ~= DataItem) ifTrue: [Clipboard booboo. ^nil].	clipItem _ Clipboard retrieveEntry.	(fromCenter _ clipItem propertyAt: #center) == self		ifTrue:	"item in copy buffer is in same info center as trying to paste into"			[^self putThisItem: clipItem contents inThisFolder: folder before: aPointer notifyError: true]		ifFalse: "paste into different info center"			[theItem _ clipItem contents.			theItem isFolder				ifTrue: [newIndex _ self duplicateThisFolder: theItem sourceCenter: fromCenter into: folder keepItems: true dupItems: false]				ifFalse: [newIndex _ self duplicateThisItem: theItem sourceCenter: fromCenter into: folder dupFileName: nil].			 newIndex = 0 ifFalse:					[(fromCenter inbox fPointersIncludes: theItem centerIndex type: (fromCenter linkTypeFor: #contains)) ifTrue:						[fromCenter removeSelection: (clipItem propertyAt: #pointer).						fromCenter inbox classification: (fromCenter folderClassificationFor: fromCenter inbox).						ContainerModel changed: fromCenter inbox]]].	newIndex <= 0 ifTrue: [^nil].	^Array with: theItem iconDisplayString with: (DataItemPointer index: newIndex)!putThisItem: item inThisFolder: folder before: aPointer notifyError: notify	| theNewPointer newClass containsLink | 	folder isFolder		ifFalse: [notify ifTrue: [self booboo: folder label, ' is not a folder, you can''t add a connection here']. ^nil].	ContainerModel changed: folder.	containsLink _ self linkTypeFor: #contains.	(folder fPointersIncludes: item centerIndex type: containsLink)		ifTrue: [notify ifTrue: [self booboo: item label, ' is already in ', folder label]. ^nil].	theNewPointer _ DataItemPointer index: item centerIndex.	aPointer == nil		ifTrue:[folder addFPointer: (theNewPointer)]		ifFalse:[folder insertFPointer: (theNewPointer) before: aPointer].	item addBPointer: folder centerIndex type: containsLink.	Auditor audit ifTrue:[self class auditThis: (Array with: #add with: item displayString with: folder displayString with: self name)].	(folder centerIndex ~= self trashIndex and: [self trash fPointersIncludes: item centerIndex type: containsLink])			ifTrue: [self trash removeFPointer: (theNewPointer).					item removeBPointer: self trashIndex type: containsLink.					self trash classification: (self folderClassificationFor: self trash).					ContainerModel changed: self trash].	(folder centerIndex ~= self inboxIndex and: [self inbox fPointersIncludes: item centerIndex type: containsLink])			ifTrue: [self inbox removeFPointer: (theNewPointer).					item removeBPointer: self inboxIndex type: containsLink.					self inbox classification: (self folderClassificationFor: self inbox).					ContainerModel changed: self inbox].	newClass _ self folderClassificationFor: folder.	newClass = folder classificationIndex ifFalse:			[folder classification: newClass.			self updateClassFor: folder].	^Array with: item iconDisplayString with: theNewPointer!removeLinkOfType: aSymbol from: fromItem to: toItem 	"given any two dataItems, remove a link in the center of the specified 	symbolic type"	| linkType |	linkType _ self linkTypeFor: aSymbol.	(fromItem fPointersIncludes: toItem centerIndex type: linkType)		ifFalse: [^nil]		ifTrue: 			[fromItem removeFPointer: (DataItemPointer type: linkType index: toItem centerIndex).			toItem removeBPointer: fromItem centerIndex type: linkType.			self checkAndPerhapsTrash: toItem]!removeSelection: thePointer	| bPointers | 	(bPointers _ (fileCabinet at: (thePointer index)) bPointers) == nil ifFalse:		[bPointers do: "destroy all links to this item"			[:bP | (fileCabinet at: (bP index)) removeFPointer: thePointer index type: bP linkType]].	self removeOrphansOf: (fileCabinet at: (thePointer index)).	freeList add: (thePointer index).	fileCabinet at: (thePointer index) put: nil!removeThisItem: item fromFolder: folder	| itemPointer containsLink | 	(item bPointersIncludes: folder centerIndex type: (containsLink _ (self linkTypeFor: #contains))) ifFalse: [^false].	Clipboard clip: item.	Clipboard last propertyAt: #pointer put:(itemPointer _ DataItemPointer index: item centerIndex).	Clipboard last propertyAt: #center put: self.	Auditor audit ifTrue:[self class auditThis: (Array with: #cut with: item displayString with: folder displayString with: self name)].	ContainerModel message:'The available Item Reference is:', item iconDisplayString.	item removeBPointer: folder centerIndex type: containsLink.	item bPointers == nil ifTrue: "not referenced anywhere else?"		[self trash addFPointer: itemPointer.		 (fileCabinet at: (itemPointer index)) addBPointer: self trashIndex type: containsLink.		 self trash classification: (self folderClassificationFor: self trash).		 ContainerModel changed: self trash].	folder removeFPointer: itemPointer.	folder classification: (self folderClassificationFor: folder).	self updateClassFor: folder.	ContainerModel changed: folder.	^true! !!InformationCenter methodsFor: 'file server access'!backup: aSelection	"back up the selection into the users backup directory."	| netFileStream | 	(Smalltalk includesKey: #XDEInterfaceModel) ifFalse: [^self booboo: 'Sorry, I cannot do that'].	self save.	netFileStream _ FileStream fileNamed: 'backup'.	(self getFileNamesForSelection: aSelection withMapSupport: false) do:		[:item | netFileStream nextPutAll: item; nextPut: $ ].	netFileStream nextPutAll: self name, self class centerSuffix.	netFileStream close.	XDEInterfaceModel storeThese: '@backup' inDirectory: UserName,'>BackupData'!getTheseMapFilesFromServer: aMapSet	"get the missing map vector files from the file server"	| aXDE sendString theFileServerName | 	(Smalltalk includesKey: #XDEInterfaceModel) ifFalse: [^self booboo: 'Sorry, I cannot do that'].	theFileServerName _ UserProfile current selectFileServer.	theFileServerName == nil ifTrue: [^self].	aXDE _XDEInterfaceModel giveMeOne: true.	sendString _ 'ftp/l "', theFileServerName, (String with: $"), ' dir/c <AnalystSupport>MapData retrieve/c ',aMapSet.	aXDE sendTemplate: sendString.	aXDE changed.	XDEInterfaceModel openWith: aXDE!sendFilesToServer: aSelection	| aXDE netFileStream theHosts return theUsers sendString sendFiles | 	"get a list of file names for the user."	((Smalltalk includesKey: #XDEInterfaceModel) and: [(sendFiles _ self getFileNamesForSelection: aSelection withMapSupport: false) size ~= 0])		ifFalse: [^self booboo: 'Sorry, I cannot do that'].		UserProfile current userPassword isEmpty		ifTrue: [UserProfile current login == nil ifTrue: [^self]].	netFileStream _ FileStream fileNamed: #sendme asString.	sendFiles do: [:item | netFileStream nextPutAll: item; nextPut: $ ].	netFileStream close.	aXDE _XDEInterfaceModel giveMeOne: true.	(theHosts _ UserProfile current fileServerChoices copy) isEmpty ifTrue: [^self booboo: 'I do not know about any file servers'].	theHosts addFirst: #Hosts:.	theUsers _ LogInOut userList.	theUsers addFirst: #Receivers:.	return _ DBoxView		openFor: #(select multipleSelect )		title: 'Send Selection to selected users'		labels: (Array with: (theHosts asArray)  with: (theUsers asArray))		defaults: (Array with: ((theHosts includes: UserProfile current ifsName) ifTrue: [UserProfile current ifsName] ifFalse: [theHosts at: 2]) with: String new)		autoAccept: false.	return == nil ifTrue: [^self].	((return at: 2) == nil or: [(return at: 2) isEmpty]) ifTrue: [^self].	UserProfile current ifsName: (return at: 1).	sendString _ 'ftp/l "', (return at: 1), (String with: $").	(return at: 2) do: [:each | sendString _ sendString, ' dir/c <AnalystSupport>', each, ' store/ua @sendme'].	aXDE sendTemplate: sendString.	aXDE changed.	XDEInterfaceModel openWith: aXDE! !!InformationCenter methodsFor: 'add items and folders'!addThis: dataItem linkType: linkType to: thisFolder	"the caller to this method may need to set a backpointer in dataItem to theIndex returned by this method"	| theSlots theIndex | 	freeList isEmpty		ifTrue:			[theIndex _fileCabinet size + 1.			fileCabinet add: dataItem]		ifFalse:			[theIndex _ freeList last.			freeList removeLast.			fileCabinet at: theIndex put: dataItem].	dataItem centerIndex: theIndex.	thisFolder addFPointer: theIndex type: linkType certainty: DefaultCert.	^theIndex!addThis: dataItem linkType: linkType to: thisFolder beforePointer: aPointer	"the caller to this method may need to set a backpointer in dataItem to theIndex returned by this method"	| theSlots theIndex | 	freeList isEmpty		ifTrue:			[theIndex _ fileCabinet size + 1.			fileCabinet add: dataItem]		ifFalse:			[theIndex _ freeList last.			freeList removeLast.			fileCabinet at: theIndex put: dataItem].	dataItem centerIndex: theIndex.	aPointer == nil		ifTrue:[thisFolder addFPointer: theIndex type: linkType certainty: DefaultCert.]		ifFalse:[thisFolder insertFPointer: (DataItemPointer type: linkType index: theIndex) before: aPointer].	^theIndex!fetchNewFilesFrom: localDirectory message: objectToShowOn	"find on the local disk all files in this localDirectory and make sure they are referenced in the top level of this center (normally the Scavenge center)"	| theList dataTypes theShorterList otherwiseReferenced | 	Cursor execute showWhile: [	objectToShowOn show: 'Recovering new files, please wait . . . '.	theList _ Disk filesMatching: (localDirectory, (String with: $*)).	dataTypes _ Set new.	theList do: [:each | dataTypes add: (DataMaster giveMe: #englishString for: each)].	dataTypes do: [:dt | theList _ DataMaster trimList: theList for: dt].	otherwiseReferenced _ DataMaster getBasicAssociatedFilesOfTypes: dataTypes localDirectory: localDirectory.	theShorterList _ OrderedCollection new.	theList do:		[:each |		((self class lookForLabel: nil andKeys: nil dataType: nil fileName: each inUser: self name) == nil and: [(otherwiseReferenced includes: ((FileDirectory decomposeName: each) at: 'Name-Body')) not]) ifTrue: [theShorterList add: each]]].	theShorterList isEmpty ifTrue: [objectToShowOn show: 'There are no new files'. ^false].	self addFilesInList: theShorterList toFolder: (fileCabinet at: 1).	objectToShowOn show: theShorterList size printString, ' new data items are now available in the ', self name, ' Center'.	^true!fileAway: theItem	"Take the item in the copy buffer and paste it in this FileCabinet according to its key 	words. If no key word hits are found then it will be left in the in box for manual filing later "	| filedIt |	filedIt _ false. 	(theItem fPointersOfType: (self linkTypeFor: #keyword)) do:		[:kwItemPtr |		((fileCabinet at: (kwItemPtr index)) bPointersOfType: (self linkTypeFor: #keyword)) do:			[:diPtr |			(fileCabinet at: (diPtr index)) isFolder				ifTrue: [(self putThisItem: theItem inThisFolder: (fileCabinet at: (diPtr index)) before: nil notifyError: false) == nil					ifFalse: [ContainerModel changed: (fileCabinet at: (diPtr index)).					 filedIt _ true]]]].	^filedIt!makeAHolderOn: thePointers withLabel: theLabel searchString: searchString menuType: menuType	| hierarchPointers aDataItem | 	hierarchPointers _ Set new. "holders must have only hierarchical pointers"	thePointers do: [:ptr | hierarchPointers add: (DataItemPointer index: ptr index)].	aDataItem _ DataItem type: #Folder label: theLabel fPointers: hierarchPointers atIndex: 0.	aDataItem classification: (self folderClassificationFor: aDataItem).	(ContainerModel createForIndexOrItem: aDataItem inCenter: self) searchString: searchString; scheduleTheFolder: aDataItem label usingMenu: menuType width: 2 helpMessage: #Holder! !!InformationCenter methodsFor: 'verify center'!sweepCenterFrom: aDataItem	| theItem | 	aDataItem isFlagSet ifTrue: [^self] ifFalse: [aDataItem setFlag].	(aDataItem fPointersOfType: (self linkTypeFor: #contains)) do:		[:each | theItem _ fileCabinet at: (each index).		theItem isFolder			ifTrue: [ self  sweepCenterFrom: theItem]			ifFalse: [theItem setFlag]]!verify	| count theItem aSet | 	self clearFlags.	self sweepCenterFrom: (fileCabinet at: 1).	self sweepCenterFrom: (fileCabinet at: 2).	self sweepCenterFrom: (fileCabinet at: 3).	self sweepCenterFrom: (fileCabinet at: 4).	aSet _ Set new.	count _0.	DataStart to: fileCabinet size do:		[:index | (theItem _ fileCabinet at: index) == nil			ifFalse: [theItem isFlagSet				ifFalse: [count _ count + 1.					aSet add: theItem]]].	count = 0 ifTrue:[^nil].	aSet do: [:each| self addLinkOfType: (self linkTypeFor: #contains) from: self inbox to: each ].	ContainerModel changed: self inbox.	^count! !!InformationCenter methodsFor: 'item access'!openItemAt: centerIndex	"pack his suitcase and send him off"	| theSuitcase backwards thePointers tabLabel theItem |	theItem _ fileCabinet at: centerIndex.	theItem == nil ifTrue: [^self booboo: 'This item has been removed.'].	theItem isFolder ifTrue: [^ContainerModel openThisFolder: theItem inCenter: self searchString: String new].	theItem isKeyword ifTrue:		[tabLabel _ 'Connections from keyword ' , theItem label.		DataMaster findTheOneByEvaluating:		[:each | (each model isKindOf: ContainerModel) and: [each view label = tabLabel]]. 		backwards _ theItem bPointers.		thePointers _ OrderedCollection new.		backwards == nil ifFalse: [backwards do: [:each | each index >= self dataStart ifTrue:[thePointers add: each]]].		thePointers do: [:each | (self okToFoolWith: (self fileCabinet at: each index))								ifFalse: [thePointers remove: each]].		thePointers isEmpty ifTrue: [^self booboo: 'There are no items linked to this keyword.'].		self makeAHolderOn: thePointers withLabel: tabLabel searchString: nil menuType: 5].	(theItem typeSymbol = #Item)		ifTrue: [theSuitcase _ (Suitcase new packTheSuitcaseFrom: self name forItem: theItem).				theSuitcase searchString: String new.				^DataMaster viewSelection: theItem withSuitcase: theSuitcase]! !SharedObject comment:'Copyright (c) 1983, 1984, 1985, 1986 Xerox Corporation.  All Rights Reserved.'!!SharedObject methodsFor: 'initialize-release'!setSharedObject: anObject	thisContext sender receiver == self class		ifTrue: [realObject _ anObject.				protector _ CriticalSection forMutualExclusion]		ifFalse: [self error: 'The message setSharedObject: cannot presently be monitored']! !!SharedObject methodsFor: 'accessing'!getRealObject	^realObject! !!SharedObject methodsFor: 'trapping'!doesNotUnderstand: aMessage	^protector critical:		[realObject perform: aMessage selector			withArguments: aMessage arguments]! !!SharedObject methodsFor: 'overridden object messages'!addDependent: anObject	^self perform: #addDependent: with: anObject!at: index	^self perform: #at: with: index!at: index put: value	^self perform: #at:put: with: index with: value!broadcast: aSymbol	^self perform: #broadcast: with: aSymbol!broadcast: aSymbol with: anObject	^self perform: #broadcast:with: with: aSymbol with: anObject!copy	^self perform: #copy!dependents	^self perform: #dependents!perform: aSymbol	^self doesNotUnderstand:		(Message selector: #perform: argument: aSymbol)!perform: aSymbol with: anObject	^self doesNotUnderstand:		(Message selector: #perform:with: arguments:			(Array with: aSymbol with: anObject))!perform: aSymbol with: firstObject with: secondObject	^self doesNotUnderstand:		(Message selector: #perform:with: arguments:			(Array with: aSymbol with: firstObject with: secondObject))!perform: aSymbol with: firstObject with: secondObject with: thirdObject	^self doesNotUnderstand:		(Message selector: #perform:with: arguments:			(Array with: aSymbol with: firstObject with: secondObject with: thirdObject))!perform: aSymbol withArguments: anArray	^self doesNotUnderstand:		(Message selector: #perform:withArguments: arguments:			(Array with: aSymbol with: anArray))!release	^self perform: #release!removeDependent: anObject	^self perform: #removeDependent: with: anObject!size	^self perform: #size! !!Rectangle methodsFor: 'enumerating'!numbersDo: aBlock	origin numbersDo: aBlock.	corner numbersDo: aBlock.!numbersInit: aBlock	origin _ Point numbersInit: aBlock.	corner _ Point numbersInit: aBlock.!numbersReverseDo: aBlock	origin numbersReverseDo: aBlock.	corner numbersReverseDo: aBlock.!numbersReverseInit: aBlock	origin _ Point numbersReverseInit: aBlock.	corner _ Point numbersReverseInit: aBlock.!pointsDo: aBlock	origin _ aBlock value: origin.	corner _ aBlock value: corner.!pointsInit: aBlock	origin _ aBlock value.	corner _  aBlock value.! !!Rectangle methodsFor: 'from user'!userChangeCornerMinExtent: minExt maxExtent: maxExt grid: gridPoint gridOrigin: fixPoint outlineColor: halftoneForm 	"Get a new rectangle by moving the corner. Change the cursor accordingly.  	Keep the rectangle extent in bounds(nil if don't care). Keep corner gridded (nil if don't care).  	Return a new rectangle."	| grid minPoint maxPoint point |	minPoint _ origin +(minExt == nil ifTrue: [0@0] ifFalse: [minExt]).	maxPoint _ origin + (maxExt == nil ifTrue: [Display extent] ifFalse: [maxExt]).	grid _ gridPoint == nil ifTrue: [1@1] ifFalse: [gridPoint].	Sensor cursorPoint: corner.	Sensor waitButton.	^Cursor corner 		showWhile: [Display				outline: 					[point _ (Sensor cursorPoint min: maxPoint)								max: minPoint.					point _ (point - fixPoint grid: grid) + fixPoint.					origin corner: point]				while: 					[Processor yield.					Sensor redButtonPressed]				width: 2				halftone: halftoneForm]! !!Quadrangle methodsFor: 'displaying-generic'!displayOn: aDisplayMedium	"Display the border and insideRegion of the receiver."	insideColor ~~ nil ifTrue: [aDisplayMedium fill: self inside mask: insideColor].	"borderWidth ~~ 0 & (insideColor ~~ nil)		ifTrue: 			[aDisplayMedium fill: self region mask: borderColor.			aDisplayMedium fill: self inside mask: insideColor]"	borderWidth == 0 ifFalse:		[insideColor == nil		 ifTrue:			[(self region areasOutside: self inside) do: [:r |				aDisplayMedium fill: r mask: borderColor]]		 ifFalse:			[aDisplayMedium fill: self region mask: borderColor.			aDisplayMedium fill: self inside mask: insideColor]]! !!InputState methodsFor: 'private'!keyAt: index put: value	| mask |	index < 8r200	  ifTrue:  "Not a potential special character "		[value ~= 0 ifTrue:			[(index = $c asciiValue and: [ctrlState ~= 0])				ifTrue: [lshiftState ~= 0							ifTrue: [UserName == nil ifFalse: [self forkEmergencyEvaluatorAt: Processor userInterruptPriority]]							ifFalse: [UserName == nil ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]]				ifFalse: [(index = $a asciiValue and: [ctrlState ~= 0])								ifTrue: [(Smalltalk includesKey: #BackgroundPrinter) ifTrue: [ScheduledControllers suicideLeapInto:[BackgroundPrinter snapForm]]]								ifFalse: [^keyboardQueue nextPut:												(KeyboardEvent code: index																 meta: metaState)]]]]	  ifFalse:		[index = CtrlKey		  ifTrue: [ctrlState _ value bitShift: 1]		  ifFalse:			[index = LshiftKey			  ifTrue: [lshiftState _ value]			  ifFalse:				[index = RshiftKey				  ifTrue: [rshiftState _ value]				  ifFalse:					[index = LockKey					  ifTrue: [lockState _ value bitShift: 2]					  ifFalse:						[(index >= BitMin and: [index <= BitMax])						  ifTrue:							[mask _ 1 bitShift: index - BitMin.							value = 1							  ifTrue: [bitState _ bitState bitOr: mask]							  ifFalse: [bitState _ bitState bitAnd: -1 - mask]]						  ifFalse:							[value ~= 0 ifTrue:								[keyboardQueue nextPut:									(KeyboardEvent code: index meta: metaState)]]]]]].		metaState _ (ctrlState bitOr: (lshiftState bitOr: rshiftState)) bitOr: lockState]!nextEvent: type with: param	"Process a single input event, aside from mouse X/Y"	| highTime lowTime |	type = 0  "Delta time"		ifTrue: 			[timeProtect critical: [deltaTime _ deltaTime + param]]		ifFalse:			[type = 3	"Key down"				ifTrue:					[Idle newEvent ifTrue: [^self].					self keyAt: param put: 1.					]				ifFalse:					[type = 4	"Key up"						ifTrue:							[Idle newEvent ifTrue: [^self].							self keyAt: param put: 0.							]						ifFalse:							[type = 5	"Reset time"								ifTrue:									[InputSemaphore wait.									highTime _ self primInputWord.									InputSemaphore wait.									lowTime _ self primInputWord.									timeProtect critical:										[baseTime _ (highTime bitShift: 16) + lowTime.										 deltaTime _ 0]]								ifFalse: [self error: 'Bad event type']]]]! !Pool named: #TextConstants includes: #Justified!Pool named: #TextConstants includes: #DefaultBaseline!Pool named: #TextConstants includes: #DefaultLineGrid!!TextStyle methodsFor: 'accessing'!alignment: anInteger 	"Set the current setting of the alignment to be anInteger--	0=left flush, 1=right flush, 2=centered, 3=justified."	alignment _ anInteger \\ (Justified + 1)!baseline	"Answer the distance from the top of the line to the bottom of most of the characters (by convention, bottom of A)."	outputMedium = #DisplayPrinterWidths		ifTrue:	[^baseline // self pressScale]		ifFalse:	[^baseline]!fontAt: index 	"This is private because no object outside TextStyle should depend on the representation of the font family in fontArray"	| fontIndex |	fontIndex _ (index min: (fontArray size)) max: 1.	((fontArray at: fontIndex) isMemberOf: StrikeFont)		ifTrue: [^fontArray at: fontIndex].	((fontArray at: 1)		isMemberOf: StrikeFont)			ifTrue: [^fontArray at: 1].	self error: 'No valid fonts in font array'.!lineGrid	"Answer the relative space between lines of a paragraph in the style of the receiver."	^lineGrid!outputMedium: aSymbol	"Set the outputMedium for this style -- currently either Display or PressPrinter"	outputMedium _ aSymbol.	outputMedium = #Display		ifTrue:	[lineGrid _ DefaultLineGrid.				baseline _ DefaultBaseline]		ifFalse:	[outputMedium = #PressPrinter					ifTrue:	[lineGrid _  565. "(16 * 2540.0 / 72.0 + 1) asInteger"							baseline _ lineGrid "make same for now"]]!pressScale	^(outputMedium == #PressPrinter or: [outputMedium == #DisplayPrinterWidths])		ifTrue: [PressFile pressScale]		ifFalse:	[1]!tabsArray	^tabsArray! !Pool named: #TextConstants includes: #DefaultTab!!TextStyle methodsFor: 'tabs and margins'!nextTabXFrom: anX leftMargin: leftMargin rightMargin: rightMargin	"Tab stops are distances from the leftMargin. Set the distance into anX normalized for the paragraph's left margin. Scale makes the routine usable for printing. On the display the scale is 1."	| normalizedX tabX |	normalizedX _ anX - leftMargin.	1 to: tabsArray size do: 		[:i | (tabX _ ((tabsArray at: i) * self pressScale) asInteger) > normalizedX 				ifTrue: [^leftMargin + tabX min: rightMargin]].	^rightMargin!tabWidth	"Answer the width of standard tab."	^ DefaultTab * self pressScale! !!TextStyle methodsFor: 'private'!marginTabAt: marginIndex side: sideIndex	"The marginTabsArray is an Array of tuples.  The Array is indexed according to the marginIndex, the 'nesting' level of the requestor. sideIndex is 1 for left, 2 for right"	| scale |	(outputMedium = #PressPrinter)		ifTrue:	[scale _ self pressScale]		ifFalse:	[scale _ 1].	(marginIndex > 0 and: [marginIndex < marginTabsArray size])		ifTrue: [^((marginTabsArray at: marginIndex) at: sideIndex) * scale]		ifFalse: [^0]! !PrintStyle comment:'Copyright (c) 1984, 1985 Xerox Corporation.  All rights reserved.I provides so called styles only for printing operations. Next instance variables make it easy to imagine what''s like printStyle for more concrete. The measurement unit used is 2 micas(2/100 mm) everywhere.Instance Variables: fontArray<Array>  A collection of printFonts. The emphasis portion of aText returns a value for indexing the font. lineGrid	<Integer>  The amount to be added to the top of a line to find the top of the next line. tabsArray<Array>  Tab stops.  Values are relative to the left margin of the text. leftMargin, rightMargin, topMargin, BottomMargin<Integer> Master cordinates delimitating printing materials. Pay attention that ringhtMargin is measured from the left most side of ''substantial area'', which is the intersectional area of A4 and letter size, and bottomMargin is from the top most side of ''substantial area''.hedingString<String>For page header. formScale<Integer> Single dot on the display screen is printed as n*n dots on the printer, in case of formScale=n" . paperSize<Point> Size(width and height) of (substantial)printing area. For example, 10500 @ 13970 for the intersectional area of A4 and US letter size. closed<Boolean> ''true'' means the consistency of current printStyle is guaranteed and false means not.'!!PrintStyle methodsFor: 'accessing'!formScale	^formScale!formScale: anInteger 	anInteger isInteger		ifTrue: [formScale _ anInteger]		ifFalse: [formScale _ nil]!lineGrid: anInteger 	anInteger isInteger		ifTrue: [lineGrid _ anInteger]		ifFalse: [lineGrid _ nil]!paperSize	^paperSize!paperSize: aPoint 	(aPoint isMemberOf: Point)		ifTrue: [paperSize _ Point x: aPoint x y: aPoint y]		ifFalse: [paperSize _ nil]!pressScale	^ self class pressScale! !!PrintStyle methodsFor: 'margin accessing'!bottomMargin	^bottomMargin!bottomMargin: anInteger 	anInteger isInteger		ifTrue: [bottomMargin _ anInteger]		ifFalse: [bottomMargin _ nil]!leftMargin	^leftMargin!leftMargin: anInteger 	anInteger isInteger		ifTrue: [leftMargin _ anInteger]		ifFalse: [leftMargin _ nil]!rightMargin	^rightMargin!rightMargin: anInteger 	anInteger isInteger		ifTrue: [rightMargin _ anInteger]		ifFalse: [rightMargin _ nil]!topMargin	^topMargin!topMargin: anInteger 	anInteger isInteger		ifTrue: [topMargin _ anInteger]		ifFalse: [topMargin _ nil]! !!PrintStyle methodsFor: 'private'!copy	| newPrintStyle |	newPrintStyle _ self shallowCopy.	newPrintStyle		lineGrid: lineGrid deepCopy;		alignment: alignment deepCopy."		tabsArray: tabsArray deepCopy"	^newPrintStyle! !!PrintStyle methodsFor: 'font accessing'!fontArray: anArray 	"Replacement of current fontArray by a designed new 	array(argument)"	| newArray newSize |	(anArray isMemberOf: Array)		ifFalse: [fontArray _ nil. ^self].	anArray do: [:font | (font isMemberOf: DisplayPrintFont)			ifFalse: [fontArray _ nil]].	fontArray _ anArray shallowCopy.	lineGrid _ ((fontArray at: 1) fontSize * (1.2 * 635 / 36)) ceiling!fontAt: index	| aFont |  	"Answer aPrintFont in fontArray designated by index(argument). Default printFont is the first element of fontArray."	aFont _ (fontArray at: (self class defaultFontsConversionArray at: index)) copy.	aFont strikeFont: (DefaultTextStyle fontAt: index).	^aFont!fontFor: fontIndex face: face	| currentFont currentFamilySizeFace family size emphasis newFamilySizeFace |	currentFamilySizeFace _ (currentFont _ TextStyle default fontAt: fontIndex) familySizeFace.	family _ currentFamilySizeFace at: FamilyName.	size _ currentFamilySizeFace at: PointSize.	emphasis _ currentFont emphasis.	(1 to: TextStyle default fontArray size)		do:	[:faceFontIndex |			newFamilySizeFace _ (currentFont _ TextStyle default fontAt: faceFontIndex) familySizeFace.			((((family = (newFamilySizeFace at: FamilyName))				and: [size = (newFamilySizeFace at: PointSize)])					and: [face = (newFamilySizeFace at: Face)])						and: [(emphasis bitAnd: NonFaceEmphasisMask) =								(currentFont emphasis bitAnd: NonFaceEmphasisMask)])				ifTrue:	[^faceFontIndex]].	^ fontIndex!newFontArray: anArrayForPrintFont 	"initialize instance variables with defaults"	super newFontArray: anArrayForPrintFont.	lineGrid _ DefaultPrinterLineGrid.	tabsArray _ DefaultPrinterTabsArray.	outputMedium _ #DisplayPrinterWidths.	paperSize _ DefaultPaperSize.	paperSize _ DefaultPaperSize.	leftMargin _ DefaultLeftMargin.	rightMargin _ DefaultRightMargin.	topMargin _ DefaultTopMargin.	bottomMargin _ DefaultBottomMargin.	formScale _ DefaultFormScale! !!PrintStyle methodsFor: 'tab accessing'!nextTabXFrom: anX leftMargin: aLeftMargin rightMargin: aRightMargin"answer next tab position"	| normalizedX tabX |	normalizedX _ anX - aLeftMargin.	1 to: tabsArray size do: 		[:i | (tabX _ (tabsArray at: i) asInteger) > normalizedX 			ifTrue: [^aLeftMargin + tabX]].!tabsArray	^tabsArray!tabsArray: anArray 	| previousTabPosition |	((anArray isMemberOf: Array) and: [anArray size > 0])		ifFalse: [tabsArray _ nil].	tabsArray _ anArray!tabWidth: anX leftMargin: aLeftMargin"answer next tab position"	| normalizedX tabX |	normalizedX _ anX - aLeftMargin.	1 to: tabsArray size do: 		[:i | (tabX _ (tabsArray at: i) asInteger) = normalizedX 			ifTrue: [^tabX]].	self halt.!underlinedFontFor: fontIndex	| name thisFont underlinedFontIndex underlinedFont |	name _ (thisFont _ TextStyle default fontAt: fontIndex) name.	(1 to: TextStyle default fontArray size)		do:	[:underlinedFontIndex |			(underlinedFont _				TextStyle default fontAt:  underlinedFontIndex) name = name				ifTrue:	[(((underlinedFont emphasis bitAt: UnderlinedBit) = 1)							and: [(thisFont emphasis bitAnd: SubSuperscriptMask) =									(underlinedFont emphasis bitAnd: SubSuperscriptMask)])							ifTrue:	[^underlinedFontIndex]]].	^ fontIndex!unUnderlinedFontFor: fontIndex	| name thisFont unUnderlinedFontIndex unUnderlinedFont |	name _ (thisFont _ TextStyle default fontAt: fontIndex) name.	(1 to: TextStyle default fontArray size)		do:	[:unUnderlinedFontIndex |			(unUnderlinedFont _				TextStyle default fontAt: unUnderlinedFontIndex) name = name				ifTrue:	[(((unUnderlinedFont emphasis bitAt: UnderlinedBit) = 0)							and: [(thisFont emphasis bitAnd: SubSuperscriptMask) =									(unUnderlinedFont emphasis bitAnd: SubSuperscriptMask)])							ifTrue:	[^unUnderlinedFontIndex]]].	^ fontIndex! !ClipBuffer comment:'Copyright (c) 1986, 1987 Xerox Corporation.  All Rights Reserved.'!!ClipBuffer methodsFor: 'initialize-release'!initialize	collection _ OrderedCollection new.	tally _ 0.	displayFlag _ false.	mode _ #noStack.	firstSeenFlag _ false.	accessedOnceFlag _ false.	^self! !!ClipBuffer methodsFor: 'copy buffer accessing'!booboo	^self booboo:'The current contents of the copy bufferare not useful in this situation'!clear	"clear the clipboard"	displayFlag ifTrue:[collection do: [:each | each erase]].	collection _ OrderedCollection new.	tally _ 0.	firstSeenFlag _ false.!clip: anObject 	"place an object on the clipboard"	| displayString |	accessedOnceFlag		ifTrue: 			[self eraseAll.			self redisplay].	accessedOnceFlag _ false.	firstSeenFlag		ifTrue: 			[collection last erase.			collection removeLast.			tally _ 0.			firstSeenFlag _ false].	mode == #noStack		ifTrue: 			[self eraseAll.			collection _ OrderedCollection with: (ClipEntry new contents: anObject).			tally _ 1]		ifFalse: 			[collection add: (ClipEntry new contents: anObject).			tally _ tally + 1].	collection last form offset: 0 @ (tally - 1 * 20).	displayFlag ifTrue: [collection last display]!isEmpty	^collection isEmpty!last	"return the last ClipEntry placed on the clipboard"	^collection last!retrieve	"return the contents of the appropriate element of the clipboard, and remove that element"	| nextElement |	accessedOnceFlag _ true.	tally = 0 ifTrue:[^nil].	mode == #fifo		ifTrue: 			[nextElement _ collection first contents.			tally > 1				ifTrue: 					[displayFlag ifTrue:[collection first erase].					collection removeFirst.					tally _ tally - 1]				ifFalse: [firstSeenFlag _ true]].	mode == #lifo		ifTrue: 			[nextElement _ collection last contents.			tally > 1				ifTrue: 					[displayFlag ifTrue:[collection last erase].					collection removeLast.					tally _ tally - 1]				ifFalse: [firstSeenFlag _ true]].	mode == #noStack		ifTrue:[nextElement _ collection last contents].	^nextElement!retrieveEntry	"return the appropriate element of the clipboard (with properties), and remove that element"	| nextElement |	accessedOnceFlag _ true.	tally = 0 ifTrue:[^nil].	mode == #fifo		ifTrue: 			[nextElement _ collection first.			tally > 1				ifTrue: 					[displayFlag ifTrue:[collection first erase].					collection removeFirst.					tally _ tally - 1]				ifFalse: [firstSeenFlag _ true]].	mode == #lifo		ifTrue: 			[nextElement _ collection last.			tally > 1				ifTrue: 					[displayFlag ifTrue:[collection last erase].					collection removeLast.					tally _ tally - 1]				ifFalse: [firstSeenFlag _ true]].	mode == #noStack		ifTrue:[nextElement _ collection last].	^nextElement!statusString	^mode, (String with: $/), (String with: (displayFlag printString at: 1))!statusString: statusString	| statusStream | 	statusStream _ ReadStream on: statusString.	mode _ (statusStream upTo: $/) asSymbol.	displayFlag _ (statusStream next = $t)! !!ClipBuffer methodsFor: 'peeking'!next	"return the next element on the clipboard wihout destroying it"	collection isEmpty ifTrue: [^nil].	mode == #fifo		ifTrue: [^collection first]		ifFalse: [^collection last]!nextClass	collection isEmpty ifTrue:[^nil].	mode == #fifo		ifTrue: [^collection first contents class]		ifFalse: [^collection last contents class]!nextIsKindOf: aClass 	mode == #fifo		ifTrue: [^collection first contents isKindOf: aClass]		ifFalse: [^collection last contents isKindOf: aClass]! !!ClipBuffer methodsFor: 'state setting'!firstInFirstOut	"set the order of retrieval"	mode _ #fifo!lastInFirstOut	"set the order of retrieval"	mode _ #lifo!noStacking	mode _ #noStack.	self clear! !!ClipBuffer methodsFor: 'displaying'!eraseAll	displayFlag ifTrue: [collection do: [:each | each erase]]!redisplay	"redisplay all of the clipboard's elements"	displayFlag ifTrue: [1 to: collection size do: 			[:each | 			(collection at: each) form offset: 0 @ (each - 1 * 20).			(collection at: each) display]]! !!ClipBuffer methodsFor: 'show/hide'!doNotShow	"set the clipboard so that the elements do not display themselves"	self eraseAll	.	displayFlag _ false!show	"set the clipboard so that the elements display themselves"	displayFlag _ true.	self redisplay! !!ClipBuffer methodsFor: 'searching'!includes: anObject 	| each |	collection do: [:each | each contents class == anObject class ifTrue: [each contents = anObject ifTrue: [^true]]].	^false!remove: anObject 	| each |	collection do: [:each | each contents class == anObject class ifTrue: [each contents = anObject ifTrue: [collection remove: each]]].	self eraseAll.	self redisplay!removeUsing: aBlock	| each |	self eraseAll.	collection do: [:each | (aBlock value: each) ifTrue: [collection remove: each]].	self redisplay! !SSDataBase comment:'Copyright (c) Xerox Corporation, 1985. All rights reserved.'!!SSDataBase methodsFor: 'As yet unclassified'!deepCopy	| deep | 	deep _ self class new.	deep init: fileName!field: aStringOrSymbol 	| realName |	aStringOrSymbol class == String		ifTrue: [realName _ aStringOrSymbol asSymbol]		ifFalse: [realName _ aStringOrSymbol].	^file field: realName!field: aStringOrSymbol from: aQueryString	| realName |	aStringOrSymbol class == String		ifTrue: [realName _ aStringOrSymbol asSymbol]		ifFalse: [realName _ aStringOrSymbol].	^file field: realName fitting: (FixedFileFilter on: aQueryString)!fieldNames	^file fieldNames!getFieldName	^ PopUpMenu on: file fieldNames!getQuery	^ Querier request: 'Database Query?' withFields: file fieldNames types: file fieldTypes!init: aFileName	fileName _ aFileName.	file _ ClassifiedFixedFileStream fileNamed: aFileName!printOn: aStream	aStream nextPutAll: 'SSDataBase on: ', fileName printString!release	file close!storeOn: aStream	aStream nextPutAll: 'SSDataBase on: ', fileName printString! !Interpress comment:'Copyright (c) 1984, 1985, 1986 Xerox Corporation.  All rights reserved.I''m so called Interpress creator. My instances generate an Interpress master as aFileSream from aText or aForm input with aPrintStyle passed. Coordinate system used as Master Coordinate System internally is left-haded and its origin is placed at upper left corner of the intersectional area of A4 and US letter size(referenced as ''substantial area'' in comments below for convenience). The measurement unit used is 2 micas(2/100 mm) everywhere. This coordinate system enables easy manipulation of coordinates.Instance Variables stream<FileSream> Interpress master ,which consists of encoded values for Interpress Base Language. Having formatted style, this can be sent directly to Interpress-Printer to get hard copy buffer<ByteArray> Just a buffer in which a chunk of Interpress master is kept until its size equals to buffer size. This buffering function is adopted to improve performance. There are many checking items for each I/O operation to fileStream. So buffering reduces absolute number of them. location<SmallInteger> Index which means how many bytes as data there are in ''''buffer''''. x, y<Integers> Current positions in the Master Coordinate System. topMargin, bottomMargin, leftMargin, rightMargin<Integers> Printing image coordinates delimitating printing materials given by the current printStyle. Pay attention that ringhtMargin is measured from the left most side of substantial area and bottomMargin is from the top most side. See PrintStyle comment. lineGrid<Integer> length between contiguous lines of text retained from by current printStyle. See PrintStyle comment ''lineGrid'' for detail. linesPerPage<Integer> Number of lines containable in one page. lastIndex<Integer> Top character''s  Index of expected new line which might be retained next. pageNumber<SmallInteger> This indicates the page number being currently processed. fontArray<Array> Array of aPrintFonts for text being currently processed, which is the information from current printStyle. printStyle<PrintStyle> This represents so called printing style like margins, fonts for printing text, header information etc. See PrintStyle comments. lines<Array> An array of instances of TextLineInterval. Each of its elements'' fields contains starting index and stopping index of its representing line. Each index here is its corresponding character index in the text. text<Text> A text given for Interpressing. time<Time> Starting time of Interpressing. headingString<String> A string for heading retained from current printStyle. delimitorCountArray<Array> Each element of this array represents the number of tabs and font-changes contained in corresponding line of lines.example: (* means a character.  - for a tab, # for a font-change and % for both a tab and a font-change.) 		******#*-****%*******	(delimitorCount=3) (line: (1 to:21))		******#**************	(delimitorCount=1) (line: (22 to:42))		-**********				(delimitorcount=1) (line: (43 to:53))		--*********				(delimitorcount=2) (line: (54 to:64))				In this case, text is composed of 4 lines.  And delimitorCountArray= (3 1 1 2).  The size of this Array is same as the number of lines contained in the text and the element''s default value is 0. See PrintScanner''s comment for ''delimitorCount''. delimitorIndicesArray<Array> Each element of this array is an array of tab or font-change indices. Each index is corresponding to the tab or font-change position in the current text.example:		In the case above, delimitorIndicesArray=((7 9 14 0 0  --- 0) (28 0 0 --- 0) (43 0 0 --- 0) (54 55 0 0  --- 0)). The initial size of each element array is same as size of tabsArray(,which is one of PrintStyle''s instance variables) or 32 and the element''s default value for each element array is 0. Font-Array position here means a character index at which font continued until then ends.  See PrintScanner''s comment for ''delimitorIndices''. delimitorPositionsArray<Array> Each element of this array is an array of tab and font-change position ( not character index but x-coordinate for beginning point of the next character on the printing image). Each value is corresponding to the absolute coordinate of starting point for showing an sequence of string onto an paper.example:		In the case above, delimitorIndicesArray=((3850 4037 4890 0 0  --- 0) (4100 0 0 --- 0) (2807 0 0 --- 0) (2807 2980 0 0  --- 0)) for example. The size of each element array and element''s default value for each element array is same as of delimitorIndicesArray. See PrintScanner''s comment for ''delimitorPositions''. countsBetweenDelimitorsArray<Array> Each element of this array is an array of the number of characters. Each value is corresponding to the number of characters between delimitors(tabs or font-changes).example:		In the case above, countsBetweenDelimitorsArray=((7 1 4 0 0  --- 0) (7 0 0 --- 0) (0 0 0 --- 0) (0 0 0  --- 0)) for example. If there is no characters between tabs, corresponding values are to be 0.		The size of each element array and element''s default value for each element array is same as of delimitorIndicesArray. See PrintScanner''s comment for ''countsBetweenDelimitors''. delimitorTypesArray<Array> In single-font version, each element of this array is an array which every element is aSymbol #single, and in multi-font version, each element of this array is an array for representing delimitors type: tab, font-change or tab and font-change, each case is represented as symbol #tab, #run and #runTab respectively.example:		If considered for multi-font version, In the case above,delimitorTypesArray = ((#run #tab #runTab nil nil  - - nil) (#run nil nil  - -  nil) (#tab nil nil  -- nil) (#tab #tab nil nil  - - nil))		The size of each element array is same as of delimitorIndicesArray. Element''s default value for each element array is nil.  See PrintScanner''s comment for ''delimitorTypes''.'!!Interpress methodsFor: 'accessing'!bottomMargin^bottomMargin!bottomMargin: aMarginbottomMargin _ aMargin!heading: heading	(heading isKindOf: Array)		ifTrue: [headingString _ heading]		ifFalse: [headingString _ Array with: heading]!leftMargin^leftMargin!leftMargin: aMarginleftMargin _ aMargin!lineGrid: anInteger	lineGrid _ anInteger.	(bottomMargin == nil or: [topMargin == nil])		ifFalse: [linesPerPage _ (bottomMargin - topMargin) quo: lineGrid]!margins: aRect	leftMargin _ aRect origin x.	rightMargin _ aRect corner x.	topMargin _ aRect origin y.	bottomMargin _ aRect corner y..	(lineGrid ~= nil and: [lineGrid> 0])		ifTrue: [linesPerPage _ (bottomMargin - topMargin) quo: lineGrid]!marginsTranspose	| newLeftMargin newRightMargin | 	newLeftMargin _ topMargin.	newRightMargin _ bottomMargin.	topMargin _ leftMargin.	bottomMargin _ rightMargin.	leftMargin _ newLeftMargin.	rightMargin _ newRightMargin.	(lineGrid ~= nil and: [lineGrid> 0])		ifTrue: [linesPerPage _ (bottomMargin - topMargin) quo: lineGrid]!pageNumber: anInteger	pageNumber _ anInteger!printStyle	^printStyle!rightMargin^rightMargin!rightMargin: aMarginrightMargin _ aMargin!text	^text!text: aText	text _ aText!topMargin^topMargin!topMargin: aMargintopMargin _ aMargin! !!Interpress methodsFor: 'private'!byteSize: anInteger	"Answer minimal byte size for representing a signed integer."	| count inRange absInteger | 	count _ 0.	inRange _ false.	anInteger > 0		ifTrue: [[inRange] whileFalse:					[count _ count+1.	 				inRange _ anInteger < (self halfUpperBoundAt: count)]]		ifFalse: [absInteger _ anInteger abs.				[inRange] whileFalse:					[count _ count+1.					inRange _ absInteger <= (self halfUpperBoundAt: count)]].	^count!fileNamed: fileName setPrintStyle: aPrintStyle"Initialize instance variables common for 'text' and 'graphics' mainly from aPrintStyle (argument).""	(aPrintStyle isMemberOf: PrintStyle) 		ifFalse:[Transcript cr;show:' I want ''aPrintStyle''';cr. ^nil].	aPrintStyle isClose		ifFalse:[Transcript cr;show:'warning: consistency is not guaranteed';cr.]."	printStyle _ aPrintStyle.	fontArray _ printStyle fontArray.	topMargin _ printStyle topMargin.	bottomMargin _ printStyle bottomMargin.	leftMargin _ printStyle leftMargin.	rightMargin _ printStyle rightMargin.	headingString _ Array new: 1.	self fileNamed: fileName!halfUpperBoundAt: anInteger	"This is a dirty way to speed up Interpress printing. The array used here is equivalent to UpperBounds/2 only without the first element. This method is called while calculating the byte size of a signed integer."	^anInteger > 3		ifTrue: [(256 raisedTo: anInteger)/2]		ifFalse: [#(128 32768 8388608) at: anInteger]!isShortNumber: anInteger"Answer if anInteger(argument) is a Short Number.  Short Number's range is defined as [-4000 , 28767] in Interpress Base Language."	^anInteger <= 28767 and: [anInteger >= -4000]!setPrintStyle: aPrintStyle"Initialize instance variables common for 'text' and 'graphics' mainly from aPrintStyle(argument)."	self fileNamed: 'Scratch.interpress$' setPrintStyle: aPrintStyle!unitsPerLine"Printer has 300 lines per 1270 units(=2540 micas)."	^1270/300!upperBoundAt: anInteger	^UpperBounds size < (anInteger + 1)		ifTrue: [256 raisedTo: anInteger. Transcript cr; show: 'new upperBound: ', anInteger printString]		ifFalse: [UpperBounds at: anInteger + 1]! !!Interpress methodsFor: 'values for contents of master'!appendChars: aCollection from: start to: stop 	"Append to master stringSequenceType(=1) and aCollection characters from 	start to stop. As special case, code conversion is done if the character is $ or 	^ or _. Because in those cases, encoded values are different between 	Smalltalk side and printer side"	| char sz i |	(sz _ stop - start + 1) > 0		ifTrue: 			[self appendSequenceDescriptor: 1 length: sz.			i _ start - 1.			[(i _ i + 1) > stop]				whileFalse: [(char _ aCollection at: i) = $$						ifTrue: [stream nextPut: 164]						ifFalse: [char = $^								ifTrue: [stream nextPut: 173]								ifFalse: [char = $_										ifTrue: [stream nextPut: 172]										ifFalse: [stream nextPut: char asInteger	"why ?"]]]].			stream nextPut: 150 "16r80(128) + opNumber(22)"]!appendInt: aNumber length: len	"Encode an integer in (-256 to the power of len div 2)...(256 to the power of len div 2-1) in twos-complement. using len bytes, high-order byte first."	| upperBound num |	upperBound _ self upperBoundAt: len.	num _ aNumber.	num < 0		ifTrue: [num _ upperBound + num].	(num < 0 or: [num >= upperBound])		ifTrue: [self error: 'length ', len printString, ' is too small for the number ', aNumber printString].	len to: 1 by: -1 do: [:i |		stream nextPut: (num digitAt: i)]!appendInteger: n	"Append n(argument) as sequence of each byte's value."	| integer len |	integer _ n asInteger.	(integer >= -4000 & (integer <= 28767))		ifTrue: [self appendInt: 4000+integer length: 2]		ifFalse: 			[len _ self byteSize: integer.			self appendSequenceDescriptor: 2 "#sequenceInteger" length: len.			self appendInt: integer length: len]!appendOp: anInteger	(anInteger < 0 or: [anInteger > 8191])		ifTrue: [self error: 'invalid op code: ', anInteger printString].	anInteger <= 31		ifTrue: [stream nextPut: 128+anInteger]		ifFalse: [stream nextPut: (160+(anInteger//256)).				stream nextPut: (anInteger \\ 256)]!appendRational: r	"Append r(argument) as sequence of each byte's value. It Appends the numerator followed by the denominator. Maximum of numerator's byte size and denominator's byte size is adopted because of making each byte size be the same. For example, if the argument is -1/50000, 'bytes'(one of the temporary values below) is to be 3." 	| rational bytes n d |	(r isKindOf: Fraction)		ifTrue: 			[rational _ r asFraction.			n _ rational numerator.			d _ rational denominator.			bytes _ (self byteSize: n) max: (self byteSize: d).			self appendSequenceDescriptor: 4 "#sequenceRational" length: bytes + bytes.			self appendInt: n length: bytes.			self appendInt: d length: bytes]		ifFalse: [self appendInteger: r]!appendSequence: aCollection type: aNumber"Append to master sequenceType(aNumber--second argument) ,the size of aCollection(first argument) and aCollection as ByteArray in order."	self appendSequenceDescriptor: aNumber length: aCollection size.	stream nextPutAll: aCollection.!appendSequenceDescriptor: aNumber length: length"Append to master sequenceType(aNumber--first argument) and the size of aCollection(length--second argument) in order."	length < 256		ifTrue: 			[stream nextPut: 192"16rC0" + aNumber.			stream nextPut: length]		ifFalse: 			["(self byteSize: length) > 4 ifTrue: [self error: 'length too long'].---crazy case"			stream nextPut: 224  "16rE0" + aNumber.			self appendInt: length length: 3]!appendShortNumber: anInteger	stream nextWordPut: anInteger + 4000!appendString: aString length: stringSize	| char | "Append to master stringSequenceType(=1) and aString as collection of each character's encoded values in order. As special case, code conversion is done if the character is $ or ^ or _. Because in those cases, encoded values are different between Smalltalk side and printer side"	self appendSequenceDescriptor: 1 length: stringSize.	1 to: stringSize do: [:i |		char _ aString at: i.		char = $$		ifTrue: [stream nextPut: 164]		ifFalse:[char = $^				ifTrue:[stream nextPut: 173]				ifFalse:[char = $_						ifTrue: [stream nextPut: 172]						ifFalse: [stream nextPut: char asInteger]]]]! !!Interpress methodsFor: 'BaseLanguagesForOperator'!CONCAT	stream nextWordPut: 41125  "16rA000(40960) + opNumber(165)"!CONCATT	stream nextWordPut: 41128  "16rA000(40960) + opNumber(168)"!CORRECT	self appendOp: 110!DO	stream nextWordPut: 41191 "16rA000(40960) + opNumber(231)"!DOSAVE	stream nextWordPut: 41192 "16rA000(40960) + opNumber(232)"!DOSAVEALL	stream nextWordPut: 41193 "16rA000(40960) + opNumber(233)"!DOSAVESIMPLEBODY	stream nextWordPut:41080 "16rA000(40960)+opNumber(120)".!FGET:n	self appendShortNumber:n.	stream nextPut: 148 "16r80(128) + opNumber(20)"!FINDFONT:fontName	self appendSequence: #(120 101 114 111 120 ) "('xerox' asArray collect: [:char | char asInteger])" type: 5."	self appendSequence: #(120 99 49 45 49 45 49 ) ('xc1-1-1' asArray collect: [:char | char asInteger]) type: 5."	self appendSequence: #(120 99 56 50 45 48 45 48 ) "('xc82-0-0' asArray collect: [:char | char asInteger])" type: 5.	self appendSequence: (fontName asArray collect: [:char | char asInteger]) type: 5.	self MAKEVEC:3.	stream nextWordPut: 41107 "16rA000(40960) + opNumber(147)"!FSET:n	self appendShortNumber:n.	stream nextPut: 149 "16r80(128) + opNumber(21)"!IGET:n	self appendShortNumber:n.	stream nextPut: 146 "16r80(128) + opNumber(18)"!ISET:n	self appendShortNumber:n.	stream nextPut: 147 "16r80(128) + opNumber(19)"!ISET: n indexed: j	self appendRational: n.	self appendShortNumber: j.	stream nextPut: 147 "16r80(128) + opNumber(19)"!MAKEPIXELARRAY: aForm	| paddedWidth | 	self appendInteger: aForm height.	self appendInteger: aForm width"(paddedWidth _ aForm width + 31 truncateTo: 32)".	3 timesRepeat: [self appendInteger: 1].	self SCALE2x: 1 y: -1.	self packedPixelVector: aForm "usingWidth: paddedWidth".	stream nextWordPut: 41410 "16rA000(40960)+opNumber(450)"!MAKEPIXELARRAY:aForm scale:aScale		|aWidth|	self appendInteger: aForm height.	self appendInteger: (aWidth _ (aForm width+15 truncateTo:16 )).	3 timesRepeat: [self appendInteger: 1].	self SCALE2x:aScale y:(0-aScale).	self packedPixelVector:aForm bits formWidth:aWidth.	stream nextWordPut:41410 "16rA000(40960)+opNumber(450)"!MAKEVEC:anInteger	self appendInteger:anInteger.	stream nextWordPut: 41243 "16rA000(40960) + opNumber(283)"!MASKPIXEL: aForm	self MAKEPIXELARRAY: aForm.	stream nextWordPut: 41412  "16rA000(40960)+opNumber(452)".!MASKPIXEL:aForm scale:aScale	self MAKEPIXELARRAY:aForm scale:aScale.	stream nextWordPut:41412  "16rA000(40960)+opNumber(452)"!MODIFYFONT	stream nextWordPut: 41108 "16rA000(40960) + opNumber(148)"!ROTATE:rotation	self appendInteger:rotation.	stream nextWordPut: 41123 "16rA000(40960) + opNumber(163)"!SCALE2x:xFraction y:yFraction		self appendRational:xFraction.	self appendRational:yFraction.	stream nextWordPut: 41126 "16rA000(40960) + opNumber(166)"!SCALE: scaleFraction	(scaleFraction isKindOf: Point)		ifTrue: [self SCALE2x: scaleFraction x y: scaleFraction y]		ifFalse: [self appendRational:scaleFraction.				stream nextWordPut: 41124 "16rA000(40960) + opNumber(164)"]!SETCORRECTMEASUREx: xInteger y: yInteger	self appendInteger: xInteger.	self appendInteger: yInteger.	self appendOp: 154!SETCORRECTTOLERANCEx: xInteger y: yInteger	self appendInteger: xInteger.	self appendInteger: yInteger.	self appendOp: 155!SETFONT:n	self appendInteger:n.	stream nextWordPut: 41111 "16rA000(40960) + opNumber(151)"!SETXYx:xInteger y:yInteger	self appendInteger:xInteger.	self appendInteger:yInteger.	stream nextPut: 138 "16r80(128) + opNumber(10)"!SHOW: aString	| sz ch | 	sz _ aString size."	(sz > 0 and: [(ch _ aString last) = CR or: [ch = Ctrlf]])		ifTrue: [sz _ aString size - 1]."	sz > 0		ifTrue: [self appendString: aString length: sz.				stream nextPut: 150 "16r80(128) + opNumber(22)"]!TRANS	stream nextWordPut: 41130 "16rA000(40960) + opNumber(170)"!TRANSLATEx:xInteger y:yInteger	self appendInteger:xInteger.	self appendInteger:yInteger.	stream nextWordPut: 41122 "16rA000(40960) + opNumber(162)"! !!Interpress methodsFor: 'headers'!headerOfMaster"Append to master an header information of the current interpress master."	stream nextPutAll: #(73 110 116 101 114 112 114 101 115 115 47 88 101 114 111 120 47 49 46 48 32 )	"('Interpress/Xerox/1.0 ' asArray collect: [:char | char asInteger])"! !!Interpress methodsFor: 'aroundFont'!applyDefaultFont	"Designate a default PrintFont"	self applyFont: 1!applyFont: fontIndex	" Apply font ,which is designated by frame variable corresponding to fontIndex(argument), to imager variable. "	self SETFONT: ((self class defaultFontsConversionArray at: fontIndex) - 1)!applyFontForContents"Designate background font for printing text input."	text size = 0		ifTrue:[self applyDefaultFont]		ifFalse:[self applyFont: (text emphasisAt: lastIndex)]!setUpFonts"Set up fonts(for header and for contents) into frame variables(0 to 10)."	| font |	1 to:(fontArray size) do:[:i|	font _ fontArray at:i.	self FINDFONT:(font fontName).	self SCALE2x:((font fontSize) * (635/36)) y:((font fontSize) * (-635/36)).	self MODIFYFONT.	self FSET:(i - 1)].	(fontArray size = 1) ifTrue:[	font _ fontArray at:1.	self FINDFONT:(font fontName).	self SCALE2x:((font fontSize) * (635/36)) y:((font fontSize) * (-635/36)).	self MODIFYFONT.	self FSET:1]! !!Interpress methodsFor: 'bodies of master'!beginBody	stream nextWordPut: 41066 "16rA000(40960) + opNumber(106)"!beginMaster	stream nextWordPut: 41062 "16rA000(40960) + opNumber(102)"!endBody	stream nextWordPut: 41067 "16rA000(40960) + opNumber(107)"!endMaster	stream nextWordPut: 41063 "16rA000(40960) + opNumber(103)"! !!Interpress methodsFor: 'initialize-release'!init	"Initialize of instance variables especially for processing 'text'"	lastIndex _ 1.	printStyle == nil ifTrue: [printStyle _ PrintStyle default].	fontArray _ printStyle fontArray.	topMargin _ printStyle topMargin.	bottomMargin _ printStyle bottomMargin.	leftMargin _ printStyle leftMargin.	rightMargin _ printStyle rightMargin.	headingString _ Array new: 1.	self lineGrid: printStyle lineGrid.	pageNumber _ 1!initializeWithForm"Initialization of instance variables especially for processing 'form'"	time _ Time dateAndTimeNow printString.	pageNumber _ 1!initializeWithText: aText"Initialize of instance variables especially for processing 'text'"	(aText isMemberOf: Text)		ifFalse: [Transcript cr; show: 'Illegal printing material. Please pass aText to anInterpress.'.  ^nil].	text _ aText.	lastIndex _ 1.	self lineGrid: printStyle lineGrid.	pageNumber _ 1! !!Interpress methodsFor: 'showing'!showChars: aCollection from: start to: stop	self SETXYx: x y:y.	self appendChars: aCollection from: start to: stop!showFrom:xPosition string:aString	self SETXYx:xPosition y:y.	self SHOW:aString!showString:aString	self SETXYx: x y:y.	self SHOW:aString!strikethroughString:aString	self SETXYx: x y:y.	self appendOp: 413.	"STARTUNDERLINE"	self SHOW:aString.	self appendInteger: 35.	self appendInteger: 25.	self appendOp: 414.	"MASKUNDERLINE"!underlineString:aString	self SETXYx: x y:y.	self appendOp: 413.	"STARTUNDERLINE"	self SHOW:aString.	self appendInteger: -36.	self appendInteger: 20.	self appendOp: 414.	"MASKUNDERLINE"!underlineStringWOSet:aString	self appendOp: 159.	"GETCP"	self appendOp: 413.	"STARTUNDERLINE"	self SHOW:aString.	self appendInteger: -36.	self appendInteger: 20.	self appendOp: 414.	"MASKUNDERLINE"!underlineStringWOSet:aString toPosition: newX	self appendOp: 159.	"GETCP"	self appendOp: 413.	"STARTUNDERLINE"	self SHOW:aString.	self SETXYx: newX y: y.	self appendInteger: -36.	self appendInteger: 20.	self appendOp: 414.	"MASKUNDERLINE"!underlineTo: stopX	self appendOp: 159.	"GETCP"	self appendOp: 413.	"STARTUNDERLINE"	self SETXYx: stopX y: y.	self appendInteger: -36.	self appendInteger: 20.	self appendOp: 414.	"MASKUNDERLINE"! !Pool named: #TextConstants includes: #Ctrlf!Pool named: #TextConstants includes: #CR!Pool named: #TextConstants includes: #Space!!Interpress methodsFor: 'interpressing for text'!beginOnePageBodyAppendHeading: aString landscape: landscapeIfTrue	self beginBody.	self conversionToMaika.	landscapeIfTrue		ifTrue: [self landscapeCoordinateSystemConversion]		ifFalse: [self coordinateSystemConversion].	self SETCORRECTTOLERANCEx: 2 y: 0.	self printHeadings: landscapeIfTrue.	self appendHeader: aString!beginOnePageBodyLandscape: landscapeIfTrue	self beginBody.	self conversionToMaika.	landscapeIfTrue		ifTrue: [self landscapeCoordinateSystemConversion]		ifFalse: [self coordinateSystemConversion].	self SETCORRECTTOLERANCEx: 2 y: 0.	self printHeadings: landscapeIfTrue!beginPageBodies"Interpressing aText(argument) and create an Interpress Master as the result. Return the master."	BeginPageBodies == nil ifTrue: [self class initBeginPageBodies].	stream nextPutAll: BeginPageBodies!composeAndPrintSingleLine: aPrintScanner	"This is central routine of interpressing text.  Contents of one page body are generated. Separaters for a showing are tabs. Answer if current page is the final one."	| line delimitorCount delimitorIndices delimitorPositions countsBetweenDelimitors delimitorTypes startPoint changeFlag mode padding doCorrect fullMeasure  prevX stop tabIndex nextTabIndex sz ignorLast |	line _ aPrintScanner composeLineFrom: lastIndex left: leftMargin right: rightMargin.	lastIndex _ line last + 1.	line == nil  ifTrue: [^self].	line first > line last ifTrue: [^y _ y + lineGrid].	delimitorCount _ aPrintScanner delimitorCount.	delimitorIndices _ aPrintScanner delimitorIndices.	delimitorPositions _ aPrintScanner delimitorPositions.	countsBetweenDelimitors _ aPrintScanner countsBetweenDelimitors.	stop _ line last.	ignorLast _ 0.	[(stop >= line first) and: [(text at: stop) == Space or: [(text at: stop) == CR or: [(text at: stop) == Ctrlf]]]]		whileTrue: [stop _ stop - 1.					ignorLast _ ignorLast + 1].	(delimitorCount >= 1	and: [(delimitorIndices at: delimitorCount) = line last			and: [ignorLast > 0]])		ifTrue: [countsBetweenDelimitors at: delimitorCount put: ((countsBetweenDelimitors at: delimitorCount) - ignorLast)].	delimitorTypes _ aPrintScanner delimitorTypes.	changeFlag _ #normal.	startPoint _ line first.	mode _ printStyle alignment. 	padding _ line paddingWidth.	"mode = 0, 1, 2 or 3 for left, center, right or full justification respectively."	doCorrect _ mode = 3 and: [line internalSpaces > 0].	fullMeasure _ rightMargin.	doCorrect		ifFalse: [fullMeasure _ fullMeasure - padding].	mode = 1		ifTrue: [padding _ padding//2].	(mode = 0 or: [mode = 3])		ifTrue: [padding _ 0].	doCorrect		ifTrue: [self updateXY: leftMargin]		ifFalse: [self updateXY: leftMargin + padding].	self SETXYx: x y: y.	prevX _ leftMargin.	tabIndex _ 0.	[nextTabIndex _ aPrintScanner nextTabIndexFrom: tabIndex.	nextTabIndex > tabIndex] whileTrue:	[tabIndex + 1 to: nextTabIndex do: [:count |		self simplyShowTextFrom: startPoint size: (countsBetweenDelimitors at: count) toPosition: (padding + (delimitorPositions at: count))."		self simplyShowTextFrom: startPoint size: (countsBetweenDelimitors at: count)."		startPoint _ (delimitorIndices at: count) + 1.		((changeFlag _ delimitorTypes at: count) == #run or: [changeFlag == #runTab])			ifTrue: [	self applyFont: (text emphasisAt: startPoint)]].	prevX _ delimitorPositions at: nextTabIndex.	x _ padding + prevX.	self SETXYx: x y: y.	tabIndex _ nextTabIndex].	doCorrect		ifTrue: [self SETCORRECTMEASUREx: (fullMeasure - prevX) y: 0.				self CORRECT.				self beginBody].	tabIndex + 1 to: delimitorCount do: [:count |		self simplyShowTextFrom: startPoint size: (countsBetweenDelimitors at: count).		startPoint _ (delimitorIndices at: count) + 1.		((changeFlag _ delimitorTypes at: count) == #run or: [changeFlag == #runTab])			ifTrue: [	self applyFont: (text emphasisAt: startPoint)]].	sz _ line last - ignorLast - startPoint + 1.	sz > 0		ifTrue: [self simplyShowTextFrom: startPoint size: sz].	doCorrect		ifTrue: [self endBody.				(changeFlag == #run or: [changeFlag == #runTab])					ifTrue: [self applyFont: (text emphasisAt: startPoint)]]!endPageBodies	self endMaster.	^self close!makeOnePageBody:aForm flag:anInteger"Construct the only one page body for aForm(argument). If anInteger(argument) is 1, only a header is printed."	self beginOnePageBodyLandscape: false.	anInteger=1		ifFalse:[self makeFormBody:aForm].	self endBody!makePageContents: composedLines from: startIndex to: stopIndex left: lInteger width: width"This is central routine of interpressing text.  Contents of one page body are generated. Separaters for a showing are tabs. Answer if current page is the final one."	| savedLeftMargin savedRightMargin |	startIndex > stopIndex ifTrue: [^self].	savedLeftMargin _ leftMargin.	savedRightMargin _ rightMargin.	leftMargin _ leftMargin + lInteger.	rightMargin _ leftMargin + width.	lastIndex _ (composedLines at: startIndex) first.	self applyFont: (text emphasisAt: lastIndex).	self initializeXY.	startIndex to: stopIndex		do: [:lineIndex | self printSingleLine: (composedLines at: lineIndex)].	leftMargin _ savedLeftMargin.	rightMargin _ savedRightMargin!makePreamble	self beginBody.	self setUpFonts.	self endBody!makeSinglePageContents	"This is the central routine of interpressing text.  Contents of one page body are generated. Separaters for a showing are tabs. Answer true if current page is the last page."	| ff printScanner lineIndex |	self applyFont: (text emphasisAt: lastIndex).	printScanner _ PrintScanner new in: self.	ff _ false.	lineIndex _ 0.	[(lastIndex > text size or: [lineIndex > linesPerPage]) or: [ff]]		whileFalse: [self composeAndPrintSingleLine: printScanner.					lineIndex _ lineIndex + 1.					ff _ (text string at: (lastIndex - 1)) = Ctrlf].	^lastIndex >= text size!printSingleLine: line	"This is central routine of interpressing text.  Contents of one page body are generated. Separaters for a showing are tabs. Answer if current page is the final one."	| delimitorCount delimitorIndices delimitorPositions countsBetweenDelimitors delimitorTypes startPoint changeFlag mode padding doCorrect fullMeasure prevX stop tabIndex nextTabIndex sz ignorLast |	line == nil  ifTrue: [^self].	line first > line last ifTrue: [^y _ y + lineGrid].	delimitorCount _ line delimitorCount.	delimitorIndices _ line delimitorIndices.	delimitorPositions _ line delimitorPositions.	countsBetweenDelimitors _ line countsBetweenDelimitors.	stop _ line last.	ignorLast _ 0.	[(stop >= line first) and: [(text at: stop) == Space or: [(text at: stop) == CR or: [(text at: stop) == Ctrlf]]]]		whileTrue: [stop _ stop - 1.					ignorLast _ ignorLast + 1].	(delimitorCount >= 1	and: [(delimitorIndices at: delimitorCount) = line last			and: [ignorLast > 0]])		ifTrue: [countsBetweenDelimitors at: delimitorCount put: ((countsBetweenDelimitors at: delimitorCount) - ignorLast)].	delimitorTypes _ line delimitorTypes.	changeFlag _ #normal.	startPoint _ line first.	mode _ line alignment. 	padding _ line paddingWidth.	"mode = 0, 1, 2 or 3 for left, center, right or full justification respectively."	doCorrect _ mode = 3 and: [line internalSpaces > 0].	fullMeasure _ rightMargin - leftMargin - line rMargin.	doCorrect		ifFalse: [fullMeasure _ fullMeasure - padding].	mode = 1		ifTrue: [padding _ padding//2].	(mode = 0 or: [mode = 3])		ifTrue: [padding _ 0].	doCorrect		ifTrue: [self updateXY: leftMargin + line lMargin]		ifFalse: [self updateXY: leftMargin + line lMargin + padding].	self SETXYx: x y: y.	prevX _ line lMargin.	tabIndex _ 0.	[nextTabIndex _ line nextTabIndexFrom: tabIndex.	nextTabIndex > tabIndex] whileTrue:	[tabIndex + 1 to: nextTabIndex do: [:count |		self simplyShowTextFrom: startPoint size: (countsBetweenDelimitors at: count) toPosition: (leftMargin + padding + (delimitorPositions at: count)).		startPoint _ (delimitorIndices at: count) + 1.		((changeFlag _ delimitorTypes at: count) == #run or: [changeFlag == #runTab])			ifTrue: [	self applyFont: (text emphasisAt: startPoint)]].	prevX _ delimitorPositions at: nextTabIndex.	x _ leftMargin + padding + prevX.	self SETXYx: x y: y.	tabIndex _ nextTabIndex].	doCorrect		ifTrue: [self SETCORRECTMEASUREx: (fullMeasure - prevX) y: 0.				self CORRECT.				self beginBody].	tabIndex + 1 to: delimitorCount do: [:count |		self simplyShowTextFrom: startPoint size: (countsBetweenDelimitors at: count).		startPoint _ (delimitorIndices at: count) + 1.		((changeFlag _ delimitorTypes at: count) == #run or: [changeFlag == #runTab])			ifTrue: [	self applyFont: (text emphasisAt: startPoint)]].	sz _ line last - ignorLast - startPoint + 1.	sz > 0		ifTrue: [self simplyShowTextFrom: startPoint size: sz].	doCorrect		ifTrue: [self endBody.				(changeFlag == #run or: [changeFlag == #runTab])					ifTrue: [self applyFont: (text emphasisAt: startPoint)]]!simplyShowTextFrom: startIndex size: stringSize	| string checkEmp | 	checkEmp _ (printStyle fontAt: (text emphasisAt: startIndex)) emphasis >= 4.	stringSize > 0		ifTrue: [string _ (String new: stringSize)							primReplaceFrom:1 							to: stringSize							with: text string 							startingAt: startIndex.				checkEmp					ifTrue: [self underlineStringWOSet: string]					ifFalse: [self SHOW: string]]		ifFalse: [checkEmp ifTrue: [self underlineTo: x]]!simplyShowTextFrom: startIndex size: stringSize toPosition: stopX	| string checkEmp | 	checkEmp _ (printStyle fontAt: (text emphasisAt: startIndex)) emphasis >= 4.	stringSize > 0		ifTrue: [string _ (String new: stringSize)							primReplaceFrom:1 							to: stringSize							with: text string 							startingAt: startIndex.				checkEmp					ifTrue: [self underlineStringWOSet: string toPosition: stopX]					ifFalse: [self SHOW: string]]		ifFalse: [checkEmp ifTrue: [self underlineTo: stopX]]! !!Interpress methodsFor: 'coordination'!conversionToMaika"Scaling measurement conversion on a current Interpress Master, from meter to 2 micas(2/100 milli-meter)."	self SCALE: 1/50000.	self CONCATT!coordinateSystemConversion"Coordinate system used internally is left-haded and its origin is placed at upper left corner, which is just corresponding to upper left corner of intersectional area of A4 and US letter size. Coordinate system conversion here from Standard Interpress Coordinate System enables easy manipulation of coordinates."	self TRANSLATEx:0 y: (printStyle paperSize y).	self CONCATT.	self SCALE2x:1 y:-1.	self CONCATT!initializeXY	x _ leftMargin.	y _ topMargin!initializeXY: landscapeIfTrue	landscapeIfTrue		ifTrue: [x _ bottomMargin.				y _ leftMargin]		ifFalse: [x _ leftMargin.				y _ topMargin]!initializeXYForHeader	x _ leftMargin.	y _ topMargin - lineGrid!initializeXYForHeader: landscapeIfTrue	landscapeIfTrue		ifTrue: [x _ bottomMargin.				y _ 670]		ifFalse: [x _ leftMargin.				y _ 670]!landscapeCoordinateSystemConversion"Coordinate system used internally is left-haded and its origin is placed at upper left corner, which is just corresponding to upper left corner of intersectional area of A4 and US letter size. Coordinate system conversion here from Standard Interpress Coordinate System enables easy manipulation of coordinates."	self TRANSLATEx: 0"(printStyle paperSize y)" y: 0"(printStyle paperSize x)".	self CONCATT.	self SCALE2x: -1 y: 1.	self CONCATT.	self ROTATE: 90.	self CONCATT.!updateXY: xPos	x _ xPos.	y _ y + lineGrid! !!Interpress methodsFor: 'interpressing for form'!form: aForm"Interpressing aForm(argument) and create an Interpress Master as the result. Return the master."	| aFlag |	self initializeWithForm.	aFlag _ self questionFor:aForm.	aFlag = 0		ifTrue:[self close.				^nil].	self beginPageBodies.	self makeOnePageBody:aForm flag:aFlag.	^self endPageBodies!imageForm:aForm scale:aScale"Create a pixel array of the form to be printed, which is a contents of 'DOSAVESIMPLEBODY'." 	| imageExtent |	imageExtent _ self magnifyImage:aForm scale:aScale.	self TRANSLATEx: ((rightMargin - leftMargin - imageExtent x//2) + leftMargin)					 y: (bottomMargin - topMargin - imageExtent y//2+topMargin).	self CONCATT.	self ROTATE: 90.	self CONCATT.	self SCALE: self unitsPerLine.	self CONCATT.	self MASKPIXEL: aForm scale:aScale!magnifyImage:aForm scale:aScale"Answer an extent(width and height represented in mica) of new form which will be printed on the paper."	^aForm extent*self unitsPerLine*aScale!makeFormBody:aForm"Generate the form body itself."	self DOSAVESIMPLEBODY.	self beginBody.	self imageForm:aForm scale:printStyle formScale.	self endBody!packedPixelVector:aBits formWidth:aWidth "Create the vector which has each of aBits(argument) as its elements, where aBIts is the aForm's Bitmap." 		self appendSequenceDescriptor: 9 length: aBits size*2+4.	stream nextWordPut: 1.	stream nextWordPut: aWidth.	"aBits do: [:aword | stream nextWordPut: aword]"	aBits toFileStream: stream!questionFor:aForm"Error check method about aForm(argument) and return 0 or 1 or 2."	| aScale imageExtent|	aScale _ printStyle formScale.	(aForm isMemberOf:Form)		ifFalse:[Transcript cr; show:'   illegal form !!!!  you have to use a correct form'.				^0].	aForm bits==nil		ifTrue:[Transcript cr; show:'   warning !!!!   nil form is not good'.				^1].	(aForm width <= 0 or:[aForm height <= 0])		ifTrue:[Transcript cr; show:'   illegal form !!!!   this form has incorrect extent'.				^0].	imageExtent _ self magnifyImage:aForm scale:aScale.	imageExtent x > (rightMargin - leftMargin)		ifTrue:[Transcript cr; show:'   illegal  image !!!!   too much width'.				^0].	imageExtent y > (bottomMargin - topMargin)		ifTrue:[Transcript cr; show:'   illegal image !!!!   too much height'.				^0].	^2! !!Interpress methodsFor: 'interpress master'!close	"return the closed stream"	stream close.	^stream!fileNamed: aFileName"Generate a new fileStream for stream and initialize instance variables around it."stream _ (FileStream fileNamed: aFileName) reset binary!nextPut: aByte 	stream nextPut: aByte! !Pool named: #TextConstants includes: #Ctrlf!!Interpress methodsFor: 'background printing'!appendHeader: aString	"Append page header information to master." 	(aString == nil or: [aString isEmpty]) not		ifTrue: [self applyDefaultFont.				self initializeXYForHeader.				self showString: aString.				self initializeXY].!endOnePageBody	self endBody.	pageNumber _ pageNumber + 1!header: aString showPageNo: showPg landscape: landscapeIfTrue	"Append page header information to master." 	| startPos showHdr | 	showHdr _ (aString == nil or: [aString isEmpty]) not.	(showPg or: [showHdr])		ifTrue: [self applyDefaultFont.				self initializeXYForHeader.				showHdr ifTrue: [self showString: aString].				showPg					ifTrue: [startPos							_ landscapeIfTrue								ifTrue: [bottomMargin - topMargin]								ifFalse: [rightMargin - 250].							self showFrom: startPos string: (pageNumber printString)]].	self initializeXY.!lineText: aText font: fontIndex alignment: alignment	| para padding | 	"Append a one line text to master using font specified. alignment can be #left, #right, #center or #full. Upon entering, x & y are initialized." 	fontIndex == nil		ifFalse: [self applyFont: fontIndex].	(alignment == #center or: [alignment == #right])		ifTrue: [para _ aText asParagraph.				padding _ rightMargin - leftMargin - ((para compositionRectangle width) * printStyle pressScale).				alignment == #center					ifTrue: [x _ x + (padding // 2)]					ifFalse: [x _ x + padding]].	alignment == #full		ifTrue: [	self SETCORRECTMEASUREx: rightMargin - leftMargin y: 0.				self SETXYx: x y: y.				self CORRECT.				self beginBody.				self SHOW: aText string.				self endBody]		ifFalse: [self showString: aText string].!lineText: aString font: fontIndex setPos: aPoint	"Append a one line text to master using font specified and start at a given point." 	fontIndex == nil		ifFalse: [self applyFont: fontIndex].	x _ aPoint x.	y _ aPoint y.	self showString: aString.	self initializeXY.!of: aFileStream	"Assign aFileStream for stream and initialize instance variables around it."	self init.	stream _ aFileStream reset binary!printFromFile: inputTextFile	| runsAndTextEnd start textLeft string appendToLineEndString printScanner lineIndex ff | 	runsAndTextEnd _ self class getRunsAndTextEnd: inputTextFile.	inputTextFile reset.	self beginPageBodies.	lineIndex _ 100.	ff _ false.	[start _ inputTextFile position.	 textLeft _ (runsAndTextEnd at: 2) - start.	 textLeft > 0] whileTrue:		[string _ inputTextFile next: (5000 min: textLeft).		 (textLeft < 5001 or: [(appendToLineEndString _ inputTextFile through: Character cr) isEmpty])			ifFalse: [string _ string, appendToLineEndString].		 text _ Text string: string runs: ((runsAndTextEnd at: 1) copyFrom: start + 1 to: inputTextFile position).		lastIndex _ 1.		printScanner _ PrintScanner new in: self.		[lastIndex <= text size] whileTrue:		[(lineIndex > linesPerPage or: [ff])			ifTrue: [lineIndex = 100						ifFalse: [self endBody.								pageNumber _ pageNumber + 1].					self beginOnePageBodyLandscape: false.					lineIndex _ 0.					ff _ false.					self applyFont: (text emphasisAt: lastIndex)].		[(lastIndex > text size or: [lineIndex > linesPerPage]) or: [ff]]		whileFalse: [self composeAndPrintSingleLine: printScanner.					lineIndex _ lineIndex + 1.					ff _ (text string at: (lastIndex - 1)) = Ctrlf]]].	self endBody.	self endPageBodies.	inputTextFile close.	self close!printHeadings: landscapeIfTrue	"only call this at the beginning - before put any other text in file but after set starting page. headingString is an Array. If the size of headingString is 3, it is assumed that they are the classifications/major/minor headings for the Tiger system.  Otherwise, headings are printed one after another left justified."	headingString == nil		ifFalse: [headingString size = 3					ifTrue: [self printSpecialHeadings: landscapeIfTrue]					ifFalse: [self printMultipleHeadings: landscapeIfTrue]].	self initializeXY.	self applyFont: 1!printMultipleHeadings: landscapeIfTrue	"anArray is an array of heading strings. They are printed close together and aligned leftly and only on pages beyond the first."	| increment scale fontIndex | 	x _ leftMargin.	y _ topMargin - (headingString size * lineGrid).	scale _ printStyle pressScale.	increment _ lineGrid.	pageNumber > 1 ifTrue:		[headingString do:			[:string | (string == nil or: [string isEmpty])						ifFalse: [string class == Text									ifFalse: [string _ string asText].								self lineText: string									font: (fontIndex _ string emphasisAt: 1)									alignment: #left.								increment _ (fontArray at: fontIndex) fontSize * scale + 1].						x _ leftMargin.						y _ y + increment].		x _ leftMargin.		y _ topMargin - lineGrid.		self lineText: pageNumber printString asText			font: 1			alignment: #right]."	self initializeXY"!printRectangle: aRectangle translateBy: aPoint	| pt | 	pt _ aRectangle origin translateBy: aPoint.	self appendInteger: pt x.	self appendInteger: pt y.	self appendInteger: aRectangle width.	self appendInteger: aRectangle height.	self appendOp: 410	"MASKRECTANGLE"!printSpecialHeadings: landscapeIfTrue	"Entering here only for the Tiger system's background printer. It is assumed that the first element is the document classification, the second element is the major heading, the third element is the minor heading.  Any element can be nil if it is not to be shown.  The classification (if any) goes on the top of the page and bottom of the page centered. The major head and minor head go below the top classification, left justified."	| classification major minor increment scale fontIndex total fixedLineGrid fixedTop fixedBottom alignment para nLines |	scale _ printStyle pressScale.	fixedLineGrid _ 16 * scale.	fixedTop _ 1270.	"topMargin"	fixedBottom _ landscapeIfTrue ifTrue: [9494] ifFalse: [12662].	"bottomMargin"	x _ leftMargin.	y _ fixedTop - (total _ headingString size * fixedLineGrid).	increment _ fixedLineGrid.	classification _ headingString at: 1.	major _ headingString at: 2.	minor _ headingString at: 3.	(classification == nil or: [classification isEmpty])		ifFalse: [classification class == Text					ifFalse: [classification _ classification asText].				"x _ leftMargin."				y _ fixedBottom + total "+ fixedLineGrid".		"Well, I don't either!!"				fontIndex _ classification emphasisAt: 1.				fontIndex == nil ifFalse: [self applyFont: fontIndex].	"doesn't have anything to do with headings!!"				para _ classification asParagraph.		"one composeAll!!"				para compositionRectangle: (Rectangle origin: (0@0) extent: ((rightMargin - leftMargin) // printStyle pressScale)@increment).			"another composeAll!!!! Paragraph needs help"				nLines _ para numberOfLines.				"y _ fixedBottom - (((nLines _ para numberOfLines) - 1) * fixedLineGrid)."				1 to: nLines do:					[:line | x _ leftMargin +((((para lines at: line) paddingWidth) * printStyle pressScale) // 2).					self showChars: para text string from: (para lines at: line) first to: (para lines at: line) last.					y _ y + fixedLineGrid].				"x _ leftMargin.	"	"upper classification"				"y _ fixedTop."				fontIndex == nil ifFalse: [self applyFont: fontIndex].	"doesn't have anything to do with headings!!"				y _ fixedTop  - total "- (nLines * fixedLineGrid)".				1 to: nLines do:					[:line | x _ leftMargin +((((para lines at: line) paddingWidth) * printStyle pressScale) // 2).					self showChars: para text string from: (para lines at: line) first to: (para lines at: line) last.					y _ y + fixedLineGrid].				increment _ (fontArray at: fontIndex) fontSize * scale + 3].	"what is this ??"	pageNumber > 1		ifTrue: [x _ leftMargin.				y _ y + increment.				(major == nil or: [major isEmpty])					ifFalse: [major class == Text								ifFalse: [major _ major asText].							self lineText: major								font: (fontIndex _ major emphasisAt: 1)								alignment: #left.							increment _ (fontArray at: fontIndex) fontSize * scale + 1].				x _ leftMargin.				y _ y + increment.				(minor == nil or: [minor isEmpty])					ifFalse: [minor class == Text								ifFalse: [minor _ minor asText].							self lineText: minor								font: (minor emphasisAt: 1)								alignment: #left].				x _ leftMargin.				y _ fixedTop - fixedLineGrid.				self lineText: pageNumber printString asText					font: 1					alignment: #right]."	self initializeXY"!putText: aText	"Creating page bodies giving aText."	| done | 	text _ aText.	lastIndex _ 1.	done _ false.	[done]		whileFalse: [self beginOnePageBodyLandscape: false.					done _ self makeSinglePageContents.					self endBody.					pageNumber _ pageNumber + 1]!putText: aText withHeading: aString	"Creating page bodies giving aText."	| done s | 	text _ aText.	lastIndex _ 1.	s _ aString.	done _ false.	[done]		whileFalse: [self beginOnePageBodyAppendHeading: s landscape: false.					s _ nil.					done _ self makeSinglePageContents.					self endBody.					pageNumber _ pageNumber + 1]!startAtPageNo: anInteger	pageNumber _ anInteger!underlineText: aString font: fontIndex setPos: aPoint	"Append a one line text to master using font specified and start at a given point." 	fontIndex == nil		ifFalse: [self applyFont: fontIndex].	x _ aPoint x.	y _ aPoint y.	self underlineString: aString.!useHeadings: anArray	self heading: anArray! !!Interpress methodsFor: 'large complex image'!packedPixelVector: aForm"Create the vector which has each of aBits(argument) as its elements, where aBIts is the aForm's Bitmap." 	| aByteArray increment start aBits sizeInBytes bytesWritten | 		aBits _ aForm bits.	sizeInBytes _ ((aForm width + 31 // 32) *aForm height) bitShift: 2.	self appendSequenceDescriptor: 9 length: sizeInBytes "* 2" + 4. 	stream nextWordPut: 1.	stream nextWordPut: aForm width.	(sizeInBytes >= 8192)		ifTrue: [aByteArray _ ByteArray new: (increment _8192)].	bytesWritten _ 0.	start _ 1.	[bytesWritten < sizeInBytes] whileTrue:		[(sizeInBytes - bytesWritten) < 8192 ifTrue:			[aByteArray _ ByteArray new: (increment _ sizeInBytes - bytesWritten)].		aByteArray specialReplaceFrom: 1 to: increment with: aBits startingAt: start.		start _ start + (increment bitShift: -1).		stream nextPutAll: aByteArray.		bytesWritten _ bytesWritten + increment].!printForm: aForm scale: scale setPos: aPoint	"aCollection consists of forms."	self DOSAVESIMPLEBODY.	self beginBody.	self TRANSLATEx: aPoint x y: aPoint y.	self CONCATT.	self ROTATE: 90.	self CONCATT.	self SCALE: scale.	self CONCATT.	self MASKPIXEL: aForm.	self endBody!printFullForm: aForm scale: scale setPos: aPoint	| newForm forms w h pos | 	"aCollection consists of forms."	aForm == nil ifTrue: [^self].	forms _ OrderedCollection new.	w _ aForm width + 31 truncateTo: 32.	h _ aForm height.	aForm bits size > 32000	ifTrue:		[newForm _ Form new extent: w@(h//2).		newForm copyBits: (0@0 extent: aForm width@(h//2))				from: aForm				at: 0@0				clippingBox: newForm boundingBox				rule: Form over				mask: Form black.		forms add: newForm.		newForm _ Form new extent: w@(h - (h//2)).		newForm copyBits: (0@h//2 extent: aForm width@(h - (h//2)))				from: aForm				at: 0@0				clippingBox: newForm boundingBox				rule: Form over				mask: Form black.		forms add: newForm]	ifFalse:		[w = aForm width			ifTrue: [forms add: aForm]			ifFalse: [newForm _ Form new extent: w@h.					newForm copyBits: (0@0 extent: aForm extent)							from: aForm							at: 0@0							clippingBox: newForm boundingBox							rule: Form over							mask: Form black.					forms add: newForm]].	pos _ aPoint.	forms do: [:one |		self printForm: one scale: scale setPos: pos.		pos _ pos + (0@(one height*scale y))]! !'From The Analyst(tm) on Smalltalk-80 of August 28, 1986 (Dandelion/Daybreak Version 6) on 14 May 1987 at 8:05:31 pm'!!RS232Model methodsFor: 'initialize/release'!setInputStops	"set up array which determines what action should		be performed for every character input on RS-232"	inputStops _ Array new: 128.	inputStops		at: 16r0 + 1 put: #ignoreChar;		at: 16rA + 1 put: #ignoreChar;		"LF"		at: 16rC + 1 put: #nextPage;		"form feed"		at: 16rD + 1 put: #cr;	"CR"		at: 16r11 + 1 put: #rs232ToTransmitState;		"Xon"		at: 16r13 + 1 put: #cr;		"Xoff"		at: 16r7F + 1 put: #ignoreChar		"ascii DEL char"! !!RS232Model methodsFor: 'input parsing'!clearMemory	displayStream clearMemory.	"clear buffer"	displayStream clearLines: 1 to: displayStream maxLines.	displayStream setToColAtLine: 1@1! !!SystemDictionary methodsFor: 'time/versions'!analystVersionInfo	^'The Analyst(tm).Copyright (c) 1985, 1986, 1987 Xerox Corporation.  All rights reserved.Copyright protection claimed includes all forms and matters of copyrightable material and information now allowed by statutory or judicial law or hereinafter granted, including without limitation, material generated from the software programs which are displayed on the screen such as icons, screen display looks, etc.This Analyst was built on top of:Smalltalk-80 of August 28, 1986 (Dandelion/Daybreak Version 6)Copyright (c) 1983 Xerox Corp.  All rights reserved.Analyst base version 1.2For Xerox 6085/1186 Workstations using XDE Tajo >= 12.0 and ST80-DV6.Interpress printing support(30 April 1987 6:45:42 pm ) saved by ConfigMeisterChanges compressed.  SourceFiles changed to Array with:	1.  The original Smalltalk source file ''ST80-DV6''	2.  The ongoing changes file ''Analyst.changes''	3.  All the changes from 1 that created the Analyst ''Analyst.sources''(30 April 1987 8:47:16 pm ) saved by ellersieck0506-le-TreeMenu-release.st, 0506-le-RS232-pageMenus.st, 0508-le-LogInOut-getNetInfo.stThis virtual image has been assigned serial number: 2043087A2.1X686'! !!TreeMenu methodsFor: 'initialize-release'!letGo	"Break possible double-links between self and: parent, children, etc."	(children isKindOf: TreeMenu) ifTrue: [children letGo].	(children isKindOf: SequenceableCollection) ifTrue: [		children do: [:eachChild |			(eachChild isKindOf: TreeMenu) ifTrue: [eachChild letGo]]].	parent _ nil.	resultBlock release.	selectBlock == nil ifFalse: [selectBlock release. selectBlock _ nil]!release	"super release."	selectBlock == nil ifFalse: [selectBlock release. selectBlock _ nil].	parent release.	parent _ nil.! !!LogInOut class methodsFor: 'net info'!getNetworkInfo	"LogInOut getNetworkInfo"	| netFileStream switch fs | 	switch _ String with: $\ with: $\.	(netFileStream _ self class openOldFile: 'networkinfo') == nil		ifTrue: "file does not exist, build one from the last known choices"			[^self writeNetworkInfo].	"file exists, clear everything have and use it"	UserProfile current clearItAll.	netFileStream readOnly.	fs _ String with: netFileStream next with: netFileStream next.	fs = switch		ifTrue: [NetLogin _ (netFileStream upTo: Character cr) asSymbol]		ifFalse: [NetLogin _ #AutoSetNetPassword.				netFileStream position: 0 "reset to pick up domain"].	UserProfile current domain: (netFileStream upTo: Character cr) organization: (netFileStream upTo: Character cr).	(fs _ netFileStream upTo: Character cr) isEmpty ifFalse:		[(#(Interpress Press) includes: fs asSymbol)			ifTrue: [(Smalltalk includesKey: #BackgroundPrinter) ifTrue: [BackgroundPrinter setToPress: fs asSymbol = #Press]]			ifFalse: [UserProfile current addPrinter: fs].		 [(fs _ netFileStream upTo: Character cr) isEmpty]			whileFalse: [UserProfile current addPrinter: fs]].	netFileStream close!writeNetworkInfo	"LogInOut writeNetworkInfo"	| netFileStream switch | 	NetLogin == nil ifTrue: [NetLogin _ #AutoSetNetPassword].	switch _ String with: $\ with: $\.	netFileStream _ (FileStream fileNamed: 'networkinfo') writeShorten.	netFileStream		nextPutAll: switch, NetLogin asString;		nextPut: Character cr;		nextPutAll: UserProfile current domain;		nextPut: Character cr;		nextPutAll: UserProfile current organization.	UserProfile current fileServerChoices do: [:fs | netFileStream nextPut: Character cr; nextPutAll: fs].	netFileStream nextPut: Character cr; nextPutAll: switch.	(Smalltalk includesKey: #PressOrInterpress) ifTrue:		[netFileStream nextPut: Character cr; nextPutAll: PressOrInterpress].	UserProfile current printerChoices do: [:fs | netFileStream nextPut: Character cr; nextPutAll: fs].	netFileStream close! !!RS232Controller class methodsFor: 'initialize'!initializeFirstScrollingPagesMenu	"Initialize the 'page..' branch of the paging.. TreeMenu."	| tempMenu |	self initializeScrollingPagesMenu.	FirstPagesMenu == nil ifTrue:		[FirstPagesMenu _ ScrollMenu new: 5 on: 1.		FirstPagesMenu children: PagesMenu.		^FirstPagesMenu].	tempMenu _ ScrollMenu new: 5 on:		(RS232Collector == nil			ifTrue: [1]			ifFalse: [RS232Collector contentsStream totalPages]).	tempMenu children: PagesMenu.	FirstPagesMenu become: tempMenu.	tempMenu letGo.	^FirstPagesMenu!initializeScrollingPagesMenu	"Initialize the 'page..' branch of the paging.. TreeMenu."	| tempMenu |	PagesMenu == nil		ifTrue: [^(PagesMenu _ ScrollMenu new: 5 on: 1)].	tempMenu _ ScrollMenu new: 5 on: 		(RS232Collector == nil			ifTrue: [1]			ifFalse: [RS232Collector contentsStream totalPages]).	PagesMenu become: tempMenu.	tempMenu letGo.	^PagesMenu! !'From The Analyst(tm) on Smalltalk-80 of August 28, 1986 (Dandelion/Daybreak Version 6) on 14 May 1987 at 8:38:03 pm'!!SystemDictionary methodsFor: 'time/versions'!analystVersionInfo	^'The Analyst(tm).Copyright (c) 1985, 1986, 1987 Xerox Corporation.  All rights reserved.Copyright protection claimed includes all forms and matters of copyrightable material and information now allowed by statutory or judicial law or hereinafter granted, including without limitation, material generated from the software programs which are displayed on the screen such as icons, screen display looks, etc.This Analyst was built on top of:Smalltalk-80 of August 28, 1986 (Dandelion/Daybreak Version 6)Copyright (c) 1983 Xerox Corp.  All rights reserved.Analyst base version 1.2For Xerox 6085/1186 Workstations using XDE Tajo >= 12.0 and ST80-DV6.Interpress printing support(30 April 1987 6:45:42 pm ) saved by ConfigMeisterChanges compressed.  SourceFiles changed to Array with:	1.  The original Smalltalk source file ''ST80-DV6''	2.  The ongoing changes file ''Analyst.changes''	3.  All the changes from 1 that created the Analyst ''Analyst.sources''(30 April 1987 8:47:16 pm ) saved by ellersieck0506-le-TreeMenu-release.st, 0506-le-RS232-pageMenus.st(14 May 1987 8:13:46 pm ) saved by ellersieck0508-le-LogInOut-getNetInfo.stThis virtual image has been assigned serial number: 3043087A2.1X686'! !!LogInOut class methodsFor: 'net info'!getNetworkInfo	"LogInOut getNetworkInfo"	| netFileStream switch fs | 	switch _ String with: $\ with: $\.	(netFileStream _ self class openOldFile: 'networkinfo') == nil		ifTrue: "file does not exist, build one from the last known choices"			[^self writeNetworkInfo].	"file exists, clear everything have and use it"	UserProfile current clearItAll.	netFileStream readOnly.	fs _ String with: netFileStream next with: netFileStream next.	fs = switch		ifTrue: [NetLogin _ (netFileStream upTo: Character cr) asSymbol]		ifFalse: [NetLogin _ #AutoSetNetPassword.				netFileStream position: 0 "reset to pick up domain"].	UserProfile current domain: (netFileStream upTo: Character cr) organization: (netFileStream upTo: Character cr).	[(fs _ netFileStream upTo: Character cr) isEmpty or: [fs = switch]]		whileFalse: [UserProfile current addFileServer: fs].	(fs _ netFileStream upTo: Character cr) isEmpty ifFalse:		[(#(Interpress Press) includes: fs asSymbol)			ifTrue: [(Smalltalk includesKey: #BackgroundPrinter) ifTrue: [BackgroundPrinter setToPress: fs asSymbol = #Press]]			ifFalse: [UserProfile current addPrinter: fs].		 [(fs _ netFileStream upTo: Character cr) isEmpty]			whileFalse: [UserProfile current addPrinter: fs]].	netFileStream close! !